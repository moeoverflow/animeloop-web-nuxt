!(function (e) { const t = window.webpackJsonp; window.webpackJsonp = function webpackJsonpCallback(r, i, a) { for (var o, s, u = 0, l = []; u < r.length; u++)s = r[u], n[s] && l.push(n[s][0]), n[s] = 0; for (o in i)Object.prototype.hasOwnProperty.call(i, o) && (e[o] = i[o]); for (t && t(r, i, a); l.length;)l.shift()(); }; const r = {}; var n = { 1: 0 }; function __webpack_require__(t) { if (r[t]) return r[t].exports; const n = r[t] = { i: t, l: !1, exports: {} }; return e[t].call(n.exports, n, n.exports, __webpack_require__), n.l = !0, n.exports }__webpack_require__.e = function requireEnsure(e) { let t = n[e]; if (t === 0) return new Promise(((e) => { e() })); if (t) return t[2]; const r = new Promise(((r, i) => { t = n[e] = [r, i] })); t[2] = r; const i = document.getElementsByTagName('head')[0]; const a = document.createElement('script'); a.type = 'text/javascript', a.charset = 'utf-8', a.async = !0, a.timeout = 12e4, __webpack_require__.nc && a.setAttribute('nonce', __webpack_require__.nc), a.src = `${__webpack_require__.p}build/${{}[e] || e}.${{ 0: 'eb24027b' }[e]}.js`; const o = setTimeout(onScriptComplete, 12e4); function onScriptComplete() { a.onerror = a.onload = null, clearTimeout(o); const t = n[e]; t !== 0 && (t && t[1](new Error(`Loading chunk ${e} failed.`)), n[e] = void 0) } return a.onerror = a.onload = onScriptComplete, i.appendChild(a), r }, __webpack_require__.m = e, __webpack_require__.c = r, __webpack_require__.d = function (e, t, r) { __webpack_require__.o(e, t) || Object.defineProperty(e, t, { configurable: !1, enumerable: !0, get: r }) }, __webpack_require__.n = function (e) { const t = e && e.__esModule ? function getDefault() { return e.default } : function getModuleExports() { return e }; return __webpack_require__.d(t, 'a', t), t }, __webpack_require__.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, __webpack_require__.p = '', __webpack_require__.oe = function (e) { throw console.error(e), e }, __webpack_require__(__webpack_require__.s = 232) }([function (e, t, r) {
  e.exports = r(276);
}, function (e, t, r) { e.exports = r(289)() }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(292); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  t.a = function normalizeComponent(e, t, r, n, i, a, o, s) { const u = typeof (e = e || {}).default; u !== 'object' && u !== 'function' || (e = e.default); let l; const c = typeof e === 'function' ? e.options : e; t && (c.render = t, c.staticRenderFns = r, c._compiled = !0); n && (c.functional = !0); a && (c._scopeId = a); o ? (l = function (e) { (e = e || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (e = __VUE_SSR_CONTEXT__), i && i.call(this, e), e && e._registeredComponents && e._registeredComponents.add(o) }, c._ssrRegister = l) : i && (l = s ? function () { i.call(this, this.$root.$options.shadowRoot) } : i); if (l) if (c.functional) { c._injectStyles = l; const p = c.render; c.render = function renderWithStyleInjection(e, t) { return l.call(t), p(e, t) } } else { const f = c.beforeCreate; c.beforeCreate = f ? [].concat(f, l) : [l] } return { exports: e, options: c } };
}, function (e, t) { e.exports = function (e) { const t = []; return t.toString = function toString() { return this.map((t) => { const r = (function cssWithMappingToString(e, t) { const r = e[1] || ''; const n = e[3]; if (!n) return r; if (t && typeof btoa === 'function') { const i = (function toComment(e) { return `/*# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(unescape(encodeURIComponent(JSON.stringify(e))))} */` }(n)); const a = n.sources.map(e => `/*# sourceURL=${n.sourceRoot}${e} */`); return [r].concat(a).concat([i]).join('\n') } return [r].join('\n') }(t, e)); return t[2] ? `@media ${t[2]}{${r}}` : r }).join('') }, t.i = function (e, r) { typeof e === 'string' && (e = [[null, e, '']]); for (var n = {}, i = 0; i < this.length; i++) { const a = this[i][0]; typeof a === 'number' && (n[a] = !0) } for (i = 0; i < e.length; i++) { const o = e[i]; typeof o[0] === 'number' && n[o[0]] || (r && !o[2] ? o[2] = r : r && (o[2] = `(${o[2]}) and (${r})`), t.push(o)) } }, t } }, function (e, t, r) { const n = typeof document !== 'undefined'; if (typeof DEBUG !== 'undefined' && DEBUG && !n) throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."); const i = r(553); const a = {}; const o = n && (document.head || document.getElementsByTagName('head')[0]); let s = null; let u = 0; let l = !1; const c = function () {}; const p = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase()); function addStylesToDom(e) { for (let t = 0; t < e.length; t++) { const r = e[t]; const n = a[r.id]; if (n) { n.refs++; for (var i = 0; i < n.parts.length; i++)n.parts[i](r.parts[i]); for (;i < r.parts.length; i++)n.parts.push(addStyle(r.parts[i])); n.parts.length > r.parts.length && (n.parts.length = r.parts.length) } else { const o = []; for (i = 0; i < r.parts.length; i++)o.push(addStyle(r.parts[i])); a[r.id] = { id: r.id, refs: 1, parts: o } } } } function createStyleElement() { const e = document.createElement('style'); return e.type = 'text/css', o.appendChild(e), e } function addStyle(e) { let t; let r; let n = document.querySelector(`style[data-vue-ssr-id~="${e.id}"]`); if (n) { if (l) return c; n.parentNode.removeChild(n) } if (p) { const i = u++; n = s || (s = createStyleElement()), t = applyToSingletonTag.bind(null, n, i, !1), r = applyToSingletonTag.bind(null, n, i, !0) } else n = createStyleElement(), t = function applyToTag(e, t) { let r = t.css; const n = t.media; const i = t.sourceMap; n && e.setAttribute('media', n); i && (r += `\n/*# sourceURL=${i.sources[0]} */`, r += `\n/*# sourceMappingURL=data:application/json;base64,${btoa(unescape(encodeURIComponent(JSON.stringify(i))))} */`); if (e.styleSheet)e.styleSheet.cssText = r; else { for (;e.firstChild;)e.removeChild(e.firstChild); e.appendChild(document.createTextNode(r)) } }.bind(null, n), r = function () { n.parentNode.removeChild(n) }; return t(e), function updateStyle(n) { if (n) { if (n.css === e.css && n.media === e.media && n.sourceMap === e.sourceMap) return; t(e = n) } else r(); } }e.exports = function (e, t, r) { l = r; let n = i(e, t); return addStylesToDom(n), function update(t) { for (var r = [], o = 0; o < n.length; o++) { const s = n[o]; (u = a[s.id]).refs--, r.push(u) }t ? addStylesToDom(n = i(e, t)) : n = []; for (o = 0; o < r.length; o++) { var u; if ((u = r[o]).refs === 0) { for (let l = 0; l < u.parts.length; l++)u.parts[l](); delete a[u.id] } } } }; let f; const d = (f = [], function (e, t) { return f[e] = t, f.filter(Boolean).join('\n') }); function applyToSingletonTag(e, t, r, n) { const i = r ? '' : n.css; if (e.styleSheet)e.styleSheet.cssText = d(t, i); else { const a = document.createTextNode(i); const o = e.childNodes; o[t] && e.removeChild(o[t]), o.length ? e.insertBefore(a, o[t]) : e.appendChild(a) } } }, function (e, t, r) { const n = r(12); const i = r(7); const a = r(24); const o = r(28); var s = function (e, t, r) { let u; let l; let c; const p = e & s.F; const f = e & s.G; const d = e & s.S; const h = e & s.P; const m = e & s.B; const g = e & s.W; const v = f ? i : i[t] || (i[t] = {}); const y = v.prototype; const b = f ? n : d ? n[t] : (n[t] || {}).prototype; for (u in f && (r = t), r)(l = !p && b && void 0 !== b[u]) && u in v || (c = l ? b[u] : r[u], v[u] = f && typeof b[u] !== 'function' ? r[u] : m && l ? a(c, n) : g && b[u] == c ? (function (e) { const t = function (t, r, n) { if (this instanceof e) { switch (arguments.length) { case 0: return new e(); case 1: return new e(t); case 2: return new e(t, r); } return new e(t, r, n) } return e.apply(this, arguments) }; return t.prototype = e.prototype, t }(c)) : h && typeof c === 'function' ? a(Function.call, c) : c, h && ((v.virtual || (v.virtual = {}))[u] = c, e & s.R && y && !y[u] && o(y, u, c))); }; s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, s.U = 64, s.R = 128, e.exports = s }, function (e, t) { const r = e.exports = { version: '2.5.3' }; typeof __e === 'number' && (__e = r) }, function (e, t, r) { e.exports = r(665) }, function (e, t, r) {
  t.__esModule = !0; const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(199))); t.default = function (e) { return function () { const t = e.apply(this, arguments); return new n.default(((e, r) => (function step(i, a) { try { var o = t[i](a); var s = o.value } catch (e) { return void r(e) } if (!o.done) return n.default.resolve(s).then((e) => { step('next', e) }, (e) => { step('throw', e) }); e(s) }('next')))) } };
}, function (e, t, r) { const n = r(126); const i = typeof self === 'object' && self && self.Object === Object && self; const a = n || i || Function('return this')(); e.exports = a }, function (e, t, r) {
  let n;
  /*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
  /*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
  !(function () {
    const r = {}.hasOwnProperty; function classNames() { for (var e = [], t = 0; t < arguments.length; t++) { const n = arguments[t]; if (n) { const i = typeof n; if (i === 'string' || i === 'number')e.push(n); else if (Array.isArray(n))e.push(classNames(...n)); else if (i === 'object') for (const a in n)r.call(n, a) && n[a] && e.push(a); } } return e.join(' ') } void 0 !== e && e.exports ? e.exports = classNames : void 0 === (n = function () { return classNames }.apply(t, [])) || (e.exports = n);
  }());
}, function (e, t) { const r = e.exports = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); typeof __g === 'number' && (__g = r) }, function (e, t, r) { const n = r(203)('wks'); const i = r(113); const a = r(12).Symbol; const o = typeof a === 'function'; (e.exports = function (e) { return n[e] || (n[e] = o && a[e] || (o ? a : i)(`Symbol.${e}`)) }).store = n }, function (e, t) { let r; r = (function () { return this }()); try { r = r || Function('return this')() || (0, eval)('this') } catch (e) { typeof window === 'object' && (r = window) }e.exports = r }, function (e, t) { e.exports = function isObject(e) { const t = typeof e; return e != null && (t == 'object' || t == 'function') } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(367); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t) { const r = Array.isArray; e.exports = r }, function (e, t, r) {
  (function (e) {
    (function (t, r) {
      r = r && r.hasOwnProperty('default') ? r.default : r; const n = typeof window !== 'undefined' ? window : void 0 !== e ? e : typeof self !== 'undefined' ? self : {}; const i = (function createCommonjsModule(e, t) { return e(t = { exports: {} }, t.exports), t.exports }((e) => {
        let t; let r; let i; let a; let o; let s; let u; let l; let c; let p; let f; let d; let h; let m; let g; t = n, r = function (e, t, n) { if (!l(t) || p(t) || f(t) || d(t) || u(t)) return t; let i; let a = 0; let o = 0; if (c(t)) for (i = [], o = t.length; a < o; a++)i.push(r(e, t[a], n)); else for (const s in i = {}, t)Object.prototype.hasOwnProperty.call(t, s) && (i[e(s, n)] = r(e, t[s], n)); return i }, i = function (e) { return h(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, (e, t) => (t ? t.toUpperCase() : ''))).substr(0, 1).toLowerCase() + e.substr(1) }, a = function (e) { const t = i(e); return t.substr(0, 1).toUpperCase() + t.substr(1) }, o = function (e, t) { return (function (e, t) { const r = (t = t || {}).separator || '_'; const n = t.split || /(?=[A-Z])/; return e.split(n).join(r) }(e, t)).toLowerCase() }, s = Object.prototype.toString, u = function (e) { return typeof e === 'function' }, l = function (e) { return e === Object(e) }, c = function (e) { return s.call(e) == '[object Array]' }, p = function (e) { return s.call(e) == '[object Date]' }, f = function (e) { return s.call(e) == '[object RegExp]' }, d = function (e) { return s.call(e) == '[object Boolean]' }, h = function (e) { return (e -= 0) == e }, m = function (e, t) { const r = t && 'process' in t ? t.process : t; return typeof r !== 'function' ? e : function (t, n) { return r(t, e, n) } }, g = {
          camelize: i, decamelize: o, pascalize: a, depascalize: o, camelizeKeys(e, t) { return r(m(i, t), e) }, decamelizeKeys(e, t) { return r(m(o, t), e, t) }, pascalizeKeys(e, t) { return r(m(a, t), e) }, depascalizeKeys() { return this.decamelizeKeys.apply(this, arguments) },
        }, e.exports ? e.exports = g : t.humps = g;
      })); const a = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; const o = ((function () {
        function AwaitValue(e) { this.value = e } function AsyncGenerator(e) {
          let t; let r; function resume(t, r) { try { const n = e[t](r); const i = n.value; i instanceof AwaitValue ? Promise.resolve(i.value).then((e) => { resume('next', e) }, (e) => { resume('throw', e) }) : settle(n.done ? 'return' : 'normal', n.value) } catch (e) { settle('throw', e) } } function settle(e, n) { switch (e) { case 'return': t.resolve({ value: n, done: !0 }); break; case 'throw': t.reject(n); break; default: t.resolve({ value: n, done: !1 }); }(t = t.next) ? resume(t.key, t.arg) : r = null } this._invoke = function send(e, n) {
            return new Promise(((i, a) => {
              const o = {
                key: e, arg: n, resolve: i, reject: a, next: null,
              }; r ? r = r.next = o : (t = r = o, resume(e, n));
            }));
          }, typeof e.return !== 'function' && (this.return = void 0);
        } typeof Symbol === 'function' && Symbol.asyncIterator && (AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this }), AsyncGenerator.prototype.next = function (e) { return this._invoke('next', e) }, AsyncGenerator.prototype.throw = function (e) { return this._invoke('throw', e) }, AsyncGenerator.prototype.return = function (e) { return this._invoke('return', e) };
      }()), function (e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r, enumerable: !0, configurable: !0, writable: !0,
        }) : e[t] = r, e;
      }); const s = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const u = function (e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }; function convert(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const a = (t.children || []).map(convert.bind(null, e)); const o = Object.keys(t.attributes || {}).reduce((e, r) => { const n = t.attributes[r]; switch (r) { case 'class': e.class = (function classToObject(e) { return e.split(/\s+/).reduce((e, t) => e[t] = !0, e, {}) }(n)); break; case 'style': e.style = (function styleToObject(e) { return e.split(';').map(e => e.trim()).filter(e => e).reduce((e, t) => { const r = t.indexOf(':'); const n = i.camelize(t.slice(0, r)); const a = t.slice(r + 1).trim(); return e[n] = a, e }, {}) }(n)); break; default: e.attrs[r] = n; } return e }, { class: {}, style: {}, attrs: {} }); const l = n.class; const c = void 0 === l ? {} : l; const p = n.style; const f = void 0 === p ? {} : p; const d = n.attrs; const h = void 0 === d ? {} : d; const m = u(n, ['class', 'style', 'attrs']); return typeof t === 'string' ? t : e(t.tag, s({ class: (function combineClassObjects() { for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return t.reduce((e, t) => (Array.isArray(t) ? e = e.concat(t) : e.push(t)), e, []) }(o.class, c)), style: s({}, o.style, f), attrs: s({}, o.attrs, h) }, m, { props: r }), a) } let l = !1; try { l = !0 } catch (e) {} function objectWithKey(e, t) { return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? o({}, e, t) : {} } function normalizeIconArgs(e) { return e === null ? null : (void 0 === e ? 'undefined' : a(e)) === 'object' && e.prefix && e.iconName ? e : Array.isArray(e) && e.length === 2 ? { prefix: e[0], iconName: e[1] } : typeof e === 'string' ? { prefix: 'fas', iconName: e } : void 0 } const c = {
        name: 'FontAwesomeIcon',
        functional: !0,
        props: {
          border: { type: Boolean, default: !1 }, fixedWidth: { type: Boolean, default: !1 }, flip: { type: String, default: null, validator: function validator(e) { return ['horizontal', 'vertical', 'both'].indexOf(e) > -1 } }, icon: { type: [Object, Array, String], required: !0 }, mask: { type: [Object, Array, String], default: null }, listItem: { type: Boolean, default: !1 }, pull: { type: String, default: null, validator: function validator(e) { return ['right', 'left'].indexOf(e) > -1 } }, pulse: { type: Boolean, default: !1 }, rotation: { type: Number, default: null, validator: function validator(e) { return [90, 180, 270].indexOf(e) > -1 } }, size: { type: String, default: null, validator: function validator(e) { return ['lg', 'xs', 'sm', '1x', '2x', '3x', '4x', '5x', '6x', '7x', '8x', '9x', '10x'].indexOf(e) > -1 } }, spin: { type: Boolean, default: !1 }, transform: { type: [String, Object], default: null }, symbol: { type: [Boolean, String], default: !1 },
        },
        render: function render(e, t) {
          const n = t.props; const i = n.icon; const a = n.mask; const u = n.symbol; const c = normalizeIconArgs(i); const p = objectWithKey('classes', (function classList(e) {
            let t; const r = (t = {
              'fa-spin': e.spin, 'fa-pulse': e.pulse, 'fa-fw': e.fixedWidth, 'fa-border': e.border, 'fa-li': e.listItem, 'fa-flip-horizontal': e.flip === 'horizontal' || e.flip === 'both', 'fa-flip-vertical': e.flip === 'vertical' || e.flip === 'both',
            }, o(t, `fa-${e.size}`, e.size !== null), o(t, `fa-rotate-${e.rotation}`, e.rotation !== null), o(t, `fa-pull-${e.pull}`, e.pull !== null), t); return Object.keys(r).map(e => (r[e] ? e : null)).filter(e => e);
          }(n))); const f = objectWithKey('transform', typeof n.transform === 'string' ? r.parse.transform(n.transform) : n.transform); const d = objectWithKey('mask', normalizeIconArgs(a)); const h = r.icon(c, s({}, p, f, d, { symbol: u })); if (!h) return (function () { let e; !l && console && typeof console.error === 'function' && (e = console).error.apply(e, arguments) }('Check not find one or more icon(s)', c, d)); const m = h.abstract; return convert.bind(null, e)(m[0], {}, t.data);
        },
      }; const p = {
        name: 'FontAwesomeLayers', functional: !0, props: { fixedWidth: { type: Boolean, default: !1 } }, render: function render(e, t) { const n = r.config.familyPrefix; const i = t.data.staticClass; const a = [`${n}-layers`].concat(function (e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) }(t.props.fixedWidth ? [`${n}-fw`] : [])); return e('div', s({}, t.data, { staticClass: (function addStaticClass(e, t) { return ((e || '').length === 0 ? [] : [e]).concat(t).join(' ') }(i, a)) }), t.children) },
      }; const f = {
        name: 'FontAwesomeLayersText', functional: !0, props: { value: { type: String, default: '' }, transform: { type: [String, Object], default: null } }, render: function render(e, t) { const n = t.props; const i = objectWithKey('transform', typeof n.transform === 'string' ? r.parse.transform(n.transform) : n.transform); const a = r.text(n.value, s({}, i)).abstract; return convert.bind(null, e)(a[0], {}, t.data) },
      }; r.noAuto(), t.default = c, t.FontAwesomeIcon = c, t.FontAwesomeLayers = p, t.FontAwesomeLayersText = f, Object.defineProperty(t, '__esModule', { value: !0 });
    }(t, r(554)));
  }).call(t, r(14));
}, function (e, t, r) { const n = r(29); const i = r(567); const a = r(568); const o = Object.defineProperty; t.f = r(25) ? Object.defineProperty : function defineProperty(e, t, r) { if (n(e), t = a(t, !0), n(r), i) try { return o(e, t, r) } catch (e) {} if ('get' in r || 'set' in r) throw TypeError('Accessors not supported!'); return 'value' in r && (e[t] = r.value), e } }, function (e, t) { e.exports = function (e) { return typeof e === 'object' ? e !== null : typeof e === 'function' } }, function (e, t, r) {
  const n = function () {}; e.exports = n;
}, function (e, t) { e.exports = function isObjectLike(e) { return e != null && typeof e === 'object' } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), function (e, r) {
    /*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
    const n = Object.freeze({}); function isUndef(e) { return void 0 === e || e === null } function isDef(e) { return void 0 !== e && e !== null } function isTrue(e) { return !0 === e } function isPrimitive(e) { return typeof e === 'string' || typeof e === 'number' || typeof e === 'symbol' || typeof e === 'boolean' } function isObject(e) { return e !== null && typeof e === 'object' } const i = Object.prototype.toString; function isPlainObject(e) { return i.call(e) === '[object Object]' } function isRegExp(e) { return i.call(e) === '[object RegExp]' } function isValidArrayIndex(e) { const t = parseFloat(String(e)); return t >= 0 && Math.floor(t) === t && isFinite(e) } function toString(e) { return e == null ? '' : typeof e === 'object' ? JSON.stringify(e, null, 2) : String(e) } function toNumber(e) { const t = parseFloat(e); return isNaN(t) ? e : t } function makeMap(e, t) { for (var r = Object.create(null), n = e.split(','), i = 0; i < n.length; i++)r[n[i]] = !0; return t ? function (e) { return r[e.toLowerCase()] } : function (e) { return r[e] } } const a = makeMap('slot,component', !0); const o = makeMap('key,ref,slot,slot-scope,is'); function remove(e, t) { if (e.length) { const r = e.indexOf(t); if (r > -1) return e.splice(r, 1); } } const s = Object.prototype.hasOwnProperty; function hasOwn(e, t) { return s.call(e, t) } function cached(e) { const t = Object.create(null); return function cachedFn(r) { return t[r] || (t[r] = e(r)) } } const u = /-(\w)/g; const l = cached(e => e.replace(u, (e, t) => (t ? t.toUpperCase() : ''))); const c = cached(e => e.charAt(0).toUpperCase() + e.slice(1)); const p = /\B([A-Z])/g; const f = cached(e => e.replace(p, '-$1').toLowerCase()); const d = Function.prototype.bind ? function nativeBind(e, t) { return e.bind(t) } : function polyfillBind(e, t) { function boundFn(r) { const n = arguments.length; return n ? n > 1 ? e.apply(t, arguments) : e.call(t, r) : e.call(t) } return boundFn._length = e.length, boundFn }; function toArray(e, t) { t = t || 0; for (var r = e.length - t, n = new Array(r); r--;)n[r] = e[r + t]; return n } function extend(e, t) { for (const r in t)e[r] = t[r]; return e } function toObject(e) { for (var t = {}, r = 0; r < e.length; r++)e[r] && extend(t, e[r]); return t } function noop(e, t, r) {} const h = function (e, t, r) { return !1 }; const m = function (e) { return e }; function looseEqual(e, t) { if (e === t) return !0; const r = isObject(e); const n = isObject(t); if (!r || !n) return !r && !n && String(e) === String(t); try { const i = Array.isArray(e); const a = Array.isArray(t); if (i && a) return e.length === t.length && e.every((e, r) => looseEqual(e, t[r])); if (i || a) return !1; const o = Object.keys(e); const s = Object.keys(t); return o.length === s.length && o.every(r => looseEqual(e[r], t[r])) } catch (e) { return !1 } } function looseIndexOf(e, t) { for (let r = 0; r < e.length; r++) if (looseEqual(e[r], t)) return r; return -1 } function once(e) { let t = !1; return function () { t || (t = !0, e.apply(this, arguments)) } } const g = 'data-server-rendered'; const v = ['component', 'directive', 'filter']; const y = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured']; const b = {
      optionMergeStrategies: Object.create(null), silent: !1, productionTip: !1, devtools: !1, performance: !1, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: h, isReservedAttr: h, isUnknownElement: h, getTagNamespace: noop, parsePlatformTagName: m, mustUseProp: h, _lifecycleHooks: y,
    }; function isReserved(e) { const t = (`${e}`).charCodeAt(0); return t === 36 || t === 95 } function def(e, t, r, n) {
      Object.defineProperty(e, t, {
        value: r, enumerable: !!n, writable: !0, configurable: !0,
      });
    } const x = /[^\w.$]/; let D; const _ = '__proto__' in {}; const C = typeof window !== 'undefined'; const w = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform; const E = w && WXEnvironment.platform.toLowerCase(); const S = C && window.navigator.userAgent.toLowerCase(); const k = S && /msie|trident/.test(S); const A = S && S.indexOf('msie 9.0') > 0; const T = S && S.indexOf('edge/') > 0; const P = (S && S.indexOf('android'), S && /iphone|ipad|ipod|ios/.test(S) || E === 'ios'); const R = (S && /chrome\/\d+/.test(S), {}.watch); let O = !1; if (C) try { const F = {}; Object.defineProperty(F, 'passive', { get: function get() { O = !0 } }), window.addEventListener('test-passive', null, F) } catch (e) {} const L = function () { return void 0 === D && (D = !C && !w && void 0 !== e && e.process.env.VUE_ENV === 'server'), D }; const M = C && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function isNative(e) { return typeof e === 'function' && /native code/.test(e.toString()) } let j; const N = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys); j = typeof Set !== 'undefined' && isNative(Set) ? Set : (function () { function Set() { this.set = Object.create(null) } return Set.prototype.has = function has(e) { return !0 === this.set[e] }, Set.prototype.add = function add(e) { this.set[e] = !0 }, Set.prototype.clear = function clear() { this.set = Object.create(null) }, Set }()); const I = noop; let B = 0; const q = function Dep() { this.id = B++, this.subs = [] }; q.prototype.addSub = function addSub(e) { this.subs.push(e) }, q.prototype.removeSub = function removeSub(e) { remove(this.subs, e) }, q.prototype.depend = function depend() { q.target && q.target.addDep(this) }, q.prototype.notify = function notify() { for (let e = this.subs.slice(), t = 0, r = e.length; t < r; t++)e[t].update(); }, q.target = null; const U = []; function pushTarget(e) { q.target && U.push(q.target), q.target = e } function popTarget() { q.target = U.pop() } const z = function VNode(e, t, r, n, i, a, o, s) { this.tag = e, this.data = t, this.children = r, this.text = n, this.elm = i, this.ns = void 0, this.context = a, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = o, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1 }; const V = { child: { configurable: !0 } }; V.child.get = function () { return this.componentInstance }, Object.defineProperties(z.prototype, V); const H = function (e) { void 0 === e && (e = ''); const t = new z(); return t.text = e, t.isComment = !0, t }; function createTextVNode(e) { return new z(void 0, void 0, void 0, String(e)) } function cloneVNode(e) { const t = new z(e.tag, e.data, e.children, e.text, e.elm, e.context, e.componentOptions, e.asyncFactory); return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.isCloned = !0, t } const $ = Array.prototype; const G = Object.create($); ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach((e) => { const t = $[e]; def(G, e, function mutator() { for (var r = [], n = arguments.length; n--;)r[n] = arguments[n]; let i; const a = t.apply(this, r); const o = this.__ob__; switch (e) { case 'push': case 'unshift': i = r; break; case 'splice': i = r.slice(2); } return i && o.observeArray(i), o.dep.notify(), a }) }); const J = Object.getOwnPropertyNames(G); let W = !0; function toggleObserving(e) { W = e } const K = function Observer(e) { (this.value = e, this.dep = new q(), this.vmCount = 0, def(e, '__ob__', this), Array.isArray(e)) ? ((_ ? protoAugment : copyAugment)(e, G, J), this.observeArray(e)) : this.walk(e) }; function protoAugment(e, t, r) { e.__proto__ = t } function copyAugment(e, t, r) { for (let n = 0, i = r.length; n < i; n++) { const a = r[n]; def(e, a, t[a]) } } function observe(e, t) { let r; if (isObject(e) && !(e instanceof z)) return hasOwn(e, '__ob__') && e.__ob__ instanceof K ? r = e.__ob__ : W && !L() && (Array.isArray(e) || isPlainObject(e)) && Object.isExtensible(e) && !e._isVue && (r = new K(e)), t && r && r.vmCount++, r; } function defineReactive(e, t, r, n, i) {
      const a = new q();


      const o = Object.getOwnPropertyDescriptor(e, t); if (!o || !1 !== o.configurable) {
        const s = o && o.get; s || arguments.length !== 2 || (r = e[t]); const u = o && o.set; let l = !i && observe(r); Object.defineProperty(e, t, {
          enumerable: !0, configurable: !0, get: function reactiveGetter() { const t = s ? s.call(e) : r; return q.target && (a.depend(), l && (l.dep.depend(), Array.isArray(t) && (function dependArray(e) { for (let t = void 0, r = 0, n = e.length; r < n; r++)(t = e[r]) && t.__ob__ && t.__ob__.dep.depend(), Array.isArray(t) && dependArray(t); }(t)))), t }, set: function reactiveSetter(t) { const n = s ? s.call(e) : r; t === n || t != t && n != n || (u ? u.call(e, t) : r = t, l = !i && observe(t), a.notify()) },
        });
      }
    } function set(e, t, r) { if (Array.isArray(e) && isValidArrayIndex(t)) return e.length = Math.max(e.length, t), e.splice(t, 1, r), r; if (t in e && !(t in Object.prototype)) return e[t] = r, r; const n = e.__ob__; return e._isVue || n && n.vmCount ? r : n ? (defineReactive(n.value, t, r), n.dep.notify(), r) : (e[t] = r, r) } function del(e, t) { if (Array.isArray(e) && isValidArrayIndex(t))e.splice(t, 1); else { const r = e.__ob__; e._isVue || r && r.vmCount || hasOwn(e, t) && (delete e[t], r && r.dep.notify()) } }K.prototype.walk = function walk(e) { for (let t = Object.keys(e), r = 0; r < t.length; r++)defineReactive(e, t[r]); }, K.prototype.observeArray = function observeArray(e) { for (let t = 0, r = e.length; t < r; t++)observe(e[t]); }; const X = b.optionMergeStrategies; function mergeData(e, t) { if (!t) return e; for (var r, n, i, a = Object.keys(t), o = 0; o < a.length; o++)n = e[r = a[o]], i = t[r], hasOwn(e, r) ? isPlainObject(n) && isPlainObject(i) && mergeData(n, i) : set(e, r, i); return e } function mergeDataOrFn(e, t, r) { return r ? function mergedInstanceDataFn() { const n = typeof t === 'function' ? t.call(r, r) : t; const i = typeof e === 'function' ? e.call(r, r) : e; return n ? mergeData(n, i) : i } : t ? e ? function mergedDataFn() { return mergeData(typeof t === 'function' ? t.call(this, this) : t, typeof e === 'function' ? e.call(this, this) : e) } : t : e } function mergeHook(e, t) { return t ? e ? e.concat(t) : Array.isArray(t) ? t : [t] : e } function mergeAssets(e, t, r, n) { const i = Object.create(e || null); return t ? extend(i, t) : i }X.data = function (e, t, r) { return r ? mergeDataOrFn(e, t, r) : t && typeof t !== 'function' ? e : mergeDataOrFn(e, t) }, y.forEach((e) => { X[e] = mergeHook }), v.forEach((e) => { X[`${e}s`] = mergeAssets }), X.watch = function (e, t, r, n) { if (e === R && (e = void 0), t === R && (t = void 0), !t) return Object.create(e || null); if (!e) return t; const i = {}; for (const a in extend(i, e), t) { let o = i[a]; const s = t[a]; o && !Array.isArray(o) && (o = [o]), i[a] = o ? o.concat(s) : Array.isArray(s) ? s : [s] } return i }, X.props = X.methods = X.inject = X.computed = function (e, t, r, n) { if (!e) return t; const i = Object.create(null); return extend(i, e), t && extend(i, t), i }, X.provide = mergeDataOrFn; const Y = function (e, t) { return void 0 === t ? e : t }; function mergeOptions(e, t, r) { typeof t === 'function' && (t = t.options), (function normalizeProps(e, t) { const r = e.props; if (r) { let n; let i; const a = {}; if (Array.isArray(r)) for (n = r.length; n--;) typeof (i = r[n]) === 'string' && (a[l(i)] = { type: null }); else if (isPlainObject(r)) for (const o in r)i = r[o], a[l(o)] = isPlainObject(i) ? i : { type: i }; e.props = a } }(t)), (function normalizeInject(e, t) { const r = e.inject; if (r) { const n = e.inject = {}; if (Array.isArray(r)) for (let i = 0; i < r.length; i++)n[r[i]] = { from: r[i] }; else if (isPlainObject(r)) for (const a in r) { const o = r[a]; n[a] = isPlainObject(o) ? extend({ from: a }, o) : { from: o } } } }(t)), (function normalizeDirectives(e) { const t = e.directives; if (t) for (const r in t) { const n = t[r]; typeof n === 'function' && (t[r] = { bind: n, update: n }) } }(t)); const n = t.extends; if (n && (e = mergeOptions(e, n, r)), t.mixins) for (let i = 0, a = t.mixins.length; i < a; i++)e = mergeOptions(e, t.mixins[i], r); let o; const s = {}; for (o in e)mergeField(o); for (o in t)hasOwn(e, o) || mergeField(o); function mergeField(n) { const i = X[n] || Y; s[n] = i(e[n], t[n], r, n) } return s } function resolveAsset(e, t, r, n) { if (typeof r === 'string') { const i = e[t]; if (hasOwn(i, r)) return i[r]; const a = l(r); if (hasOwn(i, a)) return i[a]; const o = c(a); return hasOwn(i, o) ? i[o] : i[r] || i[a] || i[o] } } function validateProp(e, t, r, n) { const i = t[e]; const a = !hasOwn(r, e); let o = r[e]; const s = getTypeIndex(Boolean, i.type); if (s > -1) if (a && !hasOwn(i, 'default'))o = !1; else if (o === '' || o === f(e)) { const u = getTypeIndex(String, i.type); (u < 0 || s < u) && (o = !0) } if (void 0 === o) { o = (function getPropDefaultValue(e, t, r) { if (!hasOwn(t, 'default')) return; const n = t.default; 0; if (e && e.$options.propsData && void 0 === e.$options.propsData[r] && void 0 !== e._props[r]) return e._props[r]; return typeof n === 'function' && getType(t.type) !== 'Function' ? n.call(e) : n }(n, i, e)); const l = W; toggleObserving(!0), observe(o), toggleObserving(l) } return o } function getType(e) { const t = e && e.toString().match(/^\s*function (\w+)/); return t ? t[1] : '' } function isSameType(e, t) { return getType(e) === getType(t) } function getTypeIndex(e, t) { if (!Array.isArray(t)) return isSameType(t, e) ? 0 : -1; for (let r = 0, n = t.length; r < n; r++) if (isSameType(t[r], e)) return r; return -1 } function handleError(e, t, r) { if (t) for (let n = t; n = n.$parent;) { const i = n.$options.errorCaptured; if (i) for (let a = 0; a < i.length; a++) try { if (!1 === i[a].call(n, e, t, r)) return; } catch (e) { globalHandleError(e, n, 'errorCaptured hook') } }globalHandleError(e, t, r) } function globalHandleError(e, t, r) { if (b.errorHandler) try { return b.errorHandler.call(null, e, t, r) } catch (e) { logError(e, null, 'config.errorHandler') }logError(e, t, r) } function logError(e, t, r) { if (!C && !w || typeof console === 'undefined') throw e; console.error(e) } let Q; let Z; const ee = []; let te = !1; function flushCallbacks() { te = !1; const e = ee.slice(0); ee.length = 0; for (let t = 0; t < e.length; t++)e[t](); } let re = !1; if (void 0 !== r && isNative(r))Z = function () { r(flushCallbacks) }; else if (typeof MessageChannel === 'undefined' || !isNative(MessageChannel) && MessageChannel.toString() !== '[object MessageChannelConstructor]')Z = function () { setTimeout(flushCallbacks, 0) }; else {
      const ne = new MessageChannel();


      const ie = ne.port2; ne.port1.onmessage = flushCallbacks, Z = function () { ie.postMessage(1) };
    } if (typeof Promise !== 'undefined' && isNative(Promise)) { const ae = Promise.resolve(); Q = function () { ae.then(flushCallbacks), P && setTimeout(noop) } } else Q = Z; function nextTick(e, t) { let r; if (ee.push(() => { if (e) try { e.call(t) } catch (e) { handleError(e, t, 'nextTick') } else r && r(t); }), te || (te = !0, re ? Z() : Q()), !e && typeof Promise !== 'undefined') return new Promise(((e) => { r = e })); } const oe = new j(); function traverse(e) { !(function _traverse(e, t) { let r; let n; const i = Array.isArray(e); if (!i && !isObject(e) || Object.isFrozen(e) || e instanceof z) return; if (e.__ob__) { const a = e.__ob__.dep.id; if (t.has(a)) return; t.add(a) } if (i) for (r = e.length; r--;)_traverse(e[r], t); else for (n = Object.keys(e), r = n.length; r--;)_traverse(e[n[r]], t); }(e, oe)), oe.clear() } let se; const ue = cached((e) => {
      const t = e.charAt(0) === '&'; const r = (e = t ? e.slice(1) : e).charAt(0) === '~'; const n = (e = r ? e.slice(1) : e).charAt(0) === '!'; return {
        name: e = n ? e.slice(1) : e, once: r, capture: n, passive: t,
      };
    }); function createFnInvoker(e) { function invoker() { const e = arguments; const t = invoker.fns; if (!Array.isArray(t)) return t(...arguments); for (let r = t.slice(), n = 0; n < r.length; n++)r[n].apply(null, e); } return invoker.fns = e, invoker } function updateListeners(e, t, r, n, i) { let a; let o; let s; let u; for (a in e)o = e[a], s = t[a], u = ue(a), isUndef(o) || (isUndef(s) ? (isUndef(o.fns) && (o = e[a] = createFnInvoker(o)), r(u.name, o, u.once, u.capture, u.passive, u.params)) : o !== s && (s.fns = o, e[a] = s)); for (a in t)isUndef(e[a]) && n((u = ue(a)).name, t[a], u.capture); } function mergeVNodeHook(e, t, r) { let n; e instanceof z && (e = e.data.hook || (e.data.hook = {})); const i = e[t]; function wrappedHook() { r.apply(this, arguments), remove(n.fns, wrappedHook) }isUndef(i) ? n = createFnInvoker([wrappedHook]) : isDef(i.fns) && isTrue(i.merged) ? (n = i).fns.push(wrappedHook) : n = createFnInvoker([i, wrappedHook]), n.merged = !0, e[t] = n } function checkProp(e, t, r, n, i) { if (isDef(t)) { if (hasOwn(t, r)) return e[r] = t[r], i || delete t[r], !0; if (hasOwn(t, n)) return e[r] = t[n], i || delete t[n], !0; } return !1 } function normalizeChildren(e) { return isPrimitive(e) ? [createTextVNode(e)] : Array.isArray(e) ? (function normalizeArrayChildren(e, t) { const r = []; let n; let i; let a; let o; for (n = 0; n < e.length; n++)isUndef(i = e[n]) || typeof i === 'boolean' || (a = r.length - 1, o = r[a], Array.isArray(i) ? i.length > 0 && (isTextNode((i = normalizeArrayChildren(i, `${t || ''}_${n}`))[0]) && isTextNode(o) && (r[a] = createTextVNode(o.text + i[0].text), i.shift()), r.push(...i)) : isPrimitive(i) ? isTextNode(o) ? r[a] = createTextVNode(o.text + i) : i !== '' && r.push(createTextVNode(i)) : isTextNode(i) && isTextNode(o) ? r[a] = createTextVNode(o.text + i.text) : (isTrue(e._isVList) && isDef(i.tag) && isUndef(i.key) && isDef(t) && (i.key = `__vlist${t}_${n}__`), r.push(i))); return r }(e)) : void 0 } function isTextNode(e) { return isDef(e) && isDef(e.text) && (function isFalse(e) { return !1 === e }(e.isComment)) } function ensureCtor(e, t) { return (e.__esModule || N && e[Symbol.toStringTag] === 'Module') && (e = e.default), isObject(e) ? t.extend(e) : e } function isAsyncPlaceholder(e) { return e.isComment && e.asyncFactory } function getFirstComponentChild(e) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++) { const r = e[t]; if (isDef(r) && (isDef(r.componentOptions) || isAsyncPlaceholder(r))) return r; } } function add(e, t, r) { r ? se.$once(e, t) : se.$on(e, t) } function remove$1(e, t) { se.$off(e, t) } function updateComponentListeners(e, t, r) { se = e, updateListeners(t, r || {}, add, remove$1), se = void 0 } function resolveSlots(e, t) { const r = {}; if (!e) return r; for (let n = 0, i = e.length; n < i; n++) { const a = e[n]; const o = a.data; if (o && o.attrs && o.attrs.slot && delete o.attrs.slot, a.context !== t && a.fnContext !== t || !o || o.slot == null)(r.default || (r.default = [])).push(a); else { const s = o.slot; const u = r[s] || (r[s] = []); a.tag === 'template' ? u.push(...a.children || []) : u.push(a) } } for (const l in r)r[l].every(isWhitespace) && delete r[l]; return r } function isWhitespace(e) { return e.isComment && !e.asyncFactory || e.text === ' ' } function resolveScopedSlots(e, t) { t = t || {}; for (let r = 0; r < e.length; r++)Array.isArray(e[r]) ? resolveScopedSlots(e[r], t) : t[e[r].key] = e[r].fn; return t } let le = null; function isInInactiveTree(e) { for (;e && (e = e.$parent);) if (e._inactive) return !0; return !1 } function activateChildComponent(e, t) { if (t) { if (e._directInactive = !1, isInInactiveTree(e)) return; } else if (e._directInactive) return; if (e._inactive || e._inactive === null) { e._inactive = !1; for (let r = 0; r < e.$children.length; r++)activateChildComponent(e.$children[r]); callHook(e, 'activated') } } function callHook(e, t) { pushTarget(); const r = e.$options[t]; if (r) for (let n = 0, i = r.length; n < i; n++) try { r[n].call(e) } catch (r) { handleError(r, e, `${t} hook`) }e._hasHookEvent && e.$emit(`hook:${t}`), popTarget() } const ce = []; const pe = []; let fe = {}; let de = !1; let he = !1; let me = 0; function flushSchedulerQueue() { let e; let t; for (he = !0, ce.sort((e, t) => e.id - t.id), me = 0; me < ce.length; me++)t = (e = ce[me]).id, fe[t] = null, e.run(); const r = pe.slice(); const n = ce.slice(); !(function resetSchedulerState() { me = ce.length = pe.length = 0, fe = {}, de = he = !1 }()), (function callActivatedHooks(e) { for (let t = 0; t < e.length; t++)e[t]._inactive = !0, activateChildComponent(e[t], !0); }(r)), (function callUpdatedHooks(e) { let t = e.length; for (;t--;) { const r = e[t]; const n = r.vm; n._watcher === r && n._isMounted && callHook(n, 'updated') } }(n)), M && b.devtools && M.emit('flush') } let ge = 0; const ve = function Watcher(e, t, r, n, i) { this.vm = e, i && (e._watcher = this), e._watchers.push(this), n ? (this.deep = !!n.deep, this.user = !!n.user, this.lazy = !!n.lazy, this.sync = !!n.sync) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = r, this.id = ++ge, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new j(), this.newDepIds = new j(), this.expression = '', typeof t === 'function' ? this.getter = t : (this.getter = (function parsePath(e) { if (!x.test(e)) { const t = e.split('.'); return function (e) { for (let r = 0; r < t.length; r++) { if (!e) return; e = e[t[r]] } return e } } }(t)), this.getter || (this.getter = function () {})), this.value = this.lazy ? void 0 : this.get() }; ve.prototype.get = function get() { let e; pushTarget(this); const t = this.vm; try { e = this.getter.call(t, t) } catch (e) { if (!this.user) throw e; handleError(e, t, `getter for watcher "${this.expression}"`) } finally { this.deep && traverse(e), popTarget(), this.cleanupDeps() } return e }, ve.prototype.addDep = function addDep(e) { const t = e.id; this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this)) }, ve.prototype.cleanupDeps = function cleanupDeps() { for (let e = this.deps.length; e--;) { const t = this.deps[e]; this.newDepIds.has(t.id) || t.removeSub(this) } let r = this.depIds; this.depIds = this.newDepIds, this.newDepIds = r, this.newDepIds.clear(), r = this.deps, this.deps = this.newDeps, this.newDeps = r, this.newDeps.length = 0 }, ve.prototype.update = function update() { this.lazy ? this.dirty = !0 : this.sync ? this.run() : (function queueWatcher(e) { const t = e.id; if (fe[t] == null) { if (fe[t] = !0, he) { for (var r = ce.length - 1; r > me && ce[r].id > e.id;)r--; ce.splice(r + 1, 0, e) } else ce.push(e); de || (de = !0, nextTick(flushSchedulerQueue)) } }(this)) }, ve.prototype.run = function run() { if (this.active) { const e = this.get(); if (e !== this.value || isObject(e) || this.deep) { const t = this.value; if (this.value = e, this.user) try { this.cb.call(this.vm, e, t) } catch (e) { handleError(e, this.vm, `callback for watcher "${this.expression}"`) } else this.cb.call(this.vm, e, t); } } }, ve.prototype.evaluate = function evaluate() { this.value = this.get(), this.dirty = !1 }, ve.prototype.depend = function depend() { for (let e = this.deps.length; e--;) this.deps[e].depend(); }, ve.prototype.teardown = function teardown() { if (this.active) { this.vm._isBeingDestroyed || remove(this.vm._watchers, this); for (let e = this.deps.length; e--;) this.deps[e].removeSub(this); this.active = !1 } }; const ye = {
      enumerable: !0, configurable: !0, get: noop, set: noop,
    }; function proxy(e, t, r) { ye.get = function proxyGetter() { return this[t][r] }, ye.set = function proxySetter(e) { this[t][r] = e }, Object.defineProperty(e, r, ye) } function initState(e) { e._watchers = []; const t = e.$options; t.props && (function initProps(e, t) { const r = e.$options.propsData || {}; const n = e._props = {}; const i = e.$options._propKeys = []; e.$parent && toggleObserving(!1); const a = function (a) { i.push(a); const o = validateProp(a, t, r, e); defineReactive(n, a, o), a in e || proxy(e, '_props', a) }; for (const o in t)a(o); toggleObserving(!0) }(e, t.props)), t.methods && (function initMethods(e, t) { e.$options.props; for (const r in t)e[r] = t[r] == null ? noop : d(t[r], e); }(e, t.methods)), t.data ? (function initData(e) { let t = e.$options.data; isPlainObject(t = e._data = typeof t === 'function' ? (function getData(e, t) { pushTarget(); try { return e.call(t, t) } catch (e) { return handleError(e, t, 'data()'), {} } finally { popTarget() } }(t, e)) : t || {}) || (t = {}); const r = Object.keys(t); const n = e.$options.props; let i = (e.$options.methods, r.length); for (;i--;) { const a = r[i]; 0, n && hasOwn(n, a) || isReserved(a) || proxy(e, '_data', a) }observe(t, !0) }(e)) : observe(e._data = {}, !0), t.computed && (function initComputed(e, t) { const r = e._computedWatchers = Object.create(null); const n = L(); for (const i in t) { const a = t[i]; const o = typeof a === 'function' ? a : a.get; 0, n || (r[i] = new ve(e, o || noop, noop, be)), i in e || defineComputed(e, i, a) } }(e, t.computed)), t.watch && t.watch !== R && (function initWatch(e, t) { for (const r in t) { const n = t[r]; if (Array.isArray(n)) for (let i = 0; i < n.length; i++)createWatcher(e, r, n[i]); else createWatcher(e, r, n); } }(e, t.watch)) } var be = { lazy: !0 }; function defineComputed(e, t, r) { const n = !L(); typeof r === 'function' ? (ye.get = n ? createComputedGetter(t) : r, ye.set = noop) : (ye.get = r.get ? n && !1 !== r.cache ? createComputedGetter(t) : r.get : noop, ye.set = r.set ? r.set : noop), Object.defineProperty(e, t, ye) } function createComputedGetter(e) { return function computedGetter() { const t = this._computedWatchers && this._computedWatchers[e]; if (t) return t.dirty && t.evaluate(), q.target && t.depend(), t.value; } } function createWatcher(e, t, r, n) { return isPlainObject(r) && (n = r, r = r.handler), typeof r === 'string' && (r = e[r]), e.$watch(t, r, n) } function resolveInject(e, t) { if (e) { for (var r = Object.create(null), n = N ? Reflect.ownKeys(e).filter(t => Object.getOwnPropertyDescriptor(e, t).enumerable) : Object.keys(e), i = 0; i < n.length; i++) { for (var a = n[i], o = e[a].from, s = t; s;) { if (s._provided && hasOwn(s._provided, o)) { r[a] = s._provided[o]; break }s = s.$parent } if (!s) if ('default' in e[a]) { const u = e[a].default; r[a] = typeof u === 'function' ? u.call(t) : u } else 0; } return r } } function renderList(e, t) { let r; let n; let i; let a; let o; if (Array.isArray(e) || typeof e === 'string') for (r = new Array(e.length), n = 0, i = e.length; n < i; n++)r[n] = t(e[n], n); else if (typeof e === 'number') for (r = new Array(e), n = 0; n < e; n++)r[n] = t(n + 1, n); else if (isObject(e)) for (a = Object.keys(e), r = new Array(a.length), n = 0, i = a.length; n < i; n++)o = a[n], r[n] = t(e[o], o, n); return isDef(r) && (r._isVList = !0), r } function renderSlot(e, t, r, n) { let i; const a = this.$scopedSlots[e]; if (a)r = r || {}, n && (r = extend(extend({}, n), r)), i = a(r) || t; else { const o = this.$slots[e]; o && (o._rendered = !0), i = o || t } const s = r && r.slot; return s ? this.$createElement('template', { slot: s }, i) : i } function resolveFilter(e) { return resolveAsset(this.$options, 'filters', e) || m } function isKeyNotMatch(e, t) { return Array.isArray(e) ? e.indexOf(t) === -1 : e !== t } function checkKeyCodes(e, t, r, n, i) { const a = b.keyCodes[t] || r; return i && n && !b.keyCodes[t] ? isKeyNotMatch(i, n) : a ? isKeyNotMatch(a, e) : n ? f(n) !== t : void 0 } function bindObjectProps(e, t, r, n, i) { if (r) if (isObject(r)) { let a; Array.isArray(r) && (r = toObject(r)); const s = function (s) { if (s === 'class' || s === 'style' || o(s))a = e; else { const u = e.attrs && e.attrs.type; a = n || b.mustUseProp(t, u, s) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {}) }s in a || (a[s] = r[s], i && ((e.on || (e.on = {}))[`update:${s}`] = function (e) { r[s] = e })) }; for (const u in r)s(u); } else;return e } function renderStatic(e, t) { const r = this._staticTrees || (this._staticTrees = []); let n = r[e]; return n && !t ? n : (markStatic(n = r[e] = this.$options.staticRenderFns[e].call(this._renderProxy, null, this), `__static__${e}`, !1), n) } function markOnce(e, t, r) { return markStatic(e, `__once__${t}${r ? `_${r}` : ''}`, !0), e } function markStatic(e, t, r) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)e[n] && typeof e[n] !== 'string' && markStaticNode(e[n], `${t}_${n}`, r); else markStaticNode(e, t, r); } function markStaticNode(e, t, r) { e.isStatic = !0, e.key = t, e.isOnce = r } function bindObjectListeners(e, t) { if (t) if (isPlainObject(t)) { const r = e.on = e.on ? extend({}, e.on) : {}; for (const n in t) { const i = r[n]; const a = t[n]; r[n] = i ? [].concat(i, a) : a } } else;return e } function installRenderHelpers(e) { e._o = markOnce, e._n = toNumber, e._s = toString, e._l = renderList, e._t = renderSlot, e._q = looseEqual, e._i = looseIndexOf, e._m = renderStatic, e._f = resolveFilter, e._k = checkKeyCodes, e._b = bindObjectProps, e._v = createTextVNode, e._e = H, e._u = resolveScopedSlots, e._g = bindObjectListeners } function FunctionalRenderContext(e, t, r, i, a) { let o; const s = a.options; hasOwn(i, '_uid') ? (o = Object.create(i))._original = i : (o = i, i = i._original); const u = isTrue(s._compiled); const l = !u; this.data = e, this.props = t, this.children = r, this.parent = i, this.listeners = e.on || n, this.injections = resolveInject(s.inject, i), this.slots = function () { return resolveSlots(r, i) }, u && (this.$options = s, this.$slots = this.slots(), this.$scopedSlots = e.scopedSlots || n), s._scopeId ? this._c = function (e, t, r, n) { const a = createElement(o, e, t, r, n, l); return a && !Array.isArray(a) && (a.fnScopeId = s._scopeId, a.fnContext = i), a } : this._c = function (e, t, r, n) { return createElement(o, e, t, r, n, l) } } function cloneAndMarkFunctionalResult(e, t, r, n) { const i = cloneVNode(e); return i.fnContext = r, i.fnOptions = n, t.slot && ((i.data || (i.data = {})).slot = t.slot), i } function mergeProps(e, t) { for (const r in t)e[l(r)] = t[r]; }installRenderHelpers(FunctionalRenderContext.prototype); var xe = {
      init: function init(e, t, r, n) {
        if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) { const i = e; xe.prepatch(i, i) } else {
          (e.componentInstance = (function createComponentInstanceForVnode(e, t, r, n) {
            const i = {
              _isComponent: !0, parent: t, _parentVnode: e, _parentElm: r || null, _refElm: n || null,
            }; const a = e.data.inlineTemplate; isDef(a) && (i.render = a.render, i.staticRenderFns = a.staticRenderFns); return new e.componentOptions.Ctor(i);
          }(e, le, r, n))).$mount(t ? e.elm : void 0, t);
        }
      },
      prepatch: function prepatch(e, t) { const r = t.componentOptions; !(function updateChildComponent(e, t, r, i, a) { const o = !!(a || e.$options._renderChildren || i.data.scopedSlots || e.$scopedSlots !== n); if (e.$options._parentVnode = i, e.$vnode = i, e._vnode && (e._vnode.parent = i), e.$options._renderChildren = a, e.$attrs = i.data.attrs || n, e.$listeners = r || n, t && e.$options.props) { toggleObserving(!1); for (let s = e._props, u = e.$options._propKeys || [], l = 0; l < u.length; l++) { const c = u[l]; const p = e.$options.props; s[c] = validateProp(c, p, t, e) }toggleObserving(!0), e.$options.propsData = t }r = r || n; const f = e.$options._parentListeners; e.$options._parentListeners = r, updateComponentListeners(e, r, f), o && (e.$slots = resolveSlots(a, i.context), e.$forceUpdate()) }(t.componentInstance = e.componentInstance, r.propsData, r.listeners, t, r.children)) },
      insert: function insert(e) { const t = e.context; const r = e.componentInstance; r._isMounted || (r._isMounted = !0, callHook(r, 'mounted')), e.data.keepAlive && (t._isMounted ? (function queueActivatedComponent(e) { e._inactive = !1, pe.push(e) }(r)) : activateChildComponent(r, !0)) },
      destroy: function destroy(e) { const t = e.componentInstance; t._isDestroyed || (e.data.keepAlive ? (function deactivateChildComponent(e, t) { if (!(t && (e._directInactive = !0, isInInactiveTree(e)) || e._inactive)) { e._inactive = !0; for (let r = 0; r < e.$children.length; r++)deactivateChildComponent(e.$children[r]); callHook(e, 'deactivated') } }(t, !0)) : t.$destroy()) },
    }; const De = Object.keys(xe); function createComponent(e, t, r, i, a) {
      if (!isUndef(e)) {
        const o = r.$options._base; if (isObject(e) && (e = o.extend(e)), typeof e === 'function') {
          let s; if (isUndef(e.cid) && void 0 === (e = (function resolveAsyncComponent(e, t, r) { if (isTrue(e.error) && isDef(e.errorComp)) return e.errorComp; if (isDef(e.resolved)) return e.resolved; if (isTrue(e.loading) && isDef(e.loadingComp)) return e.loadingComp; if (!isDef(e.contexts)) { const n = e.contexts = [r]; let i = !0; const a = function () { for (let e = 0, t = n.length; e < t; e++)n[e].$forceUpdate(); }; const o = once((r) => { e.resolved = ensureCtor(r, t), i || a() }); const s = once((t) => { isDef(e.errorComp) && (e.error = !0, a()) }); const u = e(o, s); return isObject(u) && (typeof u.then === 'function' ? isUndef(e.resolved) && u.then(o, s) : isDef(u.component) && typeof u.component.then === 'function' && (u.component.then(o, s), isDef(u.error) && (e.errorComp = ensureCtor(u.error, t)), isDef(u.loading) && (e.loadingComp = ensureCtor(u.loading, t), u.delay === 0 ? e.loading = !0 : setTimeout(() => { isUndef(e.resolved) && isUndef(e.error) && (e.loading = !0, a()) }, u.delay || 200)), isDef(u.timeout) && setTimeout(() => { isUndef(e.resolved) && s(null) }, u.timeout))), i = !1, e.loading ? e.loadingComp : e.resolved }e.contexts.push(r) }(s = e, o, r)))) {
            return (function createAsyncPlaceholder(e, t, r, n, i) {
              const a = H(); return a.asyncFactory = e, a.asyncMeta = {
                data: t, context: r, children: n, tag: i,
              }, a;
            }(s, t, r, i, a));
          } t = t || {}, resolveConstructorOptions(e), isDef(t.model) && (function transformModel(e, t) { const r = e.model && e.model.prop || 'value'; const n = e.model && e.model.event || 'input'; (t.props || (t.props = {}))[r] = t.model.value; const i = t.on || (t.on = {}); isDef(i[n]) ? i[n] = [t.model.callback].concat(i[n]) : i[n] = t.model.callback }(e.options, t)); const u = (function extractPropsFromVNodeData(e, t, r) { const n = t.options.props; if (!isUndef(n)) { const i = {}; const a = e.attrs; const o = e.props; if (isDef(a) || isDef(o)) for (const s in n) { const u = f(s); checkProp(i, o, s, u, !0) || checkProp(i, a, s, u, !1) } return i } }(t, e)); if (isTrue(e.options.functional)) return (function createFunctionalComponent(e, t, r, i, a) { const o = e.options; const s = {}; const u = o.props; if (isDef(u)) for (const l in u)s[l] = validateProp(l, u, t || n); else isDef(r.attrs) && mergeProps(s, r.attrs), isDef(r.props) && mergeProps(s, r.props); const c = new FunctionalRenderContext(r, s, a, i, e); const p = o.render.call(null, c._c, c); if (p instanceof z) return cloneAndMarkFunctionalResult(p, r, c.parent, o); if (Array.isArray(p)) { for (var f = normalizeChildren(p) || [], d = new Array(f.length), h = 0; h < f.length; h++)d[h] = cloneAndMarkFunctionalResult(f[h], r, c.parent, o); return d } }(e, u, t, r, i)); const l = t.on; if (t.on = t.nativeOn, isTrue(e.options.abstract)) { const c = t.slot; t = {}, c && (t.slot = c) }!(function installComponentHooks(e) { for (let t = e.hook || (e.hook = {}), r = 0; r < De.length; r++) { const n = De[r]; t[n] = xe[n] } }(t)); const p = e.options.name || a; return new z(`vue-component-${e.cid}${p ? `-${p}` : ''}`, t, void 0, void 0, void 0, r, {
            Ctor: e, propsData: u, listeners: l, tag: a, children: i,
          }, s);
        }
      }
    } const _e = 1; const Ce = 2; function createElement(e, t, r, n, i, a) { return (Array.isArray(r) || isPrimitive(r)) && (i = n, n = r, r = void 0), isTrue(a) && (i = Ce), (function _createElement(e, t, r, n, i) { if (isDef(r) && isDef(r.__ob__)) return H(); isDef(r) && isDef(r.is) && (t = r.is); if (!t) return H(); 0; Array.isArray(n) && typeof n[0] === 'function' && ((r = r || {}).scopedSlots = { default: n[0] }, n.length = 0); i === Ce ? n = normalizeChildren(n) : i === _e && (n = (function simpleNormalizeChildren(e) { for (let t = 0; t < e.length; t++) if (Array.isArray(e[t])) return Array.prototype.concat.apply([], e); return e }(n))); let a; let o; if (typeof t === 'string') { let s; o = e.$vnode && e.$vnode.ns || b.getTagNamespace(t), a = b.isReservedTag(t) ? new z(b.parsePlatformTagName(t), r, n, void 0, void 0, e) : isDef(s = resolveAsset(e.$options, 'components', t)) ? createComponent(s, r, e, n, t) : new z(t, r, n, void 0, void 0, e) } else a = createComponent(t, r, e, n); return Array.isArray(a) ? a : isDef(a) ? (isDef(o) && (function applyNS(e, t, r) { e.ns = t; e.tag === 'foreignObject' && (t = void 0, r = !0); if (isDef(e.children)) for (let n = 0, i = e.children.length; n < i; n++) { const a = e.children[n]; isDef(a.tag) && (isUndef(a.ns) || isTrue(r) && a.tag !== 'svg') && applyNS(a, t, r) } }(a, o)), isDef(r) && (function registerDeepBindings(e) { isObject(e.style) && traverse(e.style); isObject(e.class) && traverse(e.class) }(r)), a) : H() }(e, t, r, n, i)) } let we = 0; function resolveConstructorOptions(e) { let t = e.options; if (e.super) { const r = resolveConstructorOptions(e.super); if (r !== e.superOptions) { e.superOptions = r; const n = (function resolveModifiedOptions(e) { let t; const r = e.options; const n = e.extendOptions; const i = e.sealedOptions; for (const a in r)r[a] !== i[a] && (t || (t = {}), t[a] = dedupe(r[a], n[a], i[a])); return t }(e)); n && extend(e.extendOptions, n), (t = e.options = mergeOptions(r, e.extendOptions)).name && (t.components[t.name] = e) } } return t } function dedupe(e, t, r) { if (Array.isArray(e)) { const n = []; r = Array.isArray(r) ? r : [r], t = Array.isArray(t) ? t : [t]; for (let i = 0; i < e.length; i++)(t.indexOf(e[i]) >= 0 || r.indexOf(e[i]) < 0) && n.push(e[i]); return n } return e } function Vue(e) { this._init(e) } function initExtend(e) { e.cid = 0; let t = 1; e.extend = function (e) { e = e || {}; const r = this; const n = r.cid; const i = e._Ctor || (e._Ctor = {}); if (i[n]) return i[n]; const a = e.name || r.options.name; const o = function VueComponent(e) { this._init(e) }; return (o.prototype = Object.create(r.prototype)).constructor = o, o.cid = t++, o.options = mergeOptions(r.options, e), o.super = r, o.options.props && (function initProps$1(e) { const t = e.options.props; for (const r in t)proxy(e.prototype, '_props', r); }(o)), o.options.computed && (function initComputed$1(e) { const t = e.options.computed; for (const r in t)defineComputed(e.prototype, r, t[r]); }(o)), o.extend = r.extend, o.mixin = r.mixin, o.use = r.use, v.forEach((e) => { o[e] = r[e] }), a && (o.options.components[a] = o), o.superOptions = r.options, o.extendOptions = e, o.sealedOptions = extend({}, o.options), i[n] = o, o } } function getComponentName(e) { return e && (e.Ctor.options.name || e.tag) } function matches(e, t) { return Array.isArray(e) ? e.indexOf(t) > -1 : typeof e === 'string' ? e.split(',').indexOf(t) > -1 : !!isRegExp(e) && e.test(t) } function pruneCache(e, t) { const r = e.cache; const n = e.keys; const i = e._vnode; for (const a in r) { const o = r[a]; if (o) { const s = getComponentName(o.componentOptions); s && !t(s) && pruneCacheEntry(r, a, n, i) } } } function pruneCacheEntry(e, t, r, n) { const i = e[t]; !i || n && i.tag === n.tag || i.componentInstance.$destroy(), e[t] = null, remove(r, t) }!(function initMixin(e) { e.prototype._init = function (e) { const t = this; t._uid = we++, t._isVue = !0, e && e._isComponent ? (function initInternalComponent(e, t) { const r = e.$options = Object.create(e.constructor.options); const n = t._parentVnode; r.parent = t.parent, r._parentVnode = n, r._parentElm = t._parentElm, r._refElm = t._refElm; const i = n.componentOptions; r.propsData = i.propsData, r._parentListeners = i.listeners, r._renderChildren = i.children, r._componentTag = i.tag, t.render && (r.render = t.render, r.staticRenderFns = t.staticRenderFns) }(t, e)) : t.$options = mergeOptions(resolveConstructorOptions(t.constructor), e || {}, t), t._renderProxy = t, t._self = t, (function initLifecycle(e) { const t = e.$options; let r = t.parent; if (r && !t.abstract) { for (;r.$options.abstract && r.$parent;)r = r.$parent; r.$children.push(e) }e.$parent = r, e.$root = r ? r.$root : e, e.$children = [], e.$refs = {}, e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1 }(t)), (function initEvents(e) { e._events = Object.create(null), e._hasHookEvent = !1; const t = e.$options._parentListeners; t && updateComponentListeners(e, t) }(t)), (function initRender(e) { e._vnode = null, e._staticTrees = null; const t = e.$options; const r = e.$vnode = t._parentVnode; const i = r && r.context; e.$slots = resolveSlots(t._renderChildren, i), e.$scopedSlots = n, e._c = function (t, r, n, i) { return createElement(e, t, r, n, i, !1) }, e.$createElement = function (t, r, n, i) { return createElement(e, t, r, n, i, !0) }; const a = r && r.data; defineReactive(e, '$attrs', a && a.attrs || n, null, !0), defineReactive(e, '$listeners', t._parentListeners || n, null, !0) }(t)), callHook(t, 'beforeCreate'), (function initInjections(e) { const t = resolveInject(e.$options.inject, e); t && (toggleObserving(!1), Object.keys(t).forEach((r) => { defineReactive(e, r, t[r]) }), toggleObserving(!0)) }(t)), initState(t), (function initProvide(e) { const t = e.$options.provide; t && (e._provided = typeof t === 'function' ? t.call(e) : t) }(t)), callHook(t, 'created'), t.$options.el && t.$mount(t.$options.el) } }(Vue)), (function stateMixin(e) { const t = { get() { return this._data } }; const r = { get() { return this._props } }; Object.defineProperty(e.prototype, '$data', t), Object.defineProperty(e.prototype, '$props', r), e.prototype.$set = set, e.prototype.$delete = del, e.prototype.$watch = function (e, t, r) { if (isPlainObject(t)) return createWatcher(this, e, t, r); (r = r || {}).user = !0; const n = new ve(this, e, t, r); return r.immediate && t.call(this, n.value), function unwatchFn() { n.teardown() } } }(Vue)), (function eventsMixin(e) { const t = /^hook:/; e.prototype.$on = function (e, r) { if (Array.isArray(e)) for (let n = 0, i = e.length; n < i; n++) this.$on(e[n], r); else (this._events[e] || (this._events[e] = [])).push(r), t.test(e) && (this._hasHookEvent = !0); return this }, e.prototype.$once = function (e, t) { const r = this; function on() { r.$off(e, on), t.apply(r, arguments) } return on.fn = t, r.$on(e, on), r }, e.prototype.$off = function (e, t) { const r = this; if (!arguments.length) return r._events = Object.create(null), r; if (Array.isArray(e)) { for (let n = 0, i = e.length; n < i; n++) this.$off(e[n], t); return r } const a = r._events[e]; if (!a) return r; if (!t) return r._events[e] = null, r; if (t) for (var o, s = a.length; s--;) if ((o = a[s]) === t || o.fn === t) { a.splice(s, 1); break } return r }, e.prototype.$emit = function (e) { const t = this; let r = t._events[e]; if (r) { r = r.length > 1 ? toArray(r) : r; for (let n = toArray(arguments, 1), i = 0, a = r.length; i < a; i++) try { r[i].apply(t, n) } catch (r) { handleError(r, t, `event handler for "${e}"`) } } return t } }(Vue)), (function lifecycleMixin(e) { e.prototype._update = function (e, t) { const r = this; r._isMounted && callHook(r, 'beforeUpdate'); const n = r.$el; const i = r._vnode; const a = le; le = r, r._vnode = e, i ? r.$el = r.__patch__(i, e) : (r.$el = r.__patch__(r.$el, e, t, !1, r.$options._parentElm, r.$options._refElm), r.$options._parentElm = r.$options._refElm = null), le = a, n && (n.__vue__ = null), r.$el && (r.$el.__vue__ = r), r.$vnode && r.$parent && r.$vnode === r.$parent._vnode && (r.$parent.$el = r.$el) }, e.prototype.$forceUpdate = function () { this._watcher && this._watcher.update() }, e.prototype.$destroy = function () { const e = this; if (!e._isBeingDestroyed) { callHook(e, 'beforeDestroy'), e._isBeingDestroyed = !0; const t = e.$parent; !t || t._isBeingDestroyed || e.$options.abstract || remove(t.$children, e), e._watcher && e._watcher.teardown(); for (let r = e._watchers.length; r--;)e._watchers[r].teardown(); e._data.__ob__ && e._data.__ob__.vmCount--, e._isDestroyed = !0, e.__patch__(e._vnode, null), callHook(e, 'destroyed'), e.$off(), e.$el && (e.$el.__vue__ = null), e.$vnode && (e.$vnode.parent = null) } } }(Vue)), (function renderMixin(e) { installRenderHelpers(e.prototype), e.prototype.$nextTick = function (e) { return nextTick(e, this) }, e.prototype._render = function () { let e; const t = this; const r = t.$options; const i = r.render; const a = r._parentVnode; a && (t.$scopedSlots = a.data.scopedSlots || n), t.$vnode = a; try { e = i.call(t._renderProxy, t.$createElement) } catch (r) { handleError(r, t, 'render'), e = t._vnode } return e instanceof z || (e = H()), e.parent = a, e } }(Vue)); const Ee = [String, RegExp, Array]; const Se = {
      KeepAlive: {
        name: 'keep-alive', abstract: !0, props: { include: Ee, exclude: Ee, max: [String, Number] }, created: function created() { this.cache = Object.create(null), this.keys = [] }, destroyed: function destroyed() { for (const e in this.cache)pruneCacheEntry(this.cache, e, this.keys); }, mounted: function mounted() { const e = this; this.$watch('include', (t) => { pruneCache(e, e => matches(t, e)) }), this.$watch('exclude', (t) => { pruneCache(e, e => !matches(t, e)) }) }, render: function render() { const e = this.$slots.default; const t = getFirstComponentChild(e); const r = t && t.componentOptions; if (r) { const n = getComponentName(r); const i = this.include; const a = this.exclude; if (i && (!n || !matches(i, n)) || a && n && matches(a, n)) return t; const o = this.cache; const s = this.keys; const u = t.key == null ? r.Ctor.cid + (r.tag ? `::${r.tag}` : '') : t.key; o[u] ? (t.componentInstance = o[u].componentInstance, remove(s, u), s.push(u)) : (o[u] = t, s.push(u), this.max && s.length > parseInt(this.max) && pruneCacheEntry(o, s[0], s, this._vnode)), t.data.keepAlive = !0 } return t || e && e[0] },
      },
    }; !(function initGlobalAPI(e) {
      const t = { get() { return b } }; Object.defineProperty(e, 'config', t), e.util = {
        warn: I, extend, mergeOptions, defineReactive,
      }, e.set = set, e.delete = del, e.nextTick = nextTick, e.options = Object.create(null), v.forEach((t) => { e.options[`${t}s`] = Object.create(null) }), e.options._base = e, extend(e.options.components, Se), (function initUse(e) { e.use = function (e) { const t = this._installedPlugins || (this._installedPlugins = []); if (t.indexOf(e) > -1) return this; const r = toArray(arguments, 1); return r.unshift(this), typeof e.install === 'function' ? e.install(...r) : typeof e === 'function' && e(...r), t.push(e), this } }(e)), (function initMixin$1(e) { e.mixin = function (e) { return this.options = mergeOptions(this.options, e), this } }(e)), initExtend(e), (function initAssetRegisters(e) { v.forEach((t) => { e[t] = function (e, r) { return r ? (t === 'component' && isPlainObject(r) && (r.name = r.name || e, r = this.options._base.extend(r)), t === 'directive' && typeof r === 'function' && (r = { bind: r, update: r }), this.options[`${t}s`][e] = r, r) : this.options[`${t}s`][e] } }) }(e));
    }(Vue)), Object.defineProperty(Vue.prototype, '$isServer', { get: L }), Object.defineProperty(Vue.prototype, '$ssrContext', { get: function get() { return this.$vnode && this.$vnode.ssrContext } }), Object.defineProperty(Vue, 'FunctionalRenderContext', { value: FunctionalRenderContext }), Vue.version = '2.5.16'; const ke = makeMap('style,class'); const Ae = makeMap('input,textarea,option,select,progress'); const Te = function (e, t, r) { return r === 'value' && Ae(e) && t !== 'button' || r === 'selected' && e === 'option' || r === 'checked' && e === 'input' || r === 'muted' && e === 'video' }; const Pe = makeMap('contenteditable,draggable,spellcheck'); const Re = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible'); const Oe = 'http://www.w3.org/1999/xlink'; const Fe = function (e) { return e.charAt(5) === ':' && e.slice(0, 5) === 'xlink' }; const Le = function (e) { return Fe(e) ? e.slice(6, e.length) : '' }; const Me = function (e) { return e == null || !1 === e }; function genClassForVnode(e) { for (var t = e.data, r = e, n = e; isDef(n.componentInstance);)(n = n.componentInstance._vnode) && n.data && (t = mergeClassData(n.data, t)); for (;isDef(r = r.parent);)r && r.data && (t = mergeClassData(t, r.data)); return (function renderClass(e, t) { if (isDef(e) || isDef(t)) return concat(e, stringifyClass(t)); return '' }(t.staticClass, t.class)) } function mergeClassData(e, t) { return { staticClass: concat(e.staticClass, t.staticClass), class: isDef(e.class) ? [e.class, t.class] : t.class } } function concat(e, t) { return e ? t ? `${e} ${t}` : e : t || '' } function stringifyClass(e) { return Array.isArray(e) ? (function stringifyArray(e) { for (var t, r = '', n = 0, i = e.length; n < i; n++)isDef(t = stringifyClass(e[n])) && t !== '' && (r && (r += ' '), r += t); return r }(e)) : isObject(e) ? (function stringifyObject(e) { let t = ''; for (const r in e)e[r] && (t && (t += ' '), t += r); return t }(e)) : typeof e === 'string' ? e : '' } const je = { svg: 'http://www.w3.org/2000/svg', math: 'http://www.w3.org/1998/Math/MathML' }; const Ne = makeMap('html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot'); const Ie = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', !0); const Be = function (e) { return Ne(e) || Ie(e) }; function getTagNamespace(e) { return Ie(e) ? 'svg' : e === 'math' ? 'math' : void 0 } const qe = Object.create(null); const Ue = makeMap('text,number,password,search,email,tel,url'); function query(e) { if (typeof e === 'string') { const t = document.querySelector(e); return t || document.createElement('div') } return e } const ze = Object.freeze({
      createElement: function createElement$1(e, t) { const r = document.createElement(e); return e !== 'select' ? r : (t.data && t.data.attrs && void 0 !== t.data.attrs.multiple && r.setAttribute('multiple', 'multiple'), r) }, createElementNS: function createElementNS(e, t) { return document.createElementNS(je[e], t) }, createTextNode: function createTextNode(e) { return document.createTextNode(e) }, createComment: function createComment(e) { return document.createComment(e) }, insertBefore: function insertBefore(e, t, r) { e.insertBefore(t, r) }, removeChild: function removeChild(e, t) { e.removeChild(t) }, appendChild: function appendChild(e, t) { e.appendChild(t) }, parentNode: function parentNode(e) { return e.parentNode }, nextSibling: function nextSibling(e) { return e.nextSibling }, tagName: function tagName(e) { return e.tagName }, setTextContent: function setTextContent(e, t) { e.textContent = t }, setStyleScope: function setStyleScope(e, t) { e.setAttribute(t, '') },
    }); const Ve = { create: function create(e, t) { registerRef(t) }, update: function update(e, t) { e.data.ref !== t.data.ref && (registerRef(e, !0), registerRef(t)) }, destroy: function destroy(e) { registerRef(e, !0) } }; function registerRef(e, t) { const r = e.data.ref; if (isDef(r)) { const n = e.context; const i = e.componentInstance || e.elm; const a = n.$refs; t ? Array.isArray(a[r]) ? remove(a[r], i) : a[r] === i && (a[r] = void 0) : e.data.refInFor ? Array.isArray(a[r]) ? a[r].indexOf(i) < 0 && a[r].push(i) : a[r] = [i] : a[r] = i } } const He = new z('', {}, []); const $e = ['create', 'activate', 'update', 'remove', 'destroy']; function sameVnode(e, t) { return e.key === t.key && (e.tag === t.tag && e.isComment === t.isComment && isDef(e.data) === isDef(t.data) && (function sameInputType(e, t) { if (e.tag !== 'input') return !0; let r; const n = isDef(r = e.data) && isDef(r = r.attrs) && r.type; const i = isDef(r = t.data) && isDef(r = r.attrs) && r.type; return n === i || Ue(n) && Ue(i) }(e, t)) || isTrue(e.isAsyncPlaceholder) && e.asyncFactory === t.asyncFactory && isUndef(t.asyncFactory.error)) } function createKeyToOldIdx(e, t, r) { let n; let i; const a = {}; for (n = t; n <= r; ++n)isDef(i = e[n].key) && (a[i] = n); return a } const Ge = { create: updateDirectives, update: updateDirectives, destroy: function unbindDirectives(e) { updateDirectives(e, He) } }; function updateDirectives(e, t) { (e.data.directives || t.data.directives) && (function _update(e, t) { let r; let n; let i; const a = e === He; const o = t === He; const s = normalizeDirectives$1(e.data.directives, e.context); const u = normalizeDirectives$1(t.data.directives, t.context); const l = []; const c = []; for (r in u)n = s[r], i = u[r], n ? (i.oldValue = n.value, callHook$1(i, 'update', t, e), i.def && i.def.componentUpdated && c.push(i)) : (callHook$1(i, 'bind', t, e), i.def && i.def.inserted && l.push(i)); if (l.length) { const p = function () { for (let r = 0; r < l.length; r++)callHook$1(l[r], 'inserted', t, e); }; a ? mergeVNodeHook(t, 'insert', p) : p() }c.length && mergeVNodeHook(t, 'postpatch', () => { for (let r = 0; r < c.length; r++)callHook$1(c[r], 'componentUpdated', t, e); }); if (!a) for (r in s)u[r] || callHook$1(s[r], 'unbind', e, e, o); }(e, t)) } const Je = Object.create(null); function normalizeDirectives$1(e, t) { let r; let n; const i = Object.create(null); if (!e) return i; for (r = 0; r < e.length; r++)(n = e[r]).modifiers || (n.modifiers = Je), i[getRawDirName(n)] = n, n.def = resolveAsset(t.$options, 'directives', n.name); return i } function getRawDirName(e) { return e.rawName || `${e.name}.${Object.keys(e.modifiers || {}).join('.')}` } function callHook$1(e, t, r, n, i) { const a = e.def && e.def[t]; if (a) try { a(r.elm, e, r, n, i) } catch (n) { handleError(n, r.context, `directive ${e.name} ${t} hook`) } } const We = [Ve, Ge]; function updateAttrs(e, t) { const r = t.componentOptions; if (!(isDef(r) && !1 === r.Ctor.options.inheritAttrs || isUndef(e.data.attrs) && isUndef(t.data.attrs))) { let n; let i; const a = t.elm; const o = e.data.attrs || {}; let s = t.data.attrs || {}; for (n in isDef(s.__ob__) && (s = t.data.attrs = extend({}, s)), s)i = s[n], o[n] !== i && setAttr(a, n, i); for (n in (k || T) && s.value !== o.value && setAttr(a, 'value', s.value), o)isUndef(s[n]) && (Fe(n) ? a.removeAttributeNS(Oe, Le(n)) : Pe(n) || a.removeAttribute(n)); } } function setAttr(e, t, r) { e.tagName.indexOf('-') > -1 ? baseSetAttr(e, t, r) : Re(t) ? Me(r) ? e.removeAttribute(t) : (r = t === 'allowfullscreen' && e.tagName === 'EMBED' ? 'true' : t, e.setAttribute(t, r)) : Pe(t) ? e.setAttribute(t, Me(r) || r === 'false' ? 'false' : 'true') : Fe(t) ? Me(r) ? e.removeAttributeNS(Oe, Le(t)) : e.setAttributeNS(Oe, t, r) : baseSetAttr(e, t, r) } function baseSetAttr(e, t, r) { if (Me(r))e.removeAttribute(t); else { if (k && !A && e.tagName === 'TEXTAREA' && t === 'placeholder' && !e.__ieph) { var n = function (t) { t.stopImmediatePropagation(), e.removeEventListener('input', n) }; e.addEventListener('input', n), e.__ieph = !0 }e.setAttribute(t, r) } } const Ke = { create: updateAttrs, update: updateAttrs }; function updateClass(e, t) { const r = t.elm; const n = t.data; const i = e.data; if (!(isUndef(n.staticClass) && isUndef(n.class) && (isUndef(i) || isUndef(i.staticClass) && isUndef(i.class)))) { let a = genClassForVnode(t); const o = r._transitionClasses; isDef(o) && (a = concat(a, stringifyClass(o))), a !== r._prevClass && (r.setAttribute('class', a), r._prevClass = a) } } let Xe; let Ye; let Qe; let Ze; let et; let tt; const rt = { create: updateClass, update: updateClass }; const nt = /[\w).+\-_$\]]/; function parseFilters(e) { let t; let r; let n; let i; let a; let o = !1; let s = !1; let u = !1; let l = !1; let c = 0; let p = 0; let f = 0; let d = 0; for (n = 0; n < e.length; n++) if (r = t, t = e.charCodeAt(n), o)t === 39 && r !== 92 && (o = !1); else if (s)t === 34 && r !== 92 && (s = !1); else if (u)t === 96 && r !== 92 && (u = !1); else if (l)t === 47 && r !== 92 && (l = !1); else if (t !== 124 || e.charCodeAt(n + 1) === 124 || e.charCodeAt(n - 1) === 124 || c || p || f) { switch (t) { case 34: s = !0; break; case 39: o = !0; break; case 96: u = !0; break; case 40: f++; break; case 41: f--; break; case 91: p++; break; case 93: p--; break; case 123: c++; break; case 125: c--; } if (t === 47) { for (var h = n - 1, m = void 0; h >= 0 && (m = e.charAt(h)) === ' '; h--);m && nt.test(m) || (l = !0) } } else void 0 === i ? (d = n + 1, i = e.slice(0, n).trim()) : pushFilter(); function pushFilter() { (a || (a = [])).push(e.slice(d, n).trim()), d = n + 1 } if (void 0 === i ? i = e.slice(0, n).trim() : d !== 0 && pushFilter(), a) for (n = 0; n < a.length; n++)i = wrapFilter(i, a[n]); return i } function wrapFilter(e, t) { const r = t.indexOf('('); if (r < 0) return `_f("${t}")(${e})`; const n = t.slice(0, r); const i = t.slice(r + 1); return `_f("${n}")(${e}${i !== ')' ? `,${i}` : i}` } function baseWarn(e) { console.error(`[Vue compiler]: ${e}`) } function pluckModuleFunction(e, t) { return e ? e.map(e => e[t]).filter(e => e) : [] } function addProp(e, t, r) { (e.props || (e.props = [])).push({ name: t, value: r }), e.plain = !1 } function addAttr(e, t, r) { (e.attrs || (e.attrs = [])).push({ name: t, value: r }), e.plain = !1 } function addRawAttr(e, t, r) { e.attrsMap[t] = r, e.attrsList.push({ name: t, value: r }) } function addDirective(e, t, r, n, i, a) {
      (e.directives || (e.directives = [])).push({
        name: t, rawName: r, value: n, arg: i, modifiers: a,
      }), e.plain = !1;
    } function addHandler(e, t, r, i, a, o) { let s; (i = i || n).capture && (delete i.capture, t = `!${t}`), i.once && (delete i.once, t = `~${t}`), i.passive && (delete i.passive, t = `&${t}`), t === 'click' && (i.right ? (t = 'contextmenu', delete i.right) : i.middle && (t = 'mouseup')), i.native ? (delete i.native, s = e.nativeEvents || (e.nativeEvents = {})) : s = e.events || (e.events = {}); const u = { value: r.trim() }; i !== n && (u.modifiers = i); const l = s[t]; Array.isArray(l) ? a ? l.unshift(u) : l.push(u) : s[t] = l ? a ? [u, l] : [l, u] : u, e.plain = !1 } function getBindingAttr(e, t, r) { const n = getAndRemoveAttr(e, `:${t}`) || getAndRemoveAttr(e, `v-bind:${t}`); if (n != null) return parseFilters(n); if (!1 !== r) { const i = getAndRemoveAttr(e, t); if (i != null) return JSON.stringify(i); } } function getAndRemoveAttr(e, t, r) { let n; if ((n = e.attrsMap[t]) != null) for (let i = e.attrsList, a = 0, o = i.length; a < o; a++) if (i[a].name === t) { i.splice(a, 1); break } return r && delete e.attrsMap[t], n } function genComponentModel(e, t, r) { const n = r || {}; const i = n.number; let a = '$$v'; n.trim && (a = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i && (a = `_n(${a})`); const o = genAssignmentCode(t, a); e.model = { value: `(${t})`, expression: `"${t}"`, callback: `function ($$v) {${o}}` } } function genAssignmentCode(e, t) { const r = (function parseModel(e) { if (e = e.trim(), Xe = e.length, e.indexOf('[') < 0 || e.lastIndexOf(']') < Xe - 1) return (Ze = e.lastIndexOf('.')) > -1 ? { exp: e.slice(0, Ze), key: `"${e.slice(Ze + 1)}"` } : { exp: e, key: null }; Ye = e, Ze = et = tt = 0; for (;!eof();)isStringStart(Qe = next()) ? parseString(Qe) : Qe === 91 && parseBracket(Qe); return { exp: e.slice(0, et), key: e.slice(et + 1, tt) } }(e)); return r.key === null ? `${e}=${t}` : `$set(${r.exp}, ${r.key}, ${t})` } function next() { return Ye.charCodeAt(++Ze) } function eof() { return Ze >= Xe } function isStringStart(e) { return e === 34 || e === 39 } function parseBracket(e) { let t = 1; for (et = Ze; !eof();) if (isStringStart(e = next()))parseString(e); else if (e === 91 && t++, e === 93 && t--, t === 0) { tt = Ze; break } } function parseString(e) { for (let t = e; !eof() && (e = next()) !== t;); } let it; const at = '__r'; const ot = '__c'; function add$1(e, t, r, n, i) { t = (function withMacroTask(e) { return e._withTask || (e._withTask = function () { re = !0; const t = e(...arguments); return re = !1, t }) }(t)), r && (t = (function createOnceHandler(e, t, r) { const n = it; return function onceHandler() { e(...arguments) !== null && remove$2(t, onceHandler, r, n) } }(t, e, n))), it.addEventListener(e, t, O ? { capture: n, passive: i } : n) } function remove$2(e, t, r, n) { (n || it).removeEventListener(e, t._withTask || t, r) } function updateDOMListeners(e, t) { if (!isUndef(e.data.on) || !isUndef(t.data.on)) { const r = t.data.on || {}; const n = e.data.on || {}; it = t.elm, (function normalizeEvents(e) { if (isDef(e[at])) { const t = k ? 'change' : 'input'; e[t] = [].concat(e[at], e[t] || []), delete e[at] }isDef(e[ot]) && (e.change = [].concat(e[ot], e.change || []), delete e[ot]) }(r)), updateListeners(r, n, add$1, remove$2, t.context), it = void 0 } } const st = { create: updateDOMListeners, update: updateDOMListeners }; function updateDOMProps(e, t) { if (!isUndef(e.data.domProps) || !isUndef(t.data.domProps)) { let r; let n; const i = t.elm; const a = e.data.domProps || {}; let o = t.data.domProps || {}; for (r in isDef(o.__ob__) && (o = t.data.domProps = extend({}, o)), a)isUndef(o[r]) && (i[r] = ''); for (r in o) { if (n = o[r], r === 'textContent' || r === 'innerHTML') { if (t.children && (t.children.length = 0), n === a[r]) continue; i.childNodes.length === 1 && i.removeChild(i.childNodes[0]) } if (r === 'value') { i._value = n; const s = isUndef(n) ? '' : String(n); shouldUpdateValue(i, s) && (i.value = s) } else i[r] = n; } } } function shouldUpdateValue(e, t) { return !e.composing && (e.tagName === 'OPTION' || (function isNotInFocusAndDirty(e, t) { let r = !0; try { r = document.activeElement !== e } catch (e) {} return r && e.value !== t }(e, t)) || (function isDirtyWithModifiers(e, t) { const r = e.value; const n = e._vModifiers; if (isDef(n)) { if (n.lazy) return !1; if (n.number) return toNumber(r) !== toNumber(t); if (n.trim) return r.trim() !== t.trim(); } return r !== t }(e, t))) } const ut = { create: updateDOMProps, update: updateDOMProps }; const lt = cached((e) => { const t = {}; const r = /:(.+)/; return e.split(/;(?![^(]*\))/g).forEach((e) => { if (e) { const n = e.split(r); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } }), t }); function normalizeStyleData(e) { const t = normalizeStyleBinding(e.style); return e.staticStyle ? extend(e.staticStyle, t) : t } function normalizeStyleBinding(e) { return Array.isArray(e) ? toObject(e) : typeof e === 'string' ? lt(e) : e } let ct; const pt = /^--/; const ft = /\s*!important$/; const dt = function (e, t, r) { if (pt.test(t))e.style.setProperty(t, r); else if (ft.test(r))e.style.setProperty(t, r.replace(ft, ''), 'important'); else { const n = mt(t); if (Array.isArray(r)) for (let i = 0, a = r.length; i < a; i++)e.style[n] = r[i]; else e.style[n] = r; } }; const ht = ['Webkit', 'Moz', 'ms']; var mt = cached((e) => { if (ct = ct || document.createElement('div').style, (e = l(e)) !== 'filter' && e in ct) return e; for (let t = e.charAt(0).toUpperCase() + e.slice(1), r = 0; r < ht.length; r++) { const n = ht[r] + t; if (n in ct) return n; } }); function updateStyle(e, t) { const r = t.data; const n = e.data; if (!(isUndef(r.staticStyle) && isUndef(r.style) && isUndef(n.staticStyle) && isUndef(n.style))) { let i; let a; const o = t.elm; const s = n.staticStyle; const u = n.normalizedStyle || n.style || {}; const l = s || u; const c = normalizeStyleBinding(t.data.style) || {}; t.data.normalizedStyle = isDef(c.__ob__) ? extend({}, c) : c; const p = (function getStyle(e, t) { let r; const n = {}; if (t) for (let i = e; i.componentInstance;)(i = i.componentInstance._vnode) && i.data && (r = normalizeStyleData(i.data)) && extend(n, r); (r = normalizeStyleData(e.data)) && extend(n, r); for (let a = e; a = a.parent;)a.data && (r = normalizeStyleData(a.data)) && extend(n, r); return n }(t, !0)); for (a in l)isUndef(p[a]) && dt(o, a, ''); for (a in p)(i = p[a]) !== l[a] && dt(o, a, i == null ? '' : i); } } const gt = { create: updateStyle, update: updateStyle }; function addClass(e, t) { if (t && (t = t.trim())) if (e.classList)t.indexOf(' ') > -1 ? t.split(/\s+/).forEach(t => e.classList.add(t)) : e.classList.add(t); else { const r = ` ${e.getAttribute('class') || ''} `; r.indexOf(` ${t} `) < 0 && e.setAttribute('class', (r + t).trim()) } } function removeClass(e, t) { if (t && (t = t.trim())) if (e.classList)t.indexOf(' ') > -1 ? t.split(/\s+/).forEach(t => e.classList.remove(t)) : e.classList.remove(t), e.classList.length || e.removeAttribute('class'); else { for (var r = ` ${e.getAttribute('class') || ''} `, n = ` ${t} `; r.indexOf(n) >= 0;)r = r.replace(n, ' '); (r = r.trim()) ? e.setAttribute('class', r) : e.removeAttribute('class') } } function resolveTransition(e) { if (e) { if (typeof e === 'object') { const t = {}; return !1 !== e.css && extend(t, vt(e.name || 'v')), extend(t, e), t } return typeof e === 'string' ? vt(e) : void 0 } } var vt = cached(e => ({
      enterClass: `${e}-enter`, enterToClass: `${e}-enter-to`, enterActiveClass: `${e}-enter-active`, leaveClass: `${e}-leave`, leaveToClass: `${e}-leave-to`, leaveActiveClass: `${e}-leave-active`,
    })); const yt = C && !A; const bt = 'transition'; const xt = 'animation'; let Dt = 'transition'; let _t = 'transitionend'; let Ct = 'animation'; let wt = 'animationend'; yt && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (Dt = 'WebkitTransition', _t = 'webkitTransitionEnd'), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Ct = 'WebkitAnimation', wt = 'webkitAnimationEnd')); const Et = C ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (e) { return e() }; function nextFrame(e) { Et(() => { Et(e) }) } function addTransitionClass(e, t) { const r = e._transitionClasses || (e._transitionClasses = []); r.indexOf(t) < 0 && (r.push(t), addClass(e, t)) } function removeTransitionClass(e, t) { e._transitionClasses && remove(e._transitionClasses, t), removeClass(e, t) } function whenTransitionEnds(e, t, r) { const n = getTransitionInfo(e, t); const i = n.type; const a = n.timeout; const o = n.propCount; if (!i) return r(); const s = i === bt ? _t : wt; let u = 0; const l = function () { e.removeEventListener(s, c), r() }; var c = function (t) { t.target === e && ++u >= o && l() }; setTimeout(() => { u < o && l() }, a + 1), e.addEventListener(s, c) } const St = /\b(transform|all)(,|$)/; function getTransitionInfo(e, t) {
      let r; const n = window.getComputedStyle(e); const i = n[`${Dt}Delay`].split(', '); const a = n[`${Dt}Duration`].split(', '); const o = getTimeout(i, a); const s = n[`${Ct}Delay`].split(', '); const u = n[`${Ct}Duration`].split(', '); const l = getTimeout(s, u); let c = 0; let p = 0; return t === bt ? o > 0 && (r = bt, c = o, p = a.length) : t === xt ? l > 0 && (r = xt, c = l, p = u.length) : p = (r = (c = Math.max(o, l)) > 0 ? o > l ? bt : xt : null) ? r === bt ? a.length : u.length : 0, {
        type: r, timeout: c, propCount: p, hasTransform: r === bt && St.test(n[`${Dt}Property`]),
      };
    } function getTimeout(e, t) { for (;e.length < t.length;)e = e.concat(e); return Math.max.apply(null, t.map((t, r) => toMs(t) + toMs(e[r]))) } function toMs(e) { return 1e3 * Number(e.slice(0, -1)) } function enter(e, t) { const r = e.elm; isDef(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb()); const n = resolveTransition(e.data.transition); if (!isUndef(n) && !isDef(r._enterCb) && r.nodeType === 1) { for (var i = n.css, a = n.type, o = n.enterClass, s = n.enterToClass, u = n.enterActiveClass, l = n.appearClass, c = n.appearToClass, p = n.appearActiveClass, f = n.beforeEnter, d = n.enter, h = n.afterEnter, m = n.enterCancelled, g = n.beforeAppear, v = n.appear, y = n.afterAppear, b = n.appearCancelled, x = n.duration, D = le, _ = le.$vnode; _ && _.parent;)D = (_ = _.parent).context; const C = !D._isMounted || !e.isRootInsert; if (!C || v || v === '') { const w = C && l ? l : o; const E = C && p ? p : u; const S = C && c ? c : s; const k = C && g || f; const T = C && typeof v === 'function' ? v : d; const P = C && y || h; const R = C && b || m; const O = toNumber(isObject(x) ? x.enter : x); 0; const F = !1 !== i && !A; const L = getHookArgumentsLength(T); var M = r._enterCb = once(() => { F && (removeTransitionClass(r, S), removeTransitionClass(r, E)), M.cancelled ? (F && removeTransitionClass(r, w), R && R(r)) : P && P(r), r._enterCb = null }); e.data.show || mergeVNodeHook(e, 'insert', () => { const t = r.parentNode; const n = t && t._pending && t._pending[e.key]; n && n.tag === e.tag && n.elm._leaveCb && n.elm._leaveCb(), T && T(r, M) }), k && k(r), F && (addTransitionClass(r, w), addTransitionClass(r, E), nextFrame(() => { removeTransitionClass(r, w), M.cancelled || (addTransitionClass(r, S), L || (isValidDuration(O) ? setTimeout(M, O) : whenTransitionEnds(r, a, M))) })), e.data.show && (t && t(), T && T(r, M)), F || L || M() } } } function leave(e, t) { const r = e.elm; isDef(r._enterCb) && (r._enterCb.cancelled = !0, r._enterCb()); const n = resolveTransition(e.data.transition); if (isUndef(n) || r.nodeType !== 1) return t(); if (!isDef(r._leaveCb)) { const i = n.css; var a = n.type; var o = n.leaveClass; var s = n.leaveToClass; var u = n.leaveActiveClass; var l = n.beforeLeave; var c = n.leave; const p = n.afterLeave; const f = n.leaveCancelled; const d = n.delayLeave; const h = n.duration; var m = !1 !== i && !A; var g = getHookArgumentsLength(c); var v = toNumber(isObject(h) ? h.leave : h); 0; var y = r._leaveCb = once(() => { r.parentNode && r.parentNode._pending && (r.parentNode._pending[e.key] = null), m && (removeTransitionClass(r, s), removeTransitionClass(r, u)), y.cancelled ? (m && removeTransitionClass(r, o), f && f(r)) : (t(), p && p(r)), r._leaveCb = null }); d ? d(performLeave) : performLeave() } function performLeave() { y.cancelled || (e.data.show || ((r.parentNode._pending || (r.parentNode._pending = {}))[e.key] = e), l && l(r), m && (addTransitionClass(r, o), addTransitionClass(r, u), nextFrame(() => { removeTransitionClass(r, o), y.cancelled || (addTransitionClass(r, s), g || (isValidDuration(v) ? setTimeout(y, v) : whenTransitionEnds(r, a, y))) })), c && c(r, y), m || g || y()) } } function isValidDuration(e) { return typeof e === 'number' && !isNaN(e) } function getHookArgumentsLength(e) { if (isUndef(e)) return !1; const t = e.fns; return isDef(t) ? getHookArgumentsLength(Array.isArray(t) ? t[0] : t) : (e._length || e.length) > 1 } function _enter(e, t) { !0 !== t.data.show && enter(t) } const kt = (function createPatchFunction(e) { let t; let r; const n = {}; const i = e.modules; const a = e.nodeOps; for (t = 0; t < $e.length; ++t) for (n[$e[t]] = [], r = 0; r < i.length; ++r)isDef(i[r][$e[t]]) && n[$e[t]].push(i[r][$e[t]]); function removeNode(e) { const t = a.parentNode(e); isDef(t) && a.removeChild(t, e) } function createElm(e, t, r, i, o, s, u) { if (isDef(e.elm) && isDef(s) && (e = s[u] = cloneVNode(e)), e.isRootInsert = !o, !(function createComponent(e, t, r, i) { let a = e.data; if (isDef(a)) { const o = isDef(e.componentInstance) && a.keepAlive; if (isDef(a = a.hook) && isDef(a = a.init) && a(e, !1, r, i), isDef(e.componentInstance)) return initComponent(e, t), isTrue(o) && (function reactivateComponent(e, t, r, i) { for (var a, o = e; o.componentInstance;) if (o = o.componentInstance._vnode, isDef(a = o.data) && isDef(a = a.transition)) { for (a = 0; a < n.activate.length; ++a)n.activate[a](He, o); t.push(o); break }insert(r, e.elm, i) }(e, t, r, i)), !0; } }(e, t, r, i))) { const l = e.data; const c = e.children; const p = e.tag; isDef(p) ? (e.elm = e.ns ? a.createElementNS(e.ns, p) : a.createElement(p, e), setScope(e), createChildren(e, c, t), isDef(l) && invokeCreateHooks(e, t), insert(r, e.elm, i)) : isTrue(e.isComment) ? (e.elm = a.createComment(e.text), insert(r, e.elm, i)) : (e.elm = a.createTextNode(e.text), insert(r, e.elm, i)) } } function initComponent(e, t) { isDef(e.data.pendingInsert) && (t.push(...e.data.pendingInsert), e.data.pendingInsert = null), e.elm = e.componentInstance.$el, isPatchable(e) ? (invokeCreateHooks(e, t), setScope(e)) : (registerRef(e), t.push(e)) } function insert(e, t, r) { isDef(e) && (isDef(r) ? r.parentNode === e && a.insertBefore(e, t, r) : a.appendChild(e, t)) } function createChildren(e, t, r) { if (Array.isArray(t)) for (let n = 0; n < t.length; ++n)createElm(t[n], r, e.elm, null, !0, t, n); else isPrimitive(e.text) && a.appendChild(e.elm, a.createTextNode(String(e.text))); } function isPatchable(e) { for (;e.componentInstance;)e = e.componentInstance._vnode; return isDef(e.tag) } function invokeCreateHooks(e, r) { for (let i = 0; i < n.create.length; ++i)n.create[i](He, e); isDef(t = e.data.hook) && (isDef(t.create) && t.create(He, e), isDef(t.insert) && r.push(e)) } function setScope(e) { let t; if (isDef(t = e.fnScopeId))a.setStyleScope(e.elm, t); else for (let r = e; r;)isDef(t = r.context) && isDef(t = t.$options._scopeId) && a.setStyleScope(e.elm, t), r = r.parent; isDef(t = le) && t !== e.context && t !== e.fnContext && isDef(t = t.$options._scopeId) && a.setStyleScope(e.elm, t) } function addVnodes(e, t, r, n, i, a) { for (;n <= i; ++n)createElm(r[n], a, e, t, !1, r, n); } function invokeDestroyHook(e) { let t; let r; const i = e.data; if (isDef(i)) for (isDef(t = i.hook) && isDef(t = t.destroy) && t(e), t = 0; t < n.destroy.length; ++t)n.destroy[t](e); if (isDef(t = e.children)) for (r = 0; r < e.children.length; ++r)invokeDestroyHook(e.children[r]); } function removeVnodes(e, t, r, n) { for (;r <= n; ++r) { const i = t[r]; isDef(i) && (isDef(i.tag) ? (removeAndInvokeRemoveHook(i), invokeDestroyHook(i)) : removeNode(i.elm)) } } function removeAndInvokeRemoveHook(e, t) { if (isDef(t) || isDef(e.data)) { let r; const i = n.remove.length + 1; for (isDef(t) ? t.listeners += i : t = (function createRmCb(e, t) { function remove() { --remove.listeners == 0 && removeNode(e) } return remove.listeners = t, remove }(e.elm, i)), isDef(r = e.componentInstance) && isDef(r = r._vnode) && isDef(r.data) && removeAndInvokeRemoveHook(r, t), r = 0; r < n.remove.length; ++r)n.remove[r](e, t); isDef(r = e.data.hook) && isDef(r = r.remove) ? r(e, t) : t() } else removeNode(e.elm); } function findIdxInOld(e, t, r, n) { for (let i = r; i < n; i++) { const a = t[i]; if (isDef(a) && sameVnode(e, a)) return i; } } function patchVnode(e, t, r, i) { if (e !== t) { const o = t.elm = e.elm; if (isTrue(e.isAsyncPlaceholder))isDef(t.asyncFactory.resolved) ? hydrate(e.elm, t, r) : t.isAsyncPlaceholder = !0; else if (isTrue(t.isStatic) && isTrue(e.isStatic) && t.key === e.key && (isTrue(t.isCloned) || isTrue(t.isOnce)))t.componentInstance = e.componentInstance; else { let s; const u = t.data; isDef(u) && isDef(s = u.hook) && isDef(s = s.prepatch) && s(e, t); const l = e.children; const c = t.children; if (isDef(u) && isPatchable(t)) { for (s = 0; s < n.update.length; ++s)n.update[s](e, t); isDef(s = u.hook) && isDef(s = s.update) && s(e, t) }isUndef(t.text) ? isDef(l) && isDef(c) ? l !== c && (function updateChildren(e, t, r, n, i) { for (var o, s, u, l = 0, c = 0, p = t.length - 1, f = t[0], d = t[p], h = r.length - 1, m = r[0], g = r[h], v = !i; l <= p && c <= h;)isUndef(f) ? f = t[++l] : isUndef(d) ? d = t[--p] : sameVnode(f, m) ? (patchVnode(f, m, n), f = t[++l], m = r[++c]) : sameVnode(d, g) ? (patchVnode(d, g, n), d = t[--p], g = r[--h]) : sameVnode(f, g) ? (patchVnode(f, g, n), v && a.insertBefore(e, f.elm, a.nextSibling(d.elm)), f = t[++l], g = r[--h]) : sameVnode(d, m) ? (patchVnode(d, m, n), v && a.insertBefore(e, d.elm, f.elm), d = t[--p], m = r[++c]) : (isUndef(o) && (o = createKeyToOldIdx(t, l, p)), isUndef(s = isDef(m.key) ? o[m.key] : findIdxInOld(m, t, l, p)) ? createElm(m, n, e, f.elm, !1, r, c) : sameVnode(u = t[s], m) ? (patchVnode(u, m, n), t[s] = void 0, v && a.insertBefore(e, u.elm, f.elm)) : createElm(m, n, e, f.elm, !1, r, c), m = r[++c]); l > p ? addVnodes(e, isUndef(r[h + 1]) ? null : r[h + 1].elm, r, c, h, n) : c > h && removeVnodes(0, t, l, p) }(o, l, c, r, i)) : isDef(c) ? (isDef(e.text) && a.setTextContent(o, ''), addVnodes(o, null, c, 0, c.length - 1, r)) : isDef(l) ? removeVnodes(0, l, 0, l.length - 1) : isDef(e.text) && a.setTextContent(o, '') : e.text !== t.text && a.setTextContent(o, t.text), isDef(u) && isDef(s = u.hook) && isDef(s = s.postpatch) && s(e, t) } } } function invokeInsertHook(e, t, r) { if (isTrue(r) && isDef(e.parent))e.parent.data.pendingInsert = t; else for (let n = 0; n < t.length; ++n)t[n].data.hook.insert(t[n]); } const o = makeMap('attrs,class,staticClass,staticStyle,key'); function hydrate(e, t, r, n) { let i; const a = t.tag; const s = t.data; const u = t.children; if (n = n || s && s.pre, t.elm = e, isTrue(t.isComment) && isDef(t.asyncFactory)) return t.isAsyncPlaceholder = !0, !0; if (isDef(s) && (isDef(i = s.hook) && isDef(i = i.init) && i(t, !0), isDef(i = t.componentInstance))) return initComponent(t, r), !0; if (isDef(a)) { if (isDef(u)) if (e.hasChildNodes()) if (isDef(i = s) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) { if (i !== e.innerHTML) return !1; } else { for (var l = !0, c = e.firstChild, p = 0; p < u.length; p++) { if (!c || !hydrate(c, u[p], r, n)) { l = !1; break }c = c.nextSibling } if (!l || c) return !1; } else createChildren(t, u, r); if (isDef(s)) { let f = !1; for (const d in s) if (!o(d)) { f = !0, invokeCreateHooks(t, r); break }!f && s.class && traverse(s.class) } } else e.data !== t.text && (e.data = t.text); return !0 } return function patch(e, t, r, i, o, s) { if (!isUndef(t)) { let u = !1; const l = []; if (isUndef(e))u = !0, createElm(t, l, o, s); else { const c = isDef(e.nodeType); if (!c && sameVnode(e, t))patchVnode(e, t, l, i); else { if (c) { if (e.nodeType === 1 && e.hasAttribute(g) && (e.removeAttribute(g), r = !0), isTrue(r) && hydrate(e, t, l)) return invokeInsertHook(t, l, !0), e; e = (function emptyNodeAt(e) { return new z(a.tagName(e).toLowerCase(), {}, [], void 0, e) }(e)) } const p = e.elm; const f = a.parentNode(p); if (createElm(t, l, p._leaveCb ? null : f, a.nextSibling(p)), isDef(t.parent)) for (let d = t.parent, h = isPatchable(t); d;) { for (let m = 0; m < n.destroy.length; ++m)n.destroy[m](d); if (d.elm = t.elm, h) { for (let v = 0; v < n.create.length; ++v)n.create[v](He, d); const y = d.data.hook.insert; if (y.merged) for (let b = 1; b < y.fns.length; b++)y.fns[b](); } else registerRef(d); d = d.parent }isDef(f) ? removeVnodes(0, [e], 0, 0) : isDef(e.tag) && invokeDestroyHook(e) } } return invokeInsertHook(t, l, u), t.elm }isDef(e) && invokeDestroyHook(e) } }({ nodeOps: ze, modules: [Ke, rt, st, ut, gt, C ? { create: _enter, activate: _enter, remove: function remove$$1(e, t) { !0 !== e.data.show ? leave(e, t) : t() } } : {}].concat(We) })); A && document.addEventListener('selectionchange', () => { const e = document.activeElement; e && e.vmodel && trigger(e, 'input') }); var At = { inserted: function inserted(e, t, r, n) { r.tag === 'select' ? (n.elm && !n.elm._vOptions ? mergeVNodeHook(r, 'postpatch', () => { At.componentUpdated(e, t, r) }) : setSelected(e, t, r.context), e._vOptions = [].map.call(e.options, getValue)) : (r.tag === 'textarea' || Ue(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener('compositionstart', onCompositionStart), e.addEventListener('compositionend', onCompositionEnd), e.addEventListener('change', onCompositionEnd), A && (e.vmodel = !0))) }, componentUpdated: function componentUpdated(e, t, r) { if (r.tag === 'select') { setSelected(e, t, r.context); const n = e._vOptions; const i = e._vOptions = [].map.call(e.options, getValue); if (i.some((e, t) => !looseEqual(e, n[t])))(e.multiple ? t.value.some(e => hasNoMatchingOption(e, i)) : t.value !== t.oldValue && hasNoMatchingOption(t.value, i)) && trigger(e, 'change'); } } }; function setSelected(e, t, r) { actuallySetSelected(e, t, r), (k || T) && setTimeout(() => { actuallySetSelected(e, t, r) }, 0) } function actuallySetSelected(e, t, r) { const n = t.value; const i = e.multiple; if (!i || Array.isArray(n)) { for (var a, o, s = 0, u = e.options.length; s < u; s++) if (o = e.options[s], i)a = looseIndexOf(n, getValue(o)) > -1, o.selected !== a && (o.selected = a); else if (looseEqual(getValue(o), n)) return void (e.selectedIndex !== s && (e.selectedIndex = s)); i || (e.selectedIndex = -1) } } function hasNoMatchingOption(e, t) { return t.every(t => !looseEqual(t, e)) } function getValue(e) { return '_value' in e ? e._value : e.value } function onCompositionStart(e) { e.target.composing = !0 } function onCompositionEnd(e) { e.target.composing && (e.target.composing = !1, trigger(e.target, 'input')) } function trigger(e, t) { const r = document.createEvent('HTMLEvents'); r.initEvent(t, !0, !0), e.dispatchEvent(r) } function locateNode(e) { return !e.componentInstance || e.data && e.data.transition ? e : locateNode(e.componentInstance._vnode) } const Tt = { model: At, show: { bind: function bind(e, t, r) { const n = t.value; const i = (r = locateNode(r)).data && r.data.transition; const a = e.__vOriginalDisplay = e.style.display === 'none' ? '' : e.style.display; n && i ? (r.data.show = !0, enter(r, () => { e.style.display = a })) : e.style.display = n ? a : 'none' }, update: function update(e, t, r) { const n = t.value; !n != !t.oldValue && ((r = locateNode(r)).data && r.data.transition ? (r.data.show = !0, n ? enter(r, () => { e.style.display = e.__vOriginalDisplay }) : leave(r, () => { e.style.display = 'none' })) : e.style.display = n ? e.__vOriginalDisplay : 'none') }, unbind: function unbind(e, t, r, n, i) { i || (e.style.display = e.__vOriginalDisplay) } } }; const Pt = {
      name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object],
    }; function getRealChild(e) { const t = e && e.componentOptions; return t && t.Ctor.options.abstract ? getRealChild(getFirstComponentChild(t.children)) : e } function extractTransitionData(e) { const t = {}; const r = e.$options; for (const n in r.propsData)t[n] = e[n]; const i = r._parentListeners; for (const a in i)t[l(a)] = i[a]; return t } function placeholder(e, t) { if (/\d-keep-alive$/.test(t.tag)) return e('keep-alive', { props: t.componentOptions.propsData }); } const Rt = {
      name: 'transition', props: Pt, abstract: !0, render: function render(e) { const t = this; let r = this.$slots.default; if (r && (r = r.filter(e => e.tag || isAsyncPlaceholder(e))).length) { 0; const n = this.mode; 0; const i = r[0]; if (function hasParentTransition(e) { for (;e = e.parent;) if (e.data.transition) return !0; }(this.$vnode)) return i; const a = getRealChild(i); if (!a) return i; if (this._leaving) return placeholder(e, i); const o = `__transition-${this._uid}-`; a.key = a.key == null ? a.isComment ? `${o}comment` : o + a.tag : isPrimitive(a.key) ? String(a.key).indexOf(o) === 0 ? a.key : o + a.key : a.key; const s = (a.data || (a.data = {})).transition = extractTransitionData(this); const u = this._vnode; const l = getRealChild(u); if (a.data.directives && a.data.directives.some(e => e.name === 'show') && (a.data.show = !0), l && l.data && !(function isSameChild(e, t) { return t.key === e.key && t.tag === e.tag }(a, l)) && !isAsyncPlaceholder(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) { const c = l.data.transition = extend({}, s); if (n === 'out-in') return this._leaving = !0, mergeVNodeHook(c, 'afterLeave', () => { t._leaving = !1, t.$forceUpdate() }), placeholder(e, i); if (n === 'in-out') { if (isAsyncPlaceholder(a)) return u; let p; const f = function () { p() }; mergeVNodeHook(s, 'afterEnter', f), mergeVNodeHook(s, 'enterCancelled', f), mergeVNodeHook(c, 'delayLeave', (e) => { p = e }) } } return i } },
    }; const Ot = extend({ tag: String, moveClass: String }, Pt); function callPendingCbs(e) { e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb() } function recordPosition(e) { e.data.newPos = e.elm.getBoundingClientRect() } function applyTranslation(e) { const t = e.data.pos; const r = e.data.newPos; const n = t.left - r.left; const i = t.top - r.top; if (n || i) { e.data.moved = !0; const a = e.elm.style; a.transform = a.WebkitTransform = `translate(${n}px,${i}px)`, a.transitionDuration = '0s' } } delete Ot.mode; const Ft = {
      Transition: Rt,
      TransitionGroup: {
        props: Ot, render: function render(e) { for (var t = this.tag || this.$vnode.data.tag || 'span', r = Object.create(null), n = this.prevChildren = this.children, i = this.$slots.default || [], a = this.children = [], o = extractTransitionData(this), s = 0; s < i.length; s++) { const u = i[s]; if (u.tag) if (u.key != null && String(u.key).indexOf('__vlist') !== 0)a.push(u), r[u.key] = u, (u.data || (u.data = {})).transition = o; else; } if (n) { for (var l = [], c = [], p = 0; p < n.length; p++) { const f = n[p]; f.data.transition = o, f.data.pos = f.elm.getBoundingClientRect(), r[f.key] ? l.push(f) : c.push(f) } this.kept = e(t, null, l), this.removed = c } return e(t, null, a) }, beforeUpdate: function beforeUpdate() { this.__patch__(this._vnode, this.kept, !1, !0), this._vnode = this.kept }, updated: function updated() { const e = this.prevChildren; const t = this.moveClass || `${this.name || 'v'}-move`; e.length && this.hasMove(e[0].elm, t) && (e.forEach(callPendingCbs), e.forEach(recordPosition), e.forEach(applyTranslation), this._reflow = document.body.offsetHeight, e.forEach((e) => { if (e.data.moved) { const r = e.elm; const n = r.style; addTransitionClass(r, t), n.transform = n.WebkitTransform = n.transitionDuration = '', r.addEventListener(_t, r._moveCb = function cb(e) { e && !/transform$/.test(e.propertyName) || (r.removeEventListener(_t, cb), r._moveCb = null, removeTransitionClass(r, t)) }) } })) }, methods: { hasMove: function hasMove(e, t) { if (!yt) return !1; if (this._hasMove) return this._hasMove; const r = e.cloneNode(); e._transitionClasses && e._transitionClasses.forEach((e) => { removeClass(r, e) }), addClass(r, t), r.style.display = 'none', this.$el.appendChild(r); const n = getTransitionInfo(r); return this.$el.removeChild(r), this._hasMove = n.hasTransform } },
      },
    }; Vue.config.mustUseProp = Te, Vue.config.isReservedTag = Be, Vue.config.isReservedAttr = ke, Vue.config.getTagNamespace = getTagNamespace, Vue.config.isUnknownElement = function isUnknownElement(e) { if (!C) return !0; if (Be(e)) return !1; if (e = e.toLowerCase(), qe[e] != null) return qe[e]; const t = document.createElement(e); return e.indexOf('-') > -1 ? qe[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : qe[e] = /HTMLUnknownElement/.test(t.toString()) }, extend(Vue.options.directives, Tt), extend(Vue.options.components, Ft), Vue.prototype.__patch__ = C ? kt : noop, Vue.prototype.$mount = function (e, t) { return (function mountComponent(e, t, r) { return e.$el = t, e.$options.render || (e.$options.render = H), callHook(e, 'beforeMount'), new ve(e, (() => { e._update(e._render(), r) }), noop, null, !0), r = !1, e.$vnode == null && (e._isMounted = !0, callHook(e, 'mounted')), e }(this, e = e && C ? query(e) : void 0, t)) }, C && setTimeout(() => { b.devtools && M && M.emit('init', Vue) }, 0); const Lt = /\{\{((?:.|\n)+?)\}\}/g; const Mt = /[-.*+?^${}()|[\]\/\\]/g; const jt = cached((e) => { const t = e[0].replace(Mt, '\\$&'); const r = e[1].replace(Mt, '\\$&'); return new RegExp(`${t}((?:.|\\n)+?)${r}`, 'g') }); function parseText(e, t) { const r = t ? jt(t) : Lt; if (r.test(e)) { for (var n, i, a, o = [], s = [], u = r.lastIndex = 0; n = r.exec(e);) { (i = n.index) > u && (s.push(a = e.slice(u, i)), o.push(JSON.stringify(a))); const l = parseFilters(n[1].trim()); o.push(`_s(${l})`), s.push({ '@binding': l }), u = i + n[0].length } return u < e.length && (s.push(a = e.slice(u)), o.push(JSON.stringify(a))), { expression: o.join('+'), tokens: s } } } const Nt = { staticKeys: ['staticClass'], transformNode: function transformNode(e, t) { t.warn; const r = getAndRemoveAttr(e, 'class'); r && (e.staticClass = JSON.stringify(r)); const n = getBindingAttr(e, 'class', !1); n && (e.classBinding = n) }, genData: function genData(e) { let t = ''; return e.staticClass && (t += `staticClass:${e.staticClass},`), e.classBinding && (t += `class:${e.classBinding},`), t } }; let It; const Bt = { staticKeys: ['staticStyle'], transformNode: function transformNode$1(e, t) { t.warn; const r = getAndRemoveAttr(e, 'style'); r && (e.staticStyle = JSON.stringify(lt(r))); const n = getBindingAttr(e, 'style', !1); n && (e.styleBinding = n) }, genData: function genData$1(e) { let t = ''; return e.staticStyle && (t += `staticStyle:${e.staticStyle},`), e.styleBinding && (t += `style:(${e.styleBinding}),`), t } }; const qt = function decode(e) { return (It = It || document.createElement('div')).innerHTML = e, It.textContent }; const Ut = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr'); const zt = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); const Vt = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track'); const Ht = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/; const $t = '[a-zA-Z_][\\w\\-\\.]*'; const Gt = `((?:${$t}\\:)?${$t})`; const Jt = new RegExp(`^<${Gt}`); const Wt = /^\s*(\/?)>/; const Kt = new RegExp(`^<\\/${Gt}[^>]*>`); const Xt = /^<!DOCTYPE [^>]+>/i; const Yt = /^<!\--/; const Qt = /^<!\[/; let Zt = !1; 'x'.replace(/x(.)?/g, (e, t) => { Zt = t === '' }); const er = makeMap('script,style,textarea', !0); const tr = {}; const rr = {
      '&lt;': '<', '&gt;': '>', '&quot;': '"', '&amp;': '&', '&#10;': '\n', '&#9;': '\t',
    }; const nr = /&(?:lt|gt|quot|amp);/g; const ir = /&(?:lt|gt|quot|amp|#10|#9);/g; const ar = makeMap('pre,textarea', !0); const or = function (e, t) { return e && ar(e) && t[0] === '\n' }; function decodeAttr(e, t) { const r = t ? ir : nr; return e.replace(r, e => rr[e]) } let sr; let ur; let lr; let cr; let pr; let fr; let dr; let hr; const mr = /^@|^v-on:/; const gr = /^v-|^@|^:/; const vr = /([^]*?)\s+(?:in|of)\s+([^]*)/; const yr = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/; const br = /^\(|\)$/g; const xr = /:(.*)$/; const Dr = /^:|^v-bind:/; const _r = /\.[^.]+/g; const Cr = cached(qt); function createASTElement(e, t, r) {
      return {
        type: 1, tag: e, attrsList: t, attrsMap: (function makeAttrsMap(e) { for (var t = {}, r = 0, n = e.length; r < n; r++)t[e[r].name] = e[r].value; return t }(t)), parent: r, children: [],
      };
    } function parse(e, t) {
      sr = t.warn || baseWarn, fr = t.isPreTag || h, dr = t.mustUseProp || h, hr = t.getTagNamespace || h, lr = pluckModuleFunction(t.modules, 'transformNode'), cr = pluckModuleFunction(t.modules, 'preTransformNode'), pr = pluckModuleFunction(t.modules, 'postTransformNode'), ur = t.delimiters; let r; let n; const i = []; const a = !1 !== t.preserveWhitespace; let o = !1; let s = !1; function closeElement(e) { e.pre && (o = !1), fr(e.tag) && (s = !1); for (let r = 0; r < pr.length; r++)pr[r](e, t); } return (function parseHTML(e, t) { for (var r, n, i = [], a = t.expectHTML, o = t.isUnaryTag || h, s = t.canBeLeftOpenTag || h, u = 0; e;) { if (r = e, n && er(n)) { var l = 0; const c = n.toLowerCase(); const p = tr[c] || (tr[c] = new RegExp(`([\\s\\S]*?)(</${c}[^>]*>)`, 'i')); const f = e.replace(p, (e, r, n) => l = n.length, er(c) || c === 'noscript' || (r = r.replace(/<!\--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')), or(c, r) && (r = r.slice(1)), t.chars && t.chars(r), ''); u += e.length - f.length, e = f, parseEndTag(c, u - l, u) } else { let d = e.indexOf('<'); if (d === 0) { if (Yt.test(e)) { const m = e.indexOf('--\x3e'); if (m >= 0) { t.shouldKeepComment && t.comment(e.substring(4, m)), advance(m + 3); continue } } if (Qt.test(e)) { const g = e.indexOf(']>'); if (g >= 0) { advance(g + 2); continue } } const v = e.match(Xt); if (v) { advance(v[0].length); continue } const y = e.match(Kt); if (y) { const b = u; advance(y[0].length), parseEndTag(y[1], b, u); continue } const x = parseStartTag(); if (x) { handleStartTag(x), or(n, e) && advance(1); continue } } let D = void 0; let _ = void 0; let C = void 0; if (d >= 0) { for (_ = e.slice(d); !(Kt.test(_) || Jt.test(_) || Yt.test(_) || Qt.test(_) || (C = _.indexOf('<', 1)) < 0);)d += C, _ = e.slice(d); D = e.substring(0, d), advance(d) }d < 0 && (D = e, e = ''), t.chars && D && t.chars(D) } if (e === r) { t.chars && t.chars(e); break } } function advance(t) { u += t, e = e.substring(t) } function parseStartTag() { const t = e.match(Jt); if (t) { let r; let n; const i = { tagName: t[1], attrs: [], start: u }; for (advance(t[0].length); !(r = e.match(Wt)) && (n = e.match(Ht));)advance(n[0].length), i.attrs.push(n); if (r) return i.unarySlash = r[1], advance(r[0].length), i.end = u, i; } } function handleStartTag(e) { const r = e.tagName; const u = e.unarySlash; a && (n === 'p' && Vt(r) && parseEndTag(n), s(r) && n === r && parseEndTag(r)); for (var l = o(r) || !!u, c = e.attrs.length, p = new Array(c), f = 0; f < c; f++) { const d = e.attrs[f]; Zt && d[0].indexOf('""') === -1 && (d[3] === '' && delete d[3], d[4] === '' && delete d[4], d[5] === '' && delete d[5]); const h = d[3] || d[4] || d[5] || ''; const m = r === 'a' && d[1] === 'href' ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines; p[f] = { name: d[1], value: decodeAttr(h, m) } }l || (i.push({ tag: r, lowerCasedTag: r.toLowerCase(), attrs: p }), n = r), t.start && t.start(r, p, l, e.start, e.end) } function parseEndTag(e, r, a) { let o; let s; if (r == null && (r = u), a == null && (a = u), e && (s = e.toLowerCase()), e) for (o = i.length - 1; o >= 0 && i[o].lowerCasedTag !== s; o--);else o = 0; if (o >= 0) { for (let l = i.length - 1; l >= o; l--)t.end && t.end(i[l].tag, r, a); i.length = o, n = o && i[o - 1].tag } else s === 'br' ? t.start && t.start(e, [], !0, r, a) : s === 'p' && (t.start && t.start(e, [], !1, r, a), t.end && t.end(e, r, a)); }parseEndTag() }(e, {
        warn: sr,
        expectHTML: t.expectHTML,
        isUnaryTag: t.isUnaryTag,
        canBeLeftOpenTag: t.canBeLeftOpenTag,
        shouldDecodeNewlines: t.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,
        shouldKeepComment: t.comments,
        start: function start(e, a, u) { const l = n && n.ns || hr(e); k && l === 'svg' && (a = (function guardIESVGBug(e) { for (var t = [], r = 0; r < e.length; r++) { const n = e[r]; wr.test(n.name) || (n.name = n.name.replace(Er, ''), t.push(n)) } return t }(a))); let c = createASTElement(e, a, n); l && (c.ns = l), (function isForbiddenTag(e) { return e.tag === 'style' || e.tag === 'script' && (!e.attrsMap.type || e.attrsMap.type === 'text/javascript') }(c)) && !L() && (c.forbidden = !0); for (let p = 0; p < cr.length; p++)c = cr[p](c, t) || c; function checkRootConstraints(e) { 0 } if (o || (!(function processPre(e) { getAndRemoveAttr(e, 'v-pre') != null && (e.pre = !0) }(c)), c.pre && (o = !0)), fr(c.tag) && (s = !0), o ? (function processRawAttrs(e) { const t = e.attrsList.length; if (t) for (let r = e.attrs = new Array(t), n = 0; n < t; n++)r[n] = { name: e.attrsList[n].name, value: JSON.stringify(e.attrsList[n].value) }; else e.pre || (e.plain = !0); }(c)) : c.processed || (processFor(c), (function processIf(e) { const t = getAndRemoveAttr(e, 'v-if'); if (t)e.if = t, addIfCondition(e, { exp: t, block: e }); else { getAndRemoveAttr(e, 'v-else') != null && (e.else = !0); const r = getAndRemoveAttr(e, 'v-else-if'); r && (e.elseif = r) } }(c)), (function processOnce(e) { getAndRemoveAttr(e, 'v-once') != null && (e.once = !0) }(c)), processElement(c, t)), r ? i.length || r.if && (c.elseif || c.else) && (checkRootConstraints(), addIfCondition(r, { exp: c.elseif, block: c })) : (r = c, checkRootConstraints()), n && !c.forbidden) if (c.elseif || c.else)!(function processIfConditions(e, t) { const r = (function findPrevElement(e) { let t = e.length; for (;t--;) { if (e[t].type === 1) return e[t]; e.pop() } }(t.children)); r && r.if && addIfCondition(r, { exp: e.elseif, block: e }) }(c, n)); else if (c.slotScope) { n.plain = !1; const f = c.slotTarget || '"default"'; (n.scopedSlots || (n.scopedSlots = {}))[f] = c } else n.children.push(c), c.parent = n; u ? closeElement(c) : (n = c, i.push(c)) },
        end: function end() { const e = i[i.length - 1]; const t = e.children[e.children.length - 1]; t && t.type === 3 && t.text === ' ' && !s && e.children.pop(), i.length -= 1, n = i[i.length - 1], closeElement(e) },
        chars: function chars(e) {
          if (n && (!k || n.tag !== 'textarea' || n.attrsMap.placeholder !== e)) {
            let t; const r = n.children; if (e = s || e.trim() ? (function isTextTag(e) { return e.tag === 'script' || e.tag === 'style' }(n)) ? e : Cr(e) : a && r.length ? ' ' : '') {
              !o && e !== ' ' && (t = parseText(e, ur)) ? r.push({
                type: 2, expression: t.expression, tokens: t.tokens, text: e,
              }) : e === ' ' && r.length && r[r.length - 1].text === ' ' || r.push({ type: 3, text: e });
            }
          }
        },
        comment: function comment(e) { n.children.push({ type: 3, text: e, isComment: !0 }) },
      })), r;
    } function processElement(e, t) { !(function processKey(e) { const t = getBindingAttr(e, 'key'); t && (e.key = t) }(e)), e.plain = !e.key && !e.attrsList.length, (function processRef(e) { const t = getBindingAttr(e, 'ref'); t && (e.ref = t, e.refInFor = (function checkInFor(e) { let t = e; for (;t;) { if (void 0 !== t.for) return !0; t = t.parent } return !1 }(e))) }(e)), (function processSlot(e) { if (e.tag === 'slot')e.slotName = getBindingAttr(e, 'name'); else { let t; e.tag === 'template' ? (t = getAndRemoveAttr(e, 'scope'), e.slotScope = t || getAndRemoveAttr(e, 'slot-scope')) : (t = getAndRemoveAttr(e, 'slot-scope')) && (e.slotScope = t); const r = getBindingAttr(e, 'slot'); r && (e.slotTarget = r === '""' ? '"default"' : r, e.tag === 'template' || e.slotScope || addAttr(e, 'slot', r)) } }(e)), (function processComponent(e) { let t; (t = getBindingAttr(e, 'is')) && (e.component = t); getAndRemoveAttr(e, 'inline-template') != null && (e.inlineTemplate = !0) }(e)); for (let r = 0; r < lr.length; r++)e = lr[r](e, t) || e; !(function processAttrs(e) { let t; let r; let n; let i; let a; let o; let s; const u = e.attrsList; for (t = 0, r = u.length; t < r; t++) { if (n = i = u[t].name, a = u[t].value, gr.test(n)) if (e.hasBindings = !0, (o = parseModifiers(n)) && (n = n.replace(_r, '')), Dr.test(n))n = n.replace(Dr, ''), a = parseFilters(a), s = !1, o && (o.prop && (s = !0, (n = l(n)) === 'innerHtml' && (n = 'innerHTML')), o.camel && (n = l(n)), o.sync && addHandler(e, `update:${l(n)}`, genAssignmentCode(a, '$event'))), s || !e.component && dr(e.tag, e.attrsMap.type, n) ? addProp(e, n, a) : addAttr(e, n, a); else if (mr.test(n))n = n.replace(mr, ''), addHandler(e, n, a, o, !1); else { const c = (n = n.replace(gr, '')).match(xr); const p = c && c[1]; p && (n = n.slice(0, -(p.length + 1))), addDirective(e, n, i, a, p, o) } else addAttr(e, n, JSON.stringify(a)), !e.component && n === 'muted' && dr(e.tag, e.attrsMap.type, n) && addProp(e, n, 'true'); } }(e)) } function processFor(e) { let t; if (t = getAndRemoveAttr(e, 'v-for')) { const r = (function parseFor(e) { const t = e.match(vr); if (!t) return; const r = {}; r.for = t[2].trim(); const n = t[1].trim().replace(br, ''); const i = n.match(yr); i ? (r.alias = n.replace(yr, ''), r.iterator1 = i[1].trim(), i[2] && (r.iterator2 = i[2].trim())) : r.alias = n; return r }(t)); r && extend(e, r) } } function addIfCondition(e, t) { e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t) } function parseModifiers(e) { const t = e.match(_r); if (t) { const r = {}; return t.forEach((e) => { r[e.slice(1)] = !0 }), r } } var wr = /^xmlns:NS\d+/; var Er = /^NS\d+:/; function cloneASTElement(e) { return createASTElement(e.tag, e.attrsList.slice(), e.parent) } const Sr = [Nt, Bt, { preTransformNode: function preTransformNode(e, t) { if (e.tag === 'input') { let r; const n = e.attrsMap; if (!n['v-model']) return; if ((n[':type'] || n['v-bind:type']) && (r = getBindingAttr(e, 'type')), n.type || r || !n['v-bind'] || (r = `(${n['v-bind']}).type`), r) { const i = getAndRemoveAttr(e, 'v-if', !0); const a = i ? `&&(${i})` : ''; const o = getAndRemoveAttr(e, 'v-else', !0) != null; const s = getAndRemoveAttr(e, 'v-else-if', !0); const u = cloneASTElement(e); processFor(u), addRawAttr(u, 'type', 'checkbox'), processElement(u, t), u.processed = !0, u.if = `(${r})==='checkbox'${a}`, addIfCondition(u, { exp: u.if, block: u }); const l = cloneASTElement(e); getAndRemoveAttr(l, 'v-for', !0), addRawAttr(l, 'type', 'radio'), processElement(l, t), addIfCondition(u, { exp: `(${r})==='radio'${a}`, block: l }); const c = cloneASTElement(e); return getAndRemoveAttr(c, 'v-for', !0), addRawAttr(c, ':type', r), processElement(c, t), addIfCondition(u, { exp: i, block: c }), o ? u.else = !0 : s && (u.elseif = s), u } } } }]; let kr; let Ar; const Tr = {
      expectHTML: !0, modules: Sr, directives: { model: function model(e, t, r) { r; const n = t.value; const i = t.modifiers; const a = e.tag; const o = e.attrsMap.type; if (e.component) return genComponentModel(e, n, i), !1; if (a === 'select')!(function genSelect(e, t, r) { let n = `var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ${r && r.number ? '_n(val)' : 'val'}});`; n = `${n} ${genAssignmentCode(t, '$event.target.multiple ? $$selectedVal : $$selectedVal[0]')}`, addHandler(e, 'change', n, null, !0) }(e, n, i)); else if (a === 'input' && o === 'checkbox')!(function genCheckboxModel(e, t, r) { const n = r && r.number; const i = getBindingAttr(e, 'value') || 'null'; const a = getBindingAttr(e, 'true-value') || 'true'; const o = getBindingAttr(e, 'false-value') || 'false'; addProp(e, 'checked', `Array.isArray(${t})?_i(${t},${i})>-1${a === 'true' ? `:(${t})` : `:_q(${t},${a})`}`), addHandler(e, 'change', `var $$a=${t},$$el=$event.target,$$c=$$el.checked?(${a}):(${o});if(Array.isArray($$a)){var $$v=${n ? `_n(${i})` : i},$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(${genAssignmentCode(t, '$$a.concat([$$v])')})}else{$$i>-1&&(${genAssignmentCode(t, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')})}}else{${genAssignmentCode(t, '$$c')}}`, null, !0) }(e, n, i)); else if (a === 'input' && o === 'radio')!(function genRadioModel(e, t, r) { const n = r && r.number; let i = getBindingAttr(e, 'value') || 'null'; addProp(e, 'checked', `_q(${t},${i = n ? `_n(${i})` : i})`), addHandler(e, 'change', genAssignmentCode(t, i), null, !0) }(e, n, i)); else if (a === 'input' || a === 'textarea')!(function genDefaultModel(e, t, r) { const n = e.attrsMap.type; const i = r || {}; const a = i.lazy; const o = i.number; const s = i.trim; const u = !a && n !== 'range'; const l = a ? 'change' : n === 'range' ? at : 'input'; let c = '$event.target.value'; s && (c = '$event.target.value.trim()'), o && (c = `_n(${c})`); let p = genAssignmentCode(t, c); u && (p = `if($event.target.composing)return;${p}`), addProp(e, 'value', `(${t})`), addHandler(e, l, p, null, !0), (s || o) && addHandler(e, 'blur', '$forceUpdate()') }(e, n, i)); else if (!b.isReservedTag(a)) return genComponentModel(e, n, i), !1; return !0 }, text: function text(e, t) { t.value && addProp(e, 'textContent', `_s(${t.value})`) }, html: function html(e, t) { t.value && addProp(e, 'innerHTML', `_s(${t.value})`) } }, isPreTag(e) { return e === 'pre' }, isUnaryTag: Ut, mustUseProp: Te, canBeLeftOpenTag: zt, isReservedTag: Be, getTagNamespace, staticKeys: (function genStaticKeys(e) { return e.reduce((e, t) => e.concat(t.staticKeys || []), []).join(',') }(Sr)),
    }; const Pr = cached(e => makeMap(`type,tag,attrsList,attrsMap,plain,parent,children,attrs${e ? `,${e}` : ''}`)); function optimize(e, t) { e && (kr = Pr(t.staticKeys || ''), Ar = t.isReservedTag || h, (function markStatic$1(e) { e.static = (function isStatic(e) { if (e.type === 2) return !1; if (e.type === 3) return !0; return !(!e.pre && (e.hasBindings || e.if || e.for || a(e.tag) || !Ar(e.tag) || (function isDirectChildOfTemplateFor(e) { for (;e.parent;) { if ((e = e.parent).tag !== 'template') return !1; if (e.for) return !0; } return !1 }(e)) || !Object.keys(e).every(kr))) }(e)); if (e.type === 1) { if (!Ar(e.tag) && e.tag !== 'slot' && e.attrsMap['inline-template'] == null) return; for (let t = 0, r = e.children.length; t < r; t++) { const n = e.children[t]; markStatic$1(n), n.static || (e.static = !1) } if (e.ifConditions) for (let i = 1, o = e.ifConditions.length; i < o; i++) { const s = e.ifConditions[i].block; markStatic$1(s), s.static || (e.static = !1) } } }(e)), (function markStaticRoots(e, t) { if (e.type === 1) { if ((e.static || e.once) && (e.staticInFor = t), e.static && e.children.length && (e.children.length !== 1 || e.children[0].type !== 3)) return void (e.staticRoot = !0); if (e.staticRoot = !1, e.children) for (let r = 0, n = e.children.length; r < n; r++)markStaticRoots(e.children[r], t || !!e.for); if (e.ifConditions) for (let i = 1, a = e.ifConditions.length; i < a; i++)markStaticRoots(e.ifConditions[i].block, t); } }(e, !1))) } const Rr = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/; const Or = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; const Fr = {
      esc: 27, tab: 9, enter: 13, space: 32, up: 38, left: 37, right: 39, down: 40, delete: [8, 46],
    }; const Lr = {
      esc: 'Escape', tab: 'Tab', enter: 'Enter', space: ' ', up: ['Up', 'ArrowUp'], left: ['Left', 'ArrowLeft'], right: ['Right', 'ArrowRight'], down: ['Down', 'ArrowDown'], delete: ['Backspace', 'Delete'],
    }; const Mr = function (e) { return `if(${e})return null;` }; const jr = {
      stop: '$event.stopPropagation();', prevent: '$event.preventDefault();', self: Mr('$event.target !== $event.currentTarget'), ctrl: Mr('!$event.ctrlKey'), shift: Mr('!$event.shiftKey'), alt: Mr('!$event.altKey'), meta: Mr('!$event.metaKey'), left: Mr("'button' in $event && $event.button !== 0"), middle: Mr("'button' in $event && $event.button !== 1"), right: Mr("'button' in $event && $event.button !== 2"),
    }; function genHandlers(e, t, r) { let n = t ? 'nativeOn:{' : 'on:{'; for (const i in e)n += `"${i}":${genHandler(i, e[i])},`; return `${n.slice(0, -1)}}` } function genHandler(e, t) { if (!t) return 'function(){}'; if (Array.isArray(t)) return `[${t.map(t => genHandler(e, t)).join(',')}]`; const r = Or.test(t.value); const n = Rr.test(t.value); if (t.modifiers) { let i = ''; let a = ''; const o = []; for (const s in t.modifiers) if (jr[s])a += jr[s], Fr[s] && o.push(s); else if (s === 'exact') { var u = t.modifiers; a += Mr(['ctrl', 'shift', 'alt', 'meta'].filter(e => !u[e]).map(e => `$event.${e}Key`).join('||')) } else o.push(s); return o.length && (i += (function genKeyFilter(e) { return `if(!('button' in $event)&&${e.map(genFilterCode).join('&&')})return null;` }(o))), a && (i += a), `function($event){${i}${r ? `return ${t.value}($event)` : n ? `return (${t.value})($event)` : t.value}}` } return r || n ? t.value : `function($event){${t.value}}` } function genFilterCode(e) { const t = parseInt(e, 10); if (t) return `$event.keyCode!==${t}`; const r = Fr[e]; const n = Lr[e]; return `_k($event.keyCode,${JSON.stringify(e)},${JSON.stringify(r)},$event.key,${JSON.stringify(n)})` } const Nr = { on: function on(e, t) { e.wrapListeners = function (e) { return `_g(${e},${t.value})` } }, bind: function bind$1(e, t) { e.wrapData = function (r) { return `_b(${r},'${e.tag}',${t.value},${t.modifiers && t.modifiers.prop ? 'true' : 'false'}${t.modifiers && t.modifiers.sync ? ',true' : ''})` } }, cloak: noop }; const Ir = function CodegenState(e) { this.options = e, this.warn = e.warn || baseWarn, this.transforms = pluckModuleFunction(e.modules, 'transformCode'), this.dataGenFns = pluckModuleFunction(e.modules, 'genData'), this.directives = extend(extend({}, Nr), e.directives); const t = e.isReservedTag || h; this.maybeComponent = function (e) { return !t(e.tag) }, this.onceId = 0, this.staticRenderFns = [] }; function generate(e, t) { const r = new Ir(t); return { render: `with(this){return ${e ? genElement(e, r) : '_c("div")'}}`, staticRenderFns: r.staticRenderFns } } function genElement(e, t) { if (e.staticRoot && !e.staticProcessed) return genStatic(e, t); if (e.once && !e.onceProcessed) return genOnce(e, t); if (e.for && !e.forProcessed) return (function genFor(e, t, r, n) { const i = e.for; const a = e.alias; const o = e.iterator1 ? `,${e.iterator1}` : ''; const s = e.iterator2 ? `,${e.iterator2}` : ''; 0; return e.forProcessed = !0, `${n || '_l'}((${i}),function(${a}${o}${s}){return ${(r || genElement)(e, t)}})` }(e, t)); if (e.if && !e.ifProcessed) return genIf(e, t); if (e.tag !== 'template' || e.slotTarget) { if (e.tag === 'slot') return (function genSlot(e, t) { const r = e.slotName || '"default"'; const n = genChildren(e, t); let i = `_t(${r}${n ? `,${n}` : ''}`; const a = e.attrs && `{${e.attrs.map(e => `${l(e.name)}:${e.value}`).join(',')}}`; const o = e.attrsMap['v-bind']; !a && !o || n || (i += ',null'); a && (i += `,${a}`); o && (i += `${a ? '' : ',null'},${o}`); return `${i})` }(e, t)); let r; if (e.component)r = (function genComponent(e, t, r) { const n = t.inlineTemplate ? null : genChildren(t, r, !0); return `_c(${e},${genData$2(t, r)}${n ? `,${n}` : ''})` }(e.component, e, t)); else { const n = e.plain ? void 0 : genData$2(e, t); const i = e.inlineTemplate ? null : genChildren(e, t, !0); r = `_c('${e.tag}'${n ? `,${n}` : ''}${i ? `,${i}` : ''})` } for (let a = 0; a < t.transforms.length; a++)r = t.transforms[a](e, r); return r } return genChildren(e, t) || 'void 0' } function genStatic(e, t) { return e.staticProcessed = !0, t.staticRenderFns.push(`with(this){return ${genElement(e, t)}}`), `_m(${t.staticRenderFns.length - 1}${e.staticInFor ? ',true' : ''})` } function genOnce(e, t) { if (e.onceProcessed = !0, e.if && !e.ifProcessed) return genIf(e, t); if (e.staticInFor) { for (var r = '', n = e.parent; n;) { if (n.for) { r = n.key; break }n = n.parent } return r ? `_o(${genElement(e, t)},${t.onceId++},${r})` : genElement(e, t) } return genStatic(e, t) } function genIf(e, t, r, n) { return e.ifProcessed = !0, (function genIfConditions(e, t, r, n) { if (!e.length) return n || '_e()'; const i = e.shift(); return i.exp ? `(${i.exp})?${genTernaryExp(i.block)}:${genIfConditions(e, t, r, n)}` : `${genTernaryExp(i.block)}`; function genTernaryExp(e) { return r ? r(e, t) : e.once ? genOnce(e, t) : genElement(e, t) } }(e.ifConditions.slice(), t, r, n)) } function genData$2(e, t) { let r = '{'; const n = (function genDirectives(e, t) { const r = e.directives; if (!r) return; let n; let i; let a; let o; let s = 'directives:['; let u = !1; for (n = 0, i = r.length; n < i; n++) { a = r[n], o = !0; const l = t.directives[a.name]; l && (o = !!l(e, a, t.warn)), o && (u = !0, s += `{name:"${a.name}",rawName:"${a.rawName}"${a.value ? `,value:(${a.value}),expression:${JSON.stringify(a.value)}` : ''}${a.arg ? `,arg:"${a.arg}"` : ''}${a.modifiers ? `,modifiers:${JSON.stringify(a.modifiers)}` : ''}},`) } if (u) return `${s.slice(0, -1)}]`; }(e, t)); n && (r += `${n},`), e.key && (r += `key:${e.key},`), e.ref && (r += `ref:${e.ref},`), e.refInFor && (r += 'refInFor:true,'), e.pre && (r += 'pre:true,'), e.component && (r += `tag:"${e.tag}",`); for (let i = 0; i < t.dataGenFns.length; i++)r += t.dataGenFns[i](e); if (e.attrs && (r += `attrs:{${genProps(e.attrs)}},`), e.props && (r += `domProps:{${genProps(e.props)}},`), e.events && (r += `${genHandlers(e.events, !1, t.warn)},`), e.nativeEvents && (r += `${genHandlers(e.nativeEvents, !0, t.warn)},`), e.slotTarget && !e.slotScope && (r += `slot:${e.slotTarget},`), e.scopedSlots && (r += `${(function genScopedSlots(e, t) { return `scopedSlots:_u([${Object.keys(e).map(r => genScopedSlot(r, e[r], t)).join(',')}])` }(e.scopedSlots, t))},`), e.model && (r += `model:{value:${e.model.value},callback:${e.model.callback},expression:${e.model.expression}},`), e.inlineTemplate) { const a = (function genInlineTemplate(e, t) { const r = e.children[0]; 0; if (r.type === 1) { const n = generate(r, t.options); return `inlineTemplate:{render:function(){${n.render}},staticRenderFns:[${n.staticRenderFns.map(e => `function(){${e}}`).join(',')}]}` } }(e, t)); a && (r += `${a},`) } return r = `${r.replace(/,$/, '')}}`, e.wrapData && (r = e.wrapData(r)), e.wrapListeners && (r = e.wrapListeners(r)), r } function genScopedSlot(e, t, r) { return t.for && !t.forProcessed ? (function genForScopedSlot(e, t, r) { const n = t.for; const i = t.alias; const a = t.iterator1 ? `,${t.iterator1}` : ''; const o = t.iterator2 ? `,${t.iterator2}` : ''; return t.forProcessed = !0, `_l((${n}),function(${i}${a}${o}){return ${genScopedSlot(e, t, r)}})` }(e, t, r)) : `{key:${e},fn:` + `function(${String(t.slotScope)}){return ${t.tag === 'template' ? t.if ? `${t.if}?${genChildren(t, r) || 'undefined'}:undefined` : genChildren(t, r) || 'undefined' : genElement(t, r)}}` + '}' } function genChildren(e, t, r, n, i) { const a = e.children; if (a.length) { const o = a[0]; if (a.length === 1 && o.for && o.tag !== 'template' && o.tag !== 'slot') return (n || genElement)(o, t); const s = r ? (function getNormalizationType(e, t) { for (var r = 0, n = 0; n < e.length; n++) { const i = e[n]; if (i.type === 1) { if (needsNormalization(i) || i.ifConditions && i.ifConditions.some(e => needsNormalization(e.block))) { r = 2; break }(t(i) || i.ifConditions && i.ifConditions.some(e => t(e.block))) && (r = 1) } } return r }(a, t.maybeComponent)) : 0; const u = i || genNode; return `[${a.map(e => u(e, t)).join(',')}]${s ? `,${s}` : ''}` } } function needsNormalization(e) { return void 0 !== e.for || e.tag === 'template' || e.tag === 'slot' } function genNode(e, t) { return e.type === 1 ? genElement(e, t) : e.type === 3 && e.isComment ? (function genComment(e) { return `_e(${JSON.stringify(e.text)})` }(e)) : (function genText(e) { return `_v(${e.type === 2 ? e.expression : transformSpecialNewlines(JSON.stringify(e.text))})` }(e)) } function genProps(e) { for (var t = '', r = 0; r < e.length; r++) { const n = e[r]; t += `"${n.name}":${transformSpecialNewlines(n.value)},` } return t.slice(0, -1) } function transformSpecialNewlines(e) { return e.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029') } new RegExp(`\\b${'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments'.split(',').join('\\b|\\b')}\\b`), new RegExp(`\\b${'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b')}\\s*\\([^\\)]*\\)`); function createFunction(e, t) { try { return new Function(e) } catch (r) { return t.push({ err: r, code: e }), noop } } let Br; const qr = (function createCompilerCreator(e) { return function createCompiler(t) { function compile(r, n) { const i = Object.create(t); const a = []; const o = []; if (i.warn = function (e, t) { (t ? o : a).push(e) }, n) for (const s in n.modules && (i.modules = (t.modules || []).concat(n.modules)), n.directives && (i.directives = extend(Object.create(t.directives || null), n.directives)), n)s !== 'modules' && s !== 'directives' && (i[s] = n[s]); const u = e(r, i); return u.errors = a, u.tips = o, u } return { compile, compileToFunctions: (function createCompileToFunctionFn(e) { const t = Object.create(null); return function compileToFunctions(r, n, i) { (n = extend({}, n)).warn, delete n.warn; const a = n.delimiters ? String(n.delimiters) + r : r; if (t[a]) return t[a]; const o = e(r, n); const s = {}; const u = []; return s.render = createFunction(o.render, u), s.staticRenderFns = o.staticRenderFns.map(e => createFunction(e, u)), t[a] = s } }(compile)) } } }((e, t) => { const r = parse(e.trim(), t); !1 !== t.optimize && optimize(r, t); const n = generate(r, t); return { ast: r, render: n.render, staticRenderFns: n.staticRenderFns } }))(Tr).compileToFunctions; function getShouldDecode(e) { return (Br = Br || document.createElement('div')).innerHTML = e ? '<a href="\n"/>' : '<div a="\n"/>', Br.innerHTML.indexOf('&#10;') > 0 } const Ur = !!C && getShouldDecode(!1); const zr = !!C && getShouldDecode(!0); const Vr = cached((e) => { const t = query(e); return t && t.innerHTML }); const Hr = Vue.prototype.$mount; Vue.prototype.$mount = function (e, t) {
      if ((e = e && query(e)) === document.body || e === document.documentElement) return this; const r = this.$options; if (!r.render) {
        let n = r.template; if (n) if (typeof n === 'string')n.charAt(0) === '#' && (n = Vr(n)); else { if (!n.nodeType) return this; n = n.innerHTML } else e && (n = (function getOuterHTML(e) { if (e.outerHTML) return e.outerHTML; const t = document.createElement('div'); return t.appendChild(e.cloneNode(!0)), t.innerHTML }(e))); if (n) {
          0; const i = qr(n, {
            shouldDecodeNewlines: Ur, shouldDecodeNewlinesForHref: zr, delimiters: r.delimiters, comments: r.comments,
          }, this); const a = i.render; const o = i.staticRenderFns; r.render = a, r.staticRenderFns = o;
        }
      } return Hr.call(this, e, t);
    }, Vue.compile = qr, t.default = Vue;
  }.call(t, r(14), r(154).setImmediate);
}, function (e, t, r) { const n = r(39); e.exports = function (e, t, r) { if (n(e), void 0 === t) return e; switch (r) { case 1: return function (r) { return e.call(t, r) }; case 2: return function (r, n) { return e.call(t, r, n) }; case 3: return function (r, n, i) { return e.call(t, r, n, i) }; } return function () { return e.apply(t, arguments) } } }, function (e, t, r) { e.exports = !r(33)(() => Object.defineProperty({}, 'a', { get() { return 7 } }).a != 7) }, function (e, t, r) { const n = r(306); const i = r(311); e.exports = function getNative(e, t) { const r = i(e, t); return n(r) ? r : void 0 } }, function (e, t, r) { const n = r(51); const i = r(307); const a = r(308); const o = '[object Null]'; const s = '[object Undefined]'; const u = n ? n.toStringTag : void 0; e.exports = function baseGetTag(e) { return e == null ? void 0 === e ? s : o : u && u in Object(e) ? i(e) : a(e) } }, function (e, t, r) { const n = r(19); const i = r(101); e.exports = r(25) ? function (e, t, r) { return n.f(e, t, i(1, r)) } : function (e, t, r) { return e[t] = r, e } }, function (e, t, r) { const n = r(20); e.exports = function (e) { if (!n(e)) throw TypeError(`${e} is not an object!`); return e } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; const a = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const o = _interopRequireDefault(r(21)); const s = _interopRequireDefault(r(69)); const u = _interopRequireDefault(r(46)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = (function () { function StyleRule(e, t, r) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, StyleRule)), this.type = 'style', this.isProcessed = !1; const n = r.sheet; const i = r.Renderer; const a = r.selector; this.key = e, this.options = r, this.style = t, a && (this.selectorText = a), this.renderer = n ? n.renderer : new i() } return a(StyleRule, [{ key: 'prop', value: function prop(e, t) { if (void 0 === t) return this.style[e]; if (this.style[e] === t) return this; const r = (t = this.options.jss.plugins.onChangeValue(t, e, this)) == null || !1 === t; const n = e in this.style; if (r && !n) return this; const i = r && n; if (i ? delete this.style[e] : this.style[e] = t, this.renderable) return i ? this.renderer.removeProperty(this.renderable, e) : this.renderer.setProperty(this.renderable, e, t), this; const a = this.options.sheet; return a && a.attached && (0, o.default)(!1, 'Rule is not linked. Missing sheet option "link: true".'), this } }, { key: 'applyTo', value: function applyTo(e) { const t = this.toJSON(); for (const r in t) this.renderer.setProperty(e, r, t[r]); return this } }, { key: 'toJSON', value: function toJSON() { const e = {}; for (const t in this.style) { const r = this.style[t]; (void 0 === r ? 'undefined' : i(r)) !== 'object' ? e[t] = r : Array.isArray(r) && (e[t] = (0, u.default)(r)) } return e } }, { key: 'toString', value: function toString(e) { const t = this.options.sheet; const r = !!t && t.options.link ? n({}, e, { allowEmpty: !0 }) : e; return (0, s.default)(this.selector, this.style, r) } }, { key: 'selector', set: function set(e) { if (e !== this.selectorText && (this.selectorText = e, this.renderable && !this.renderer.setSelector(this.renderable, e) && this.renderable)) { const t = this.renderer.replaceRule(this.renderable, this); t && (this.renderable = t) } }, get: function get() { return this.selectorText } }]), StyleRule }()); t.default = l;
}, function (e, t, r) { const n = r(74); const i = r(81); e.exports = function isArrayLike(e) { return e != null && i(e.length) && !n(e) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); t.DisplayModes = Object.freeze({
    all: 'all', section: 'section', component: 'component', example: 'example',
  });
}, function (e, t) { e.exports = function (e) { try { return !!e() } catch (e) { return !0 } } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = _interopRequireDefault(r(47)); const o = _interopRequireDefault(r(121)); const s = _interopRequireDefault(r(30)); const u = _interopRequireDefault(r(247)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = (function () {
    function RuleList(e) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, RuleList)), this.map = {}, this.raw = {}, this.index = [], this.options = e, this.classes = e.classes } return i(RuleList, [{
      key: 'add',
      value: function add(e, t, r) {
        const i = this.options; const o = i.parent; const l = i.sheet; const c = i.jss; const p = i.Renderer; const f = i.generateClassName; !(r = n({
          classes: this.classes, parent: o, sheet: l, jss: c, Renderer: p, generateClassName: f,
        }, r)).selector && this.classes[e] && (r.selector = `.${(0, u.default)(this.classes[e])}`), this.raw[e] = t; const d = (0, a.default)(e, t, r); let h = void 0; !r.selector && d instanceof s.default && (h = f(d, l), d.selector = `.${(0, u.default)(h)}`), this.register(d, h); const m = void 0 === r.index ? this.index.length : r.index; return this.index.splice(m, 0, d), d;
      },
    }, { key: 'get', value: function get(e) { return this.map[e] } }, { key: 'remove', value: function remove(e) { this.unregister(e), this.index.splice(this.indexOf(e), 1) } }, { key: 'indexOf', value: function indexOf(e) { return this.index.indexOf(e) } }, { key: 'process', value: function process() { const e = this.options.jss.plugins; this.index.slice(0).forEach(e.onProcessRule, e) } }, { key: 'register', value: function register(e, t) { this.map[e.key] = e, e instanceof s.default && (this.map[e.selector] = e, t && (this.classes[e.key] = t)) } }, { key: 'unregister', value: function unregister(e) { delete this.map[e.key], e instanceof s.default && (delete this.map[e.selector], delete this.classes[e.key]) } }, { key: 'update', value: function update(e, t) { const r = this.options; const n = r.jss.plugins; const i = r.sheet; if (typeof e !== 'string') for (let a = 0; a < this.index.length; a++)n.onUpdate(e, this.index[a], i); else n.onUpdate(t, this.get(e), i); } }, { key: 'link', value: function link(e) { for (let t = this.options.sheet.renderer.getUnescapedKeysMap(this.index), r = 0; r < e.length; r++) { const n = e[r]; let i = this.options.sheet.renderer.getKey(n); t[i] && (i = t[i]); const a = this.map[i]; a && (0, o.default)(a, n) } } }, { key: 'toString', value: function toString(e) { for (var t = '', r = this.options.sheet, n = !!r && r.options.link, i = 0; i < this.index.length; i++) { const a = this.index[i].toString(e); (a || n) && (t && (t += '\n'), t += a) } return t } }]), RuleList;
  }()); t.default = l;
}, function (e, t) { e.exports = function eq(e, t) { return e === t || e != e && t != t } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(382); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(395); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = r(55); const i = 1 / 0; e.exports = function toKey(e) { if (typeof e === 'string' || n(e)) return e; const t = `${e}`; return t == '0' && 1 / e == -i ? '-0' : t } }, function (e, t) { e.exports = function (e) { if (typeof e !== 'function') throw TypeError(`${e} is not a function!`); return e } }, function (e, t) { const r = {}.hasOwnProperty; e.exports = function (e, t) { return r.call(e, t) } }, function (e, t) { e.exports = {} }, function (e, t) { const r = {}.toString; e.exports = function (e) { return r.call(e).slice(8, -1) } }, function (e, t, r) { const n = r(109); e.exports = function (e) { return Object(n(e)) } }, function (e, t, r) { const n = r(24); const i = r(208); const a = r(209); const o = r(29); const s = r(64); const u = r(210); const l = {}; const c = {}; (t = e.exports = function (e, t, r, p, f) { let d; let h; let m; let g; const v = f ? function () { return e } : u(e); const y = n(r, p, t ? 2 : 1); let b = 0; if (typeof v !== 'function') throw TypeError(`${e} is not iterable!`); if (a(v)) { for (d = s(e.length); d > b; b++) if ((g = t ? y(o(h = e[b])[0], h[1]) : y(e[b])) === l || g === c) return g; } else for (m = v.call(e); !(h = m.next()).done;) if ((g = i(m, y, h.value, t)) === l || g === c) return g; }).BREAK = l, t.RETURN = c }, function (e, t) { let r; let n; const i = e.exports = {}; function defaultSetTimout() { throw new Error('setTimeout has not been defined') } function defaultClearTimeout() { throw new Error('clearTimeout has not been defined') } function runTimeout(e) { if (r === setTimeout) return setTimeout(e, 0); if ((r === defaultSetTimout || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0); try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } }!(function () { try { r = typeof setTimeout === 'function' ? setTimeout : defaultSetTimout } catch (e) { r = defaultSetTimout } try { n = typeof clearTimeout === 'function' ? clearTimeout : defaultClearTimeout } catch (e) { n = defaultClearTimeout } }()); let a; let o = []; let s = !1; let u = -1; function cleanUpNextTick() { s && a && (s = !1, a.length ? o = a.concat(o) : u = -1, o.length && drainQueue()) } function drainQueue() { if (!s) { const e = runTimeout(cleanUpNextTick); s = !0; for (let t = o.length; t;) { for (a = o, o = []; ++u < t;)a && a[u].run(); u = -1, t = o.length }a = null, s = !1, (function runClearTimeout(e) { if (n === clearTimeout) return clearTimeout(e); if ((n === defaultClearTimeout || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { return n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } }(e)) } } function Item(e, t) { this.fun = e, this.array = t } function noop() {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) for (let r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; o.push(new Item(e, t)), o.length !== 1 || s || runTimeout(drainQueue) }, Item.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = noop, i.addListener = noop, i.once = noop, i.off = noop, i.removeListener = noop, i.removeAllListeners = noop, i.emit = noop, i.prependListener = noop, i.prependOnceListener = noop, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function toCssValue(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!Array.isArray(e)) return e; let r = ''; if (Array.isArray(e[0])) for (let i = 0; i < e.length && e[i] !== '!important'; i++)r && (r += ', '), r += n(e[i], ' '); else r = n(e, ', '); t || e[e.length - 1] !== '!important' || (r += ' !important'); return r }; var n = function join(e, t) { for (var r = '', n = 0; n < e.length && e[n] !== '!important'; n++)r && (r += t), r += e[n]; return r };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function createRule() {
    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'unnamed';


    const t = arguments[1];


    const r = arguments[2]; const o = r.jss;


    const s = (0, a.default)(t);


    const u = o.plugins.onCreateRule(e, s, r); if (u) return u; e[0] === '@' && (0, n.default)(!1, '[JSS] Unknown at-rule %s', e); return new i.default(e, s, r);
  }; var n = _interopRequireDefault(r(21)); var i = _interopRequireDefault(r(30)); var a = _interopRequireDefault(r(243)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }
}, function (e, t, r) {
  function makeEmptyFunction(e) { return function () { return e } } const n = function emptyFunction() {}; n.thatReturns = makeEmptyFunction, n.thatReturnsFalse = makeEmptyFunction(!1), n.thatReturnsTrue = makeEmptyFunction(!0), n.thatReturnsNull = makeEmptyFunction(null), n.thatReturnsThis = function () { return this }, n.thatReturnsArgument = function (e) { return e }, e.exports = n;
}, function (e, t, r) { const n = r(296); const i = r(297); const a = r(298); const o = r(299); const s = r(300); function ListCache(e) { let t = -1; const r = e == null ? 0 : e.length; for (this.clear(); ++t < r;) { const n = e[t]; this.set(n[0], n[1]) } }ListCache.prototype.clear = n, ListCache.prototype.delete = i, ListCache.prototype.get = a, ListCache.prototype.has = o, ListCache.prototype.set = s, e.exports = ListCache }, function (e, t, r) { const n = r(35); e.exports = function assocIndexOf(e, t) { for (let r = e.length; r--;) if (n(e[r][0], t)) return r; return -1 } }, function (e, t, r) { const n = r(10).Symbol; e.exports = n }, function (e, t, r) { const n = r(26)(Object, 'create'); e.exports = n }, function (e, t, r) { const n = r(320); e.exports = function getMapData(e, t) { const r = e.__data__; return n(t) ? r[typeof t === 'string' ? 'string' : 'hash'] : r.map } }, function (e, t) { const r = 9007199254740991; const n = /^(?:0|[1-9]\d*)$/; e.exports = function isIndex(e, t) { const i = typeof e; return !!(t = t == null ? r : t) && (i == 'number' || i != 'symbol' && n.test(e)) && e > -1 && e % 1 == 0 && e < t } }, function (e, t, r) { const n = r(27); const i = r(22); const a = '[object Symbol]'; e.exports = function isSymbol(e) { return typeof e === 'symbol' || i(e) && n(e) == a } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(372); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(397); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = r(17); const i = r(95); const a = r(422); const o = r(424); e.exports = function castPath(e, t) { return n(e) ? e : i(e, t) ? [e] : a(o(e)) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(436); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.unquote = function unquote(e) { return e.replace(/^['"]|['"]$/g, '') }, t.getType = function getType(e) { return e.flowType || e.type }, t.showSpaces = function showSpaces(e) { return e.replace(/^\s|\s$/g, '') }, t.getUrlNavigation = function getUrlNavigation(e, t) {
    const r = t.level; const i = t.sections; const a = t.components; const o = t.nameParent; const s = t.name; const u = t.slug; const l = t.anchor; const c = t.isolated; if (e) return r < 2 && (i || a) ? (0, n.default)({ name: s, isolated: !0 }) : (0, n.default)({ name: o, id: u, isolated: !0 }); return (0, n.default)({
      name: s, slug: u, anchor: l, isolated: c,
    });
  }, t.replaceAll = function replaceAll(e, t, r) { return e.split(t).join(r) }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(96)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(162); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(569); const s = r(3); const u = function injectStyle(e) { r(561) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-5d20253a', null); t.default = l.exports;
}, function (e, t, r) { const n = r(672); const i = r(204); e.exports = Object.keys || function keys(e) { return n(e, i) } }, function (e, t, r) { const n = r(111); const i = r(109); e.exports = function (e) { return n(i(e)) } }, function (e, t, r) { const n = r(108); const i = Math.min; e.exports = function (e) { return e > 0 ? i(n(e), 9007199254740991) : 0 } }, function (e, t, r) { const n = r(19).f; const i = r(40); const a = r(13)('toStringTag'); e.exports = function (e, t, r) { e && !i(e = r ? e : e.prototype, a) && n(e, a, { configurable: !0, value: t }) } }, function (e, t, r) {
  (function (e) {
    Object.defineProperty(t, '__esModule', { value: !0 }); let n; const i = _interopRequireDefault(r(8)); const a = _interopRequireDefault(r(9)); const o = _interopRequireDefault(r(729)); const s = (n = (0, a.default)(i.default.mark(function _callee(e) { let t; let r; let n; let a; let s; return i.default.wrap((i) => { for (;;) switch (i.prev = i.next) { case 0: return t = { method: e.method || 'GET', headers: {} }, (r = !(t.method === 'GET' || t.method === 'HEAD')) && (t.headers['content-type'] = 'application/x-www-form-urlencoded', t.body = (c = e.data, (0, o.default)(c).map(e => `${e[0]}=${encodeURIComponent(e[1])}`).join('&'))), n = !r && e.data ? `${p}${e.url}${l.default.stringify(e.data, { addQueryPrefix: !0 })}` : `${p}${e.url}`, i.prev = 4, i.next = 7, (0, u.default)(n, t); case 7: return a = i.sent, i.next = 10, a.json(); case 10: return s = i.sent, i.abrupt('return', s); case 14: throw i.prev = 14, i.t0 = i.catch(4), i.t0; case 17: case 'end': return i.stop(); } let c }, _callee, this, [[4, 14]]) })), function callApi(e) { return n.apply(this, arguments) }); var u = _interopRequireDefault(r(733)); var l = _interopRequireDefault(r(735)); const c = _interopRequireDefault(r(738)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } var p = e.client ? c.default.browser : c.default.server; const f = {
      getOneRandomLoop: s({ url: 'rand/loop', data: { full: !0, limit: 1 } }),
      getRandomLoopList: function getRandomLoopList(e) { return s({ url: 'rand/loop', data: { full: !0, limit: e } }) },
      getLoopByID: function getLoopByID(e) { return s({ url: 'loop', data: { id: e } }) },
      getLoopsByEpisodeID: function getLoopsByEpisodeID(e) { return s({ url: 'loop', data: { episodeid: e } }) },
      getEpisodeByID: function getEpisodeByID(e) { return s({ url: 'episode', data: { id: e } }) },
      getEpisodesBySeriesID: function getEpisodesBySeriesID(e) { return s({ url: 'episode', data: { seriesid: e } }) },
      getTagsByID: function getTagsByID(e) { return s({ url: 'tag', data: { loopid: e } }) },
      getSeriesByID: function getSeriesByID(e) { return s({ url: 'series', data: { id: e } }) },
      getSeriesByString: function getSeriesByString(e) { return s({ url: 'search/series', data: { value: e } }) },
      getAllSeasons: s({ url: 'series/season' }),
      getSeriesGroup: function getSeriesGroup() {
        const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.type; const r = e.season; const n = e.page; const i = e.limit; return s({
          url: 'series',
          data: {
            type: t, season: r, page: n, limit: i,
          },
        });
      },
      getSeriesCount: function getSeriesCount() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.type; const r = e.season; return s({ url: 'series/count', data: { season: r, type: t } }) },
    }; t.default = f;
  }).call(t, r(45));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(221))); const i = { arr: function arr(e) { return Array.isArray(e) !== 'undefined' && e.length }, obj: function obj(e) { return e.constructor === Object && (0, n.default)(e).length !== 0 } }; t.default = i;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = r(118); const a = _interopRequireDefault(r(262)); const o = _interopRequireDefault(r(263)); const s = _interopRequireDefault(r(266)); const u = _interopRequireDefault(r(267)); const l = _interopRequireDefault(r(269)); const c = _interopRequireDefault(r(271)); const p = _interopRequireDefault(r(272)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const f = (0, i.create)({
    createGenerateClassName: function createGenerateClassName() { let e = 0; return function (t) { return `rsg--${t.key}-${e++}` } },
    plugins: [(0, a.default)(), (0, o.default)({
      reset: n({}, p.default, {
        boxSizing: 'border-box', color: 'inherit', fontFamily: 'inherit', lineHeight: 'inherit', fontSize: 'inherit',
      }),
    }), (0, s.default)(), (0, u.default)(), (0, l.default)(), (0, c.default)()],
  }); t.default = f;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function toCss(e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; let i = ''; if (!t) return i; const a = r.indent; let o = void 0 === a ? 0 : a; const s = t.fallbacks; if (o++, s) if (Array.isArray(s)) for (let u = 0; u < s.length; u++) { const l = s[u]; for (const c in l) { const p = l[c]; p != null && (i += `\n${indentStr(`${c}: ${(0, n.default)(p)};`, o)}`) } } else for (const f in s) { const d = s[f]; d != null && (i += `\n${indentStr(`${f}: ${(0, n.default)(d)};`, o)}`) } for (const h in t) { const m = t[h]; m != null && h !== 'fallbacks' && (i += `\n${indentStr(`${h}: ${(0, n.default)(m)};`, o)}`) } return i || r.allowEmpty ? i = indentStr(`${e} {${i}\n`, --o) + indentStr('}', o) : i }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(46))); function indentStr(e, t) { for (var r = '', n = 0; n < t; n++)r += '  '; return r + e }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(119))); t.default = new n.default();
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.DOCS_TAB_USAGE = t.EXAMPLE_TAB_CODE_EDITOR = void 0; const n = _interopRequireDefault(r(286)); const i = _interopRequireDefault(r(357)); const a = _interopRequireDefault(r(449)); const o = _interopRequireDefault(r(453)); const s = _interopRequireDefault(r(455)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const u = t.EXAMPLE_TAB_CODE_EDITOR = 'rsg-code-editor'; const l = t.DOCS_TAB_USAGE = 'rsg-usage'; t.default = function (e) {
    const t = e.navigation ? [] : [a.default]; return {
      sectionToolbar: t, componentToolbar: t, exampleToolbar: t, exampleTabButtons: [{ id: u, render: o.default }], exampleTabs: [{ id: u, render: n.default }], docsTabButtons: [{ id: l, render: s.default }], docsTabs: [{ id: l, render: i.default }],
    };
  };
}, function (e, t, r) { const n = r(49); const i = r(301); const a = r(302); const o = r(303); const s = r(304); const u = r(305); function Stack(e) { const t = this.__data__ = new n(e); this.size = t.size }Stack.prototype.clear = i, Stack.prototype.delete = a, Stack.prototype.get = o, Stack.prototype.has = s, Stack.prototype.set = u, e.exports = Stack }, function (e, t, r) { const n = r(26)(r(10), 'Map'); e.exports = n }, function (e, t, r) { const n = r(27); const i = r(15); const a = '[object AsyncFunction]'; const o = '[object Function]'; const s = '[object GeneratorFunction]'; const u = '[object Proxy]'; e.exports = function isFunction(e) { if (!i(e)) return !1; const t = n(e); return t == o || t == s || t == a || t == u } }, function (e, t, r) { const n = r(312); const i = r(319); const a = r(321); const o = r(322); const s = r(323); function MapCache(e) { let t = -1; const r = e == null ? 0 : e.length; for (this.clear(); ++t < r;) { const n = e[t]; this.set(n[0], n[1]) } }MapCache.prototype.clear = n, MapCache.prototype.delete = i, MapCache.prototype.get = a, MapCache.prototype.has = o, MapCache.prototype.set = s, e.exports = MapCache }, function (e, t, r) {
  const n = r(129); e.exports = function baseAssignValue(e, t, r) {
    t == '__proto__' && n ? n(e, t, {
      configurable: !0, enumerable: !0, value: r, writable: !0,
    }) : e[t] = r;
  };
}, function (e, t) { e.exports = function (e) { return e.webpackPolyfill || (e.deprecate = function () {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, 'loaded', { enumerable: !0, get() { return e.l } }), Object.defineProperty(e, 'id', { enumerable: !0, get() { return e.i } }), e.webpackPolyfill = 1), e } }, function (e, t, r) { const n = r(132)(Object.getPrototypeOf, Object); e.exports = n }, function (e, t) { const r = Object.prototype; e.exports = function isPrototype(e) { const t = e && e.constructor; return e === (typeof t === 'function' && t.prototype || r) } }, function (e, t, r) { const n = r(332); const i = r(22); const a = Object.prototype; const o = a.hasOwnProperty; const s = a.propertyIsEnumerable; const u = n(function () { return arguments }()) ? n : function (e) { return i(e) && o.call(e, 'callee') && !s.call(e, 'callee') }; e.exports = u }, function (e, t) { const r = 9007199254740991; e.exports = function isLength(e) { return typeof e === 'number' && e > -1 && e % 1 == 0 && e <= r } }, function (e, t, r) { (function (e) { const n = r(10); const i = r(334); const a = typeof t === 'object' && t && !t.nodeType && t; const o = a && typeof e === 'object' && e && !e.nodeType && e; const s = o && o.exports === a ? n.Buffer : void 0; const u = (s ? s.isBuffer : void 0) || i; e.exports = u }).call(t, r(77)(e)) }, function (e, t, r) { const n = r(336); const i = r(337); const a = r(338); const o = a && a.isTypedArray; const s = o ? i(o) : n; e.exports = s }, function (e, t, r) { const n = r(135); const i = r(342); const a = r(31); e.exports = function keysIn(e) { return a(e) ? n(e, !0) : i(e) } }, function (e, t) { e.exports = function identity(e) { return e } }, function (e, t, r) {
  const n = r(0); const i = r(1); function Group(e) { let t = e.children ? (function castArray(e) { return Array.isArray(e) ? e : [e] }(e.children)) : []; let r = t = t.filter(e => !!e); let i = e.separator; const a = n.isValidElement(i); return t.length > 1 && (r = [t.shift()], t.forEach((e, t) => { if (a) { const o = `separator-${e.key || t}`; i = n.cloneElement(i, { key: o }) } return r.push(i, e) })), n.createElement(e.inline ? 'span' : 'div', { className: e.className }, r) }Group.propTypes = {
    children: i.node, inline: i.bool, separator: i.node, className: i.string,
  }, Group.defaultProps = { separator: ' ' }, e.exports = Group;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(365); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(366); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(375); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(396); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = r(92); const i = r(140); const a = r(432); const o = r(17); e.exports = function map(e, t) { return (o(e) ? n : a)(e, i(t, 3)) } }, function (e, t) { e.exports = function arrayMap(e, t) { for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n;)i[r] = t(e[r], r, e); return i } }, function (e, t, r) { const n = r(135); const i = r(412); const a = r(31); e.exports = function keys(e) { return a(e) ? n(e) : i(e) } }, function (e, t, r) { const n = r(58); const i = r(38); e.exports = function baseGet(e, t) { for (var r = 0, a = (t = n(t, e)).length; e != null && r < a;)e = e[i(t[r++])]; return r && r == a ? e : void 0 } }, function (e, t, r) { const n = r(17); const i = r(55); const a = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/; const o = /^\w*$/; e.exports = function isKey(e, t) { if (n(e)) return !1; const r = typeof e; return !(r != 'number' && r != 'symbol' && r != 'boolean' && e != null && !i(e)) || o.test(e) || !a.test(e) || t != null && e in Object(t) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getUrl() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.name; const r = e.slug; const n = e.example; const i = e.anchor; const a = e.isolated; const o = e.nochrome; const s = e.absolute; const u = e.id; const l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : window.location; const c = l.origin; let p = l.pathname; o && (p += '?nochrome'); i ? p += `#${r}` : (a || o) && (p += `#!/${t}`); u && (p += `?id=${u}`); void 0 !== n && (p += `/${n}`); if (s) return c + p; return p };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = function IconBase(e, t) {
    const r = e.children; const a = e.color; const o = e.size; const s = e.style; const u = e.width; const l = e.height; const c = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['children', 'color', 'size', 'style', 'width', 'height'])); const p = t.reactIconBase; const f = void 0 === p ? {} : p; const d = o || f.size || '1em'; return i.default.createElement('svg', n({
      children: r, fill: 'currentColor', preserveAspectRatio: 'xMidYMid meet', height: l || d, width: u || d,
    }, f, c, { style: n({ verticalAlign: 'middle', color: a || f.color }, f.style || {}, s) }));
  }; o.propTypes = {
    color: a.default.string, size: a.default.oneOfType([a.default.string, a.default.number]), width: a.default.oneOfType([a.default.string, a.default.number]), height: a.default.oneOfType([a.default.string, a.default.number]), style: a.default.object,
  }, o.contextTypes = { reactIconBase: a.default.shape(o.propTypes) }, t.default = o, e.exports = t.default;
}, function (e, t, r) {
  const n = r(491); function assign(e, t) { for (const r in t)hasOwn(t, r) && (e[r] = t[r]); } function hasOwn(e, t) { return Object.prototype.hasOwnProperty.call(e, t) }e.exports = function extend(e) { n(e) || (e = {}); for (let t = arguments.length, r = 1; r < t; r++) { const i = arguments[r]; n(i) && assign(e, i) } return e };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(509); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = r(20); const i = r(12).document; const a = n(i) && n(i.createElement); e.exports = function (e) { return a ? i.createElement(e) : {} } }, function (e, t) {
  e.exports = function (e, t) {
    return {
      enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t,
    };
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(165); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(580); const s = r(3); const u = function injectStyle(e) { r(575) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-100c0cfe', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(172); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(593); const s = r(3); const u = function injectStyle(e) { r(591) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-71f0e36b', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(190); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(635); const s = r(3); const u = function injectStyle(e) { r(633) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-35f739b0', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(191); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(639); const s = r(3); const u = function injectStyle(e) { r(637) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-d0d485ea', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(192); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(646); const s = r(3); const u = function injectStyle(e) { r(641) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-1eb4bb55', null); t.default = l.exports;
}, function (e, t, r) {
  const n = r(668)(!0); r(110)(String, 'String', function (e) { this._t = String(e), this._i = 0 }, function () { let e; const t = this._t; const r = this._i; return r >= t.length ? { value: void 0, done: !0 } : (e = n(t, r), this._i += e.length, { value: e, done: !1 }) });
}, function (e, t) { const r = Math.ceil; const n = Math.floor; e.exports = function (e) { return isNaN(e = +e) ? 0 : (e > 0 ? n : r)(e) } }, function (e, t) { e.exports = function (e) { if (void 0 == e) throw TypeError(`Can't call method on  ${e}`); return e } }, function (e, t, r) {
  const n = r(201); const i = r(6); const a = r(669); const o = r(28); const s = r(40); const u = r(41); const l = r(670); const c = r(65); const p = r(675); const f = r(13)('iterator'); const d = !([].keys && 'next' in [].keys()); const h = function () { return this }; e.exports = function (e, t, r, m, g, v, y) { l(r, t, m); let b; let x; let D; const _ = function (e) { if (!d && e in S) return S[e]; switch (e) { case 'keys': return function keys() { return new r(this, e) }; case 'values': return function values() { return new r(this, e) }; } return function entries() { return new r(this, e) } }; const C = `${t} Iterator`; const w = g == 'values'; let E = !1; var S = e.prototype; const k = S[f] || S['@@iterator'] || g && S[g]; let A = !d && k || _(g); const T = g ? w ? _('entries') : A : void 0; const P = t == 'Array' && S.entries || k; if (P && (D = p(P.call(new e()))) !== Object.prototype && D.next && (c(D, C, !0), n || s(D, f) || o(D, f, h)), w && k && k.name !== 'values' && (E = !0, A = function values() { return k.call(this) }), n && !y || !d && !E && S[f] || o(S, f, A), u[t] = A, u[C] = h, g) if (b = { values: w ? A : _('values'), keys: v ? A : _('keys'), entries: T }, y) for (x in b)x in S || a(S, x, b[x]); else i(i.P + i.F * (d || E), t, b); return b };
}, function (e, t, r) { const n = r(42); e.exports = Object('z').propertyIsEnumerable(0) ? Object : function (e) { return n(e) == 'String' ? e.split('') : Object(e) } }, function (e, t, r) { const n = r(203)('keys'); const i = r(113); e.exports = function (e) { return n[e] || (n[e] = i(e)) } }, function (e, t) { let r = 0; const n = Math.random(); e.exports = function (e) { return 'Symbol('.concat(void 0 === e ? '' : e, ')_', (++r + n).toString(36)) } }, function (e, t, r) { const n = r(42); const i = r(13)('toStringTag'); const a = n(function () { return arguments }()) == 'Arguments'; e.exports = function (e) { let t; let r; let o; return void 0 === e ? 'Undefined' : e === null ? 'Null' : typeof (r = (function (e, t) { try { return e[t] } catch (e) {} }(t = Object(e), i))) === 'string' ? r : a ? n(t) : (o = n(t)) == 'Object' && typeof t.callee === 'function' ? 'Arguments' : o } }, function (e, t) { e.exports = function (e, t, r, n) { if (!(e instanceof t) || void 0 !== n && n in e) throw TypeError(`${r}: incorrect invocation!`); return e } }, function (e, t, r) {
  const n = r(39); e.exports.f = function (e) { return new function PromiseCapability(e) { let t; let r; this.promise = new e(((e, n) => { if (void 0 !== t || void 0 !== r) throw TypeError('Bad Promise constructor'); t = e, r = n })), this.resolve = n(t), this.reject = n(r) }(e) };
}, function (e, t, r) { const n = r(28); e.exports = function (e, t, r) { for (const i in t)r && e[i] ? e[i] = t[i] : n(e, i, t[i]); return e } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.create = t.createGenerateClassName = t.sheets = t.RuleList = t.SheetsManager = t.SheetsRegistry = t.toCssValue = t.getDynamicStyles = void 0; const n = r(241); Object.defineProperty(t, 'getDynamicStyles', { enumerable: !0, get: function get() { return _interopRequireDefault(n).default } }); const i = r(46); Object.defineProperty(t, 'toCssValue', { enumerable: !0, get: function get() { return _interopRequireDefault(i).default } }); const a = r(119); Object.defineProperty(t, 'SheetsRegistry', { enumerable: !0, get: function get() { return _interopRequireDefault(a).default } }); const o = r(242); Object.defineProperty(t, 'SheetsManager', { enumerable: !0, get: function get() { return _interopRequireDefault(o).default } }); const s = r(34); Object.defineProperty(t, 'RuleList', { enumerable: !0, get: function get() { return _interopRequireDefault(s).default } }); const u = r(70); Object.defineProperty(t, 'sheets', { enumerable: !0, get: function get() { return _interopRequireDefault(u).default } }); const l = r(122); Object.defineProperty(t, 'createGenerateClassName', { enumerable: !0, get: function get() { return _interopRequireDefault(l).default } }); const c = _interopRequireDefault(r(249)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const p = t.create = function create(e) { return new c.default(e) }; t.default = p();
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function () { function SheetsRegistry() { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, SheetsRegistry)), this.registry = [] } return n(SheetsRegistry, [{ key: 'add', value: function add(e) { const t = this.registry; const r = e.options.index; if (t.indexOf(e) === -1) if (t.length === 0 || r >= this.index)t.push(e); else for (let n = 0; n < t.length; n++) if (t[n].options.index > r) return void t.splice(n, 0, e); } }, { key: 'reset', value: function reset() { this.registry = [] } }, { key: 'remove', value: function remove(e) { const t = this.registry.indexOf(e); this.registry.splice(t, 1) } }, { key: 'toString', value: function toString(e) { return this.registry.filter(e => e.attached).map(t => t.toString(e)).join('\n') } }, { key: 'index', get: function get() { return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index } }]), SheetsRegistry }()); t.default = i;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(244))); t.default = function (e) { return e && e[n.default] && e === e[n.default]() };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function linkRule(e, t) { e.renderable = t, e.rules && t.cssRules && e.rules.link(t.cssRules) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(21)); const i = (_interopRequireDefault(r(123)), _interopRequireDefault(r(248))); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = function () { let e = 0; return function (t, r) { (e += 1) > 1e10 && (0, n.default)(!1, '[JSS] You might have a memory leak. Rule counter is at %s.', e); let a = 'c'; let o = ''; return r && (a = r.options.classNamePrefix || 'c', r.options.jss.id != null && (o += r.options.jss.id)), `${a}${i.default}${o}${e}` } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = _interopRequireDefault(r(121)); const o = _interopRequireDefault(r(34)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = (function () { function StyleSheet(e, t) { for (const r in (function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, StyleSheet)), this.attached = !1, this.deployed = !1, this.linked = !1, this.classes = {}, this.options = n({}, t, { sheet: this, parent: this, classes: this.classes }), this.renderer = new t.Renderer(this), this.rules = new o.default(this.options), e) this.rules.add(r, e[r]); this.rules.process() } return i(StyleSheet, [{ key: 'attach', value: function attach() { return this.attached ? this : (this.deployed || this.deploy(), this.renderer.attach(), !this.linked && this.options.link && this.link(), this.attached = !0, this) } }, { key: 'detach', value: function detach() { return this.attached ? (this.renderer.detach(), this.attached = !1, this) : this } }, { key: 'addRule', value: function addRule(e, t, r) { const n = this.queue; this.attached && !n && (this.queue = []); const i = this.rules.add(e, t, r); return this.options.jss.plugins.onProcessRule(i), this.attached ? this.deployed ? (n ? n.push(i) : (this.insertRule(i), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0)), i) : i : (this.deployed = !1, i) } }, { key: 'insertRule', value: function insertRule(e) { const t = this.renderer.insertRule(e); t && this.options.link && (0, a.default)(e, t) } }, { key: 'addRules', value: function addRules(e, t) { const r = []; for (const n in e)r.push(this.addRule(n, e[n], t)); return r } }, { key: 'getRule', value: function getRule(e) { return this.rules.get(e) } }, { key: 'deleteRule', value: function deleteRule(e) { const t = this.rules.get(e); return !!t && (this.rules.remove(t), !this.attached || !t.renderable || this.renderer.deleteRule(t.renderable)) } }, { key: 'indexOf', value: function indexOf(e) { return this.rules.indexOf(e) } }, { key: 'deploy', value: function deploy() { return this.renderer.deploy(), this.deployed = !0, this } }, { key: 'link', value: function link() { const e = this.renderer.getRules(); return e && this.rules.link(e), this.linked = !0, this } }, { key: 'update', value: function update(e, t) { return this.rules.update(e, t), this } }, { key: 'toString', value: function toString(e) { return this.rules.toString(e) } }]), StyleSheet }()); t.default = s;
}, function (e, t, r) {
  /*
object-assign
(c) Sindre Sorhus
@license MIT
*/const n = Object.getOwnPropertySymbols; const i = Object.prototype.hasOwnProperty; const a = Object.prototype.propertyIsEnumerable; e.exports = (function shouldUseNative() { try { if (!Object.assign) return !1; const e = new String('abc'); if (e[5] = 'de', Object.getOwnPropertyNames(e)[0] === '5') return !1; for (var t = {}, r = 0; r < 10; r++)t[`_${String.fromCharCode(r)}`] = r; if (Object.getOwnPropertyNames(t).map(e => t[e]).join('') !== '0123456789') return !1; const n = {}; return 'abcdefghijklmnopqrst'.split('').forEach((e) => { n[e] = e }), Object.keys(Object.assign({}, n)).join('') === 'abcdefghijklmnopqrst' } catch (e) { return !1 } }()) ? Object.assign : function (e, t) { for (var r, o, s = (function toObject(e) { if (e === null || void 0 === e) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(e) }(e)), u = 1; u < arguments.length; u++) { for (const l in r = Object(arguments[u]))i.call(r, l) && (s[l] = r[l]); if (n) { o = n(r); for (let c = 0; c < o.length; c++)a.call(r, o[c]) && (s[o[c]] = r[o[c]]); } } return s };
}, function (e, t, r) {
  const n = {}; e.exports = n;
}, function (e, t, r) { (function (t) { const r = typeof t === 'object' && t && t.Object === Object && t; e.exports = r }).call(t, r(14)) }, function (e, t) { const r = Function.prototype.toString; e.exports = function toSource(e) { if (e != null) { try { return r.call(e) } catch (e) {} try { return `${e}` } catch (e) {} } return '' } }, function (e, t, r) { const n = r(76); const i = r(35); e.exports = function assignMergeValue(e, t, r) { (void 0 === r || i(e[t], r)) && (void 0 !== r || t in e) || n(e, t, r) } }, function (e, t, r) { const n = r(26); const i = (function () { try { const e = n(Object, 'defineProperty'); return e({}, '', {}), e } catch (e) {} }()); e.exports = i }, function (e, t, r) { const n = r(324)(); e.exports = n }, function (e, t, r) { const n = r(10).Uint8Array; e.exports = n }, function (e, t) { e.exports = function overArg(e, t) { return function (r) { return e(t(r)) } } }, function (e, t) { e.exports = function safeGet(e, t) { return t == '__proto__' ? void 0 : e[t] } }, function (e, t, r) { const n = r(76); const i = r(35); const a = Object.prototype.hasOwnProperty; e.exports = function assignValue(e, t, r) { const o = e[t]; a.call(e, t) && i(o, r) && (void 0 !== r || t in e) || n(e, t, r) } }, function (e, t, r) { const n = r(341); const i = r(80); const a = r(17); const o = r(82); const s = r(54); const u = r(83); const l = Object.prototype.hasOwnProperty; e.exports = function arrayLikeKeys(e, t) { const r = a(e); const c = !r && i(e); const p = !r && !c && o(e); const f = !r && !c && !p && u(e); const d = r || c || p || f; const h = d ? n(e.length, String) : []; const m = h.length; for (const g in e)!t && !l.call(e, g) || d && (g == 'length' || p && (g == 'offset' || g == 'parent') || f && (g == 'buffer' || g == 'byteLength' || g == 'byteOffset') || s(g, m)) || h.push(g); return h } }, function (e, t, r) { const n = r(75); const i = 'Expected a function'; function memoize(e, t) { if (typeof e !== 'function' || t != null && typeof t !== 'function') throw new TypeError(i); var r = function () { const n = arguments; const i = t ? t.apply(this, n) : n[0]; const a = r.cache; if (a.has(i)) return a.get(i); const o = e.apply(this, n); return r.cache = a.set(i, o) || a, o }; return r.cache = new (memoize.Cache || n)(), r }memoize.Cache = n, e.exports = memoize }, function (e, t, r) {
  (function (e) {
    /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
    const n = r(362); const i = r(363); const a = r(364); function kMaxLength() { return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function createBuffer(e, t) { if (kMaxLength() < t) throw new RangeError('Invalid typed array length'); return Buffer.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = Buffer.prototype : (e === null && (e = new Buffer(t)), e.length = t), e } function Buffer(e, t, r) { if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer)) return new Buffer(e, t, r); if (typeof e === 'number') { if (typeof t === 'string') throw new Error('If encoding is specified then the first argument must be a string'); return allocUnsafe(this, e) } return from(this, e, t, r) } function from(e, t, r, n) { if (typeof t === 'number') throw new TypeError('"value" argument must not be a number'); return typeof ArrayBuffer !== 'undefined' && t instanceof ArrayBuffer ? (function fromArrayBuffer(e, t, r, n) { if (t.byteLength, r < 0 || t.byteLength < r) throw new RangeError("'offset' is out of bounds"); if (t.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds"); t = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n); Buffer.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = Buffer.prototype : e = fromArrayLike(e, t); return e }(e, t, r, n)) : typeof t === 'string' ? (function fromString(e, t, r) { typeof r === 'string' && r !== '' || (r = 'utf8'); if (!Buffer.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding'); const n = 0 | byteLength(t, r); const i = (e = createBuffer(e, n)).write(t, r); i !== n && (e = e.slice(0, i)); return e }(e, t, r)) : (function fromObject(e, t) { if (Buffer.isBuffer(t)) { const r = 0 | checked(t.length); return (e = createBuffer(e, r)).length === 0 ? e : (t.copy(e, 0, 0, r), e) } if (t) { if (typeof ArrayBuffer !== 'undefined' && t.buffer instanceof ArrayBuffer || 'length' in t) return typeof t.length !== 'number' || (function isnan(e) { return e != e }(t.length)) ? createBuffer(e, 0) : fromArrayLike(e, t); if (t.type === 'Buffer' && a(t.data)) return fromArrayLike(e, t.data); } throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.') }(e, t)) } function assertSize(e) { if (typeof e !== 'number') throw new TypeError('"size" argument must be a number'); if (e < 0) throw new RangeError('"size" argument must not be negative'); } function allocUnsafe(e, t) { if (assertSize(t), e = createBuffer(e, t < 0 ? 0 : 0 | checked(t)), !Buffer.TYPED_ARRAY_SUPPORT) for (let r = 0; r < t; ++r)e[r] = 0; return e } function fromArrayLike(e, t) { const r = t.length < 0 ? 0 : 0 | checked(t.length); e = createBuffer(e, r); for (let n = 0; n < r; n += 1)e[n] = 255 & t[n]; return e } function checked(e) { if (e >= kMaxLength()) throw new RangeError(`Attempt to allocate Buffer larger than maximum size: 0x${kMaxLength().toString(16)} bytes`); return 0 | e } function byteLength(e, t) { if (Buffer.isBuffer(e)) return e.length; if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength; typeof e !== 'string' && (e = `${e}`); const r = e.length; if (r === 0) return 0; for (let n = !1; ;) switch (t) { case 'ascii': case 'latin1': case 'binary': return r; case 'utf8': case 'utf-8': case void 0: return utf8ToBytes(e).length; case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return 2 * r; case 'hex': return r >>> 1; case 'base64': return base64ToBytes(e).length; default: if (n) return utf8ToBytes(e).length; t = (`${t}`).toLowerCase(), n = !0; } } function swap(e, t, r) { const n = e[t]; e[t] = e[r], e[r] = n } function bidirectionalIndexOf(e, t, r, n, i) { if (e.length === 0) return -1; if (typeof r === 'string' ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) { if (i) return -1; r = e.length - 1 } else if (r < 0) { if (!i) return -1; r = 0 } if (typeof t === 'string' && (t = Buffer.from(t, n)), Buffer.isBuffer(t)) return t.length === 0 ? -1 : arrayIndexOf(e, t, r, n, i); if (typeof t === 'number') return t &= 255, Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function' ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : arrayIndexOf(e, [t], r, n, i); throw new TypeError('val must be string, number or Buffer') } function arrayIndexOf(e, t, r, n, i) { let a; let o = 1; let s = e.length; let u = t.length; if (void 0 !== n && ((n = String(n).toLowerCase()) === 'ucs2' || n === 'ucs-2' || n === 'utf16le' || n === 'utf-16le')) { if (e.length < 2 || t.length < 2) return -1; o = 2, s /= 2, u /= 2, r /= 2 } function read(e, t) { return o === 1 ? e[t] : e.readUInt16BE(t * o) } if (i) { let l = -1; for (a = r; a < s; a++) if (read(e, a) === read(t, l === -1 ? 0 : a - l)) { if (l === -1 && (l = a), a - l + 1 === u) return l * o; } else l !== -1 && (a -= a - l), l = -1; } else for (r + u > s && (r = s - u), a = r; a >= 0; a--) { for (var c = !0, p = 0; p < u; p++) if (read(e, a + p) !== read(t, p)) { c = !1; break } if (c) return a; } return -1 } function hexWrite(e, t, r, n) { r = Number(r) || 0; const i = e.length - r; n ? (n = Number(n)) > i && (n = i) : n = i; const a = t.length; if (a % 2 != 0) throw new TypeError('Invalid hex string'); n > a / 2 && (n = a / 2); for (var o = 0; o < n; ++o) { const s = parseInt(t.substr(2 * o, 2), 16); if (isNaN(s)) return o; e[r + o] = s } return o } function utf8Write(e, t, r, n) { return blitBuffer(utf8ToBytes(t, e.length - r), e, r, n) } function asciiWrite(e, t, r, n) { return blitBuffer((function asciiToBytes(e) { for (var t = [], r = 0; r < e.length; ++r)t.push(255 & e.charCodeAt(r)); return t }(t)), e, r, n) } function latin1Write(e, t, r, n) { return asciiWrite(e, t, r, n) } function base64Write(e, t, r, n) { return blitBuffer(base64ToBytes(t), e, r, n) } function ucs2Write(e, t, r, n) { return blitBuffer((function utf16leToBytes(e, t) { for (var r, n, i, a = [], o = 0; o < e.length && !((t -= 2) < 0); ++o)r = e.charCodeAt(o), n = r >> 8, i = r % 256, a.push(i), a.push(n); return a }(t, e.length - r)), e, r, n) } function base64Slice(e, t, r) { return t === 0 && r === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, r)) } function utf8Slice(e, t, r) { r = Math.min(e.length, r); for (var n = [], i = t; i < r;) { var a; var s; var u; var l; const c = e[i]; let p = null; let f = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (i + f <= r) switch (f) { case 1: c < 128 && (p = c); break; case 2: (192 & (a = e[i + 1])) == 128 && (l = (31 & c) << 6 | 63 & a) > 127 && (p = l); break; case 3: a = e[i + 1], s = e[i + 2], (192 & a) == 128 && (192 & s) == 128 && (l = (15 & c) << 12 | (63 & a) << 6 | 63 & s) > 2047 && (l < 55296 || l > 57343) && (p = l); break; case 4: a = e[i + 1], s = e[i + 2], u = e[i + 3], (192 & a) == 128 && (192 & s) == 128 && (192 & u) == 128 && (l = (15 & c) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & u) > 65535 && l < 1114112 && (p = l); }p === null ? (p = 65533, f = 1) : p > 65535 && (p -= 65536, n.push(p >>> 10 & 1023 | 55296), p = 56320 | 1023 & p), n.push(p), i += f } return (function decodeCodePointsArray(e) { const t = e.length; if (t <= o) return String.fromCharCode(...e); let r = ''; let n = 0; for (;n < t;)r += String.fromCharCode(...e.slice(n, n += o)); return r }(n)) }t.Buffer = Buffer, t.SlowBuffer = function SlowBuffer(e) { +e != e && (e = 0); return Buffer.alloc(+e) }, t.INSPECT_MAX_BYTES = 50, Buffer.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : (function typedArraySupport() { try { const e = new Uint8Array(1); return e.__proto__ = { __proto__: Uint8Array.prototype, foo() { return 42 } }, e.foo() === 42 && typeof e.subarray === 'function' && e.subarray(1, 1).byteLength === 0 } catch (e) { return !1 } }()), t.kMaxLength = kMaxLength(), Buffer.poolSize = 8192, Buffer._augment = function (e) { return e.__proto__ = Buffer.prototype, e }, Buffer.from = function (e, t, r) { return from(null, e, t, r) }, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: !0 })), Buffer.alloc = function (e, t, r) { return (function alloc(e, t, r, n) { return assertSize(t), t <= 0 ? createBuffer(e, t) : void 0 !== r ? typeof n === 'string' ? createBuffer(e, t).fill(r, n) : createBuffer(e, t).fill(r) : createBuffer(e, t) }(null, e, t, r)) }, Buffer.allocUnsafe = function (e) { return allocUnsafe(null, e) }, Buffer.allocUnsafeSlow = function (e) { return allocUnsafe(null, e) }, Buffer.isBuffer = function isBuffer(e) { return !(e == null || !e._isBuffer) }, Buffer.compare = function compare(e, t) { if (!Buffer.isBuffer(e) || !Buffer.isBuffer(t)) throw new TypeError('Arguments must be Buffers'); if (e === t) return 0; for (var r = e.length, n = t.length, i = 0, a = Math.min(r, n); i < a; ++i) if (e[i] !== t[i]) { r = e[i], n = t[i]; break } return r < n ? -1 : n < r ? 1 : 0 }, Buffer.isEncoding = function isEncoding(e) { switch (String(e).toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return !0; default: return !1; } }, Buffer.concat = function concat(e, t) { if (!a(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (e.length === 0) return Buffer.alloc(0); let r; if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r)t += e[r].length; const n = Buffer.allocUnsafe(t); let i = 0; for (r = 0; r < e.length; ++r) { const o = e[r]; if (!Buffer.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers'); o.copy(n, i), i += o.length } return n }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function swap16() { const e = this.length; if (e % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits'); for (let t = 0; t < e; t += 2)swap(this, t, t + 1); return this }, Buffer.prototype.swap32 = function swap32() { const e = this.length; if (e % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits'); for (let t = 0; t < e; t += 4)swap(this, t, t + 3), swap(this, t + 1, t + 2); return this }, Buffer.prototype.swap64 = function swap64() { const e = this.length; if (e % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits'); for (let t = 0; t < e; t += 8)swap(this, t, t + 7), swap(this, t + 1, t + 6), swap(this, t + 2, t + 5), swap(this, t + 3, t + 4); return this }, Buffer.prototype.toString = function toString() { const e = 0 | this.length; return e === 0 ? '' : arguments.length === 0 ? utf8Slice(this, 0, e) : function slowToString(e, t, r) { let n = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ''; if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return ''; if ((r >>>= 0) <= (t >>>= 0)) return ''; for (e || (e = 'utf8'); ;) switch (e) { case 'hex': return hexSlice(this, t, r); case 'utf8': case 'utf-8': return utf8Slice(this, t, r); case 'ascii': return asciiSlice(this, t, r); case 'latin1': case 'binary': return latin1Slice(this, t, r); case 'base64': return base64Slice(this, t, r); case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return utf16leSlice(this, t, r); default: if (n) throw new TypeError(`Unknown encoding: ${e}`); e = (`${e}`).toLowerCase(), n = !0; } }.apply(this, arguments) }, Buffer.prototype.equals = function equals(e) { if (!Buffer.isBuffer(e)) throw new TypeError('Argument must be a Buffer'); return this === e || Buffer.compare(this, e) === 0 }, Buffer.prototype.inspect = function inspect() { let e = ''; const r = t.INSPECT_MAX_BYTES; return this.length > 0 && (e = this.toString('hex', 0, r).match(/.{2}/g).join(' '), this.length > r && (e += ' ... ')), `<Buffer ${e}>` }, Buffer.prototype.compare = function compare(e, t, r, n, i) { if (!Buffer.isBuffer(e)) throw new TypeError('Argument must be a Buffer'); if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), t < 0 || r > e.length || n < 0 || i > this.length) throw new RangeError('out of range index'); if (n >= i && t >= r) return 0; if (n >= i) return -1; if (t >= r) return 1; if (t >>>= 0, r >>>= 0, n >>>= 0, i >>>= 0, this === e) return 0; for (var a = i - n, o = r - t, s = Math.min(a, o), u = this.slice(n, i), l = e.slice(t, r), c = 0; c < s; ++c) if (u[c] !== l[c]) { a = u[c], o = l[c]; break } return a < o ? -1 : o < a ? 1 : 0 }, Buffer.prototype.includes = function includes(e, t, r) { return this.indexOf(e, t, r) !== -1 }, Buffer.prototype.indexOf = function indexOf(e, t, r) { return bidirectionalIndexOf(this, e, t, r, !0) }, Buffer.prototype.lastIndexOf = function lastIndexOf(e, t, r) { return bidirectionalIndexOf(this, e, t, r, !1) }, Buffer.prototype.write = function write(e, t, r, n) { if (void 0 === t)n = 'utf8', r = this.length, t = 0; else if (void 0 === r && typeof t === 'string')n = t, r = this.length, t = 0; else { if (!isFinite(t)) throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported'); t |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = 'utf8')) : (n = r, r = void 0) } const i = this.length - t; if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError('Attempt to write outside buffer bounds'); n || (n = 'utf8'); for (let a = !1; ;) switch (n) { case 'hex': return hexWrite(this, e, t, r); case 'utf8': case 'utf-8': return utf8Write(this, e, t, r); case 'ascii': return asciiWrite(this, e, t, r); case 'latin1': case 'binary': return latin1Write(this, e, t, r); case 'base64': return base64Write(this, e, t, r); case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return ucs2Write(this, e, t, r); default: if (a) throw new TypeError(`Unknown encoding: ${n}`); n = (`${n}`).toLowerCase(), a = !0; } }, Buffer.prototype.toJSON = function toJSON() { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } }; var o = 4096; function asciiSlice(e, t, r) { let n = ''; r = Math.min(e.length, r); for (let i = t; i < r; ++i)n += String.fromCharCode(127 & e[i]); return n } function latin1Slice(e, t, r) { let n = ''; r = Math.min(e.length, r); for (let i = t; i < r; ++i)n += String.fromCharCode(e[i]); return n } function hexSlice(e, t, r) { const n = e.length; (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n); for (var i = '', a = t; a < r; ++a)i += toHex(e[a]); return i } function utf16leSlice(e, t, r) { for (var n = e.slice(t, r), i = '', a = 0; a < n.length; a += 2)i += String.fromCharCode(n[a] + 256 * n[a + 1]); return i } function checkOffset(e, t, r) { if (e % 1 != 0 || e < 0) throw new RangeError('offset is not uint'); if (e + t > r) throw new RangeError('Trying to access beyond buffer length'); } function checkInt(e, t, r, n, i, a) { if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > i || t < a) throw new RangeError('"value" argument is out of bounds'); if (r + n > e.length) throw new RangeError('Index out of range'); } function objectWriteUInt16(e, t, r, n) { t < 0 && (t = 65535 + t + 1); for (let i = 0, a = Math.min(e.length - r, 2); i < a; ++i)e[r + i] = (t & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i); } function objectWriteUInt32(e, t, r, n) { t < 0 && (t = 4294967295 + t + 1); for (let i = 0, a = Math.min(e.length - r, 4); i < a; ++i)e[r + i] = t >>> 8 * (n ? i : 3 - i) & 255; } function checkIEEE754(e, t, r, n, i, a) { if (r + n > e.length) throw new RangeError('Index out of range'); if (r < 0) throw new RangeError('Index out of range'); } function writeFloat(e, t, r, n, a) { return a || checkIEEE754(e, 0, r, 4), i.write(e, t, r, n, 23, 4), r + 4 } function writeDouble(e, t, r, n, a) { return a || checkIEEE754(e, 0, r, 8), i.write(e, t, r, n, 52, 8), r + 8 }Buffer.prototype.slice = function slice(e, t) { let r; const n = this.length; if (e = ~~e, t = void 0 === t ? n : ~~t, e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), Buffer.TYPED_ARRAY_SUPPORT)(r = this.subarray(e, t)).__proto__ = Buffer.prototype; else { const i = t - e; r = new Buffer(i, void 0); for (let a = 0; a < i; ++a)r[a] = this[a + e]; } return r }, Buffer.prototype.readUIntLE = function readUIntLE(e, t, r) { e |= 0, t |= 0, r || checkOffset(e, t, this.length); for (var n = this[e], i = 1, a = 0; ++a < t && (i *= 256);)n += this[e + a] * i; return n }, Buffer.prototype.readUIntBE = function readUIntBE(e, t, r) { e |= 0, t |= 0, r || checkOffset(e, t, this.length); for (var n = this[e + --t], i = 1; t > 0 && (i *= 256);)n += this[e + --t] * i; return n }, Buffer.prototype.readUInt8 = function readUInt8(e, t) { return t || checkOffset(e, 1, this.length), this[e] }, Buffer.prototype.readUInt16LE = function readUInt16LE(e, t) { return t || checkOffset(e, 2, this.length), this[e] | this[e + 1] << 8 }, Buffer.prototype.readUInt16BE = function readUInt16BE(e, t) { return t || checkOffset(e, 2, this.length), this[e] << 8 | this[e + 1] }, Buffer.prototype.readUInt32LE = function readUInt32LE(e, t) { return t || checkOffset(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, Buffer.prototype.readUInt32BE = function readUInt32BE(e, t) { return t || checkOffset(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, Buffer.prototype.readIntLE = function readIntLE(e, t, r) { e |= 0, t |= 0, r || checkOffset(e, t, this.length); for (var n = this[e], i = 1, a = 0; ++a < t && (i *= 256);)n += this[e + a] * i; return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n }, Buffer.prototype.readIntBE = function readIntBE(e, t, r) { e |= 0, t |= 0, r || checkOffset(e, t, this.length); for (var n = t, i = 1, a = this[e + --n]; n > 0 && (i *= 256);)a += this[e + --n] * i; return a >= (i *= 128) && (a -= Math.pow(2, 8 * t)), a }, Buffer.prototype.readInt8 = function readInt8(e, t) { return t || checkOffset(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, Buffer.prototype.readInt16LE = function readInt16LE(e, t) { t || checkOffset(e, 2, this.length); const r = this[e] | this[e + 1] << 8; return 32768 & r ? 4294901760 | r : r }, Buffer.prototype.readInt16BE = function readInt16BE(e, t) { t || checkOffset(e, 2, this.length); const r = this[e + 1] | this[e] << 8; return 32768 & r ? 4294901760 | r : r }, Buffer.prototype.readInt32LE = function readInt32LE(e, t) { return t || checkOffset(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, Buffer.prototype.readInt32BE = function readInt32BE(e, t) { return t || checkOffset(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, Buffer.prototype.readFloatLE = function readFloatLE(e, t) { return t || checkOffset(e, 4, this.length), i.read(this, e, !0, 23, 4) }, Buffer.prototype.readFloatBE = function readFloatBE(e, t) { return t || checkOffset(e, 4, this.length), i.read(this, e, !1, 23, 4) }, Buffer.prototype.readDoubleLE = function readDoubleLE(e, t) { return t || checkOffset(e, 8, this.length), i.read(this, e, !0, 52, 8) }, Buffer.prototype.readDoubleBE = function readDoubleBE(e, t) { return t || checkOffset(e, 8, this.length), i.read(this, e, !1, 52, 8) }, Buffer.prototype.writeUIntLE = function writeUIntLE(e, t, r, n) { (e = +e, t |= 0, r |= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0); let i = 1; let a = 0; for (this[t] = 255 & e; ++a < r && (i *= 256);) this[t + a] = e / i & 255; return t + r }, Buffer.prototype.writeUIntBE = function writeUIntBE(e, t, r, n) { (e = +e, t |= 0, r |= 0, n) || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0); let i = r - 1; let a = 1; for (this[t + i] = 255 & e; --i >= 0 && (a *= 256);) this[t + i] = e / a & 255; return t + r }, Buffer.prototype.writeUInt8 = function writeUInt8(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1 }, Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : objectWriteUInt16(this, e, t, !0), t + 2 }, Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : objectWriteUInt16(this, e, t, !1), t + 2 }, Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : objectWriteUInt32(this, e, t, !0), t + 4 }, Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : objectWriteUInt32(this, e, t, !1), t + 4 }, Buffer.prototype.writeIntLE = function writeIntLE(e, t, r, n) { if (e = +e, t |= 0, !n) { const i = Math.pow(2, 8 * r - 1); checkInt(this, e, t, r, i - 1, -i) } let a = 0; let o = 1; let s = 0; for (this[t] = 255 & e; ++a < r && (o *= 256);)e < 0 && s === 0 && this[t + a - 1] !== 0 && (s = 1), this[t + a] = (e / o >> 0) - s & 255; return t + r }, Buffer.prototype.writeIntBE = function writeIntBE(e, t, r, n) { if (e = +e, t |= 0, !n) { const i = Math.pow(2, 8 * r - 1); checkInt(this, e, t, r, i - 1, -i) } let a = r - 1; let o = 1; let s = 0; for (this[t + a] = 255 & e; --a >= 0 && (o *= 256);)e < 0 && s === 0 && this[t + a + 1] !== 0 && (s = 1), this[t + a] = (e / o >> 0) - s & 255; return t + r }, Buffer.prototype.writeInt8 = function writeInt8(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, Buffer.prototype.writeInt16LE = function writeInt16LE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : objectWriteUInt16(this, e, t, !0), t + 2 }, Buffer.prototype.writeInt16BE = function writeInt16BE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : objectWriteUInt16(this, e, t, !1), t + 2 }, Buffer.prototype.writeInt32LE = function writeInt32LE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : objectWriteUInt32(this, e, t, !0), t + 4 }, Buffer.prototype.writeInt32BE = function writeInt32BE(e, t, r) { return e = +e, t |= 0, r || checkInt(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : objectWriteUInt32(this, e, t, !1), t + 4 }, Buffer.prototype.writeFloatLE = function writeFloatLE(e, t, r) { return writeFloat(this, e, t, !0, r) }, Buffer.prototype.writeFloatBE = function writeFloatBE(e, t, r) { return writeFloat(this, e, t, !1, r) }, Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, t, r) { return writeDouble(this, e, t, !0, r) }, Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, t, r) { return writeDouble(this, e, t, !1, r) }, Buffer.prototype.copy = function copy(e, t, r, n) { if (r || (r = 0), n || n === 0 || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0; if (e.length === 0 || this.length === 0) return 0; if (t < 0) throw new RangeError('targetStart out of bounds'); if (r < 0 || r >= this.length) throw new RangeError('sourceStart out of bounds'); if (n < 0) throw new RangeError('sourceEnd out of bounds'); n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r); let i; const a = n - r; if (this === e && r < t && t < n) for (i = a - 1; i >= 0; --i)e[i + t] = this[i + r]; else if (a < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) for (i = 0; i < a; ++i)e[i + t] = this[i + r]; else Uint8Array.prototype.set.call(e, this.subarray(r, r + a), t); return a }, Buffer.prototype.fill = function fill(e, t, r, n) { if (typeof e === 'string') { if (typeof t === 'string' ? (n = t, t = 0, r = this.length) : typeof r === 'string' && (n = r, r = this.length), e.length === 1) { const i = e.charCodeAt(0); i < 256 && (e = i) } if (void 0 !== n && typeof n !== 'string') throw new TypeError('encoding must be a string'); if (typeof n === 'string' && !Buffer.isEncoding(n)) throw new TypeError(`Unknown encoding: ${n}`); } else typeof e === 'number' && (e &= 255); if (t < 0 || this.length < t || this.length < r) throw new RangeError('Out of range index'); if (r <= t) return this; let a; if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), typeof e === 'number') for (a = t; a < r; ++a) this[a] = e; else { const o = Buffer.isBuffer(e) ? e : utf8ToBytes(new Buffer(e, n).toString()); const s = o.length; for (a = 0; a < r - t; ++a) this[a + t] = o[a % s]; } return this }; const s = /[^+\/0-9A-Za-z-_]/g; function toHex(e) { return e < 16 ? `0${e.toString(16)}` : e.toString(16) } function utf8ToBytes(e, t) { let r; t = t || 1 / 0; for (var n = e.length, i = null, a = [], o = 0; o < n; ++o) { if ((r = e.charCodeAt(o)) > 55295 && r < 57344) { if (!i) { if (r > 56319) { (t -= 3) > -1 && a.push(239, 191, 189); continue } if (o + 1 === n) { (t -= 3) > -1 && a.push(239, 191, 189); continue }i = r; continue } if (r < 56320) { (t -= 3) > -1 && a.push(239, 191, 189), i = r; continue }r = 65536 + (i - 55296 << 10 | r - 56320) } else i && (t -= 3) > -1 && a.push(239, 191, 189); if (i = null, r < 128) { if ((t -= 1) < 0) break; a.push(r) } else if (r < 2048) { if ((t -= 2) < 0) break; a.push(r >> 6 | 192, 63 & r | 128) } else if (r < 65536) { if ((t -= 3) < 0) break; a.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128) } else { if (!(r < 1114112)) throw new Error('Invalid code point'); if ((t -= 4) < 0) break; a.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128) } } return a } function base64ToBytes(e) { return n.toByteArray(function base64clean(e) { if ((e = (function stringtrim(e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, '') }(e)).replace(s, '')).length < 2) return ''; for (;e.length % 4 != 0;)e += '='; return e }(e)) } function blitBuffer(e, t, r, n) { for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i)t[i + r] = e[i]; return i }
  }).call(t, r(14));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(370); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(371); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = r(398); const i = r(420); const a = r(85); const o = r(17); const s = r(429); e.exports = function baseIteratee(e) { return typeof e === 'function' ? e : e == null ? a : typeof e === 'object' ? o(e) ? i(e[0], e[1]) : n(e) : s(e) } }, function (e, t, r) { const n = r(400); const i = r(22); e.exports = function baseIsEqual(e, t, r, a, o) { return e === t || (e == null || t == null || !i(e) && !i(t) ? e != e && t != t : n(e, t, r, a, baseIsEqual, o)) } }, function (e, t, r) { const n = r(401); const i = r(404); const a = r(405); const o = 1; const s = 2; e.exports = function equalArrays(e, t, r, u, l, c) { const p = r & o; const f = e.length; const d = t.length; if (f != d && !(p && d > f)) return !1; const h = c.get(e); if (h && c.get(t)) return h == t; let m = -1; let g = !0; const v = r & s ? new n() : void 0; for (c.set(e, t), c.set(t, e); ++m < f;) { var y = e[m]; const b = t[m]; if (u) var x = p ? u(b, y, m, t, e, c) : u(y, b, m, e, t, c); if (void 0 !== x) { if (x) continue; g = !1; break } if (v) { if (!i(t, (e, t) => { if (!a(v, t) && (y === e || l(y, e, r, u, c))) return v.push(t); })) { g = !1; break } } else if (y !== b && !l(y, b, r, u, c)) { g = !1; break } } return c.delete(e), c.delete(t), g } }, function (e, t, r) { const n = r(144); const i = r(17); e.exports = function baseGetAllKeys(e, t, r) { const a = t(e); return i(e) ? a : n(a, r(e)) } }, function (e, t) { e.exports = function arrayPush(e, t) { for (let r = -1, n = t.length, i = e.length; ++r < n;)e[i + r] = t[r]; return e } }, function (e, t, r) { const n = r(411); const i = r(146); const a = Object.prototype.propertyIsEnumerable; const o = Object.getOwnPropertySymbols; const s = o ? function (e) { return e == null ? [] : (e = Object(e), n(o(e), t => a.call(e, t))) } : i; e.exports = s }, function (e, t) { e.exports = function stubArray() { return [] } }, function (e, t, r) { const n = r(15); e.exports = function isStrictComparable(e) { return e == e && !n(e) } }, function (e, t) { e.exports = function matchesStrictComparable(e, t) { return function (r) { return r != null && r[e] === t && (void 0 !== t || e in Object(r)) } } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(452); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(454); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getFilterRegExp(e) { return e = e.replace(/[^a-z0-9]/gi, '').split('').join('.*'), new RegExp(e, 'i') };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(472); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(475); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) { const n = Function.prototype.apply; function Timeout(e, t) { this._id = e, this._clearFn = t }t.setTimeout = function () { return new Timeout(n.call(setTimeout, window, arguments), clearTimeout) }, t.setInterval = function () { return new Timeout(n.call(setInterval, window, arguments), clearInterval) }, t.clearTimeout = t.clearInterval = function (e) { e && e.close() }, Timeout.prototype.unref = Timeout.prototype.ref = function () {}, Timeout.prototype.close = function () { this._clearFn.call(window, this._id) }, t.enroll = function (e, t) { clearTimeout(e._idleTimeoutId), e._idleTimeout = t }, t.unenroll = function (e) { clearTimeout(e._idleTimeoutId), e._idleTimeout = -1 }, t._unrefActive = t.active = function (e) { clearTimeout(e._idleTimeoutId); const t = e._idleTimeout; t >= 0 && (e._idleTimeoutId = setTimeout(() => { e._onTimeout && e._onTimeout() }, t)) }, r(487), t.setImmediate = setImmediate, t.clearImmediate = clearImmediate }, function (e, t) {
  function isBuffer(e) { return !!e.constructor && typeof e.constructor.isBuffer === 'function' && e.constructor.isBuffer(e) }
  /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
  e.exports = function (e) { return e != null && (isBuffer(e) || (function isSlowBuffer(e) { return typeof e.readFloatLE === 'function' && typeof e.slice === 'function' && isBuffer(e.slice(0, 0)) }(e)) || !!e._isBuffer) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(516); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t) {
  const r = 'https://github.com/vue-styleguidist/vue-styleguidist/'; e.exports = {
    HOMEPAGE: r, BUGS: `${r}/issues`, DOCS_CONFIG: `${r}blob/master/docs/Configuration.md`, DOCS_COMPONENTS: `${r}blob/master/docs/Components.md`, DOCS_WEBPACK: `${r}blob/master/docs/Webpack.md`, DOCS_DOCUMENTING: `${r}blob/master/docs/Documenting.md`, DOCS_THIRDPARTIES: '',
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(159); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(555); const s = r(3); const u = function injectStyle(e) { r(551) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-72d66d28', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'PageIcon',
    components: { FontAwesomeIcon: n.default },
    props: {
      isEnabled: { type: Boolean, required: !0, default: !1 },
      direction: {
        type: String, required: !0, default: 'left', validator: function validator(e) { return e === 'left' || e === 'right' },
      },
    },
    computed: { faIcon: function faIcon() { return this.direction === 'left' ? 'chevron-left' : 'chevron-right' } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(161); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(559); const s = r(3); const u = function injectStyle(e) { r(557) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-411b1062', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'TimeTag',
    components: { FontAwesomeIcon: n.default },
    props: {
      type: {
        type: String, required: !0, default: 'length', validator: function validator(e) { return e === 'length' || e === 'timestamp' },
      },
      start: { type: String, required: !1, default: '0' },
      end: { type: String, required: !1, default: '0' },
      duration: { type: String, required: !1, default: '0' },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(563))); t.default = {
    name: 'TypeTag',
    props: {
      type: {
        type: String, required: !0, default: 'simple', validator: function validator(e) { return e === 'simple' || e === 'withSeason' },
      },
      animeType: { type: String, required: !0, default: 'Unknown' },
      season: { type: String, required: !1, default: '2046-01' },
    },
    data: function data() {
      return {
        typeClasses: {
          OVA: 'Series--ova', ONA: 'Series--ona', Movie: 'Series--movie', Special: 'Series--special', 'TV Short': 'Series--tvShort', TV: 'Series--tv', Other: 'Series--other',
        },
      };
    },
    methods: { typeClassObj: function typeClassObj(e) { const t = e.type; const r = this.typeClasses[t] || 'Other'; return (0, n.default)({}, r, !0) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(164); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(573); const s = r(3); const u = function injectStyle(e) { r(571) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-1dfafaec', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = { name: 'Breadcrumb' };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(18)); const i = _interopRequireDefault(r(166)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'LoopCard',
    components: { GifPlayer: i.default, FontAwesomeIcon: n.default },
    props: {
      loopid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } },
      loopType: {
        type: String, required: !0, default: 'mp4', validator: function validator(e) { return e === 'mp4' || e === 'gif' },
      },
      pageType: {
        type: String, required: !0, default: 'loop', validator: function validator(e) { return ['home', 'episode', 'loop'].indexOf(e) > -1 },
      },
    },
    data: function data() { return { hovered: !1, canplaythrough: !1, isVideoLoaded: !1 } },
    computed: { files: function files() { return this.$store.state.loop.loops[this.loopid].files } },
    methods: { onHovered: function onHovered() { this.hovered || (this.hovered = !0, this.$refs.video.play()) }, onUnhovered: function onUnhovered() { this.hovered = !1, this.$refs.video.pause() }, canplay: function canplay() { this.canplaythrough = !0 } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(167); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(579); const s = r(3); const u = function injectStyle(e) { r(577) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-09021016', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = {
    name: 'GifPlayer', props: { jpgsrc: { type: String, required: !0 }, gifsrc: { type: String, required: !0 } }, data: function data() { return { gifLoaded: !1 } }, computed: { playState: function playState() { return this.$store.state.loop.play } }, methods: { imageOnload: function imageOnload() { this.gifLoaded = !0 } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(169); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(584); const s = r(3); const u = function injectStyle(e) { r(582) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-1c713996', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(61))); t.default = {
    name: 'CardDetails',
    components: { TypeTag: n.default },
    props: { type: { type: String, required: !0, validator: function validator(e) { return e === 'episode' || e === 'loop' } }, loopid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } } },
    computed: {
      i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.loop.series.titleJA; case 'zh': return this.loop.series.title; case 'en': default: return this.loop.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, loop: function loop() { return this.$store.state.loop.loops[this.loopid] }, formattedTimeStamps: function formattedTimeStamps() { return this.$store.getters.formatTimeStamps(this.loopid) },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(171); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(588); const s = r(3); const u = function injectStyle(e) { r(586) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-131a77aa', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = { name: 'Downloads', props: { loopid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } } }, computed: { files: function files() { return this.$store.state.loop.loops[this.loopid].files }, downloadEntries: function downloadEntries() { return [{ name: 'gif_180p', url: this.files.gif_360p, typeClass: 'Downloads-gif' }, { name: 'jpg_360p', url: this.files.jpg_360p, typeClass: '' }, { name: 'jpg_720p', url: this.files.jpg_720p, typeClass: '' }, { name: 'jpg_1080p', url: this.files.jpg_1080p, typeClass: '' }, { name: 'mp4_360p', url: this.files.mp4_360p, typeClass: 'Downloads-video' }, { name: 'mp4_720p', url: this.files.mp4_720p, typeClass: 'Downloads-video' }, { name: 'mp4_1080p', url: this.files.mp4_1080p, typeClass: 'Downloads-video' }] } } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(102)); const i = _interopRequireDefault(r(168)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'LoopGrid',
    components: { LoopCard: n.default, CardDetails: i.default },
    props: {
      pageType: {
        type: String, required: !0, default: 'home', validator: function validator(e) { return e === 'home' || e === 'episode' },
      },
      episodeid: {
        type: String, required: !1, default: '', validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) || e === '' },
      },
    },
    computed: { loopList: function loopList() { return this.pageType === 'episode' ? this.$store.state.loop.loopList[this.episodeid] : this.pageType === 'home' ? this.$store.state.loop.randomLoopList : [] } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(174); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(600); const s = r(3); const u = function injectStyle(e) { r(595) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-2dff73ba', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(175)); const i = _interopRequireDefault(r(102)); const a = _interopRequireDefault(r(163)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'LoopPageView',
    components: { Breadcrumb: a.default, LoopInfo: n.default, LoopCard: i.default },
    props: {
      pageType: {
        type: String, required: !0, default: 'loop', validator: function validator(e) { return e === 'loop' || e === 'random' },
      },
    },
    computed: { i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.loop.series.titleJA; case 'zh': return this.loop.series.title; case 'en': default: return this.loop.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, loop: function loop() { return this.pageType === 'loop' ? this.$store.state.loop.loops[this.$route.params.id] : this.$store.state.loop.loops[this.$store.state.loop.randomPageLoopid] } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(176); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(599); const s = r(3); const u = function injectStyle(e) { r(597) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-14fa35fc', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(160)); const i = _interopRequireDefault(r(61)); const a = _interopRequireDefault(r(170)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'LoopInfo', components: { Downloads: a.default, TimeTag: n.default, TypeTag: i.default }, props: { loopid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } } }, computed: { loop: function loop() { return this.$store.state.loop.loops[this.loopid] }, formattedTimeStamps: function formattedTimeStamps() { return this.$store.getters.formatTimeStamps(this.loopid) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(178); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(605); const s = r(3); const u = function injectStyle(e) { r(603) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-2eb55006', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'NavbarEntry', components: { FontAwesomeIcon: n.default }, data: function data() { return { entries: [{ name: 'navbar.list', icon: 'th-list', routeName: 'list' }, { name: 'navbar.random', icon: 'question-circle', routeName: 'random' }, { name: 'navbar.about', icon: 'info', routeName: 'about' }] } }, computed: { navStates: function navStates() { return this.$store.state.navbar }, toggledStyle: function toggledStyle() { return this.navStates.burgerOpen ? { display: 'flex' } : {} } }, methods: { toggleBurger: function toggleBurger() { this.navStates.burgerOpen && this.$store.dispatch('toggleNavbarState', { type: 'burger' }) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(177)); const i = _interopRequireDefault(r(180)); const a = _interopRequireDefault(r(182)); const o = _interopRequireDefault(r(184)); const s = _interopRequireDefault(r(186)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'Navbar',
    components: {
      NavbarEntry: n.default, NavbarLangMenu: i.default, NavbarBurgerMenu: a.default, NavbarSearch: o.default, NavbarTitle: s.default,
    },
    data: function data() { return {} },
    computed: { navStates: function navStates() { return this.$store.state.navbar }, toggleContainerStyle: function toggleContainerStyle() { return this.navStates.burgerOpen ? { 'flex-wrap': 'wrap' } : {} } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(181); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(612); const s = r(3); const u = function injectStyle(e) { r(610) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-0731830a', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'NavbarLangMenu', components: { FontAwesomeIcon: n.default }, data: function data() { return { localeList: [{ id: 'zh', text: '' }, { id: 'en', text: 'English' }, { id: 'ja', text: '' }] } }, computed: { navStates: function navStates() { return this.$store.state.navbar }, toggleLangStyle: function toggleLangStyle() { return this.navStates.langOpen ? { display: 'block' } : {} }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale } }, methods: { toggleLang: function toggleLang() { this.$store.dispatch('toggleNavbarState', { type: 'lang' }) }, onClickOutside: function onClickOutside() { this.navStates.langOpen && this.toggleLang() }, setLanguage: function setLanguage(e) { this.$store.dispatch('setLang', { locale: e }) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(183); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(615); const s = r(3); const u = function injectStyle(e) { r(613) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-f3deda52', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'NavbarBurgerMenu', components: { FontAwesomeIcon: n.default }, computed: { navStates: function navStates() { return this.$store.state.navbar }, burgerIcon: function burgerIcon() { return this.navStates.burgerOpen || this.navStates.searchOpen ? 'times' : 'bars' }, toggleSearchStyle: function toggleSearchStyle() { return this.navStates.searchOpen ? { flex: '0 1 1em' } : {} } }, methods: { toggleBurger: function toggleBurger() { this.navStates.searchOpen ? this.$store.dispatch('toggleNavbarState', { type: 'search' }) : this.$store.dispatch('toggleNavbarState', { type: 'burger' }) }, toggleSearch: function toggleSearch() { this.$store.dispatch('toggleNavbarState', { type: 'search' }) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(185); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(618); const s = r(3); const u = function injectStyle(e) { r(616) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-68b232e0', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'NavbarSearch',
    components: { FontAwesomeIcon: n.default },
    data: function data() { return { keyword: '', searchFocused: !1 } },
    computed: {
      navStates: function navStates() { return this.$store.state.navbar }, toggleContainerStyle: function toggleContainerStyle() { return this.navStates.searchOpen ? { display: 'flex', 'max-width': 'calc(100% - 2.1rem)' } : {} }, toggleArrowButtonStyle: function toggleArrowButtonStyle() { return this.navStates.searchOpen ? { display: 'flex' } : {} }, searchbarPlaceholder: function searchbarPlaceholder() { return this.keyword ? this.keyword : this.searchFocused ? '' : this.$t('navbar.search') },
    },
    methods: { dispatchSearch: function dispatchSearch() { this.keyword && (this.$store.dispatch('fetchSeriesByString', { searchString: this.keyword }), this.$router.push({ path: '/search', query: { keyword: this.keyword } }), this.$refs.search.blur()) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(187); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(621); const s = r(3); const u = function injectStyle(e) { r(619) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-267aba02', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(18))); t.default = {
    name: 'NavbarTitle', components: { FontAwesomeIcon: n.default }, computed: { playState: function playState() { return this.$store.state.loop.play }, playIcon: function playIcon() { return this.playState ? 'pause-circle' : 'play-circle' }, showPlayIcon: function showPlayIcon() { return this.$route.name === 'episode-id' || this.$route.name === 'index' } }, methods: { togglePlay: function togglePlay() { const e = this.playState; this.$store.dispatch('setPlay', { play: !e }) } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(189); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(631); const s = r(3); const u = function injectStyle(e) { r(629) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-5be6b1a4', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = {
    name: 'SeriesCover',
    props: { seriesid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } } },
    computed: {
      i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.series.titleJA; case 'zh': return this.series.title; case 'en': default: return this.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, series: function series() { return this.$store.state.series.series[this.seriesid] }, coverBackgroundImageStyle: function coverBackgroundImageStyle() { return { 'background-image': `url(${this.series.image_url_large})` } },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = { name: 'SeriesGenres', props: { genres: { type: Array, required: !0, default: function _default() { return ['Unknown Genre'] } } } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(188))); t.default = {
    name: 'SeriesGrid',
    components: { SeriesCover: n.default },
    props: {
      type: {
        type: String, required: !0, default: 'list', validator: function validator(e) { return ['listPage', 'search'].indexOf(e) > -1 },
      },
    },
    data: function data() { return {} },
    computed: { seriesList: function seriesList() { return this.type === 'search' ? this.$store.state.search.searchResult : this.type === 'listPage' ? this.$store.state.series.seriesListByGroupFilter : {} } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(18)); const i = _interopRequireDefault(r(103)); const a = _interopRequireDefault(r(104)); const o = _interopRequireDefault(r(193)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'SeriesPageView',
    components: {
      FontAwesomeIcon: n.default, LoopGrid: i.default, Genres: a.default, Info: o.default,
    },
    props: {
      seriesid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } },
      episodeid: {
        type: String, required: !1, default: '', validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) || e === '' },
      },
      episodeno: {
        type: String, required: !1, default: '', validator: function validator(e) { return /^[\w]{0,10}$/.test(e) || e === '' },
      },
    },
    head: function head() { return { title: this.metaTitle, meta: [{ hid: 'og:title', name: 'og:title', content: this.episodeid ? `${this.series.titleJA} ${this.episodeno}` : this.series.titleJA }, { hid: 'og:description', property: 'og:description', content: this.series.description }, { hid: 'og:site_name', name: 'og:site_name', content: 'Animeloop Beta' }, { hid: 'og:image', property: 'og:image', content: this.series.image_url_large }] } },
    data: function data() { return { currentSeriesID: this.seriesid, selectedEpisodeID: this.episodeid ? this.episodeid : '' } },
    computed: {
      metaTitle: function metaTitle() { return this.episodeid ? `${this.episodeno} | ${this.i18nTitle} | Animeloop` : `${this.i18nTitle} | Animeloop` }, i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.series.titleJA; case 'zh': return this.series.title; case 'en': default: return this.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, loops: function loops() { return this.$store.state.loop.loopList[this.selectedEpisodeID] }, episodeList: function episodeList() { return this.$store.state.episode.episodeList[this.currentSeriesID] }, series: function series() { return this.$store.state.series.series[this.currentSeriesID] }, upperHalfBackgroundImage: function upperHalfBackgroundImage() { return { background: `linear-gradient(0deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.4)), url(${this.series.image_url_large})` } },
    },
    created: function created() { this.episodeList || this.fetchEpisodes(), this.$route.name === 'episode-id' && this.fetchLoops() },
    methods: { selectChanged: function selectChanged() { this.$router.push({ path: `/episode/${this.selectedEpisodeID}` }), this.fetchLoops() }, fetchEpisodes: function fetchEpisodes() { try { this.$store.dispatch('fetchEpisodesBySeriesID', { seriesid: this.currentSeriesID }) } catch (e) { throw new Error(e) } }, fetchLoops: function fetchLoops() { try { this.$store.dispatch('fetchLoopsByEpisodeID', { episodeid: this.selectedEpisodeID }) } catch (e) { throw new Error(e) } } },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(194); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(645); const s = r(3); const u = function injectStyle(e) { r(643) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-3cdb4c40', null); t.default = l.exports;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(104)); const i = _interopRequireDefault(r(61)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'SeriesInfo',
    components: { Genres: n.default, TypeTag: i.default },
    props: { seriesid: { type: String, required: !0, validator: function validator(e) { return /^[a-z0-9]{24}$/.test(e) } } },
    computed: {
      i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.series.titleJA; case 'zh': return this.series.title; case 'en': default: return this.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, episodes: function episodes() { return this.$store.state.episode.episodeList[this.seriesid] }, series: function series() { return this.$store.state.series.series[this.seriesid] },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(23))); t.default = {
    name: 'NuxtLoading',
    data: function data() {
      return {
        percent: 0, show: !1, canSuccess: !0, duration: 5e3, height: '2px', color: '#1E50A2', failedColor: '#C9171E',
      };
    },
    methods: {
      start: function start() { const e = this; return this.show = !0, this.canSuccess = !0, this._timer && (clearInterval(this._timer), this.percent = 0), this._cut = 1e4 / Math.floor(this.duration), this._timer = setInterval(() => { e.increase(e._cut * Math.random()), e.percent > 95 && e.finish() }, 100), this }, set: function set(e) { return this.show = !0, this.canSuccess = !0, this.percent = Math.floor(e), this }, get: function get() { return Math.floor(this.percent) }, increase: function increase(e) { return this.percent = this.percent + Math.floor(e), this }, decrease: function decrease(e) { return this.percent = this.percent - Math.floor(e), this }, finish: function finish() { return this.percent = 100, this.hide(), this }, pause: function pause() { return clearInterval(this._timer), this }, hide: function hide() { const e = this; return clearInterval(this._timer), this._timer = null, setTimeout(() => { e.show = !1, n.default.nextTick(() => { setTimeout(() => { e.percent = 0 }, 200) }) }, 500), this }, fail: function fail() { return this.canSuccess = !1, this },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = { name: 'About', head: function head() { return { title: `${this.$t('about')} | Animeloop` } }, data: function data() { return {} } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = { name: 'APIStatus', metaInfo: { title: 'API & Status' }, data: function data() { return {} } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(106)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'PageEpisodeID', components: { SeriesPage: a.default }, asyncData: function asyncData(e) { return { episodeid: e.params.id } }, fetch: (function () { const e = (0, i.default)(n.default.mark(function _callee(e) { const t = e.store; const r = e.error; const i = e.params.id; return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, t.dispatch('fetchEpisodeByID', { episodeid: i }); case 3: e.next = 8; break; case 5: e.prev = 5, e.t0 = e.catch(0), r({ statusCode: 404, message: 'API returned Error', customMsg: e.t0.message }); case 8: case 'end': return e.stop(); } }, _callee, this, [[0, 5]]) })); return function fetch(t) { return e.apply(this, arguments) } }()), validate: function validate(e) { const t = e.params; return /^[a-z0-9]{24}$/.test(t.id) }, computed: { episodes: function episodes() { return this.$store.state.episode.episodes[this.$route.params.id] } },
  };
}, function (e, t, r) { e.exports = { default: r(667), __esModule: !0 } }, function (e, t) {}, function (e, t) { e.exports = !0 }, function (e, t, r) { const n = r(29); const i = r(671); const a = r(204); const o = r(112)('IE_PROTO'); const s = function () {}; var u = function () { let e; const t = r(100)('iframe'); let n = a.length; for (t.style.display = 'none', r(205).appendChild(t), t.src = 'javascript:', (e = t.contentWindow.document).open(), e.write('<script>document.F=Object<\/script>'), e.close(), u = e.F; n--;) delete u.prototype[a[n]]; return u() }; e.exports = Object.create || function create(e, t) { let r; return e !== null ? (s.prototype = n(e), r = new s(), s.prototype = null, r[o] = e) : r = u(), void 0 === t ? r : i(r, t) } }, function (e, t, r) { const n = r(12); const i = n['__core-js_shared__'] || (n['__core-js_shared__'] = {}); e.exports = function (e) { return i[e] || (i[e] = {}) } }, function (e, t) { e.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',') }, function (e, t, r) { const n = r(12).document; e.exports = n && n.documentElement }, function (e, t, r) { r(676); for (let n = r(12), i = r(28), a = r(41), o = r(13)('toStringTag'), s = 'CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList'.split(','), u = 0; u < s.length; u++) { const l = s[u]; const c = n[l]; const p = c && c.prototype; p && !p[o] && i(p, o, l), a[l] = a.Array } }, function (e, t) { e.exports = function (e, t) { return { value: t, done: !!e } } }, function (e, t, r) { const n = r(29); e.exports = function (e, t, r, i) { try { return i ? t(n(r)[0], r[1]) : t(r) } catch (t) { const a = e.return; throw void 0 !== a && n(a.call(e)), t } } }, function (e, t, r) { const n = r(41); const i = r(13)('iterator'); const a = Array.prototype; e.exports = function (e) { return void 0 !== e && (n.Array === e || a[i] === e) } }, function (e, t, r) { const n = r(114); const i = r(13)('iterator'); const a = r(41); e.exports = r(7).getIteratorMethod = function (e) { if (void 0 != e) return e[i] || e['@@iterator'] || a[n(e)]; } }, function (e, t, r) { const n = r(29); const i = r(39); const a = r(13)('species'); e.exports = function (e, t) { let r; const o = n(e).constructor; return void 0 === o || void 0 == (r = n(o)[a]) ? t : i(r) } }, function (e, t, r) { let n; let i; let a; const o = r(24); const s = r(679); const u = r(205); const l = r(100); const c = r(12); const p = c.process; let f = c.setImmediate; let d = c.clearImmediate; const h = c.MessageChannel; const m = c.Dispatch; let g = 0; const v = {}; const y = function () { const e = +this; if (v.hasOwnProperty(e)) { const t = v[e]; delete v[e], t() } }; const b = function (e) { y.call(e.data) }; f && d || (f = function setImmediate(e) { for (var t = [], r = 1; arguments.length > r;)t.push(arguments[r++]); return v[++g] = function () { s(typeof e === 'function' ? e : Function(e), t) }, n(g), g }, d = function clearImmediate(e) { delete v[e] }, r(42)(p) == 'process' ? n = function (e) { p.nextTick(o(y, e, 1)) } : m && m.now ? n = function (e) { m.now(o(y, e, 1)) } : h ? (a = (i = new h()).port2, i.port1.onmessage = b, n = o(a.postMessage, a, 1)) : c.addEventListener && typeof postMessage === 'function' && !c.importScripts ? (n = function (e) { c.postMessage(`${e}`, '*') }, c.addEventListener('message', b, !1)) : n = 'onreadystatechange' in l('script') ? function (e) { u.appendChild(l('script')).onreadystatechange = function () { u.removeChild(this), y.call(e) } } : function (e) { setTimeout(o(y, e, 1), 0) }), e.exports = { set: f, clear: d } }, function (e, t) { e.exports = function (e) { try { return { e: !1, v: e() } } catch (e) { return { e: !0, v: e } } } }, function (e, t, r) { const n = r(29); const i = r(20); const a = r(116); e.exports = function (e, t) { if (n(e), i(t) && t.constructor === e) return t; const r = a.f(e); return (0, r.resolve)(t), r.promise } }, function (e, t, r) {
  const n = r(12); const i = r(7); const a = r(19); const o = r(25); const s = r(13)('species'); e.exports = function (e) { const t = typeof i[e] === 'function' ? i[e] : n[e]; o && t && !t[s] && a.f(t, s, { configurable: !0, get() { return this } }) };
}, function (e, t, r) { const n = r(13)('iterator'); let i = !1; try { const a = [7][n](); a.return = function () { i = !0 }, Array.from(a, () => { throw 2 }) } catch (e) {}e.exports = function (e, t) { if (!t && !i) return !1; let r = !1; try { const a = [7]; const o = a[n](); o.next = function () { return { done: r = !0 } }, a[n] = function () { return o }, e(a) } catch (e) {} return r } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(103)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'Home', components: { LoopGrid: a.default }, head: function head() { return { title: `${this.$t('home')} | Animeloop` } }, fetch: (function () { const e = (0, i.default)(n.default.mark(function _callee(e) { const t = e.store; const r = e.error; return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, t.dispatch('fetchRandomLoopList', { count: 12 }); case 3: e.next = 8; break; case 5: e.prev = 5, e.t0 = e.catch(0), r({ statusCode: 404, message: 'API returned error', customMsg: e.t0.message }); case 8: case 'end': return e.stop(); } }, _callee, this, [[0, 5]]) })); return function fetch(t) { return e.apply(this, arguments) } }()),
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(693)); const i = _interopRequireDefault(r(8)); const a = _interopRequireDefault(r(199)); const o = _interopRequireDefault(r(698)); const s = _interopRequireDefault(r(9)); const u = _interopRequireDefault(r(220)); const l = _interopRequireDefault(r(221)); const c = _interopRequireDefault(r(105)); const p = _interopRequireDefault(r(158)); const f = _interopRequireDefault(r(18)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'PageList',
    components: { SeriesGrid: c.default, FontAwesomeIcon: f.default, PageIcon: p.default },
    head: function head() { return { title: `${this.$t('list')} | Animeloop` } },
    watchQuery: ['type', 'season', 'page'],
    key: function key(e) { return e.fullPath },
    data: function data() {
      const e = this.$store.state.series.seasons; const t = (0, l.default)(e)[(0, l.default)(e).length - 1]; const r = Math.max(...(0, u.default)(e[t].map(Number))); const n = this.$route.query; const i = n.type; const a = void 0 === i ? '' : i; const o = n.season; const s = void 0 === o ? `${t}-${r}` : o; const c = n.page; return {
        selectedPageNum: (void 0 === c ? '1' : c).toString(), selectedType: a, selectedYear: s.split('-')[0], selectedMonth: s.split('-')[1], seriesTypes: ['TV', 'Movie', 'TV Short', 'OVA', 'ONA', 'Special'],
      };
    },
    fetch: (function () { const e = (0, s.default)(i.default.mark(function _callee(e) { let t; let r; let n; let s; let c; let p; let f; let d; let h; let m; const g = e.store; const v = e.query; const y = e.redirect; const b = e.error; return i.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: if (e.prev = 0, (0, l.default)(g.state.series.seasons).length !== 0) { e.next = 4; break } return e.next = 4, g.dispatch('fetchAllSeasons'); case 4: return v.page === '1' && (v.page, t = (0, o.default)(v, ['page']), y(301, '/list', t)), r = g.state.series.seasons, n = (0, l.default)(r)[(0, l.default)(r).length - 1], s = Math.max(...(0, u.default)(r[n].map(Number))), c = v.type, p = void 0 === c ? '' : c, f = v.season, d = void 0 === f ? `${n}-${s}` : f, h = v.page, m = void 0 === h ? 1 : h, e.next = 11, a.default.all([g.dispatch('fetchSeriesGroup', { type: p, season: d, page: m }), g.dispatch('fetchSeriesCount', { type: p, season: d })]); case 11: e.next = 16; break; case 13: e.prev = 13, e.t0 = e.catch(0), b({ statusCode: 404, message: 'API returned Error', customMsg: e.t0.message }); case 16: case 'end': return e.stop(); } }, _callee, this, [[0, 13]]) })); return function fetch(t) { return e.apply(this, arguments) } }()),
    computed: {
      seriesCount: function seriesCount() { return this.$store.state.series.seriesCount }, pageCount: function pageCount() { return Math.ceil(this.seriesCount / 30) }, currentPageNumInt: function currentPageNumInt() { return this.$route.query.page ? parseInt(this.$route.query.page, 10) : 1 }, prevPageQueryObj: function prevPageQueryObj() { if (this.$route.query.page === 2) { const e = this.$route.query; e.page; return (0, o.default)(e, ['page']) } return (0, n.default)({}, this.$route.query, { page: this.currentPageNumInt - 1 }) }, disablePrevPage: function disablePrevPage() { return this.currentPageNumInt === 1 }, disableNextPage: function disableNextPage() { return this.currentPageNumInt === this.pageCount }, seasons: function seasons() { return this.$store.state.series.seasons }, selectedSeason: function selectedSeason() { return `${this.selectedYear}-${this.selectedMonth}` },
    },
    methods: { pageChanged: function pageChanged() { this.$router.push({ name: 'list', query: (0, n.default)({}, this.$route.query, { page: this.selectedPageNum }) }) }, fetchNewGroup: (function () { const e = (0, s.default)(i.default.mark(function _callee2() { return i.default.wrap(function _callee2$(e) { for (;;) switch (e.prev = e.next) { case 0: return e.next = 2, a.default.all([this.$store.dispatch('fetchSeriesGroup', { type: this.selectedType, season: this.selectedSeason, page: this.selectedPageNum }), this.$store.dispatch('fetchSeriesCount', { type: this.selectedType, season: this.selectedSeason })]); case 2: case 'end': return e.stop(); } }, _callee2, this) })); return function fetchNewGroup() { return e.apply(this, arguments) } }()), applyFilter: function applyFilter() { const e = { season: this.selectedSeason }; (0, n.default)(e, this.selectedType && { type: this.selectedType }), this.$router.push({ name: 'list', query: e }) } },
  };
}, function (e, t) { t.f = {}.propertyIsEnumerable }, function (e, t, r) {
  t.__esModule = !0; const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(699))); t.default = function (e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return (0, n.default)(e) };
}, function (e, t, r) { e.exports = { default: r(703), __esModule: !0 } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(173)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'PageLoopID',
    components: { LoopPage: a.default },
    head: function head() { return { title: `${this.loop.episode.no} | ${this.i18nTitle} | Animeloop`, meta: [{ hid: 'twitter:card', name: 'twitter:card', content: 'player' }, { hid: 'twitter:site', name: 'twitter:site', content: '@animeloopbot' }, { hid: 'twitter:title', name: 'twitter:title', content: `${this.loop.series.titleJA} | ${this.formattedTimeStamps.begin} - ${this.formattedTimeStamps.end}` }, { hid: 'twitter:description', name: 'twitter:description', content: 'View the loop on Animeloop.' }, { hid: 'twitter:image', name: 'twitter:image', content: this.loop.files.jpg_1080p }, { hid: 'og:title', name: 'og:title', content: `${this.loop.series.titleJA} | ${this.formattedTimeStamps.begin} - ${this.formattedTimeStamps.end}` }, { hid: 'og:image', name: 'og:image', content: this.loop.files.jpg_1080p }, { hid: 'og:description', property: 'og:description', content: 'View the loop on Animeloop.' }, { hid: 'og:site_name', name: 'og:site_name', content: 'Animeloop Beta' }, { hid: 'og:video:secure_url', property: 'og:video:secure_url', content: this.loop.files.mp4_1080p }, { hid: 'og:video:type', property: 'og:video:type', content: 'video/mp4' }, { hid: 'og:video:width', property: 'og:video:width', content: '1920' }, { hid: 'og:video:height', property: 'og:video:height', content: '1080' }] } },
    fetch: (function () { const e = (0, i.default)(n.default.mark(function _callee(e) { const t = e.store; const r = e.error; const i = e.params.id; return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, t.dispatch('fetchLoopByID', { loopid: i }); case 3: e.next = 8; break; case 5: e.prev = 5, e.t0 = e.catch(0), r({ statusCode: 404, message: 'API returned Error', customMsg: e.t0.message }); case 8: case 'end': return e.stop(); } }, _callee, this, [[0, 5]]) })); return function fetch(t) { return e.apply(this, arguments) } }()),
    validate: function validate(e) { const t = e.params; return /^[a-z0-9]{24}$/.test(t.id) },
    computed: {
      i18nTitle: function i18nTitle() { switch (this.currentLocale) { case 'ja': return this.loop.series.titleJA; case 'zh': return this.loop.series.title; case 'en': default: return this.loop.series.titleEN; } }, currentLocale: function currentLocale() { return this.$store.state.i18n.locale }, loop: function loop() { return this.$store.state.loop.loops[this.$route.params.id] }, formattedTimeStamps: function formattedTimeStamps() { return this.$store.getters.formatTimeStamps(this.$route.params.id) },
    },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = { name: 'PageRandom', fetch: (function () { const e = (0, i.default)(n.default.mark(function _callee(e) { let t; const r = e.store; const i = e.error; const a = e.redirect; return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, r.dispatch('fetchRandomLoop'); case 3: e.next = 8; break; case 5: e.prev = 5, e.t0 = e.catch(0), i({ statusCode: 404, message: 'API returned Error' }); case 8: t = r.state.loop.randomPageLoopid, a(302, `/loop/${t}`); case 10: case 'end': return e.stop(); } }, _callee, this, [[0, 5]]) })); return function fetch(t) { return e.apply(this, arguments) } }()) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(105)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'PageSearch',
    components: { SeriesGrid: a.default },
    head: function head() { return { title: this.hasKeyword ? `"${this.keyword}" | ${this.$t('search')} | Animeloop` : `${this.$t('search')} | Animeloop` } },
    asyncData: function asyncData(e) { return { hasKeyword: !!e.query.keyword } },
    data: function data() { return { errMsg: '' } },
    computed: {
      keyword: function keyword() { return this.$route.query.keyword || '' }, isSearching: function isSearching() { return this.$store.state.search.isSearching }, isEmptyResult: function isEmptyResult() { return !(Array.isArray(this.searchResult) && this.searchResult.length !== 0) }, searchResult: function searchResult() { return this.$store.state.search.searchResult },
    },
    created: function created() { this.hasKeyword && this.dispatchSearch() },
    methods: { dispatchSearch: (function () { const e = (0, i.default)(n.default.mark(function _callee() { return n.default.wrap(function _callee$(e) { for (;;) switch (e.prev = e.next) { case 0: return this.$router.push({ path: '/search', query: { keyword: this.keyword } }), e.prev = 1, e.next = 4, this.$store.dispatch('fetchSeriesByString', { searchString: this.keyword }); case 4: e.next = 9; break; case 6: e.prev = 6, e.t0 = e.catch(1), this.errMsg = e.t0.message; case 9: case 'end': return e.stop(); } }, _callee, this, [[1, 6]]) })); return function dispatchSearch() { return e.apply(this, arguments) } }()) },
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(106)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = {
    name: 'PageSeriesID', components: { SeriesPage: a.default }, data: function data() { return { selectedEpisodeID: '' } }, fetch: (function () { const e = (0, i.default)(n.default.mark(function _callee(e) { const t = e.store; const r = e.error; const i = e.params.id; return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, t.dispatch('fetchSeriesByID', { seriesid: i }); case 3: e.next = 8; break; case 5: e.prev = 5, e.t0 = e.catch(0), r({ statusCode: 404, message: 'API returned Error', customMsg: e.t0.message }); case 8: case 'end': return e.stop(); } }, _callee, this, [[0, 5]]) })); return function fetch(t) { return e.apply(this, arguments) } }()), validate: function validate(e) { const t = e.params; return /^[a-z0-9]{24}$/.test(t.id) }, computed: { series: function series() { return this.$store.state.series.series[this.$route.params.id] } },
  };
}, function (e, t, r) {
  const n = Object.prototype.hasOwnProperty; const i = (function () { for (var e = [], t = 0; t < 256; ++t)e.push(`%${((t < 16 ? '0' : '') + t.toString(16)).toUpperCase()}`); return e }()); t.arrayToObject = function arrayToObject(e, t) { for (var r = t && t.plainObjects ? Object.create(null) : {}, n = 0; n < e.length; ++n) void 0 !== e[n] && (r[n] = e[n]); return r }, t.merge = function merge(e, r, i) { if (!r) return e; if (typeof r !== 'object') { if (Array.isArray(e))e.push(r); else { if (typeof e !== 'object') return [e, r]; (i.plainObjects || i.allowPrototypes || !n.call(Object.prototype, r)) && (e[r] = !0) } return e } if (typeof e !== 'object') return [e].concat(r); let a = e; return Array.isArray(e) && !Array.isArray(r) && (a = t.arrayToObject(e, i)), Array.isArray(e) && Array.isArray(r) ? (r.forEach((r, a) => { n.call(e, a) ? e[a] && typeof e[a] === 'object' ? e[a] = t.merge(e[a], r, i) : e.push(r) : e[a] = r }), e) : Object.keys(r).reduce((e, a) => { const o = r[a]; return n.call(e, a) ? e[a] = t.merge(e[a], o, i) : e[a] = o, e }, a) }, t.assign = function assignSingleSource(e, t) { return Object.keys(t).reduce((e, r) => e[r] = t[r], e, e) }, t.decode = function (e) { try { return decodeURIComponent(e.replace(/\+/g, ' ')) } catch (t) { return e } }, t.encode = function encode(e) { if (e.length === 0) return e; for (var t = typeof e === 'string' ? e : String(e), r = '', n = 0; n < t.length; ++n) { let a = t.charCodeAt(n); a === 45 || a === 46 || a === 95 || a === 126 || a >= 48 && a <= 57 || a >= 65 && a <= 90 || a >= 97 && a <= 122 ? r += t.charAt(n) : a < 128 ? r += i[a] : a < 2048 ? r += i[192 | a >> 6] + i[128 | 63 & a] : a < 55296 || a >= 57344 ? r += i[224 | a >> 12] + i[128 | a >> 6 & 63] + i[128 | 63 & a] : (n += 1, a = 65536 + ((1023 & a) << 10 | 1023 & t.charCodeAt(n)), r += i[240 | a >> 18] + i[128 | a >> 12 & 63] + i[128 | a >> 6 & 63] + i[128 | 63 & a]) } return r }, t.compact = function compact(e) { for (var t = [{ obj: { o: e }, prop: 'o' }], r = [], n = 0; n < t.length; ++n) for (let i = t[n], a = i.obj[i.prop], o = Object.keys(a), s = 0; s < o.length; ++s) { const u = o[s]; const l = a[u]; typeof l === 'object' && l !== null && r.indexOf(l) === -1 && (t.push({ obj: a, prop: u }), r.push(l)) } return (function compactQueue(e) { for (var t; e.length;) { const r = e.pop(); if (t = r.obj[r.prop], Array.isArray(t)) { for (var n = [], i = 0; i < t.length; ++i) void 0 !== t[i] && n.push(t[i]); r.obj[r.prop] = n } } return t }(t)) }, t.isRegExp = function isRegExp(e) { return Object.prototype.toString.call(e) === '[object RegExp]' }, t.isBuffer = function isBuffer(e) { return e !== null && void 0 !== e && !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e)) };
}, function (e, t, r) {
  const n = String.prototype.replace; const i = /%20/g; e.exports = {
    default: 'RFC3986', formatters: { RFC1738(e) { return n.call(e, i, '+') }, RFC3986(e) { return e } }, RFC1738: 'RFC1738', RFC3986: 'RFC3986',
  };
}, function (e, t, r) {
  const n = r(113)('meta'); const i = r(20); const a = r(40); const o = r(19).f; let s = 0; const u = Object.isExtensible || function () { return !0 }; const l = !r(33)(() => u(Object.preventExtensions({}))); const c = function (e) { o(e, n, { value: { i: `O${++s}`, w: {} } }) }; var p = e.exports = {
    KEY: n, NEED: !1, fastKey(e, t) { if (!i(e)) return typeof e === 'symbol' ? e : (typeof e === 'string' ? 'S' : 'P') + e; if (!a(e, n)) { if (!u(e)) return 'F'; if (!t) return 'E'; c(e) } return e[n].i }, getWeak(e, t) { if (!a(e, n)) { if (!u(e)) return !0; if (!t) return !1; c(e) } return e[n].w }, onFreeze(e) { return l && p.NEED && u(e) && !a(e, n) && c(e), e },
  };
}, function (e, t, r) { const n = r(20); e.exports = function (e, t) { if (!n(e) || e._t !== t) throw TypeError(`Incompatible receiver, ${t} required!`); return e } }, function (e, t, r) { let n; let i; const a = {}; const o = (n = function () { return window && document && document.all && !window.atob }, function () { return void 0 === i && (i = n.apply(this, arguments)), i }); const s = (function (e) { const t = {}; return function (e) { if (typeof e === 'function') return e(); if (void 0 === t[e]) { let r = function (e) { return document.querySelector(e) }.call(this, e); if (window.HTMLIFrameElement && r instanceof window.HTMLIFrameElement) try { r = r.contentDocument.head } catch (e) { r = null }t[e] = r } return t[e] } }()); let u = null; let l = 0; const c = []; const p = r(356); function addStylesToDom(e, t) { for (let r = 0; r < e.length; r++) { const n = e[r]; const i = a[n.id]; if (i) { i.refs++; for (var o = 0; o < i.parts.length; o++)i.parts[o](n.parts[o]); for (;o < n.parts.length; o++)i.parts.push(addStyle(n.parts[o], t)); } else { const s = []; for (o = 0; o < n.parts.length; o++)s.push(addStyle(n.parts[o], t)); a[n.id] = { id: n.id, refs: 1, parts: s } } } } function listToStyles(e, t) { for (var r = [], n = {}, i = 0; i < e.length; i++) { const a = e[i]; const o = t.base ? a[0] + t.base : a[0]; const s = { css: a[1], media: a[2], sourceMap: a[3] }; n[o] ? n[o].parts.push(s) : r.push(n[o] = { id: o, parts: [s] }) } return r } function insertStyleElement(e, t) { const r = s(e.insertInto); if (!r) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid."); const n = c[c.length - 1]; if (e.insertAt === 'top')n ? n.nextSibling ? r.insertBefore(t, n.nextSibling) : r.appendChild(t) : r.insertBefore(t, r.firstChild), c.push(t); else if (e.insertAt === 'bottom')r.appendChild(t); else { if (typeof e.insertAt !== 'object' || !e.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n"); const i = s(`${e.insertInto} ${e.insertAt.before}`); r.insertBefore(t, i) } } function removeStyleElement(e) { if (e.parentNode === null) return !1; e.parentNode.removeChild(e); const t = c.indexOf(e); t >= 0 && c.splice(t, 1) } function createStyleElement(e) { const t = document.createElement('style'); return e.attrs.type = 'text/css', addAttrs(t, e.attrs), insertStyleElement(e, t), t } function addAttrs(e, t) { Object.keys(t).forEach((r) => { e.setAttribute(r, t[r]) }) } function addStyle(e, t) { let r; let n; let i; let a; if (t.transform && e.css) { if (!(a = t.transform(e.css))) return function () {}; e.css = a } if (t.singleton) { const o = l++; r = u || (u = createStyleElement(t)), n = applyToSingletonTag.bind(null, r, o, !1), i = applyToSingletonTag.bind(null, r, o, !0) } else e.sourceMap && typeof URL === 'function' && typeof URL.createObjectURL === 'function' && typeof URL.revokeObjectURL === 'function' && typeof Blob === 'function' && typeof btoa === 'function' ? (r = (function createLinkElement(e) { const t = document.createElement('link'); return e.attrs.type = 'text/css', e.attrs.rel = 'stylesheet', addAttrs(t, e.attrs), insertStyleElement(e, t), t }(t)), n = function updateLink(e, t, r) { let n = r.css; const i = r.sourceMap; const a = void 0 === t.convertToAbsoluteUrls && i; (t.convertToAbsoluteUrls || a) && (n = p(n)); i && (n += `\n/*# sourceMappingURL=data:application/json;base64,${btoa(unescape(encodeURIComponent(JSON.stringify(i))))} */`); const o = new Blob([n], { type: 'text/css' }); const s = e.href; e.href = URL.createObjectURL(o), s && URL.revokeObjectURL(s) }.bind(null, r, t), i = function () { removeStyleElement(r), r.href && URL.revokeObjectURL(r.href) }) : (r = createStyleElement(t), n = function applyToTag(e, t) { const r = t.css; const n = t.media; n && e.setAttribute('media', n); if (e.styleSheet)e.styleSheet.cssText = r; else { for (;e.firstChild;)e.removeChild(e.firstChild); e.appendChild(document.createTextNode(r)) } }.bind(null, r), i = function () { removeStyleElement(r) }); return n(e), function updateStyle(t) { if (t) { if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap) return; n(e = t) } else i(); } }e.exports = function (e, t) { if (typeof DEBUG !== 'undefined' && DEBUG && typeof document !== 'object') throw new Error('The style-loader cannot be used in a non-browser environment'); (t = t || {}).attrs = typeof t.attrs === 'object' ? t.attrs : {}, t.singleton || typeof t.singleton === 'boolean' || (t.singleton = o()), t.insertInto || (t.insertInto = 'head'), t.insertAt || (t.insertAt = 'bottom'); const r = listToStyles(e, t); return addStylesToDom(r, t), function update(e) { for (var n = [], i = 0; i < r.length; i++) { const o = r[i]; (s = a[o.id]).refs--, n.push(s) }e && addStylesToDom(listToStyles(e, t), t); for (i = 0; i < n.length; i++) { var s; if ((s = n[i]).refs === 0) { for (let u = 0; u < s.parts.length; u++)s.parts[u](); delete a[s.id] } } } }; let f; const d = (f = [], function (e, t) { return f[e] = t, f.filter(Boolean).join('\n') }); function applyToSingletonTag(e, t, r, n) { const i = r ? '' : n.css; if (e.styleSheet)e.styleSheet.cssText = d(t, i); else { const a = document.createTextNode(i); const o = e.childNodes; o[t] && e.removeChild(o[t]), o.length ? e.insertBefore(a, o[t]) : e.appendChild(a) } } }, function (e, t, r) { const n = r(15); const i = r(354); const a = r(355); const o = 'Expected a function'; const s = Math.max; const u = Math.min; e.exports = function debounce(e, t, r) { let l; let c; let p; let f; let d; let h; let m = 0; let g = !1; let v = !1; let y = !0; if (typeof e !== 'function') throw new TypeError(o); function invokeFunc(t) { const r = l; const n = c; return l = c = void 0, m = t, f = e.apply(n, r) } function shouldInvoke(e) { const r = e - h; return void 0 === h || r >= t || r < 0 || v && e - m >= p } function timerExpired() { const e = i(); if (shouldInvoke(e)) return trailingEdge(e); d = setTimeout(timerExpired, (function remainingWait(e) { const r = t - (e - h); return v ? u(r, p - (e - m)) : r }(e))) } function trailingEdge(e) { return d = void 0, y && l ? invokeFunc(e) : (l = c = void 0, f) } function debounced() { const e = i(); const r = shouldInvoke(e); if (l = arguments, c = this, h = e, r) { if (void 0 === d) return (function leadingEdge(e) { return m = e, d = setTimeout(timerExpired, t), g ? invokeFunc(e) : f }(h)); if (v) return d = setTimeout(timerExpired, t), invokeFunc(h); } return void 0 === d && (d = setTimeout(timerExpired, t)), f } return t = a(t) || 0, n(r) && (g = !!r.leading, p = (v = 'maxWait' in r) ? s(a(r.maxWait) || 0, t) : p, y = 'trailing' in r ? !!r.trailing : y), debounced.cancel = function cancel() { void 0 !== d && clearTimeout(d), m = 0, l = h = c = d = void 0 }, debounced.flush = function flush() { return void 0 === d ? f : trailingEdge(i()) }, debounced } }, function (e, t, r) { e.exports = r(233) }, function (e, t, r) {
  r(234), r(240); const n = _interopRequireDefault(r(274)); const i = _interopRequireDefault(r(285)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const a = 0; const o = function render() { const e = r(550); let t = 'rsg-root'; document.getElementById('app') && (console.warn("The use of 'app' element id in the template is deprecated. Please, update your template file to use 'rsg-root' as the container id."), t = 'app'), n.default.render((0, i.default)(e, a), document.getElementById(t)) }; window.addEventListener('hashchange', o), window.addEventListener('hashchange', () => { window.location.hash.indexOf('#!/') === 0 && window.scrollTo(0, 0) }), o();
}, function (e, t, r) {
  r(235), r(236), r(238);
}, function (e, t) { !(function () { const e = /^\s*function\s+([^\(\s]*)\s*/; function _name() { let t; let r; return this === Function || this === Function.prototype.constructor ? r = 'Function' : this !== Function.prototype && (r = (t = (`${this}`).match(e)) && t[1]), r || '' } const t = !('name' in Function.prototype && 'name' in function x() {}); const r = typeof Object.defineProperty === 'function' && (function () { let e; try { Object.defineProperty(Function.prototype, '_xyz', { get() { return 'blah' }, configurable: !0 }), e = Function.prototype._xyz === 'blah', delete Function.prototype._xyz } catch (t) { e = !1 } return e }()); const n = typeof Object.prototype.__defineGetter__ === 'function' && (function () { let e; try { Function.prototype.__defineGetter__('_abc', () => 'foo'), e = Function.prototype._abc === 'foo', delete Function.prototype._abc } catch (t) { e = !1 } return e }()); Function.prototype._name = _name, t && (r ? Object.defineProperty(Function.prototype, 'name', { get() { const e = _name.call(this); return this !== Function.prototype && Object.defineProperty(this, 'name', { value: e, configurable: !0 }), e }, configurable: !0 }) : n && Function.prototype.__defineGetter__('name', function () { const e = _name.call(this); return this !== Function.prototype && this.__defineGetter__('name', () => e), e })) }()) }, function (e, t, r) {
  r(237).polyfill();
}, function (e, t, r) {
  function assign(e, t) { if (void 0 === e || e === null) throw new TypeError('Cannot convert first argument to object'); for (var r = Object(e), n = 1; n < arguments.length; n++) { const i = arguments[n]; if (void 0 !== i && i !== null) for (let a = Object.keys(Object(i)), o = 0, s = a.length; o < s; o++) { const u = a[o]; const l = Object.getOwnPropertyDescriptor(i, u); void 0 !== l && l.enumerable && (r[u] = i[u]) } } return r }e.exports = {
    assign,
    polyfill: function polyfill() {
      Object.assign || Object.defineProperty(Object, 'assign', {
        enumerable: !1, configurable: !0, writable: !0, value: assign,
      });
    },
  };
}, function (e, t, r) {
  e.exports = r(239).polyfill();
}, function (e, t, r) {
  (function (t, r) {
    /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */let n; n = function () {
      function isFunction(e) { return typeof e === 'function' } const e = Array.isArray ? Array.isArray : function (e) { return Object.prototype.toString.call(e) === '[object Array]' }; let n = 0; let i = void 0; let a = void 0; let o = function asap(e, t) { f[n] = e, f[n + 1] = t, (n += 2) === 2 && (a ? a(flush) : d()) }; const s = typeof window !== 'undefined' ? window : void 0; const u = s || {}; const l = u.MutationObserver || u.WebKitMutationObserver; const c = typeof self === 'undefined' && void 0 !== t && {}.toString.call(t) === '[object process]'; const p = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; function useSetTimeout() { const e = setTimeout; return function () { return e(flush, 1) } } var f = new Array(1e3); function flush() { for (let e = 0; e < n; e += 2) { (0, f[e])(f[e + 1]), f[e] = void 0, f[e + 1] = void 0 }n = 0 } var d = void 0; function then(e, t) { const r = this; const n = new this.constructor(noop); void 0 === n[h] && makePromise(n); const i = r._state; if (i) { const a = arguments[i - 1]; o(() => invokeCallback(i, n, a, r._result)) } else subscribe(r, n, e, t); return n } function resolve$1(e) { if (e && typeof e === 'object' && e.constructor === this) return e; const t = new this(noop); return resolve(t, e), t }d = c ? (function useNextTick() { return function () { return t.nextTick(flush) } }()) : l ? (function useMutationObserver() { let e = 0; const t = new l(flush); const r = document.createTextNode(''); return t.observe(r, { characterData: !0 }), function () { r.data = e = ++e % 2 } }()) : p ? (function useMessageChannel() { const e = new MessageChannel(); return e.port1.onmessage = flush, function () { return e.port2.postMessage(0) } }()) : void 0 === s ? (function attemptVertx() { try { const e = Function('return this')().require('vertx'); return i = e.runOnLoop || e.runOnContext, (function useVertxTimer() { return void 0 !== i ? function () { i(flush) } : useSetTimeout() }()) } catch (e) { return useSetTimeout() } }()) : useSetTimeout(); var h = Math.random().toString(36).substring(2); function noop() {} const m = void 0; const g = 1; const v = 2; const y = { error: null }; function getThen(e) { try { return e.then } catch (e) { return y.error = e, y } } function handleMaybeThenable(e, t, r) { t.constructor === e.constructor && r === then && t.constructor.resolve === resolve$1 ? (function handleOwnThenable(e, t) { t._state === g ? fulfill(e, t._result) : t._state === v ? reject(e, t._result) : subscribe(t, void 0, t => resolve(e, t), t => reject(e, t)) }(e, t)) : r === y ? (reject(e, y.error), y.error = null) : void 0 === r ? fulfill(e, t) : isFunction(r) ? (function handleForeignThenable(e, t, r) { o((e) => { let n = !1; const i = (function tryThen(e, t, r, n) { try { e.call(t, r, n) } catch (e) { return e } }(r, t, (r) => { n || (n = !0, t !== r ? resolve(e, r) : fulfill(e, r)) }, (t) => { n || (n = !0, reject(e, t)) }, e._label)); !n && i && (n = !0, reject(e, i)) }, e) }(e, t, r)) : fulfill(e, t) } function resolve(e, t) { e === t ? reject(e, (function selfFulfillment() { return new TypeError('You cannot resolve a promise with itself') }())) : !(function objectOrFunction(e) { const t = typeof e; return e !== null && (t === 'object' || t === 'function') }(t)) ? fulfill(e, t) : handleMaybeThenable(e, t, getThen(t)) } function publishRejection(e) { e._onerror && e._onerror(e._result), publish(e) } function fulfill(e, t) { e._state === m && (e._result = t, e._state = g, e._subscribers.length !== 0 && o(publish, e)) } function reject(e, t) { e._state === m && (e._state = v, e._result = t, o(publishRejection, e)) } function subscribe(e, t, r, n) { const i = e._subscribers; const a = i.length; e._onerror = null, i[a] = t, i[a + g] = r, i[a + v] = n, a === 0 && e._state && o(publish, e) } function publish(e) { const t = e._subscribers; const r = e._state; if (t.length !== 0) { for (let n = void 0, i = void 0, a = e._result, o = 0; o < t.length; o += 3)n = t[o], i = t[o + r], n ? invokeCallback(r, n, i, a) : i(a); e._subscribers.length = 0 } } function invokeCallback(e, t, r, n) { const i = isFunction(r); let a = void 0; let o = void 0; let s = void 0; let u = void 0; if (i) { if ((a = (function tryCatch(e, t) { try { return e(t) } catch (e) { return y.error = e, y } }(r, n))) === y ? (u = !0, o = a.error, a.error = null) : s = !0, t === a) return void reject(t, (function cannotReturnOwn() { return new TypeError('A promises callback cannot return that same promise.') }())); } else a = n, s = !0; t._state !== m || (i && s ? resolve(t, a) : u ? reject(t, o) : e === g ? fulfill(t, a) : e === v && reject(t, a)) } let b = 0; function makePromise(e) { e[h] = b++, e._state = void 0, e._result = void 0, e._subscribers = [] } const x = (function () { function Enumerator(t, r) { this._instanceConstructor = t, this.promise = new t(noop), this.promise[h] || makePromise(this.promise), e(r) ? (this.length = r.length, this._remaining = r.length, this._result = new Array(this.length), this.length === 0 ? fulfill(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(r), this._remaining === 0 && fulfill(this.promise, this._result))) : reject(this.promise, (function validationError() { return new Error('Array Methods must be provided an Array') }())) } return Enumerator.prototype._enumerate = function _enumerate(e) { for (let t = 0; this._state === m && t < e.length; t++) this._eachEntry(e[t], t); }, Enumerator.prototype._eachEntry = function _eachEntry(e, t) { const r = this._instanceConstructor; const n = r.resolve; if (n === resolve$1) { const i = getThen(e); if (i === then && e._state !== m) this._settledAt(e._state, t, e._result); else if (typeof i !== 'function') this._remaining--, this._result[t] = e; else if (r === D) { const a = new r(noop); handleMaybeThenable(a, e, i), this._willSettleAt(a, t) } else this._willSettleAt(new r((t => t(e))), t); } else this._willSettleAt(n(e), t); }, Enumerator.prototype._settledAt = function _settledAt(e, t, r) { const n = this.promise; n._state === m && (this._remaining--, e === v ? reject(n, r) : this._result[t] = r), this._remaining === 0 && fulfill(n, this._result) }, Enumerator.prototype._willSettleAt = function _willSettleAt(e, t) { const r = this; subscribe(e, void 0, e => r._settledAt(g, t, e), e => r._settledAt(v, t, e)) }, Enumerator }()); var D = (function () { function Promise(e) { this[h] = (function nextId() { return b++ }()), this._result = this._state = void 0, this._subscribers = [], noop !== e && (typeof e !== 'function' && (function needsResolver() { throw new TypeError('You must pass a resolver function as the first argument to the promise constructor') }()), this instanceof Promise ? (function initializePromise(e, t) { try { t((t) => { resolve(e, t) }, (t) => { reject(e, t) }) } catch (t) { reject(e, t) } }(this, e)) : (function needsNew() { throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.") }())) } return Promise.prototype.catch = function _catch(e) { return this.then(null, e) }, Promise.prototype.finally = function _finally(e) { const t = this.constructor; return this.then(r => t.resolve(e()).then(() => r), r => t.resolve(e()).then(() => { throw r })) }, Promise }()); return D.prototype.then = then, D.all = function all(e) { return new x(this, e).promise }, D.race = function race(t) { const r = this; return e(t) ? new r(((e, n) => { for (let i = t.length, a = 0; a < i; a++)r.resolve(t[a]).then(e, n); })) : new r(((e, t) => t(new TypeError('You must pass an array to race.')))) }, D.resolve = resolve$1, D.reject = function reject$1(e) { const t = new this(noop); return reject(t, e), t }, D._setScheduler = function setScheduler(e) { a = e }, D._setAsap = function setAsap(e) { o = e }, D._asap = o, D.polyfill = function polyfill() { let e = void 0; if (void 0 !== r)e = r; else if (typeof self !== 'undefined')e = self; else try { e = Function('return this')() } catch (e) { throw new Error('polyfill failed because global object is unavailable in this environment') } const t = e.Promise; if (t) { let n = null; try { n = Object.prototype.toString.call(t.resolve()) } catch (e) {} if (n === '[object Promise]' && !t.cast) return; }e.Promise = D }, D.Promise = D, D;
    }, e.exports = n();
  }).call(t, r(45), r(14));
}, function (e, t, r) {
  r(68), r(273);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; t.default = function getDynamicStyles(e) { let t = null; for (const r in e) { const i = e[r]; const a = void 0 === i ? 'undefined' : n(i); if (a === 'function')t || (t = {}), t[r] = i; else if (a === 'object' && i !== null && !Array.isArray(i)) { const o = getDynamicStyles(i); o && (t || (t = {}), t[r] = o) } } return t };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(21))); const a = (function () { function SheetsManager() { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, SheetsManager)), this.sheets = [], this.refs = [], this.keys = [] } return n(SheetsManager, [{ key: 'get', value: function get(e) { const t = this.keys.indexOf(e); return this.sheets[t] } }, { key: 'add', value: function add(e, t) { const r = this.sheets; const n = this.refs; const i = this.keys; const a = r.indexOf(t); return a !== -1 ? a : (r.push(t), n.push(0), i.push(e), r.length - 1) } }, { key: 'manage', value: function manage(e) { const t = this.keys.indexOf(e); const r = this.sheets[t]; return this.refs[t] === 0 && r.attach(), this.refs[t]++, this.keys[t] || this.keys.splice(t, 0, e), r } }, { key: 'unmanage', value: function unmanage(e) { const t = this.keys.indexOf(e); t !== -1 ? this.refs[t] > 0 && (this.refs[t]--, this.refs[t] === 0 && this.sheets[t].detach()) : (0, i.default)(!1, "SheetsManager: can't find sheet to unmanage") } }, { key: 'size', get: function get() { return this.keys.length } }]), SheetsManager }()); t.default = a;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; t.default = function cloneStyle(e) { if (e == null) return e; const t = void 0 === e ? 'undefined' : n(e); if (t === 'string' || t === 'number' || t === 'function') return e; if (a(e)) return e.map(cloneStyle); if ((0, i.default)(e)) return e; const r = {}; for (const o in e) { const s = e[o]; (void 0 === s ? 'undefined' : n(s)) !== 'object' ? r[o] = s : r[o] = cloneStyle(s) } return r }; var i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(120))); var a = Array.isArray;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), function (e, n) { let i; const a = r(246); i = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : void 0 !== e ? e : n; const o = Object(a.a)(i); t.default = o }.call(t, r(14), r(245)(e));
}, function (e, t) { e.exports = function (e) { if (!e.webpackPolyfill) { var t = Object.create(e); t.children || (t.children = []), Object.defineProperty(t, 'loaded', { enumerable: !0, get() { return t.l } }), Object.defineProperty(t, 'id', { enumerable: !0, get() { return t.i } }), Object.defineProperty(t, 'exports', { enumerable: !0 }), t.webpackPolyfill = 1 } return t } }, function (e, t, r) {
  t.a = function symbolObservablePonyfill(e) { let t; const r = e.Symbol; typeof r === 'function' ? r.observable ? t = r.observable : (t = r('observable'), r.observable = t) : t = '@@observable'; return t };
}, function (e, t, r) {
  (function (e) { Object.defineProperty(t, '__esModule', { value: !0 }); e.CSS; t.default = function (e) { return e } }).call(t, r(14));
}, function (e, t, r) {
  (function (e) { Object.defineProperty(t, '__esModule', { value: !0 }); const r = '2f1acc6c3a606b082e5eef5e54414ffb'; e[r] == null && (e[r] = 0), t.default = e[r]++ }).call(t, r(14));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; const i = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const a = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const o = _interopRequireDefault(r(250)); const s = _interopRequireDefault(r(123)); const u = _interopRequireDefault(r(251)); const l = _interopRequireDefault(r(252)); const c = _interopRequireDefault(r(258)); const p = _interopRequireDefault(r(259)); const f = _interopRequireDefault(r(70)); const d = _interopRequireDefault(r(30)); const h = _interopRequireDefault(r(122)); const m = _interopRequireDefault(r(47)); const g = _interopRequireDefault(r(260)); const v = _interopRequireDefault(r(261)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const y = l.default.concat([c.default, p.default]); let b = 0; const x = (function () {
    function Jss(e) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, Jss)), this.id = b++, this.version = '9.8.1', this.plugins = new u.default(), this.options = { createGenerateClassName: h.default, Renderer: o.default ? g.default : v.default, plugins: [] }, this.generateClassName = (0, h.default)(), this.use.apply(this, y), this.setup(e) } return a(Jss, [{ key: 'setup', value: function setup() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e.createGenerateClassName && (this.options.createGenerateClassName = e.createGenerateClassName, this.generateClassName = e.createGenerateClassName()), e.insertionPoint != null && (this.options.insertionPoint = e.insertionPoint), (e.virtual || e.Renderer) && (this.options.Renderer = e.Renderer || (e.virtual ? v.default : g.default)), e.plugins && this.use.apply(this, e.plugins), this } }, {
      key: 'createStyleSheet',
      value: function createStyleSheet(e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let r = t.index; typeof r !== 'number' && (r = f.default.index === 0 ? 0 : f.default.index + 1); const n = new s.default(e, i({}, t, {
          jss: this, generateClassName: t.generateClassName || this.generateClassName, insertionPoint: this.options.insertionPoint, Renderer: this.options.Renderer, index: r,
        })); return this.plugins.onProcessSheet(n), n;
      },
    }, { key: 'removeStyleSheet', value: function removeStyleSheet(e) { return e.detach(), f.default.remove(e), this } }, { key: 'createRule', value: function createRule(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; (void 0 === e ? 'undefined' : n(e)) === 'object' && (r = t, t = e, e = void 0); const i = r; i.jss = this, i.Renderer = this.options.Renderer, i.generateClassName || (i.generateClassName = this.generateClassName), i.classes || (i.classes = {}); const a = (0, m.default)(e, t, i); return !i.selector && a instanceof d.default && (a.selector = `.${i.generateClassName(a)}`), this.plugins.onProcessRule(a), a } }, { key: 'use', value: function use() { for (var e = this, t = arguments.length, r = Array(t), n = 0; n < t; n++)r[n] = arguments[n]; return r.forEach((t) => { e.options.plugins.indexOf(t) === -1 && (e.options.plugins.push(t), e.plugins.use(t)) }), this } }]), Jss;
  }()); t.default = x;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), r.d(t, 'isBrowser', () => i); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; var i = (typeof window === 'undefined' ? 'undefined' : n(window)) === 'object' && (typeof document === 'undefined' ? 'undefined' : n(document)) === 'object' && document.nodeType === 9; t.default = i;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(21))); const a = (function () {
    function PluginsRegistry() {
      !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, PluginsRegistry)), this.hooks = {
        onCreateRule: [], onProcessRule: [], onProcessStyle: [], onProcessSheet: [], onChangeValue: [], onUpdate: [],
      };
    } return n(PluginsRegistry, [{ key: 'onCreateRule', value: function onCreateRule(e, t, r) { for (let n = 0; n < this.hooks.onCreateRule.length; n++) { const i = this.hooks.onCreateRule[n](e, t, r); if (i) return i; } return null } }, { key: 'onProcessRule', value: function onProcessRule(e) { if (!e.isProcessed) { for (var t = e.options.sheet, r = 0; r < this.hooks.onProcessRule.length; r++) this.hooks.onProcessRule[r](e, t); e.style && this.onProcessStyle(e.style, e, t), e.isProcessed = !0 } } }, { key: 'onProcessStyle', value: function onProcessStyle(e, t, r) { for (let n = e, i = 0; i < this.hooks.onProcessStyle.length; i++)n = this.hooks.onProcessStyle[i](n, t, r), t.style = n; } }, { key: 'onProcessSheet', value: function onProcessSheet(e) { for (let t = 0; t < this.hooks.onProcessSheet.length; t++) this.hooks.onProcessSheet[t](e); } }, { key: 'onUpdate', value: function onUpdate(e, t, r) { for (let n = 0; n < this.hooks.onUpdate.length; n++) this.hooks.onUpdate[n](e, t, r); } }, { key: 'onChangeValue', value: function onChangeValue(e, t, r) { for (var n = e, i = 0; i < this.hooks.onChangeValue.length; i++)n = this.hooks.onChangeValue[i](n, t, r); return n } }, { key: 'use', value: function use(e) { for (const t in e) this.hooks[t] ? this.hooks[t].push(e[t]) : (0, i.default)(!1, '[JSS] Unknown hook "%s".', t); } }]), PluginsRegistry;
  }()); t.default = a;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(253)); const i = _interopRequireDefault(r(254)); const a = _interopRequireDefault(r(255)); const o = _interopRequireDefault(r(256)); const s = _interopRequireDefault(r(257)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const u = {
    '@charset': n.default, '@import': n.default, '@namespace': n.default, '@keyframes': i.default, '@media': a.default, '@supports': a.default, '@font-face': o.default, '@viewport': s.default, '@-ms-viewport': s.default,
  }; t.default = Object.keys(u).map((e) => { const t = new RegExp(`^${e}`); return { onCreateRule: function onCreateRule(r, n, i) { return t.test(r) ? new u[e](r, n, i) : null } } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function () { function SimpleRule(e, t, r) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, SimpleRule)), this.type = 'simple', this.isProcessed = !1, this.key = e, this.value = t, this.options = r } return n(SimpleRule, [{ key: 'toString', value: function toString(e) { if (Array.isArray(this.value)) { for (var t = '', r = 0; r < this.value.length; r++)t += `${this.key} ${this.value[r]};`, this.value[r + 1] && (t += '\n'); return t } return `${this.key} ${this.value};` } }]), SimpleRule }()); t.default = i;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(34))); const o = (function () { function KeyframesRule(e, t, r) { for (const i in (function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, KeyframesRule)), this.type = 'keyframes', this.isProcessed = !1, this.key = e, this.options = r, this.rules = new a.default(n({}, r, { parent: this })), t) this.rules.add(i, t[i], n({}, this.options, { parent: this, selector: i })); this.rules.process() } return i(KeyframesRule, [{ key: 'toString', value: function toString() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { indent: 1 }; let t = this.rules.toString(e); return t && (t += '\n'), `${this.key} {\n${t}}` } }]), KeyframesRule }()); t.default = o;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(34))); const o = (function () { function ConditionalRule(e, t, r) { for (const i in (function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, ConditionalRule)), this.type = 'conditional', this.isProcessed = !1, this.key = e, this.options = r, this.rules = new a.default(n({}, r, { parent: this })), t) this.rules.add(i, t[i]); this.rules.process() } return i(ConditionalRule, [{ key: 'getRule', value: function getRule(e) { return this.rules.get(e) } }, { key: 'indexOf', value: function indexOf(e) { return this.rules.indexOf(e) } }, { key: 'addRule', value: function addRule(e, t, r) { const n = this.rules.add(e, t, r); return this.options.jss.plugins.onProcessRule(n), n } }, { key: 'toString', value: function toString() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { indent: 1 }; const t = this.rules.toString(e); return t ? `${this.key} {\n${t}\n}` : '' } }]), ConditionalRule }()); t.default = o;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(69))); const a = (function () { function FontFaceRule(e, t, r) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, FontFaceRule)), this.type = 'font-face', this.isProcessed = !1, this.key = e, this.style = t, this.options = r } return n(FontFaceRule, [{ key: 'toString', value: function toString(e) { if (Array.isArray(this.style)) { for (var t = '', r = 0; r < this.style.length; r++)t += (0, i.default)(this.key, this.style[r]), this.style[r + 1] && (t += '\n'); return t } return (0, i.default)(this.key, this.style, e) } }]), FontFaceRule }()); t.default = a;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(69))); const a = (function () { function ViewportRule(e, t, r) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, ViewportRule)), this.type = 'viewport', this.isProcessed = !1, this.key = e, this.style = t, this.options = r } return n(ViewportRule, [{ key: 'toString', value: function toString(e) { return (0, i.default)(this.key, this.style, e) } }]), ViewportRule }()); t.default = a;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(30)); const i = _interopRequireDefault(r(47)); const a = _interopRequireDefault(r(120)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = { onCreateRule: function onCreateRule(e, t, r) { if (!(0, a.default)(t)) return null; const n = t; const o = (0, i.default)(e, {}, r); return n.subscribe((e) => { for (const t in e)o.prop(t, e[t]); }), o }, onProcessRule: function onProcessRule(e) { if (e instanceof n.default) { const t = e; const r = t.style; const i = function _loop(e) { const n = r[e]; if (!(0, a.default)(n)) return 'continue'; delete r[e], n.subscribe({ next: function next(r) { t.prop(e, r) } }) }; for (const o in r)i(o); } } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(34)); const i = _interopRequireDefault(r(30)); const a = _interopRequireDefault(r(47)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } let o = Date.now(); const s = `fnValues${o}`; const u = `fnStyle${++o}`; t.default = { onCreateRule: function onCreateRule(e, t, r) { if (typeof t !== 'function') return null; const n = (0, a.default)(e, {}, r); return n[u] = t, n }, onProcessStyle: function onProcessStyle(e, t) { const r = {}; for (const n in e) { const i = e[n]; typeof i === 'function' && (delete e[n], r[n] = i) } return (t = t)[s] = r, e }, onUpdate: function onUpdate(e, t) { if (t.rules instanceof n.default)t.rules.update(e); else if (t instanceof i.default) { if ((t = t)[s]) for (const r in t[s])t.prop(r, t[s][r](e)); const a = (t = t)[u]; if (a) { const o = a(e); for (const l in o)t.prop(l, o[l]); } } } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = _interopRequireDefault(r(21)); const a = _interopRequireDefault(r(70)); const o = _interopRequireDefault(r(30)); const s = _interopRequireDefault(r(46)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const u = function memoize(e) { let t = void 0; return function () { return t || (t = e()), t } }; function getPropertyValue(e, t) { try { return e.style.getPropertyValue(t) } catch (e) { return '' } } function setProperty(e, t, r) { try { let n = r; if (Array.isArray(r) && (n = (0, s.default)(r, !0), r[r.length - 1] === '!important')) return e.style.setProperty(t, n, 'important'), !0; e.style.setProperty(t, n) } catch (e) { return !1 } return !0 } function removeProperty(e, t) { try { e.style.removeProperty(t) } catch (e) { (0, i.default)(!1, '[JSS] DOMException "%s" was thrown. Tried to remove property "%s".', e.message, t) } } let l; const c = 1; const p = 7; const f = (l = function extractKey(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; return e.substr(t, e.indexOf('{') - 1) }, function (e) { if (e.type === c) return e.selectorText; if (e.type === p) { const t = e.name; if (t) return `@keyframes ${t}`; const r = e.cssText; return `@${l(r, r.indexOf('keyframes'))}` } return l(e.cssText) }); function setSelector(e, t) { return e.selectorText = t, e.selectorText === t } let d; let h; const m = u(() => document.head || document.getElementsByTagName('head')[0]); const g = (d = void 0, h = !1, function (e) { const t = {}; d || (d = document.createElement('style')); for (let r = 0; r < e.length; r++) { const n = e[r]; if (n instanceof o.default) { const i = n.selector; if (i && i.indexOf('\\') !== -1) { h || (m().appendChild(d), h = !0), d.textContent = `${i} {}`; const a = d.sheet; if (a) { const s = a.cssRules; s && (t[s[0].selectorText] = n.key) } } } } return h && (m().removeChild(d), h = !1), t }); function findPrevNode(e) { const t = a.default.registry; if (t.length > 0) { let r = (function findHigherSheet(e, t) { for (let r = 0; r < e.length; r++) { const n = e[r]; if (n.attached && n.options.index > t.index && n.options.insertionPoint === t.insertionPoint) return n; } return null }(t, e)); if (r) return r.renderer.element; if (r = (function findHighestSheet(e, t) { for (let r = e.length - 1; r >= 0; r--) { const n = e[r]; if (n.attached && n.options.insertionPoint === t.insertionPoint) return n; } return null }(t, e))) return r.renderer.element.nextElementSibling; } const n = e.insertionPoint; if (n && typeof n === 'string') { const o = (function findCommentNode(e) { for (let t = m(), r = 0; r < t.childNodes.length; r++) { const n = t.childNodes[r]; if (n.nodeType === 8 && n.nodeValue.trim() === e) return n; } return null }(n)); if (o) return o.nextSibling; (0, i.default)(n === 'jss', '[JSS] Insertion point "%s" not found.', n) } return null } const v = u(() => { const e = document.querySelector('meta[property="csp-nonce"]'); return e ? e.getAttribute('content') : null }); const y = (function () { function DomRenderer(e) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, DomRenderer)), this.getPropertyValue = getPropertyValue, this.setProperty = setProperty, this.removeProperty = removeProperty, this.setSelector = setSelector, this.getKey = f, this.getUnescapedKeysMap = g, this.hasInsertedRules = !1, e && a.default.add(e), this.sheet = e; const t = this.sheet ? this.sheet.options : {}; const r = t.media; const n = t.meta; const i = t.element; this.element = i || document.createElement('style'), this.element.type = 'text/css', this.element.setAttribute('data-jss', ''), r && this.element.setAttribute('media', r), n && this.element.setAttribute('data-meta', n); const o = v(); o && this.element.setAttribute('nonce', o) } return n(DomRenderer, [{ key: 'attach', value: function attach() { !this.element.parentNode && this.sheet && (this.hasInsertedRules && (this.deploy(), this.hasInsertedRules = !1), (function insertStyle(e, t) { const r = t.insertionPoint; const n = findPrevNode(t); if (n) { const a = n.parentNode; a && a.insertBefore(e, n) } else if (r && typeof r.nodeType === 'number') { const o = r; const s = o.parentNode; s ? s.insertBefore(e, o.nextSibling) : (0, i.default)(!1, '[JSS] Insertion point is not in the DOM.') } else m().insertBefore(e, n); }(this.element, this.sheet.options))) } }, { key: 'detach', value: function detach() { this.element.parentNode.removeChild(this.element) } }, { key: 'deploy', value: function deploy() { this.sheet && (this.element.textContent = `\n${this.sheet.toString()}\n`) } }, { key: 'insertRule', value: function insertRule(e, t) { const r = this.element.sheet; const n = r.cssRules; const a = e.toString(); if (t || (t = n.length), !a) return !1; try { r.insertRule(a, t) } catch (t) { return (0, i.default)(!1, '[JSS] Can not insert an unsupported rule \n\r%s', e), !1 } return this.hasInsertedRules = !0, n[t] } }, { key: 'deleteRule', value: function deleteRule(e) { const t = this.element.sheet; const r = this.indexOf(e); return r !== -1 && (t.deleteRule(r), !0) } }, { key: 'indexOf', value: function indexOf(e) { for (let t = this.element.sheet.cssRules, r = 0; r < t.length; r++) if (e === t[r]) return r; return -1 } }, { key: 'replaceRule', value: function replaceRule(e, t) { const r = this.indexOf(e); const n = this.insertRule(t, r); return this.element.sheet.deleteRule(r), n } }, { key: 'getRules', value: function getRules() { return this.element.sheet.cssRules } }]), DomRenderer }()); t.default = y;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = (function () { function VirtualRenderer() { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, VirtualRenderer)) } return n(VirtualRenderer, [{ key: 'setProperty', value: function setProperty() { return !0 } }, { key: 'getPropertyValue', value: function getPropertyValue() { return '' } }, { key: 'removeProperty', value: function removeProperty() {} }, { key: 'setSelector', value: function setSelector() { return !0 } }, { key: 'getKey', value: function getKey() { return '' } }, { key: 'attach', value: function attach() {} }, { key: 'detach', value: function detach() {} }, { key: 'deploy', value: function deploy() {} }, { key: 'insertRule', value: function insertRule() { return !1 } }, { key: 'deleteRule', value: function deleteRule() { return !0 } }, { key: 'replaceRule', value: function replaceRule() { return !1 } }, { key: 'getRules', value: function getRules() {} }, { key: 'indexOf', value: function indexOf() { return -1 } }]), VirtualRenderer }()); t.default = i;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); t.default = function jssGlobal() { return { onCreateRule: function onCreateRule(e, t, r) { if (e === o) return new u(e, t, r); if (e[0] === '@' && e.substr(0, s.length) === s) return new l(e, t, r); const n = r.parent; n && (n.type !== 'global' && n.options.parent.type !== 'global' || (r.global = !0)); r.global && (r.selector = e); return null }, onProcessRule: function onProcessRule(e) { if (e.type !== 'style') return; (function handleNestedGlobalContainerRule(e) { const t = e.options; const r = e.style; const i = r[o]; if (!i) return; for (const a in i)t.sheet.addRule(a, i[a], n({}, t, { selector: addScope(a, e.selector) })); delete r[o] }(e)), (function handlePrefixedGlobalRule(e) { const t = e.options; const r = e.style; for (const i in r) if (i.substr(0, o.length) === o) { const a = addScope(i.substr(o.length), e.selector); t.sheet.addRule(a, r[i], n({}, t, { selector: a })), delete r[i] } }(e)) } } }; const a = r(118); function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } var o = '@global'; var s = '@global '; var u = (function () { function GlobalContainerRule(e, t, r) { for (const i in _classCallCheck(this, GlobalContainerRule), this.type = 'global', this.key = e, this.options = r, this.rules = new a.RuleList(n({}, r, { parent: this })), t) this.rules.add(i, t[i], { selector: i }); this.rules.process() } return i(GlobalContainerRule, [{ key: 'getRule', value: function getRule(e) { return this.rules.get(e) } }, { key: 'addRule', value: function addRule(e, t, r) { const n = this.rules.add(e, t, r); return this.options.jss.plugins.onProcessRule(n), n } }, { key: 'indexOf', value: function indexOf(e) { return this.rules.indexOf(e) } }, { key: 'toString', value: function toString() { return this.rules.toString() } }]), GlobalContainerRule }()); var l = (function () { function GlobalPrefixedRule(e, t, r) { _classCallCheck(this, GlobalPrefixedRule), this.name = e, this.options = r; const i = e.substr(s.length); this.rule = r.jss.createRule(i, t, n({}, r, { parent: this, selector: i })) } return i(GlobalPrefixedRule, [{ key: 'toString', value: function toString(e) { return this.rule.toString(e) } }]), GlobalPrefixedRule }()); const c = /\s*,\s*/g; function addScope(e, t) { for (var r = e.split(c), n = '', i = 0; i < r.length; i++)n += `${t} ${r[i].trim()}`, r[i + 1] && (n += ', '); return n }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; t.default = function jssIsolate() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; let t = !1; const r = []; let n = void 0; let i = void 0; const a = function setSelector() { i.selector = r.join(',\n') }; const o = f(a); return { onProcessRule: function onProcessRule(a, u) { if (!u || u === n || a.type !== 'style') return; if (!p(a, u, e)) return; i || (n = a.options.jss.createStyleSheet(null, s), i = n.addRule('reset', l(e.reset)), n.attach()); const c = a.selector; r.indexOf(c) === -1 && (r.push(c), t = o()) }, onProcessSheet: function onProcessSheet() { !t && r.length && a() } } }; const a = _interopRequireDefault(r(264)); const o = _interopRequireDefault(r(265)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } var s = { meta: 'jss-isolate', index: -1 / 0, link: !0 }; const u = { inherited: a.default, all: o.default }; var l = function getStyle() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'inherited'; if (typeof e === 'string') return u[e]; if ((void 0 === e ? 'undefined' : i(e)) === 'object') { if (Array.isArray(e)) { const t = e[0]; const r = e[1]; return n({}, u[t], r) } return n({}, a.default, e) } return a.default }; const c = { keyframes: !0, conditional: !0 }; var p = function shouldIsolate(e, t, r) { const n = e.options.parent; if (n && c[n.type]) return !1; let i = r.isolate == null || r.isolate; return t.options.isolate != null && (i = t.options.isolate), e.style.isolate != null && (i = e.style.isolate, delete e.style.isolate), typeof i === 'string' ? i === e.key : i }; var f = function createDebounced(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3; let r = Date.now(); return function () { const n = Date.now(); return !(n - r < t) && (r = n, e(), !0) } };
}, function (e, t) {
  e.exports = {
    azimuth: 'center', 'border-collapse': 'separate', 'border-spacing': '0', 'caption-side': 'top', 'caret-color': 'auto', color: 'initial', cursor: 'auto', 'empty-cells': 'show', 'font-family': 'initial', 'font-feature-settings': 'normal', 'font-kerning': 'auto', 'font-language-override': 'normal', 'font-size': 'medium', 'font-size-adjust': 'none', 'font-stretch': 'normal', 'font-style': 'normal', 'font-synthesis': 'weight style', 'font-variant': 'normal', 'font-variant-alternates': 'normal', 'font-variant-caps': 'normal', 'font-variant-east-asian': 'normal', 'font-variant-ligatures': 'normal', 'font-variant-numeric': 'normal', 'font-variant-position': 'normal', 'font-weight': 'normal', hyphens: 'manual', 'image-orientation': '0deg', 'image-rendering': 'auto', 'image-resolution': '1dppx', 'letter-spacing': 'normal', 'line-height': 'normal', 'list-style-image': 'none', 'list-style-position': 'outside', 'list-style-type': 'disc', 'object-position': '50% 50%', orphans: '2', 'overflow-wrap': 'normal', 'pointer-events': 'auto', quotes: 'initial', 'ruby-align': 'space-around', 'ruby-merge': 'separate', 'ruby-position': 'over', 'tab-size': '8', 'text-align': 'initial', 'text-align-last': 'auto', 'text-combine-upright': 'none', 'text-indent': '0', 'text-justify': 'auto', 'text-orientation': 'mixed', 'text-rendering': 'auto', 'text-shadow': 'none', 'text-transform': 'none', 'text-underline-position': 'auto', visibility: 'visible', 'white-space': 'normal', widows: '2', 'word-break': 'normal', 'word-spacing': 'normal', 'word-wrap': 'normal', 'writing-mode': 'horizontal-tb', '-webkit-appearance': 'none', '-moz-appearance': 'none', '-ms-appearance': 'none', appearance: 'none',
  };
}, function (e, t) {
  e.exports = {
    'align-content': 'stretch', 'align-items': 'stretch', 'align-self': 'auto', 'animation-delay': '0s', 'animation-direction': 'normal', 'animation-duration': '0s', 'animation-fill-mode': 'none', 'animation-iteration-count': '1', 'animation-name': 'none', 'animation-play-state': 'running', 'animation-timing-function': 'ease', azimuth: 'center', 'backface-visibility': 'visible', 'background-attachment': 'scroll', 'background-blend-mode': 'normal', 'background-clip': 'border-box', 'background-color': 'transparent', 'background-image': 'none', 'background-origin': 'padding-box', 'background-position': '0% 0%', 'background-repeat': 'repeat', 'background-size': 'auto auto', 'block-size': 'auto', 'border-block-end-color': 'currentcolor', 'border-block-end-style': 'none', 'border-block-end-width': 'medium', 'border-block-start-color': 'currentcolor', 'border-block-start-style': 'none', 'border-block-start-width': 'medium', 'border-bottom-color': 'currentcolor', 'border-bottom-left-radius': '0', 'border-bottom-right-radius': '0', 'border-bottom-style': 'none', 'border-bottom-width': 'medium', 'border-collapse': 'separate', 'border-image-outset': '0s', 'border-image-repeat': 'stretch', 'border-image-slice': '100%', 'border-image-source': 'none', 'border-image-width': '1', 'border-inline-end-color': 'currentcolor', 'border-inline-end-style': 'none', 'border-inline-end-width': 'medium', 'border-inline-start-color': 'currentcolor', 'border-inline-start-style': 'none', 'border-inline-start-width': 'medium', 'border-left-color': 'currentcolor', 'border-left-style': 'none', 'border-left-width': 'medium', 'border-right-color': 'currentcolor', 'border-right-style': 'none', 'border-right-width': 'medium', 'border-spacing': '0', 'border-top-color': 'currentcolor', 'border-top-left-radius': '0', 'border-top-right-radius': '0', 'border-top-style': 'none', 'border-top-width': 'medium', bottom: 'auto', 'box-decoration-break': 'slice', 'box-shadow': 'none', 'box-sizing': 'content-box', 'break-after': 'auto', 'break-before': 'auto', 'break-inside': 'auto', 'caption-side': 'top', 'caret-color': 'auto', clear: 'none', clip: 'auto', 'clip-path': 'none', color: 'initial', 'column-count': 'auto', 'column-fill': 'balance', 'column-gap': 'normal', 'column-rule-color': 'currentcolor', 'column-rule-style': 'none', 'column-rule-width': 'medium', 'column-span': 'none', 'column-width': 'auto', content: 'normal', 'counter-increment': 'none', 'counter-reset': 'none', cursor: 'auto', display: 'inline', 'empty-cells': 'show', filter: 'none', 'flex-basis': 'auto', 'flex-direction': 'row', 'flex-grow': '0', 'flex-shrink': '1', 'flex-wrap': 'nowrap', float: 'none', 'font-family': 'initial', 'font-feature-settings': 'normal', 'font-kerning': 'auto', 'font-language-override': 'normal', 'font-size': 'medium', 'font-size-adjust': 'none', 'font-stretch': 'normal', 'font-style': 'normal', 'font-synthesis': 'weight style', 'font-variant': 'normal', 'font-variant-alternates': 'normal', 'font-variant-caps': 'normal', 'font-variant-east-asian': 'normal', 'font-variant-ligatures': 'normal', 'font-variant-numeric': 'normal', 'font-variant-position': 'normal', 'font-weight': 'normal', 'grid-auto-columns': 'auto', 'grid-auto-flow': 'row', 'grid-auto-rows': 'auto', 'grid-column-end': 'auto', 'grid-column-gap': '0', 'grid-column-start': 'auto', 'grid-row-end': 'auto', 'grid-row-gap': '0', 'grid-row-start': 'auto', 'grid-template-areas': 'none', 'grid-template-columns': 'none', 'grid-template-rows': 'none', height: 'auto', hyphens: 'manual', 'image-orientation': '0deg', 'image-rendering': 'auto', 'image-resolution': '1dppx', 'ime-mode': 'auto', 'inline-size': 'auto', isolation: 'auto', 'justify-content': 'flex-start', left: 'auto', 'letter-spacing': 'normal', 'line-break': 'auto', 'line-height': 'normal', 'list-style-image': 'none', 'list-style-position': 'outside', 'list-style-type': 'disc', 'margin-block-end': '0', 'margin-block-start': '0', 'margin-bottom': '0', 'margin-inline-end': '0', 'margin-inline-start': '0', 'margin-left': '0', 'margin-right': '0', 'margin-top': '0', 'mask-clip': 'border-box', 'mask-composite': 'add', 'mask-image': 'none', 'mask-mode': 'match-source', 'mask-origin': 'border-box', 'mask-position': '0% 0%', 'mask-repeat': 'repeat', 'mask-size': 'auto', 'mask-type': 'luminance', 'max-height': 'none', 'max-width': 'none', 'min-block-size': '0', 'min-height': '0', 'min-inline-size': '0', 'min-width': '0', 'mix-blend-mode': 'normal', 'object-fit': 'fill', 'object-position': '50% 50%', 'offset-block-end': 'auto', 'offset-block-start': 'auto', 'offset-inline-end': 'auto', 'offset-inline-start': 'auto', opacity: '1.0', order: '0', orphans: '2', 'outline-color': 'initial', 'outline-offset': '0', 'outline-style': 'none', 'outline-width': 'medium', overflow: 'visible', 'overflow-wrap': 'normal', 'overflow-x': 'visible', 'overflow-y': 'visible', 'padding-block-end': '0', 'padding-block-start': '0', 'padding-bottom': '0', 'padding-inline-end': '0', 'padding-inline-start': '0', 'padding-left': '0', 'padding-right': '0', 'padding-top': '0', 'page-break-after': 'auto', 'page-break-before': 'auto', 'page-break-inside': 'auto', perspective: 'none', 'perspective-origin': '50% 50%', 'pointer-events': 'auto', position: 'static', quotes: 'initial', resize: 'none', right: 'auto', 'ruby-align': 'space-around', 'ruby-merge': 'separate', 'ruby-position': 'over', 'scroll-behavior': 'auto', 'scroll-snap-coordinate': 'none', 'scroll-snap-destination': '0px 0px', 'scroll-snap-points-x': 'none', 'scroll-snap-points-y': 'none', 'scroll-snap-type': 'none', 'shape-image-threshold': '0.0', 'shape-margin': '0', 'shape-outside': 'none', 'tab-size': '8', 'table-layout': 'auto', 'text-align': 'initial', 'text-align-last': 'auto', 'text-combine-upright': 'none', 'text-decoration-color': 'currentcolor', 'text-decoration-line': 'none', 'text-decoration-style': 'solid', 'text-emphasis-color': 'currentcolor', 'text-emphasis-position': 'over right', 'text-emphasis-style': 'none', 'text-indent': '0', 'text-justify': 'auto', 'text-orientation': 'mixed', 'text-overflow': 'clip', 'text-rendering': 'auto', 'text-shadow': 'none', 'text-transform': 'none', 'text-underline-position': 'auto', top: 'auto', 'touch-action': 'auto', transform: 'none', 'transform-box': 'border-box ', 'transform-origin': '50% 50% 0', 'transform-style': 'flat', 'transition-delay': '0s', 'transition-duration': '0s', 'transition-property': 'all', 'transition-timing-function': 'ease', 'vertical-align': 'baseline', visibility: 'visible', 'white-space': 'normal', widows: '2', width: 'auto', 'will-change': 'auto', 'word-break': 'normal', 'word-spacing': 'normal', 'word-wrap': 'normal', 'writing-mode': 'horizontal-tb', 'z-index': 'auto', '-webkit-appearance': 'none', '-moz-appearance': 'none', '-ms-appearance': 'none', appearance: 'none',
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function jssNested() { function getReplaceRef(e) { return function (t, r) { const n = e.getRule(r); return n ? n.selector : ((0, i.default)(!1, '[JSS] Could not find the referenced rule %s in %s.', r, e.options.meta || e), r) } } const e = function hasAnd(e) { return e.indexOf('&') !== -1 }; function replaceParentRefs(t, r) { for (var n = r.split(a), i = t.split(a), s = '', u = 0; u < n.length; u++) for (let l = n[u], c = 0; c < i.length; c++) { const p = i[c]; s && (s += ', '), s += e(p) ? p.replace(o, l) : `${l} ${p}` } return s } function getOptions(e, t, r) { if (r) return n({}, r, { index: r.index + 1 }); let i = e.options.nestingLevel; return i = void 0 === i ? 1 : i + 1, n({}, e.options, { nestingLevel: i, index: t.indexOf(e) + 1 }) } return { onProcessStyle: function onProcessStyle(t, r) { if (r.type !== 'style') return t; const i = r.options.parent; let a = void 0; let o = void 0; for (const u in t) { const l = e(u); const c = u[0] === '@'; if (l || c) { if (a = getOptions(r, i, a), l) { let p = replaceParentRefs(u, r.selector); o || (o = getReplaceRef(i)), p = p.replace(s, o), i.addRule(p, t[u], n({}, a, { selector: p })) } else c && i.addRule(u, null, a).addRule(r.key, t[u], { selector: r.selector }); delete t[u] } } return t } } }; var i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(21))); var a = /\s*,\s*/g; var o = /&/g; var s = /\$([\w-]+)/g;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function camelCase() { return { onProcessStyle: function onProcessStyle(e) { if (Array.isArray(e)) { for (let t = 0; t < e.length; t++)e[t] = convertCase(e[t]); return e } return convertCase(e) }, onChangeValue: function onChangeValue(e, t, r) { const i = (0, n.default)(t); return t === i ? e : (r.prop(i, e), null) } } }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(268))); function convertCase(e) { const t = {}; for (const r in e)t[(0, n.default)(r)] = e[r]; return e.fallbacks && (Array.isArray(e.fallbacks) ? t.fallbacks = e.fallbacks.map(convertCase) : t.fallbacks = convertCase(e.fallbacks)), t }
}, function (e, t, r) {
  const n = /[A-Z]/g; const i = /^ms-/; const a = {}; e.exports = function hyphenateStyleName(e) { return e in a ? a[e] : a[e] = e.replace(n, '-$&').toLowerCase().replace(i, '-ms-') };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e }; function addCamelCasedVersion(e) { const t = /(-[a-z])/g; const r = function replace(e) { return e[1].toUpperCase() }; const n = {}; for (const i in e)n[i] = e[i], n[i.replace(t, r)] = e[i]; return n }t.default = function defaultUnit() { const e = addCamelCasedVersion(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}); return { onProcessStyle: function onProcessStyle(t, r) { if (r.type !== 'style') return t; for (const n in t)t[n] = iterate(n, t[n], e); return t }, onChangeValue: function onChangeValue(t, r) { return iterate(r, t, e) } } }; const i = addCamelCasedVersion((function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(270))).default); function iterate(e, t, r) { if (!t) return t; let a = t; let o = void 0 === t ? 'undefined' : n(t); switch (o === 'object' && Array.isArray(t) && (o = 'array'), o) { case 'object': if (e === 'fallbacks') { for (const s in t)t[s] = iterate(s, t[s], r); break } for (const u in t)t[u] = iterate(`${e}-${u}`, t[u], r); break; case 'array': for (let l = 0; l < t.length; l++)t[l] = iterate(e, t[l], r); break; case 'number': t !== 0 && (a = t + (r[e] || i[e] || '')); } return a }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = {
    'animation-delay': 'ms', 'animation-duration': 'ms', 'background-position': 'px', 'background-position-x': 'px', 'background-position-y': 'px', 'background-size': 'px', border: 'px', 'border-bottom': 'px', 'border-bottom-left-radius': 'px', 'border-bottom-right-radius': 'px', 'border-bottom-width': 'px', 'border-left': 'px', 'border-left-width': 'px', 'border-radius': 'px', 'border-right': 'px', 'border-right-width': 'px', 'border-spacing': 'px', 'border-top': 'px', 'border-top-left-radius': 'px', 'border-top-right-radius': 'px', 'border-top-width': 'px', 'border-width': 'px', 'border-after-width': 'px', 'border-before-width': 'px', 'border-end-width': 'px', 'border-horizontal-spacing': 'px', 'border-start-width': 'px', 'border-vertical-spacing': 'px', bottom: 'px', 'box-shadow': 'px', 'column-gap': 'px', 'column-rule': 'px', 'column-rule-width': 'px', 'column-width': 'px', 'flex-basis': 'px', 'font-size': 'px', 'font-size-delta': 'px', height: 'px', left: 'px', 'letter-spacing': 'px', 'logical-height': 'px', 'logical-width': 'px', margin: 'px', 'margin-after': 'px', 'margin-before': 'px', 'margin-bottom': 'px', 'margin-left': 'px', 'margin-right': 'px', 'margin-top': 'px', 'max-height': 'px', 'max-width': 'px', 'margin-end': 'px', 'margin-start': 'px', 'mask-position-x': 'px', 'mask-position-y': 'px', 'mask-size': 'px', 'max-logical-height': 'px', 'max-logical-width': 'px', 'min-height': 'px', 'min-width': 'px', 'min-logical-height': 'px', 'min-logical-width': 'px', motion: 'px', 'motion-offset': 'px', outline: 'px', 'outline-offset': 'px', 'outline-width': 'px', padding: 'px', 'padding-bottom': 'px', 'padding-left': 'px', 'padding-right': 'px', 'padding-top': 'px', 'padding-after': 'px', 'padding-before': 'px', 'padding-end': 'px', 'padding-start': 'px', 'perspective-origin-x': '%', 'perspective-origin-y': '%', perspective: 'px', right: 'px', 'shape-margin': 'px', size: 'px', 'text-indent': 'px', 'text-stroke': 'px', 'text-stroke-width': 'px', top: 'px', 'transform-origin': '%', 'transform-origin-x': '%', 'transform-origin-y': '%', 'transform-origin-z': '%', 'transition-delay': 'ms', 'transition-duration': 'ms', 'vertical-align': 'px', width: 'px', 'word-spacing': 'px', 'box-shadow-x': 'px', 'box-shadow-y': 'px', 'box-shadow-blur': 'px', 'box-shadow-spread': 'px', 'font-line-height': 'px', 'text-shadow-x': 'px', 'text-shadow-y': 'px', 'text-shadow-blur': 'px',
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function jssCompose() { return { onProcessStyle: function onProcessStyle(e, t) { return e.composes ? ((function registerClass(e, t) { if (!t) return !0; if (Array.isArray(t)) { for (let r = 0; r < t.length; r++) { const i = registerClass(e, t[r]); if (!i) return !1; } return !0 } if (t.indexOf(' ') > -1) return registerClass(e, t.split(' ')); const a = e.options.parent; if (t[0] === '$') { const o = a.getRule(t.substr(1)); return o ? o === e ? ((0, n.default)(!1, '[JSS] Cyclic composition detected. \r\n%s', e), !1) : (a.classes[e.key] += ` ${a.classes[o.key]}`, !0) : ((0, n.default)(!1, '[JSS] Referenced rule is not defined. \r\n%s', e), !1) } return e.options.parent.classes[e.key] += ` ${t}`, !0 }(t, e.composes)), delete e.composes, e) : e } } }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(21)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = {
    animation: 'none 0s ease 0s 1 normal none running', 'backface-visibility': 'visible', background: 'transparent none repeat 0 0 / auto auto padding-box border-box scroll', border: 'medium none currentColor', 'border-image': 'none', 'border-radius': '0', bottom: 'auto', 'box-shadow': 'none', clear: 'none', clip: 'auto', columns: 'auto', 'column-count': 'auto', 'column-fill': 'balance', 'column-gap': 'normal', 'column-rule': 'medium none currentColor', 'column-span': '1', 'column-width': 'auto', content: 'normal', 'counter-increment': 'none', 'counter-reset': 'none', float: 'none', height: 'auto', hyphens: 'none', left: 'auto', margin: '0', 'max-height': 'none', 'max-width': 'none', 'min-height': '0', 'min-width': '0', opacity: '1', outline: 'medium none invert', overflow: 'visible', 'overflow-x': 'visible', 'overflow-y': 'visible', padding: '0', 'page-break-after': 'auto', 'page-break-before': 'auto', 'page-break-inside': 'auto', perspective: 'none', 'perspective-origin': '50% 50%', position: 'static', right: 'auto', 'table-layout': 'auto', 'text-decoration': 'none', top: 'auto', transform: 'none', 'transform-origin': '50% 50% 0', 'transform-style': 'flat', transition: 'none 0s ease 0s', 'unicode-bidi': 'normal', 'vertical-align': 'baseline', width: 'auto', 'z-index': 'auto',
  };
}, function (e, t, r) {
  const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(68))).default.createStyleSheet({
    body: {
      isolate: !1, margin: 0, padding: 0, border: 0,
    },
  }).attach().classes.body; document.body.classList.add(n);
}, function (e, t, r) {
  !(function checkDCE() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE === 'function') try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE) } catch (e) { console.error(e) } }()), e.exports = r(275);
}, function (t, r, n) {
  /** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const i = n(0); const a = n(277); const o = n(124); const s = n(48); const l = n(278); const p = n(279); const x = n(280); const D = n(281); const _ = n(284); const C = n(125); function E(e) { for (var t = arguments.length - 1, r = `Minified React error #${e}; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=${e}`, n = 0; n < t; n++)r += `&args[]=${encodeURIComponent(arguments[n + 1])}`; throw (t = Error(`${r} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)).name = 'Invariant Violation', t.framesToPop = 1, t }i || E('227'); const S = {
    children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0,
  }; function pa(e, t) { return (e & t) === t } var P = {
    MUST_USE_PROPERTY: 1,
    HAS_BOOLEAN_VALUE: 4,
    HAS_NUMERIC_VALUE: 8,
    HAS_POSITIVE_NUMERIC_VALUE: 24,
    HAS_OVERLOADED_BOOLEAN_VALUE: 32,
    HAS_STRING_BOOLEAN_VALUE: 64,
    injectDOMPropertyConfig(e) {
      const t = P; const r = e.Properties || {}; const n = e.DOMAttributeNamespaces || {}; const i = e.DOMAttributeNames || {}; for (const a in e = e.DOMMutationMethods || {}, r) {
        R.hasOwnProperty(a) && E('48', a); let o = a.toLowerCase(); const s = r[a]; (o = {
          attributeName: o, attributeNamespace: null, propertyName: a, mutationMethod: null, mustUseProperty: pa(s, t.MUST_USE_PROPERTY), hasBooleanValue: pa(s, t.HAS_BOOLEAN_VALUE), hasNumericValue: pa(s, t.HAS_NUMERIC_VALUE), hasPositiveNumericValue: pa(s, t.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: pa(s, t.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: pa(s, t.HAS_STRING_BOOLEAN_VALUE),
        }).hasBooleanValue + o.hasNumericValue + o.hasOverloadedBooleanValue <= 1 || E('50', a), i.hasOwnProperty(a) && (o.attributeName = i[a]), n.hasOwnProperty(a) && (o.attributeNamespace = n[a]), e.hasOwnProperty(a) && (o.mutationMethod = e[a]), R[a] = o;
      }
    },
  }; var R = {}; function va(e, t) { if (S.hasOwnProperty(e) || e.length > 2 && (e[0] === 'o' || e[0] === 'O') && (e[1] === 'n' || e[1] === 'N')) return !1; if (t === null) return !0; switch (typeof t) { case 'boolean': return S.hasOwnProperty(e) ? e = !0 : (t = wa(e)) ? e = t.hasBooleanValue || t.hasStringBooleanValue || t.hasOverloadedBooleanValue : e = (e = e.toLowerCase().slice(0, 5)) === 'data-' || e === 'aria-', e; case 'undefined': case 'number': case 'string': case 'object': return !0; default: return !1; } } function wa(e) { return R.hasOwnProperty(e) ? R[e] : null } const O = P; const F = O.MUST_USE_PROPERTY; const M = O.HAS_BOOLEAN_VALUE; const j = O.HAS_NUMERIC_VALUE; const B = O.HAS_POSITIVE_NUMERIC_VALUE; const H = O.HAS_OVERLOADED_BOOLEAN_VALUE; const $ = O.HAS_STRING_BOOLEAN_VALUE; const K = {
    Properties: {
      allowFullScreen: M, async: M, autoFocus: M, autoPlay: M, capture: H, checked: F | M, cols: B, contentEditable: $, controls: M, default: M, defer: M, disabled: M, download: H, draggable: $, formNoValidate: M, hidden: M, loop: M, multiple: F | M, muted: F | M, noValidate: M, open: M, playsInline: M, readOnly: M, required: M, reversed: M, rows: B, rowSpan: j, scoped: M, seamless: M, selected: F | M, size: B, start: j, span: B, spellCheck: $, style: 0, tabIndex: 0, itemScope: M, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: $,
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset', className: 'class', htmlFor: 'for', httpEquiv: 'http-equiv',
    },
    DOMMutationMethods: { value(e, t) { if (t == null) return e.removeAttribute('value'); e.type !== 'number' || !1 === e.hasAttribute('value') ? e.setAttribute('value', `${t}`) : e.validity && !e.validity.badInput && e.ownerDocument.activeElement !== e && e.setAttribute('value', `${t}`) } },
  }; const X = O.HAS_STRING_BOOLEAN_VALUE; const Q = 'http://www.w3.org/1999/xlink'; const Z = 'http://www.w3.org/XML/1998/namespace'; const ee = {
    Properties: { autoReverse: X, externalResourcesRequired: X, preserveAlpha: X },
    DOMAttributeNames: { autoReverse: 'autoReverse', externalResourcesRequired: 'externalResourcesRequired', preserveAlpha: 'preserveAlpha' },
    DOMAttributeNamespaces: {
      xlinkActuate: Q, xlinkArcrole: Q, xlinkHref: Q, xlinkRole: Q, xlinkShow: Q, xlinkTitle: Q, xlinkType: Q, xmlBase: Z, xmlLang: Z, xmlSpace: Z,
    },
  }; const ie = /[\-\:]([a-z])/g; function Ia(e) { return e[1].toUpperCase() }'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space'.split(' ').forEach((e) => { const t = e.replace(ie, Ia); ee.Properties[t] = 0, ee.DOMAttributeNames[t] = e }), O.injectDOMPropertyConfig(K), O.injectDOMPropertyConfig(ee); var fe = {
    _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils(e) { typeof e.invokeGuardedCallback !== 'function' && E('197'), Ja = e.invokeGuardedCallback } }, invokeGuardedCallback(e, t, r, n, i, a, o, s, u) { Ja.apply(fe, arguments) }, invokeGuardedCallbackAndCatchFirstError(e, t, r, n, i, a, o, s, u) { if (fe.invokeGuardedCallback.apply(this, arguments), fe.hasCaughtError()) { const l = fe.clearCaughtError(); fe._hasRethrowError || (fe._hasRethrowError = !0, fe._rethrowError = l) } }, rethrowCaughtError() { return function Ka() { if (fe._hasRethrowError) { const e = fe._rethrowError; throw fe._rethrowError = null, fe._hasRethrowError = !1, e } }.apply(fe, arguments) }, hasCaughtError() { return fe._hasCaughtError }, clearCaughtError() { if (fe._hasCaughtError) { const e = fe._caughtError; return fe._caughtError = null, fe._hasCaughtError = !1, e }E('198') },
  }; function Ja(e, t, r, n, i, a, o, s, u) { fe._hasCaughtError = !1, fe._caughtError = null; const l = Array.prototype.slice.call(arguments, 3); try { t.apply(r, l) } catch (e) { fe._caughtError = e, fe._hasCaughtError = !0 } } let de = null; const he = {}; function Na() { if (de) for (const e in he) { const t = he[e]; let r = de.indexOf(e); if (r > -1 || E('96', e), !ge[r]) for (const n in t.extractEvents || E('97', e), ge[r] = t, r = t.eventTypes) { let i = void 0; const a = r[n]; const o = t; const s = n; _e.hasOwnProperty(s) && E('99', s), _e[s] = a; const u = a.phasedRegistrationNames; if (u) { for (i in u)u.hasOwnProperty(i) && Qa(u[i], o, s); i = !0 } else a.registrationName ? (Qa(a.registrationName, o, s), i = !0) : i = !1; i || E('98', n, e) } } } function Qa(e, t, r) { Se[e] && E('100', e), Se[e] = t, Ae[e] = t.eventTypes[r].dependencies } var ge = []; var _e = {}; var Se = {}; var Ae = {}; function Ta(e) { de && E('101'), de = Array.prototype.slice.call(e), Na() } function Ua(e) { let t; let r = !1; for (t in e) if (e.hasOwnProperty(t)) { const n = e[t]; he.hasOwnProperty(t) && he[t] === n || (he[t] && E('102', t), he[t] = n, r = !0) }r && Na() } const Te = Object.freeze({
    plugins: ge, eventNameDispatchConfigs: _e, registrationNameModules: Se, registrationNameDependencies: Ae, possibleRegistrationNames: null, injectEventPluginOrder: Ta, injectEventPluginsByName: Ua,
  }); let Pe = null; let Re = null; let Oe = null; function Za(e, t, r, n) { t = e.type || 'unknown-event', e.currentTarget = Oe(n), fe.invokeGuardedCallbackAndCatchFirstError(t, r, void 0, e), e.currentTarget = null } function $a(e, t) { return t == null && E('30'), e == null ? t : Array.isArray(e) ? Array.isArray(t) ? (e.push(...t), e) : (e.push(t), e) : Array.isArray(t) ? [e].concat(t) : [e, t] } function ab(e, t, r) { Array.isArray(e) ? e.forEach(t, r) : e && t.call(r, e) } let Me = null; function cb(e, t) { if (e) { const r = e._dispatchListeners; const n = e._dispatchInstances; if (Array.isArray(r)) for (let i = 0; i < r.length && !e.isPropagationStopped(); i++)Za(e, t, r[i], n[i]); else r && Za(e, t, r, n); e._dispatchListeners = null, e._dispatchInstances = null, e.isPersistent() || e.constructor.release(e) } } function db(e) { return cb(e, !0) } function gb(e) { return cb(e, !1) } const je = { injectEventPluginOrder: Ta, injectEventPluginsByName: Ua }; function ib(e, t) { let r = e.stateNode; if (!r) return null; let n = Pe(r); if (!n) return null; r = n[t]; switch (t) { case 'onClick': case 'onClickCapture': case 'onDoubleClick': case 'onDoubleClickCapture': case 'onMouseDown': case 'onMouseDownCapture': case 'onMouseMove': case 'onMouseMoveCapture': case 'onMouseUp': case 'onMouseUpCapture': (n = !n.disabled) || (n = !((e = e.type) === 'button' || e === 'input' || e === 'select' || e === 'textarea')), e = !n; break; default: e = !1; } return e ? null : (r && typeof r !== 'function' && E('231', t, typeof r), r) } function jb(e, t, r, n) { for (var i, a = 0; a < ge.length; a++) { let o = ge[a]; o && (o = o.extractEvents(e, t, r, n)) && (i = $a(i, o)) } return i } function kb(e) { e && (Me = $a(Me, e)) } function lb(e) { const t = Me; Me = null, t && (ab(t, e ? db : gb), Me && E('95'), fe.rethrowCaughtError()) } const Ne = Object.freeze({
    injection: je, getListener: ib, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb,
  }); const Ue = Math.random().toString(36).slice(2); const ze = `__reactInternalInstance$${Ue}`; const Ve = `__reactEventHandlers$${Ue}`; function pb(e) { if (e[ze]) return e[ze]; for (var t = []; !e[ze];) { if (t.push(e), !e.parentNode) return null; e = e.parentNode } let r = void 0; let n = e[ze]; if (n.tag === 5 || n.tag === 6) return n; for (;e && (n = e[ze]); e = t.pop())r = n; return r } function qb(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; E('33') } function rb(e) { return e[Ve] || null } const We = Object.freeze({
    precacheFiberNode(e, t) { t[ze] = e }, getClosestInstanceFromNode: pb, getInstanceFromNode(e) { return !(e = e[ze]) || e.tag !== 5 && e.tag !== 6 ? null : e }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps(e, t) { e[Ve] = t },
  }); function tb(e) { do { e = e.return } while (e && e.tag !== 5);return e || null } function ub(e, t, r) { for (var n = []; e;)n.push(e), e = tb(e); for (e = n.length; e-- > 0;)t(n[e], 'captured', r); for (e = 0; e < n.length; e++)t(n[e], 'bubbled', r); } function vb(e, t, r) { (t = ib(e, r.dispatchConfig.phasedRegistrationNames[t])) && (r._dispatchListeners = $a(r._dispatchListeners, t), r._dispatchInstances = $a(r._dispatchInstances, e)) } function wb(e) { e && e.dispatchConfig.phasedRegistrationNames && ub(e._targetInst, vb, e) } function xb(e) { if (e && e.dispatchConfig.phasedRegistrationNames) { let t = e._targetInst; ub(t = t ? tb(t) : null, vb, e) } } function yb(e, t, r) { e && r && r.dispatchConfig.registrationName && (t = ib(e, r.dispatchConfig.registrationName)) && (r._dispatchListeners = $a(r._dispatchListeners, t), r._dispatchInstances = $a(r._dispatchInstances, e)) } function zb(e) { e && e.dispatchConfig.registrationName && yb(e._targetInst, null, e) } function Ab(e) { ab(e, wb) } function Bb(e, t, r, n) { if (r && n)e: { for (var i = r, a = n, o = 0, s = i; s; s = tb(s))o++; s = 0; for (let u = a; u; u = tb(u))s++; for (;o - s > 0;)i = tb(i), o--; for (;s - o > 0;)a = tb(a), s--; for (;o--;) { if (i === a || i === a.alternate) break e; i = tb(i), a = tb(a) }i = null } else i = null; for (a = i, i = []; r && r !== a && ((o = r.alternate) === null || o !== a);)i.push(r), r = tb(r); for (r = []; n && n !== a && ((o = n.alternate) === null || o !== a);)r.push(n), n = tb(n); for (n = 0; n < i.length; n++)yb(i[n], 'bubbled', e); for (e = r.length; e-- > 0;)yb(r[e], 'captured', t); } const Ye = Object.freeze({
    accumulateTwoPhaseDispatches: Ab, accumulateTwoPhaseDispatchesSkipTarget(e) { ab(e, xb) }, accumulateEnterLeaveDispatches: Bb, accumulateDirectDispatches(e) { ab(e, zb) },
  }); let Qe = null; function Eb() { return !Qe && a.canUseDOM && (Qe = 'textContent' in document.documentElement ? 'textContent' : 'innerText'), Qe } const et = { _root: null, _startText: null, _fallbackText: null }; function Fb() { if (et._fallbackText) return et._fallbackText; let e; let t; const r = et._startText; const n = r.length; const i = Gb(); const a = i.length; for (e = 0; e < n && r[e] === i[e]; e++);const o = n - e; for (t = 1; t <= o && r[n - t] === i[a - t]; t++);return et._fallbackText = i.slice(e, t > 1 ? 1 - t : void 0), et._fallbackText } function Gb() { return 'value' in et._root ? et._root.value : et._root[Eb()] } const tt = 'dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances'.split(' '); const rt = {
    type: null, target: null, currentTarget: s.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp(e) { return e.timeStamp || Date.now() }, defaultPrevented: null, isTrusted: null,
  }; function T(e, t, r, n) { for (const i in this.dispatchConfig = e, this._targetInst = t, this.nativeEvent = r, e = this.constructor.Interface)e.hasOwnProperty(i) && ((t = e[i]) ? this[i] = t(r) : i === 'target' ? this.target = n : this[i] = r[i]); return this.isDefaultPrevented = (r.defaultPrevented != null ? r.defaultPrevented : !1 === r.returnValue) ? s.thatReturnsTrue : s.thatReturnsFalse, this.isPropagationStopped = s.thatReturnsFalse, this } function Kb(e, t, r, n) { if (this.eventPool.length) { const i = this.eventPool.pop(); return this.call(i, e, t, r, n), i } return new this(e, t, r, n) } function Lb(e) { e instanceof this || E('223'), e.destructor(), this.eventPool.length < 10 && this.eventPool.push(e) } function Jb(e) { e.eventPool = [], e.getPooled = Kb, e.release = Lb } function Mb(e, t, r, n) { return T.call(this, e, t, r, n) } function Nb(e, t, r, n) { return T.call(this, e, t, r, n) }o(T.prototype, {
    preventDefault() { this.defaultPrevented = !0; const e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : typeof e.returnValue !== 'unknown' && (e.returnValue = !1), this.isDefaultPrevented = s.thatReturnsTrue) }, stopPropagation() { const e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : typeof e.cancelBubble !== 'unknown' && (e.cancelBubble = !0), this.isPropagationStopped = s.thatReturnsTrue) }, persist() { this.isPersistent = s.thatReturnsTrue }, isPersistent: s.thatReturnsFalse, destructor() { let e; let t = this.constructor.Interface; for (e in t) this[e] = null; for (t = 0; t < tt.length; t++) this[tt[t]] = null; },
  }), T.Interface = rt, T.augmentClass = function (e, t) { function c() {}c.prototype = this.prototype; const r = new c(); o(r, e.prototype), e.prototype = r, e.prototype.constructor = e, e.Interface = o({}, this.Interface, t), e.augmentClass = this.augmentClass, Jb(e) }, Jb(T), T.augmentClass(Mb, { data: null }), T.augmentClass(Nb, { data: null }); let nt; const it = [9, 13, 27, 32]; const at = a.canUseDOM && 'CompositionEvent' in window; let ot = null; if (a.canUseDOM && 'documentMode' in document && (ot = document.documentMode), nt = a.canUseDOM && 'TextEvent' in window && !ot) { const st = window.opera; nt = !(typeof st === 'object' && typeof st.version === 'function' && parseInt(st.version(), 10) <= 12) } const ut = nt; const lt = a.canUseDOM && (!at || ot && ot > 8 && ot <= 11); const ct = String.fromCharCode(32); const pt = {
    beforeInput: { phasedRegistrationNames: { bubbled: 'onBeforeInput', captured: 'onBeforeInputCapture' }, dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste'] }, compositionEnd: { phasedRegistrationNames: { bubbled: 'onCompositionEnd', captured: 'onCompositionEndCapture' }, dependencies: 'topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown'.split(' ') }, compositionStart: { phasedRegistrationNames: { bubbled: 'onCompositionStart', captured: 'onCompositionStartCapture' }, dependencies: 'topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown'.split(' ') }, compositionUpdate: { phasedRegistrationNames: { bubbled: 'onCompositionUpdate', captured: 'onCompositionUpdateCapture' }, dependencies: 'topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown'.split(' ') },
  }; let ft = !1; function dc(e, t) { switch (e) { case 'topKeyUp': return it.indexOf(t.keyCode) !== -1; case 'topKeyDown': return t.keyCode !== 229; case 'topKeyPress': case 'topMouseDown': case 'topBlur': return !0; default: return !1; } } function ec(e) { return typeof (e = e.detail) === 'object' && 'data' in e ? e.data : null } let dt = !1; const ht = { eventTypes: pt, extractEvents(e, t, r, n) { let i; if (at)e: { switch (e) { case 'topCompositionStart': var a = pt.compositionStart; break e; case 'topCompositionEnd': a = pt.compositionEnd; break e; case 'topCompositionUpdate': a = pt.compositionUpdate; break e; }a = void 0 } else dt ? dc(e, r) && (a = pt.compositionEnd) : e === 'topKeyDown' && r.keyCode === 229 && (a = pt.compositionStart); return a ? (lt && (dt || a !== pt.compositionStart ? a === pt.compositionEnd && dt && (i = Fb()) : (et._root = n, et._startText = Gb(), dt = !0)), a = Mb.getPooled(a, t, r, n), i ? a.data = i : (i = ec(r)) !== null && (a.data = i), Ab(a), i = a) : i = null, (e = ut ? (function gc(e, t) { switch (e) { case 'topCompositionEnd': return ec(t); case 'topKeyPress': return t.which !== 32 ? null : (ft = !0, ct); case 'topTextInput': return (e = t.data) === ct && ft ? null : e; default: return null; } }(e, r)) : (function hc(e, t) { if (dt) return e === 'topCompositionEnd' || !at && dc(e, t) ? (e = Fb(), et._root = null, et._startText = null, et._fallbackText = null, dt = !1, e) : null; switch (e) { case 'topPaste': return null; case 'topKeyPress': if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && t.char.length > 1) return t.char; if (t.which) return String.fromCharCode(t.which); } return null; case 'topCompositionEnd': return lt ? null : t.data; default: return null; } }(e, r))) ? ((t = Nb.getPooled(pt.beforeInput, t, r, n)).data = e, Ab(t)) : t = null, [i, t] } }; let mt = null; let gt = null; let vt = null; function mc(e) { if (e = Re(e)) { mt && typeof mt.restoreControlledState === 'function' || E('194'); const t = Pe(e.stateNode); mt.restoreControlledState(e.stateNode, e.type, t) } } const yt = { injectFiberControlledHostComponent(e) { mt = e } }; function oc(e) { gt ? vt ? vt.push(e) : vt = [e] : gt = e } function pc() { if (gt) { let e = gt; const t = vt; if (vt = gt = null, mc(e), t) for (e = 0; e < t.length; e++)mc(t[e]); } } const bt = Object.freeze({ injection: yt, enqueueStateRestore: oc, restoreStateIfNeeded: pc }); function rc(e, t) { return e(t) } let xt = !1; function tc(e, t) { if (xt) return rc(e, t); xt = !0; try { return rc(e, t) } finally { xt = !1, pc() } } let Dt; const _t = {
    color: !0, date: !0, datetime: !0, 'datetime-local': !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0,
  }; function vc(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t === 'input' ? !!_t[e.type] : t === 'textarea' } function wc(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } function yc(e, t) { if (!a.canUseDOM || t && !('addEventListener' in document)) return !1; let r = (t = `on${e}`) in document; return r || ((r = document.createElement('div')).setAttribute(t, 'return;'), r = typeof r[t] === 'function'), !r && Dt && e === 'wheel' && (r = document.implementation.hasFeature('Events.wheel', '3.0')), r } function zc(e) { const t = e.type; return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio') } function Bc(e) {
    e._valueTracker || (e._valueTracker = (function Ac(e) {
      const t = zc(e) ? 'checked' : 'value';


      const r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);


      let n = `${e[t]}`; if (!e.hasOwnProperty(t) && typeof r.get === 'function' && typeof r.set === 'function') {
        return Object.defineProperty(e, t, {
          enumerable: r.enumerable, configurable: !0, get() { return r.get.call(this) }, set(e) { n = `${e}`, r.set.call(this, e) },
        }), { getValue() { return n }, setValue(e) { n = `${e}` }, stopTracking() { e._valueTracker = null, delete e[t] } };
      }
    }(e)));
  } function Cc(e) { if (!e) return !1; const t = e._valueTracker; if (!t) return !0; const r = t.getValue(); let n = ''; return e && (n = zc(e) ? e.checked ? 'true' : 'false' : e.value), (e = n) !== r && (t.setValue(e), !0) }a.canUseDOM && (Dt = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature('', '')); const Ct = { change: { phasedRegistrationNames: { bubbled: 'onChange', captured: 'onChangeCapture' }, dependencies: 'topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange'.split(' ') } }; function Ec(e, t, r) { return (e = T.getPooled(Ct.change, e, t, r)).type = 'change', oc(r), Ab(e), e } let wt = null; let Et = null; function Hc(e) { kb(e), lb(!1) } function Ic(e) { if (Cc(qb(e))) return e; } function Jc(e, t) { if (e === 'topChange') return t; } let St = !1; function Lc() { wt && (wt.detachEvent('onpropertychange', Mc), Et = wt = null) } function Mc(e) { e.propertyName === 'value' && Ic(Et) && tc(Hc, e = Ec(Et, e, wc(e))) } function Nc(e, t, r) { e === 'topFocus' ? (Lc(), Et = r, (wt = t).attachEvent('onpropertychange', Mc)) : e === 'topBlur' && Lc() } function Oc(e) { if (e === 'topSelectionChange' || e === 'topKeyUp' || e === 'topKeyDown') return Ic(Et); } function Pc(e, t) { if (e === 'topClick') return Ic(t); } function $c(e, t) { if (e === 'topInput' || e === 'topChange') return Ic(t); }a.canUseDOM && (St = yc('input') && (!document.documentMode || document.documentMode > 9)); const kt = { eventTypes: Ct, _isInputEventSupported: St, extractEvents(e, t, r, n) { const i = t ? qb(t) : window; let a = i.nodeName && i.nodeName.toLowerCase(); if (a === 'select' || a === 'input' && i.type === 'file') var o = Jc; else if (vc(i)) if (St)o = $c; else { o = Oc; var s = Nc } else !(a = i.nodeName) || a.toLowerCase() !== 'input' || i.type !== 'checkbox' && i.type !== 'radio' || (o = Pc); if (o && (o = o(e, t))) return Ec(o, r, n); s && s(e, i, t), e === 'topBlur' && t != null && (e = t._wrapperState || i._wrapperState) && e.controlled && i.type === 'number' && (e = `${i.value}`, i.getAttribute('value') !== e && i.setAttribute('value', e)) } }; function bd(e, t, r, n) { return T.call(this, e, t, r, n) }T.augmentClass(bd, { view: null, detail: null }); const At = {
    Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey',
  }; function dd(e) { const t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = At[e]) && !!t[e] } function ed() { return dd } function fd(e, t, r, n) { return T.call(this, e, t, r, n) }bd.augmentClass(fd, {
    screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: ed, button: null, buttons: null, relatedTarget(e) { return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement) },
  }); const Tt = { mouseEnter: { registrationName: 'onMouseEnter', dependencies: ['topMouseOut', 'topMouseOver'] }, mouseLeave: { registrationName: 'onMouseLeave', dependencies: ['topMouseOut', 'topMouseOver'] } }; const Pt = { eventTypes: Tt, extractEvents(e, t, r, n) { if (e === 'topMouseOver' && (r.relatedTarget || r.fromElement) || e !== 'topMouseOut' && e !== 'topMouseOver') return null; var i = n.window === n ? n : (i = n.ownerDocument) ? i.defaultView || i.parentWindow : window; if (e === 'topMouseOut' ? (e = t, t = (t = r.relatedTarget || r.toElement) ? pb(t) : null) : e = null, e === t) return null; const a = e == null ? i : qb(e); i = t == null ? i : qb(t); const o = fd.getPooled(Tt.mouseLeave, e, r, n); return o.type = 'mouseleave', o.target = a, o.relatedTarget = i, (r = fd.getPooled(Tt.mouseEnter, t, r, n)).type = 'mouseenter', r.target = i, r.relatedTarget = a, Bb(o, r, e, t), [o, r] } }; const Rt = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner; function jd(e) { return typeof (e = e.type) === 'string' ? e : typeof e === 'function' ? e.displayName || e.name : null } function kd(e) { let t = e; if (e.alternate) for (;t.return;)t = t.return; else { if ((2 & t.effectTag) != 0) return 1; for (;t.return;) if ((2 & (t = t.return).effectTag) != 0) return 1; } return t.tag === 3 ? 2 : 3 } function ld(e) { return !!(e = e._reactInternalFiber) && kd(e) === 2 } function md(e) { kd(e) !== 2 && E('188') } function nd(e) { let t = e.alternate; if (!t) return (t = kd(e)) === 3 && E('188'), t === 1 ? null : e; for (var r = e, n = t; ;) { const i = r.return; const a = i ? i.alternate : null; if (!i || !a) break; if (i.child === a.child) { for (var o = i.child; o;) { if (o === r) return md(i), e; if (o === n) return md(i), t; o = o.sibling }E('188') } if (r.return !== n.return)r = i, n = a; else { o = !1; for (var s = i.child; s;) { if (s === r) { o = !0, r = i, n = a; break } if (s === n) { o = !0, n = i, r = a; break }s = s.sibling } if (!o) { for (s = a.child; s;) { if (s === r) { o = !0, r = a, n = i; break } if (s === n) { o = !0, n = a, r = i; break }s = s.sibling }o || E('189') } }r.alternate !== n && E('190') } return r.tag !== 3 && E('188'), r.stateNode.current === r ? e : t } const Ot = []; function rd(e) { let t = e.targetInst; do { if (!t) { e.ancestors.push(t); break } var r; for (r = t; r.return;)r = r.return; if (!(r = r.tag !== 3 ? null : r.stateNode.containerInfo)) break; e.ancestors.push(t), t = pb(r) } while (t);for (r = 0; r < e.ancestors.length; r++)t = e.ancestors[r], Lt(e.topLevelType, t, e.nativeEvent, wc(e.nativeEvent)); } let Ft = !0; var Lt = void 0; function ud(e) { Ft = !!e } function U(e, t, r) { return r ? l.listen(r, t, vd.bind(null, e)) : null } function wd(e, t, r) { return r ? l.capture(r, t, vd.bind(null, e)) : null } function vd(e, t) {
    if (Ft) {
      let r = wc(t); if ((r = pb(r)) === null || typeof r.tag !== 'number' || kd(r) === 2 || (r = null), Ot.length) { const n = Ot.pop(); n.topLevelType = e, n.nativeEvent = t, n.targetInst = r, e = n } else {
        e = {
          topLevelType: e, nativeEvent: t, targetInst: r, ancestors: [],
        };
      } try { tc(rd, e) } finally { e.topLevelType = null, e.nativeEvent = null, e.targetInst = null, e.ancestors.length = 0, Ot.length < 10 && Ot.push(e) }
    }
  } const Mt = Object.freeze({
    get _enabled() { return Ft }, get _handleTopLevel() { return Lt }, setHandleTopLevel(e) { Lt = e }, setEnabled: ud, isEnabled() { return Ft }, trapBubbledEvent: U, trapCapturedEvent: wd, dispatchEvent: vd,
  }); function yd(e, t) { const r = {}; return r[e.toLowerCase()] = t.toLowerCase(), r[`Webkit${e}`] = `webkit${t}`, r[`Moz${e}`] = `moz${t}`, r[`ms${e}`] = `MS${t}`, r[`O${e}`] = `o${t.toLowerCase()}`, r } const jt = {
    animationend: yd('Animation', 'AnimationEnd'), animationiteration: yd('Animation', 'AnimationIteration'), animationstart: yd('Animation', 'AnimationStart'), transitionend: yd('Transition', 'TransitionEnd'),
  }; const Nt = {}; let It = {}; function Cd(e) { if (Nt[e]) return Nt[e]; if (!jt[e]) return e; let t; const r = jt[e]; for (t in r) if (r.hasOwnProperty(t) && t in It) return Nt[e] = r[t]; return '' }a.canUseDOM && (It = document.createElement('div').style, 'AnimationEvent' in window || (delete jt.animationend.animation, delete jt.animationiteration.animation, delete jt.animationstart.animation), 'TransitionEvent' in window || delete jt.transitionend.transition); const Bt = {
    topAbort: 'abort', topAnimationEnd: Cd('animationend') || 'animationend', topAnimationIteration: Cd('animationiteration') || 'animationiteration', topAnimationStart: Cd('animationstart') || 'animationstart', topBlur: 'blur', topCancel: 'cancel', topCanPlay: 'canplay', topCanPlayThrough: 'canplaythrough', topChange: 'change', topClick: 'click', topClose: 'close', topCompositionEnd: 'compositionend', topCompositionStart: 'compositionstart', topCompositionUpdate: 'compositionupdate', topContextMenu: 'contextmenu', topCopy: 'copy', topCut: 'cut', topDoubleClick: 'dblclick', topDrag: 'drag', topDragEnd: 'dragend', topDragEnter: 'dragenter', topDragExit: 'dragexit', topDragLeave: 'dragleave', topDragOver: 'dragover', topDragStart: 'dragstart', topDrop: 'drop', topDurationChange: 'durationchange', topEmptied: 'emptied', topEncrypted: 'encrypted', topEnded: 'ended', topError: 'error', topFocus: 'focus', topInput: 'input', topKeyDown: 'keydown', topKeyPress: 'keypress', topKeyUp: 'keyup', topLoadedData: 'loadeddata', topLoad: 'load', topLoadedMetadata: 'loadedmetadata', topLoadStart: 'loadstart', topMouseDown: 'mousedown', topMouseMove: 'mousemove', topMouseOut: 'mouseout', topMouseOver: 'mouseover', topMouseUp: 'mouseup', topPaste: 'paste', topPause: 'pause', topPlay: 'play', topPlaying: 'playing', topProgress: 'progress', topRateChange: 'ratechange', topScroll: 'scroll', topSeeked: 'seeked', topSeeking: 'seeking', topSelectionChange: 'selectionchange', topStalled: 'stalled', topSuspend: 'suspend', topTextInput: 'textInput', topTimeUpdate: 'timeupdate', topToggle: 'toggle', topTouchCancel: 'touchcancel', topTouchEnd: 'touchend', topTouchMove: 'touchmove', topTouchStart: 'touchstart', topTransitionEnd: Cd('transitionend') || 'transitionend', topVolumeChange: 'volumechange', topWaiting: 'waiting', topWheel: 'wheel',
  }; const qt = {}; let Ut = 0; const zt = `_reactListenersID${(`${Math.random()}`).slice(2)}`; function Hd(e) { return Object.prototype.hasOwnProperty.call(e, zt) || (e[zt] = Ut++, qt[e[zt]] = {}), qt[e[zt]] } function Id(e) { for (;e && e.firstChild;)e = e.firstChild; return e } function Jd(e, t) { let r; let n = Id(e); for (e = 0; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r }e: { for (;n;) { if (n.nextSibling) { n = n.nextSibling; break e }n = n.parentNode }n = void 0 }n = Id(n) } } function Kd(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === 'input' && e.type === 'text' || t === 'textarea' || e.contentEditable === 'true') } const Vt = a.canUseDOM && 'documentMode' in document && document.documentMode <= 11; const Ht = { select: { phasedRegistrationNames: { bubbled: 'onSelect', captured: 'onSelectCapture' }, dependencies: 'topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange'.split(' ') } }; let $t = null; let Gt = null; let Jt = null; let Wt = !1; function Rd(e, t) {
    if (Wt || $t == null || $t !== p()) return null; let r = $t; return 'selectionStart' in r && Kd(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : window.getSelection ? r = {
      anchorNode: (r = window.getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset,
    } : r = void 0, Jt && x(Jt, r) ? null : (Jt = r, (e = T.getPooled(Ht.select, Gt, e, t)).type = 'select', e.target = $t, Ab(e), e);
  } const Kt = { eventTypes: Ht, extractEvents(e, t, r, n) { let i; let a = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; if (!(i = !a)) { e: { a = Hd(a), i = Ae.onSelect; for (let o = 0; o < i.length; o++) { const s = i[o]; if (!a.hasOwnProperty(s) || !a[s]) { a = !1; break e } }a = !0 }i = !a } if (i) return null; switch (a = t ? qb(t) : window, e) { case 'topFocus': (vc(a) || a.contentEditable === 'true') && ($t = a, Gt = t, Jt = null); break; case 'topBlur': Jt = Gt = $t = null; break; case 'topMouseDown': Wt = !0; break; case 'topContextMenu': case 'topMouseUp': return Wt = !1, Rd(r, n); case 'topSelectionChange': if (Vt) break; case 'topKeyDown': case 'topKeyUp': return Rd(r, n); } return null } }; function Td(e, t, r, n) { return T.call(this, e, t, r, n) } function Ud(e, t, r, n) { return T.call(this, e, t, r, n) } function Vd(e, t, r, n) { return T.call(this, e, t, r, n) } function Wd(e) { const t = e.keyCode; return 'charCode' in e ? (e = e.charCode) === 0 && t === 13 && (e = 13) : e = t, e >= 32 || e === 13 ? e : 0 }T.augmentClass(Td, { animationName: null, elapsedTime: null, pseudoElement: null }), T.augmentClass(Ud, { clipboardData(e) { return 'clipboardData' in e ? e.clipboardData : window.clipboardData } }), bd.augmentClass(Vd, { relatedTarget: null }); const Xt = {
    Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified',
  }; const Yt = {
    8: 'Backspace', 9: 'Tab', 12: 'Clear', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Escape', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NumLock', 145: 'ScrollLock', 224: 'Meta',
  }; function Zd(e, t, r, n) { return T.call(this, e, t, r, n) } function $d(e, t, r, n) { return T.call(this, e, t, r, n) } function ae(e, t, r, n) { return T.call(this, e, t, r, n) } function be(e, t, r, n) { return T.call(this, e, t, r, n) } function ce(e, t, r, n) { return T.call(this, e, t, r, n) }bd.augmentClass(Zd, {
    key(e) { if (e.key) { const t = Xt[e.key] || e.key; if (t !== 'Unidentified') return t; } return e.type === 'keypress' ? (e = Wd(e)) === 13 ? 'Enter' : String.fromCharCode(e) : e.type === 'keydown' || e.type === 'keyup' ? Yt[e.keyCode] || 'Unidentified' : '' }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: ed, charCode(e) { return e.type === 'keypress' ? Wd(e) : 0 }, keyCode(e) { return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0 }, which(e) { return e.type === 'keypress' ? Wd(e) : e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0 },
  }), fd.augmentClass($d, { dataTransfer: null }), bd.augmentClass(ae, {
    touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: ed,
  }), T.augmentClass(be, { propertyName: null, elapsedTime: null, pseudoElement: null }), fd.augmentClass(ce, {
    deltaX(e) { return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0 }, deltaY(e) { return 'deltaY' in e ? e.deltaY : 'wheelDeltaY' in e ? -e.wheelDeltaY : 'wheelDelta' in e ? -e.wheelDelta : 0 }, deltaZ: null, deltaMode: null,
  }); const Qt = {}; const Zt = {}; 'abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel'.split(' ').forEach((e) => { let t = e[0].toUpperCase() + e.slice(1); let r = `on${t}`; r = { phasedRegistrationNames: { bubbled: r, captured: `${r}Capture` }, dependencies: [t = `top${t}`] }, Qt[e] = r, Zt[t] = r }); const er = { eventTypes: Qt, extractEvents(e, t, r, n) { const i = Zt[e]; if (!i) return null; switch (e) { case 'topKeyPress': if (Wd(r) === 0) return null; case 'topKeyDown': case 'topKeyUp': e = Zd; break; case 'topBlur': case 'topFocus': e = Vd; break; case 'topClick': if (r.button === 2) return null; case 'topDoubleClick': case 'topMouseDown': case 'topMouseMove': case 'topMouseUp': case 'topMouseOut': case 'topMouseOver': case 'topContextMenu': e = fd; break; case 'topDrag': case 'topDragEnd': case 'topDragEnter': case 'topDragExit': case 'topDragLeave': case 'topDragOver': case 'topDragStart': case 'topDrop': e = $d; break; case 'topTouchCancel': case 'topTouchEnd': case 'topTouchMove': case 'topTouchStart': e = ae; break; case 'topAnimationEnd': case 'topAnimationIteration': case 'topAnimationStart': e = Td; break; case 'topTransitionEnd': e = be; break; case 'topScroll': e = bd; break; case 'topWheel': e = ce; break; case 'topCopy': case 'topCut': case 'topPaste': e = Ud; break; default: e = T; } return Ab(t = e.getPooled(i, t, r, n)), t } }; Lt = function (e, t, r, n) { kb(e = jb(e, t, r, n)), lb(!1) }, je.injectEventPluginOrder('ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin'.split(' ')), Pe = We.getFiberCurrentPropsFromNode, Re = We.getInstanceFromNode, Oe = We.getNodeFromInstance, je.injectEventPluginsByName({
    SimpleEventPlugin: er, EnterLeaveEventPlugin: Pt, ChangeEventPlugin: kt, SelectEventPlugin: Kt, BeforeInputEventPlugin: ht,
  }); const tr = []; let rr = -1; function V(e) { rr < 0 || (e.current = tr[rr], tr[rr] = null, rr--) } function W(e, t) { tr[++rr] = e.current, e.current = t } new Set(); const nr = { current: C }; const ir = { current: !1 }; let ar = C; function ke(e) { return le(e) ? ar : nr.current } function me(e, t) { const r = e.type.contextTypes; if (!r) return C; const n = e.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext; let i; const a = {}; for (i in r)a[i] = t[i]; return n && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = a), a } function le(e) { return e.tag === 2 && e.type.childContextTypes != null } function ne(e) { le(e) && (V(ir), V(nr)) } function oe(e, t, r) { nr.cursor != null && E('168'), W(nr, t), W(ir, r) } function pe(e, t) { let r = e.stateNode; const n = e.type.childContextTypes; if (typeof r.getChildContext !== 'function') return t; for (const i in r = r.getChildContext())i in n || E('108', jd(e) || 'Unknown', i); return o({}, t, r) } function qe(e) { if (!le(e)) return !1; let t = e.stateNode; return t = t && t.__reactInternalMemoizedMergedChildContext || C, ar = nr.current, W(nr, t), W(ir, ir.current), !0 } function re(e, t) { const r = e.stateNode; if (r || E('169'), t) { const n = pe(e, ar); r.__reactInternalMemoizedMergedChildContext = n, V(ir), V(nr), W(nr, n) } else V(ir); W(ir, t) } function Y(e, t, r) { this.tag = e, this.key = t, this.stateNode = this.type = null, this.sibling = this.child = this.return = null, this.index = 0, this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null, this.internalContextTag = r, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.expirationTime = 0, this.alternate = null } function se(e, t, r) { let n = e.alternate; return n === null ? ((n = new Y(e.tag, e.key, e.internalContextTag)).type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.effectTag = 0, n.nextEffect = null, n.firstEffect = null, n.lastEffect = null), n.expirationTime = r, n.pendingProps = t, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function te(e, t, r) { let n = void 0; const i = e.type; const a = e.key; return typeof i === 'function' ? ((n = i.prototype && i.prototype.isReactComponent ? new Y(2, a, t) : new Y(0, a, t)).type = i, n.pendingProps = e.props) : typeof i === 'string' ? ((n = new Y(5, a, t)).type = i, n.pendingProps = e.props) : typeof i === 'object' && i !== null && typeof i.tag === 'number' ? (n = i).pendingProps = e.props : E('130', i == null ? i : typeof i, ''), n.expirationTime = r, n } function ue(e, t, r, n) { return (t = new Y(10, n, t)).pendingProps = e, t.expirationTime = r, t } function ve(e, t, r) { return (t = new Y(6, null, t)).pendingProps = e, t.expirationTime = r, t } function we(e, t, r) { return (t = new Y(7, e.key, t)).type = e.handler, t.pendingProps = e, t.expirationTime = r, t } function xe(e, t, r) { return (e = new Y(9, null, t)).expirationTime = r, e } function ye(e, t, r) { return (t = new Y(4, e.key, t)).pendingProps = e.children || [], t.expirationTime = r, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } let or = null; let sr = null; function Be(e) { return function (t) { try { return e(t) } catch (e) {} } } function De(e) { typeof or === 'function' && or(e) } function Ee(e) { typeof sr === 'function' && sr(e) } function Fe(e) {
    return {
      baseState: e, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1,
    };
  } function Ge(e, t) { e.last === null ? e.first = e.last = t : (e.last.next = t, e.last = t), (e.expirationTime === 0 || e.expirationTime > t.expirationTime) && (e.expirationTime = t.expirationTime) } function He(e, t) { const r = e.alternate; let n = e.updateQueue; n === null && (n = e.updateQueue = Fe(null)), r !== null ? (e = r.updateQueue) === null && (e = r.updateQueue = Fe(null)) : e = null, (e = e !== n ? e : null) === null ? Ge(n, t) : n.last === null || e.last === null ? (Ge(n, t), Ge(e, t)) : (Ge(n, t), e.last = t) } function Ie(e, t, r, n) { return typeof (e = e.partialState) === 'function' ? e.call(t, r, n) : e } function Je(e, t, r, n, i, a) {
    e !== null && e.updateQueue === r && (r = t.updateQueue = {
      baseState: r.baseState, expirationTime: r.expirationTime, first: r.first, last: r.last, isInitialized: r.isInitialized, callbackList: null, hasForceUpdate: !1,
    }), r.expirationTime = 0, r.isInitialized ? e = r.baseState : (e = r.baseState = t.memoizedState, r.isInitialized = !0); for (var s = !0, u = r.first, l = !1; u !== null;) { let c = u.expirationTime; if (c > a) { const p = r.expirationTime; (p === 0 || p > c) && (r.expirationTime = c), l || (l = !0, r.baseState = e) } else l || (r.first = u.next, r.first === null && (r.last = null)), u.isReplace ? (e = Ie(u, n, e, i), s = !0) : (c = Ie(u, n, e, i)) && (e = s ? o({}, e, c) : o(e, c), s = !1), u.isForced && (r.hasForceUpdate = !0), u.callback !== null && ((c = r.callbackList) === null && (c = r.callbackList = []), c.push(u)); u = u.next } return r.callbackList !== null ? t.effectTag |= 32 : r.first !== null || r.hasForceUpdate || (t.updateQueue = null), l || (r.baseState = e), e;
  } function Ke(e, t) { const r = e.callbackList; if (r !== null) for (e.callbackList = null, e = 0; e < r.length; e++) { const n = r[e]; const i = n.callback; n.callback = null, typeof i !== 'function' && E('191', i), i.call(t) } } const ur = typeof Symbol === 'function' && Symbol.for; const lr = ur ? Symbol.for('react.element') : 60103; const cr = ur ? Symbol.for('react.call') : 60104; const pr = ur ? Symbol.for('react.return') : 60105; const fr = ur ? Symbol.for('react.portal') : 60106; const dr = ur ? Symbol.for('react.fragment') : 60107; const hr = typeof Symbol === 'function' && Symbol.iterator; function Xe(e) { return e === null || void 0 === e ? null : typeof (e = hr && e[hr] || e['@@iterator']) === 'function' ? e : null } const mr = Array.isArray; function Ze(e, t) { const r = t.ref; if (r !== null && typeof r !== 'function') { if (t._owner) { let n = void 0; (t = t._owner) && (t.tag !== 2 && E('110'), n = t.stateNode), n || E('147', r); const i = `${r}`; return e !== null && e.ref !== null && e.ref._stringRef === i ? e.ref : ((e = function (e) { const t = n.refs === C ? n.refs = {} : n.refs; e === null ? delete t[i] : t[i] = e })._stringRef = i, e) } typeof r !== 'string' && E('148'), t._owner || E('149', r) } return r } function $e(e, t) { e.type !== 'textarea' && E('31', Object.prototype.toString.call(t) === '[object Object]' ? `object with keys {${Object.keys(t).join(', ')}}` : t, '') } function af(t) { function b(e, r) { if (t) { const n = e.lastEffect; n !== null ? (n.nextEffect = r, e.lastEffect = r) : e.firstEffect = e.lastEffect = r, r.nextEffect = null, r.effectTag = 8 } } function c(e, r) { if (!t) return null; for (;r !== null;)b(e, r), r = r.sibling; return null } function d(e, t) { for (e = new Map(); t !== null;)t.key !== null ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function e(e, t, r) { return (e = se(e, t, r)).index = 0, e.sibling = null, e } function f(e, r, n) { return e.index = n, t ? (n = e.alternate) !== null ? (n = n.index) < r ? (e.effectTag = 2, r) : n : (e.effectTag = 2, r) : r } function g(e) { return t && e.alternate === null && (e.effectTag = 2), e } function h(t, r, n, i) { return r === null || r.tag !== 6 ? ((r = ve(n, t.internalContextTag, i)).return = t, r) : ((r = e(r, n, i)).return = t, r) } function k(t, r, n, i) { return r !== null && r.type === n.type ? ((i = e(r, n.props, i)).ref = Ze(r, n), i.return = t, i) : ((i = te(n, t.internalContextTag, i)).ref = Ze(r, n), i.return = t, i) } function q(t, r, n, i) { return r === null || r.tag !== 7 ? ((r = we(n, t.internalContextTag, i)).return = t, r) : ((r = e(r, n, i)).return = t, r) } function v(t, r, n, i) { return r === null || r.tag !== 9 ? ((r = xe(n, t.internalContextTag, i)).type = n.value, r.return = t, r) : ((r = e(r, null, i)).type = n.value, r.return = t, r) } function y(t, r, n, i) { return r === null || r.tag !== 4 || r.stateNode.containerInfo !== n.containerInfo || r.stateNode.implementation !== n.implementation ? ((r = ye(n, t.internalContextTag, i)).return = t, r) : ((r = e(r, n.children || [], i)).return = t, r) } function u(t, r, n, i, a) { return r === null || r.tag !== 10 ? ((r = ue(n, t.internalContextTag, i, a)).return = t, r) : ((r = e(r, n, i)).return = t, r) } function z(e, t, r) { if (typeof t === 'string' || typeof t === 'number') return (t = ve(`${t}`, e.internalContextTag, r)).return = e, t; if (typeof t === 'object' && t !== null) { switch (t.$$typeof) { case lr: return t.type === dr ? ((t = ue(t.props.children, e.internalContextTag, r, t.key)).return = e, t) : ((r = te(t, e.internalContextTag, r)).ref = Ze(null, t), r.return = e, r); case cr: return (t = we(t, e.internalContextTag, r)).return = e, t; case pr: return (r = xe(t, e.internalContextTag, r)).type = t.value, r.return = e, r; case fr: return (t = ye(t, e.internalContextTag, r)).return = e, t; } if (mr(t) || Xe(t)) return (t = ue(t, e.internalContextTag, r, null)).return = e, t; $e(e, t) } return null } function G(e, t, r, n) { const i = t !== null ? t.key : null; if (typeof r === 'string' || typeof r === 'number') return i !== null ? null : h(e, t, `${r}`, n); if (typeof r === 'object' && r !== null) { switch (r.$$typeof) { case lr: return r.key === i ? r.type === dr ? u(e, t, r.props.children, n, i) : k(e, t, r, n) : null; case cr: return r.key === i ? q(e, t, r, n) : null; case pr: return i === null ? v(e, t, r, n) : null; case fr: return r.key === i ? y(e, t, r, n) : null; } if (mr(r) || Xe(r)) return i !== null ? null : u(e, t, r, n, null); $e(e, r) } return null } function I(e, t, r, n, i) { if (typeof n === 'string' || typeof n === 'number') return h(t, e = e.get(r) || null, `${n}`, i); if (typeof n === 'object' && n !== null) { switch (n.$$typeof) { case lr: return e = e.get(n.key === null ? r : n.key) || null, n.type === dr ? u(t, e, n.props.children, i, n.key) : k(t, e, n, i); case cr: return q(t, e = e.get(n.key === null ? r : n.key) || null, n, i); case pr: return v(t, e = e.get(r) || null, n, i); case fr: return y(t, e = e.get(n.key === null ? r : n.key) || null, n, i); } if (mr(n) || Xe(n)) return u(t, e = e.get(r) || null, n, i, null); $e(t, n) } return null } function L(e, r, n, i) { for (var a = null, o = null, s = r, u = r = 0, l = null; s !== null && u < n.length; u++) { s.index > u ? (l = s, s = null) : l = s.sibling; const p = G(e, s, n[u], i); if (p === null) { s === null && (s = l); break }t && s && p.alternate === null && b(e, s), r = f(p, r, u), o === null ? a = p : o.sibling = p, o = p, s = l } if (u === n.length) return c(e, s), a; if (s === null) { for (;u < n.length; u++)(s = z(e, n[u], i)) && (r = f(s, r, u), o === null ? a = s : o.sibling = s, o = s); return a } for (s = d(e, s); u < n.length; u++)(l = I(s, e, u, n[u], i)) && (t && l.alternate !== null && s.delete(l.key === null ? u : l.key), r = f(l, r, u), o === null ? a = l : o.sibling = l, o = l); return t && s.forEach(t => b(e, t)), a } function N(e, r, n, i) { let a = Xe(n); typeof a !== 'function' && E('150'), (n = a.call(n)) == null && E('151'); for (var o = a = null, s = r, u = r = 0, l = null, p = n.next(); s !== null && !p.done; u++, p = n.next()) { s.index > u ? (l = s, s = null) : l = s.sibling; const h = G(e, s, p.value, i); if (h === null) { s || (s = l); break }t && s && h.alternate === null && b(e, s), r = f(h, r, u), o === null ? a = h : o.sibling = h, o = h, s = l } if (p.done) return c(e, s), a; if (s === null) { for (;!p.done; u++, p = n.next())(p = z(e, p.value, i)) !== null && (r = f(p, r, u), o === null ? a = p : o.sibling = p, o = p); return a } for (s = d(e, s); !p.done; u++, p = n.next())(p = I(s, e, u, p.value, i)) !== null && (t && p.alternate !== null && s.delete(p.key === null ? u : p.key), r = f(p, r, u), o === null ? a = p : o.sibling = p, o = p); return t && s.forEach(t => b(e, t)), a } return function (t, r, n, i) { typeof n === 'object' && n !== null && n.type === dr && n.key === null && (n = n.props.children); let a = typeof n === 'object' && n !== null; if (a) switch (n.$$typeof) { case lr: e: { const o = n.key; for (a = r; a !== null;) { if (a.key === o) { if (a.tag === 10 ? n.type === dr : a.type === n.type) { c(t, a.sibling), (r = e(a, n.type === dr ? n.props.children : n.props, i)).ref = Ze(a, n), r.return = t, t = r; break e }c(t, a); break }b(t, a), a = a.sibling }n.type === dr ? ((r = ue(n.props.children, t.internalContextTag, i, n.key)).return = t, t = r) : ((i = te(n, t.internalContextTag, i)).ref = Ze(r, n), i.return = t, t = i) } return g(t); case cr: e: { for (a = n.key; r !== null;) { if (r.key === a) { if (r.tag === 7) { c(t, r.sibling), (r = e(r, n, i)).return = t, t = r; break e }c(t, r); break }b(t, r), r = r.sibling }(r = we(n, t.internalContextTag, i)).return = t, t = r } return g(t); case pr: e: { if (r !== null) { if (r.tag === 9) { c(t, r.sibling), (r = e(r, null, i)).type = n.value, r.return = t, t = r; break e }c(t, r) }(r = xe(n, t.internalContextTag, i)).type = n.value, r.return = t, t = r } return g(t); case fr: e: { for (a = n.key; r !== null;) { if (r.key === a) { if (r.tag === 4 && r.stateNode.containerInfo === n.containerInfo && r.stateNode.implementation === n.implementation) { c(t, r.sibling), (r = e(r, n.children || [], i)).return = t, t = r; break e }c(t, r); break }b(t, r), r = r.sibling }(r = ye(n, t.internalContextTag, i)).return = t, t = r } return g(t); } if (typeof n === 'string' || typeof n === 'number') return n = `${n}`, r !== null && r.tag === 6 ? (c(t, r.sibling), r = e(r, n, i)) : (c(t, r), r = ve(n, t.internalContextTag, i)), r.return = t, g(t = r); if (mr(n)) return L(t, r, n, i); if (Xe(n)) return N(t, r, n, i); if (a && $e(t, n), void 0 === n) switch (t.tag) { case 2: case 1: E('152', (i = t.type).displayName || i.name || 'Component'); } return c(t, r) } } const gr = af(!0); const vr = af(!1); function df(e, t, r, n, i) {
    function f(e, t, r) { const n = t.expirationTime; t.child = e === null ? vr(t, null, r, n) : gr(t, e.child, r, n) } function g(e, t) { const r = t.ref; r === null || e && e.ref === r || (t.effectTag |= 128) } function h(e, t, r, n) { if (g(e, t), !r) return n && re(t, !1), q(e, t); r = t.stateNode, Rt.current = t; const i = r.render(); return t.effectTag |= 1, f(e, t, i), t.memoizedState = r.state, t.memoizedProps = r.props, n && re(t, !0), t.child } function k(e) { const t = e.stateNode; t.pendingContext ? oe(0, t.pendingContext, t.pendingContext !== t.context) : t.context && oe(0, t.context, !1), l(e, t.containerInfo) } function q(e, t) { if (e !== null && t.child !== e.child && E('153'), t.child !== null) { let r = se(e = t.child, e.pendingProps, e.expirationTime); for (t.child = r, r.return = t; e.sibling !== null;)e = e.sibling, (r = r.sibling = se(e, e.pendingProps, e.expirationTime)).return = t; r.sibling = null } return t.child } function v(e, t) { switch (t.tag) { case 3: k(t); break; case 2: qe(t); break; case 4: l(t, t.stateNode.containerInfo); } return null } const a = e.shouldSetTextContent; const o = e.useSyncScheduling; const s = e.shouldDeprioritizeSubtree; const u = t.pushHostContext; var l = t.pushHostContainer; const c = r.enterHydrationState; const p = r.resetHydrationState; const d = r.tryToClaimNextHydratableInstance; const m = (e = (function Le(t, r, n, i) {
      function e(e, t) { t.updater = a, e.stateNode = t, t._reactInternalFiber = e } var a = {
        isMounted: ld,
        enqueueSetState(e, n, i) {
          e = e._reactInternalFiber, i = void 0 === i ? null : i; const a = r(e); He(e, {
            expirationTime: a, partialState: n, callback: i, isReplace: !1, isForced: !1, nextCallback: null, next: null,
          }), t(e, a);
        },
        enqueueReplaceState(e, n, i) {
          e = e._reactInternalFiber, i = void 0 === i ? null : i; const a = r(e); He(e, {
            expirationTime: a, partialState: n, callback: i, isReplace: !0, isForced: !1, nextCallback: null, next: null,
          }), t(e, a);
        },
        enqueueForceUpdate(e, n) {
          e = e._reactInternalFiber, n = void 0 === n ? null : n; const i = r(e); He(e, {
            expirationTime: i, partialState: null, callback: n, isReplace: !1, isForced: !0, nextCallback: null, next: null,
          }), t(e, i);
        },
      }; return {
        adoptClassInstance: e, constructClassInstance(t, r) { const n = t.type; const i = ke(t); const a = t.tag === 2 && t.type.contextTypes != null; const o = a ? me(t, i) : C; return e(t, r = new n(r, o)), a && ((t = t.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = o), r }, mountClassInstance(e, t) { const r = e.alternate; const n = e.stateNode; let i = n.state || null; const o = e.pendingProps; o || E('158'); const s = ke(e); n.props = o, n.state = e.memoizedState = i, n.refs = C, n.context = me(e, s), e.type != null && e.type.prototype != null && !0 === e.type.prototype.unstable_isAsyncReactComponent && (e.internalContextTag |= 1), typeof n.componentWillMount === 'function' && (i = n.state, n.componentWillMount(), i !== n.state && a.enqueueReplaceState(n, n.state, null), (i = e.updateQueue) !== null && (n.state = Je(r, e, i, n, o, t))), typeof n.componentDidMount === 'function' && (e.effectTag |= 4) }, updateClassInstance(e, t, r) { const o = t.stateNode; o.props = t.memoizedProps, o.state = t.memoizedState; const s = t.memoizedProps; let u = t.pendingProps; u || (u = s) == null && E('159'); let l = o.context; let c = ke(t); if (c = me(t, c), typeof o.componentWillReceiveProps !== 'function' || s === u && l === c || (l = o.state, o.componentWillReceiveProps(u, c), o.state !== l && a.enqueueReplaceState(o, o.state, null)), l = t.memoizedState, r = t.updateQueue !== null ? Je(e, t, t.updateQueue, o, u, r) : l, !(s !== u || l !== r || ir.current || t.updateQueue !== null && t.updateQueue.hasForceUpdate)) return typeof o.componentDidUpdate !== 'function' || s === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 4), !1; let p = u; if (s === null || t.updateQueue !== null && t.updateQueue.hasForceUpdate)p = !0; else { const f = t.stateNode; const d = t.type; p = typeof f.shouldComponentUpdate === 'function' ? f.shouldComponentUpdate(p, r, c) : !(d.prototype && d.prototype.isPureReactComponent && x(s, p) && x(l, r)) } return p ? (typeof o.componentWillUpdate === 'function' && o.componentWillUpdate(u, r, c), typeof o.componentDidUpdate === 'function' && (t.effectTag |= 4)) : (typeof o.componentDidUpdate !== 'function' || s === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 4), n(t, u), i(t, r)), o.props = u, o.state = r, o.context = c, p },
      };
    }(n, i, (e, t) => { e.memoizedProps = t }, (e, t) => { e.memoizedState = t }))).adoptClassInstance; const y = e.constructClassInstance; const b = e.mountClassInstance; const D = e.updateClassInstance; return { beginWork(e, t, r) { if (t.expirationTime === 0 || t.expirationTime > r) return v(0, t); switch (t.tag) { case 0: e !== null && E('155'); var n = t.type; var i = t.pendingProps; var x = ke(t); return n = n(i, x = me(t, x)), t.effectTag |= 1, typeof n === 'object' && n !== null && typeof n.render === 'function' ? (t.tag = 2, i = qe(t), m(t, n), b(t, r), t = h(e, t, !0, i)) : (t.tag = 1, f(e, t, n), t.memoizedProps = i, t = t.child), t; case 1: e: { if (i = t.type, r = t.pendingProps, n = t.memoizedProps, ir.current)r === null && (r = n); else if (r === null || n === r) { t = q(e, t); break e }i = i(r, n = me(t, n = ke(t))), t.effectTag |= 1, f(e, t, i), t.memoizedProps = r, t = t.child } return t; case 2: return i = qe(t), n = void 0, e === null ? t.stateNode ? E('153') : (y(t, t.pendingProps), b(t, r), n = !0) : n = D(e, t, r), h(e, t, n, i); case 3: return k(t), (i = t.updateQueue) !== null ? (n = t.memoizedState) === (i = Je(e, t, i, null, null, r)) ? (p(), t = q(e, t)) : (n = i.element, x = t.stateNode, (e === null || e.child === null) && x.hydrate && c(t) ? (t.effectTag |= 2, t.child = vr(t, null, n, r)) : (p(), f(e, t, n)), t.memoizedState = i, t = t.child) : (p(), t = q(e, t)), t; case 5: u(t), e === null && d(t), i = t.type; var _ = t.memoizedProps; return (n = t.pendingProps) === null && ((n = _) === null && E('154')), x = e !== null ? e.memoizedProps : null, ir.current || n !== null && _ !== n ? (_ = n.children, a(i, n) ? _ = null : x && a(i, x) && (t.effectTag |= 16), g(e, t), r !== 2147483647 && !o && s(i, n) ? (t.expirationTime = 2147483647, t = null) : (f(e, t, _), t.memoizedProps = n, t = t.child)) : t = q(e, t), t; case 6: return e === null && d(t), (e = t.pendingProps) === null && (e = t.memoizedProps), t.memoizedProps = e, null; case 8: t.tag = 7; case 7: return i = t.pendingProps, ir.current ? i === null && ((i = e && e.memoizedProps) === null && E('154')) : i !== null && t.memoizedProps !== i || (i = t.memoizedProps), n = i.children, t.stateNode = e === null ? vr(t, t.stateNode, n, r) : gr(t, t.stateNode, n, r), t.memoizedProps = i, t.stateNode; case 9: return null; case 4: e: { if (l(t, t.stateNode.containerInfo), i = t.pendingProps, ir.current)i === null && ((i = e && e.memoizedProps) == null && E('154')); else if (i === null || t.memoizedProps === i) { t = q(e, t); break e }e === null ? t.child = gr(t, null, i, r) : f(e, t, i), t.memoizedProps = i, t = t.child } return t; case 10: e: { if (r = t.pendingProps, ir.current)r === null && (r = t.memoizedProps); else if (r === null || t.memoizedProps === r) { t = q(e, t); break e }f(e, t, r), t.memoizedProps = r, t = t.child } return t; default: E('156'); } }, beginFailedWork(e, t, r) { switch (t.tag) { case 2: qe(t); break; case 3: k(t); break; default: E('157'); } return t.effectTag |= 64, e === null ? t.child = null : t.child !== e.child && (t.child = e.child), t.expirationTime === 0 || t.expirationTime > r ? v(0, t) : (t.firstEffect = null, t.lastEffect = null, t.child = e === null ? vr(t, null, null, r) : gr(t, e.child, null, r), t.tag === 2 && (e = t.stateNode, t.memoizedProps = e.props, t.memoizedState = e.state), t.child) } };
  } const yr = {}; function kf(t) {
    function b(e) { ce = Q = !0; let t = e.stateNode; if (t.current === e && E('177'), t.isReadyForCommit = !1, Rt.current = null, e.effectTag > 1) if (e.lastEffect !== null) { e.lastEffect.nextEffect = e; var r = e.firstEffect } else r = e; else r = e.firstEffect; for (U(), re = r; re !== null;) { var n = !1; var i = void 0; try { for (;re !== null;) { var a = re.effectTag; if (16 & a && D(re), 128 & a) { const o = re.alternate; o !== null && O(o) } switch (-242 & a) { case 2: _(re), re.effectTag &= -3; break; case 6: _(re), re.effectTag &= -3, T(re.alternate, re); break; case 4: T(re.alternate, re); break; case 8: pe = !0, S(re), pe = !1; }re = re.nextEffect } } catch (e) { n = !0, i = e }n && (re === null && E('178'), h(re, i), re !== null && (re = re.nextEffect)) } for (H(), t.current = e, re = r; re !== null;) { r = !1, n = void 0; try { for (;re !== null;) { const s = re.effectTag; if (36 & s && P(re.alternate, re), 128 & s && R(re), 64 & s) switch (i = re, a = void 0, ie !== null && (a = ie.get(i), ie.delete(i), a == null && i.alternate !== null && (i = i.alternate, a = ie.get(i), ie.delete(i))), a == null && E('184'), i.tag) { case 2: i.stateNode.componentDidCatch(a.error, { componentStack: a.componentStack }); break; case 3: ue === null && (ue = a.error); break; default: E('157'); } const u = re.nextEffect; re.nextEffect = null, re = u } } catch (e) { r = !0, n = e }r && (re === null && E('178'), h(re, n), re !== null && (re = re.nextEffect)) } return Q = ce = !1, De(e.stateNode), oe && (oe.forEach(G), oe = null), ue !== null && (e = ue, ue = null, Ob(e)), (t = t.current.expirationTime) === 0 && (ae = ie = null), t } function c(e) { for (;;) { const t = x(e.alternate, e, te); const r = e.return; const n = e.sibling; const i = e; if (te === 2147483647 || i.expirationTime !== 2147483647) { if (i.tag !== 2 && i.tag !== 3) var a = 0; else a = (a = i.updateQueue) === null ? 0 : a.expirationTime; for (let o = i.child; o !== null;)o.expirationTime !== 0 && (a === 0 || a > o.expirationTime) && (a = o.expirationTime), o = o.sibling; i.expirationTime = a } if (t !== null) return t; if (r !== null && (r.firstEffect === null && (r.firstEffect = e.firstEffect), e.lastEffect !== null && (r.lastEffect !== null && (r.lastEffect.nextEffect = e.firstEffect), r.lastEffect = e.lastEffect), e.effectTag > 1 && (r.lastEffect !== null ? r.lastEffect.nextEffect = e : r.firstEffect = e, r.lastEffect = e)), n !== null) return n; if (r === null) { e.stateNode.isReadyForCommit = !0; break }e = r } return null } function d(e) { let t = l(e.alternate, e, te); return t === null && (t = c(e)), Rt.current = null, t } function e(e) { let t = p(e.alternate, e, te); return t === null && (t = c(e)), Rt.current = null, t } function f(t) { if (ie !== null) { if (!(te === 0 || te > t)) if (te <= K) for (;Z !== null;)Z = k(Z) ? e(Z) : d(Z); else for (;Z !== null && !A();)Z = k(Z) ? e(Z) : d(Z); } else if (!(te === 0 || te > t)) if (te <= K) for (;Z !== null;)Z = d(Z); else for (;Z !== null && !A();)Z = d(Z); } function g(t, r) { if (Q && E('243'), Q = !0, t.isReadyForCommit = !1, t !== ee || r !== te || Z === null) { for (;rr > -1;)tr[rr] = null, rr--; ar = C, nr.current = C, ir.current = !1, o(), te = r, Z = se((ee = t).current, null, r) } let n = !1; let s = null; try { f(r) } catch (e) { n = !0, s = e } for (;n;) { if (le) { ue = s; break } let u = Z; if (u === null)le = !0; else { let l = h(u, s); if (l === null && E('183'), !le) { try { for (s = r, l = n = l; u !== null;) { switch (u.tag) { case 2: ne(u); break; case 5: a(u); break; case 3: i(u); break; case 4: i(u); } if (u === l || u.alternate === l) break; u = u.return }Z = e(n), f(s) } catch (e) { n = !0, s = e; continue } break } } } return r = ue, le = Q = !1, ue = null, r !== null && Ob(r), t.isReadyForCommit ? t.current.alternate : null } function h(e, t) {
      let r = Rt.current = null; let n = !1; let i = !1; let a = null; if (e.tag === 3)r = e, q(e) && (le = !0); else for (var o = e.return; o !== null && r === null;) { if (o.tag === 2 ? typeof o.stateNode.componentDidCatch === 'function' && (n = !0, a = jd(o), r = o, i = !0) : o.tag === 3 && (r = o), q(o)) { if (pe || oe !== null && (oe.has(o) || o.alternate !== null && oe.has(o.alternate))) return null; r = null, i = !1 }o = o.return } if (r !== null) {
        ae === null && (ae = new Set()), ae.add(r); let s = ''; o = e; do { switch (o.tag) { case 0: case 1: case 2: case 5: var u = o._debugOwner; var l = o._debugSource; var c = jd(o); var p = null; u && (p = jd(u)), u = l, c = `\n    in ${c || 'Unknown'}${u ? ` (at ${u.fileName.replace(/^.*[\\\/]/, '')}:${u.lineNumber})` : p ? ` (created by ${p})` : ''}`; break; default: c = ''; }s += c, o = o.return } while (o);o = s, e = jd(e), ie === null && (ie = new Map()), t = {
          componentName: e, componentStack: o, error: t, errorBoundary: n ? r.stateNode : null, errorBoundaryFound: n, errorBoundaryName: a, willRetry: i,
        }, ie.set(r, t); try { const f = t.error; f && f.suppressReactErrorLogging || console.error(f) } catch (e) { e && e.suppressReactErrorLogging || console.error(e) } return ce ? (oe === null && (oe = new Set()), oe.add(r)) : G(r), r;
      } return ue === null && (ue = t), null;
    } function k(e) { return ie !== null && (ie.has(e) || e.alternate !== null && ie.has(e.alternate)) } function q(e) { return ae !== null && (ae.has(e) || e.alternate !== null && ae.has(e.alternate)) } function v() { return 20 * (1 + ((I() + 100) / 20 | 0)) } function y(e) { return X !== 0 ? X : Q ? ce ? 1 : te : !B || 1 & e.internalContextTag ? v() : 1 } function u(e, t) { return z(e, t) } function z(e, t) { for (;e !== null;) { if ((e.expirationTime === 0 || e.expirationTime > t) && (e.expirationTime = t), e.alternate !== null && (e.alternate.expirationTime === 0 || e.alternate.expirationTime > t) && (e.alternate.expirationTime = t), e.return === null) { if (e.tag !== 3) break; const r = e.stateNode; !Q && r === ee && t < te && (Z = ee = null, te = 0); const n = r; const i = t; if (Ae > ke && E('185'), n.nextScheduledRoot === null)n.remainingExpirationTime = i, de === null ? (fe = de = n, n.nextScheduledRoot = n) : (de = de.nextScheduledRoot = n).nextScheduledRoot = fe; else { const a = n.remainingExpirationTime; (a === 0 || i < a) && (n.remainingExpirationTime = i) }ge || (we ? Se && m(ve = n, ye = 1) : i === 1 ? w(1, null) : L(i)), !Q && r === ee && t < te && (Z = ee = null, te = 0) }e = e.return } } function G(e) { z(e, 1) } function I() { return K = 2 + ((F() - $) / 10 | 0) } function L(e) { if (he !== 0) { if (e > he) return; j(me) } const t = F() - $; he = e, me = M(J, { timeout: 10 * (e - 2) - t }) } function N() { let e = 0; let t = null; if (de !== null) for (var r = de, n = fe; n !== null;) { let i = n.remainingExpirationTime; if (i === 0) { if ((r === null || de === null) && E('244'), n === n.nextScheduledRoot) { fe = de = n.nextScheduledRoot = null; break } if (n === fe)fe = i = n.nextScheduledRoot, de.nextScheduledRoot = i, n.nextScheduledRoot = null; else { if (n === de) { (de = r).nextScheduledRoot = fe, n.nextScheduledRoot = null; break }r.nextScheduledRoot = n.nextScheduledRoot, n.nextScheduledRoot = null }n = r.nextScheduledRoot } else { if ((e === 0 || i < e) && (e = i, t = n), n === de) break; r = n, n = n.nextScheduledRoot } }(r = ve) !== null && r === t ? Ae++ : Ae = 0, ve = t, ye = e } function J(e) { w(0, e) } function w(e, t) { for (Ce = t, N(); ve !== null && ye !== 0 && (e === 0 || ye <= e) && !be;)m(ve, ye), N(); if (Ce !== null && (he = 0, me = -1), ye !== 0 && L(ye), Ce = null, be = !1, Ae = 0, xe) throw e = _e, _e = null, xe = !1, e; } function m(e, t) { if (ge && E('245'), ge = !0, t <= I()) { var r = e.finishedWork; r !== null ? (e.finishedWork = null, e.remainingExpirationTime = b(r)) : (e.finishedWork = null, (r = g(e, t)) !== null && (e.remainingExpirationTime = b(r))) } else (r = e.finishedWork) !== null ? (e.finishedWork = null, e.remainingExpirationTime = b(r)) : (e.finishedWork = null, (r = g(e, t)) !== null && (A() ? e.finishedWork = r : e.remainingExpirationTime = b(r))); ge = !1 } function A() { return !(Ce === null || Ce.timeRemaining() > Te) && (be = !0) } function Ob(e) { ve === null && E('246'), ve.remainingExpirationTime = 0, xe || (xe = !0, _e = e) } let r = (function hf(e) {
      function b(e) { return e === yr && E('174'), e } const t = e.getChildHostContext; const r = e.getRootHostContext; const n = { current: yr }; const i = { current: yr }; const a = { current: yr }; return {
        getHostContext() { return b(n.current) }, getRootHostContainer() { return b(a.current) }, popHostContainer(e) { V(n), V(i), V(a) }, popHostContext(e) { i.current === e && (V(n), V(i)) }, pushHostContainer(e, t) { W(a, t), t = r(t), W(i, e), W(n, t) }, pushHostContext(e) { let r = b(a.current); const o = b(n.current); o !== (r = t(o, e.type, r)) && (W(i, e), W(n, r)) }, resetHostContainer() { n.current = yr, a.current = yr },
      };
    }(t)); const n = (function jf(e) {
      function b(e, t) { const r = new Y(5, null, 0); r.type = 'DELETED', r.stateNode = t, r.return = e, r.effectTag = 8, e.lastEffect !== null ? (e.lastEffect.nextEffect = r, e.lastEffect = r) : e.firstEffect = e.lastEffect = r } function c(e, t) { switch (e.tag) { case 5: return (t = r(t, e.type, e.pendingProps)) !== null && (e.stateNode = t, !0); case 6: return (t = n(t, e.pendingProps)) !== null && (e.stateNode = t, !0); default: return !1; } } function d(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3;)e = e.return; u = e } const t = e.shouldSetTextContent; if (!(e = e.hydration)) {
        return {
          enterHydrationState() { return !1 }, resetHydrationState() {}, tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance() { E('175') }, prepareToHydrateHostTextInstance() { E('176') }, popHydrationState() { return !1 },
        };
      } var r = e.canHydrateInstance; var n = e.canHydrateTextInstance; const i = e.getNextHydratableSibling; const a = e.getFirstHydratableChild; const o = e.hydrateInstance; const s = e.hydrateTextInstance; var u = null; let l = null; let p = !1; return {
        enterHydrationState(e) { return l = a(e.stateNode.containerInfo), u = e, p = !0 }, resetHydrationState() { l = u = null, p = !1 }, tryToClaimNextHydratableInstance(e) { if (p) { let t = l; if (t) { if (!c(e, t)) { if (!(t = i(t)) || !c(e, t)) return e.effectTag |= 2, p = !1, void (u = e); b(u, l) }u = e, l = a(t) } else e.effectTag |= 2, p = !1, u = e; } }, prepareToHydrateHostInstance(e, t, r) { return t = o(e.stateNode, e.type, e.memoizedProps, t, r, e), e.updateQueue = t, t !== null }, prepareToHydrateHostTextInstance(e) { return s(e.stateNode, e.memoizedProps, e) }, popHydrationState(e) { if (e !== u) return !1; if (!p) return d(e), p = !0, !1; let r = e.type; if (e.tag !== 5 || r !== 'head' && r !== 'body' && !t(r, e.memoizedProps)) for (r = l; r;)b(e, r), r = i(r); return d(e), l = u ? i(e.stateNode) : null, !0 },
      };
    }(t)); var i = r.popHostContainer; var a = r.popHostContext; var o = r.resetHostContainer; const s = df(t, r, n, u, y); var l = s.beginWork; var p = s.beginFailedWork; var x = (function ef(e, t, r) { function d(e) { e.effectTag |= 4 } const n = e.createInstance; const i = e.createTextInstance; const a = e.appendInitialChild; const o = e.finalizeInitialChildren; const s = e.prepareUpdate; const u = e.persistence; const l = t.getRootHostContainer; const c = t.popHostContext; const p = t.getHostContext; const f = t.popHostContainer; const h = r.prepareToHydrateHostInstance; const m = r.prepareToHydrateHostTextInstance; const g = r.popHydrationState; let v = void 0; let y = void 0; let b = void 0; return e.mutation ? (v = function () {}, y = function (e, t, r) { (t.updateQueue = r) && d(t) }, b = function (e, t, r, n) { r !== n && d(t) }) : E(u ? '235' : '236'), { completeWork(e, t, r) { let u = t.pendingProps; switch (u === null ? u = t.memoizedProps : t.expirationTime === 2147483647 && r !== 2147483647 || (t.pendingProps = null), t.tag) { case 1: return null; case 2: return ne(t), null; case 3: return f(t), V(ir), V(nr), (u = t.stateNode).pendingContext && (u.context = u.pendingContext, u.pendingContext = null), e !== null && e.child !== null || (g(t), t.effectTag &= -3), v(t), null; case 5: c(t), r = l(); var x = t.type; if (e !== null && t.stateNode != null) { var D = e.memoizedProps; let _ = t.stateNode; const C = p(); _ = s(_, x, D, u, r, C), y(e, t, _, x, D, u, r), e.ref !== t.ref && (t.effectTag |= 128) } else { if (!u) return t.stateNode === null && E('166'), null; if (e = p(), g(t))h(t, r, e) && d(t); else { e = n(x, u, r, e, t); e:for (D = t.child; D !== null;) { if (D.tag === 5 || D.tag === 6)a(e, D.stateNode); else if (D.tag !== 4 && D.child !== null) { D.child.return = D, D = D.child; continue } if (D === t) break; for (;D.sibling === null;) { if (D.return === null || D.return === t) break e; D = D.return }D.sibling.return = D.return, D = D.sibling }o(e, x, u, r) && d(t), t.stateNode = e }t.ref !== null && (t.effectTag |= 128) } return null; case 6: if (e && t.stateNode != null)b(e, t, e.memoizedProps, u); else { if (typeof u !== 'string') return t.stateNode === null && E('166'), null; e = l(), r = p(), g(t) ? m(t) && d(t) : t.stateNode = i(u, e, r, t) } return null; case 7: (u = t.memoizedProps) || E('165'), t.tag = 8, x = []; e:for ((D = t.stateNode) && (D.return = t); D !== null;) { if (D.tag === 5 || D.tag === 6 || D.tag === 4)E('247'); else if (D.tag === 9)x.push(D.type); else if (D.child !== null) { D.child.return = D, D = D.child; continue } for (;D.sibling === null;) { if (D.return === null || D.return === t) break e; D = D.return }D.sibling.return = D.return, D = D.sibling } return u = (D = u.handler)(u.props, x), t.child = gr(t, e !== null ? e.child : null, u, r), t.child; case 8: return t.tag = 7, null; case 9: case 10: return null; case 4: return f(t), v(t), null; case 0: E('167'); default: E('156'); } } } }(t, r, n)).completeWork; var D = (r = (function ff(t, r) {
      function c(e) { const t = e.ref; if (t !== null) try { t(null) } catch (t) { r(e, t) } } function d(t) { switch (Ee(t), t.tag) { case 2: c(t); var n = t.stateNode; if (typeof n.componentWillUnmount === 'function') try { n.props = t.memoizedProps, n.state = t.memoizedState, n.componentWillUnmount() } catch (e) { r(t, e) } break; case 5: c(t); break; case 7: e(t.stateNode); break; case 4: i && g(t); } } function e(e) { for (let t = e; ;) if (d(t), t.child === null || i && t.tag === 4) { if (t === e) break; for (;t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return }t.sibling.return = t.return, t = t.sibling } else t.child.return = t, t = t.child; } function f(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function g(t) { for (let r = t, n = !1, i = void 0, a = void 0; ;) { if (!n) { n = r.return; e:for (;;) { switch (n === null && E('160'), n.tag) { case 5: i = n.stateNode, a = !1; break e; case 3: case 4: i = n.stateNode.containerInfo, a = !0; break e; }n = n.return }n = !0 } if (r.tag === 5 || r.tag === 6)e(r), a ? y(i, r.stateNode) : v(i, r.stateNode); else if (r.tag === 4 ? i = r.stateNode.containerInfo : d(r), r.child !== null) { r.child.return = r, r = r.child; continue } if (r === t) break; for (;r.sibling === null;) { if (r.return === null || r.return === t) return; (r = r.return).tag === 4 && (n = !1) }r.sibling.return = r.return, r = r.sibling } } const n = t.getPublicInstance; var i = t.mutation; t = t.persistence, i || E(t ? '235' : '236'); const a = i.commitMount; const o = i.commitUpdate; const s = i.resetTextContent; const u = i.commitTextUpdate; const l = i.appendChild; const p = i.appendChildToContainer; const h = i.insertBefore; const m = i.insertInContainerBefore; var v = i.removeChild; var y = i.removeChildFromContainer; return {
        commitResetTextContent(e) { s(e.stateNode) }, commitPlacement(e) { e: { for (var t = e.return; t !== null;) { if (f(t)) { var r = t; break e }t = t.return }E('160'), r = void 0 } let n = t = void 0; switch (r.tag) { case 5: t = r.stateNode, n = !1; break; case 3: case 4: t = r.stateNode.containerInfo, n = !0; break; default: E('161'); }16 & r.effectTag && (s(t), r.effectTag &= -17); e:t:for (r = e; ;) { for (;r.sibling === null;) { if (r.return === null || f(r.return)) { r = null; break e }r = r.return } for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6;) { if (2 & r.effectTag) continue t; if (r.child === null || r.tag === 4) continue t; r.child.return = r, r = r.child } if (!(2 & r.effectTag)) { r = r.stateNode; break e } } for (let i = e; ;) { if (i.tag === 5 || i.tag === 6)r ? n ? m(t, i.stateNode, r) : h(t, i.stateNode, r) : n ? p(t, i.stateNode) : l(t, i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === e) break; for (;i.sibling === null;) { if (i.return === null || i.return === e) return; i = i.return }i.sibling.return = i.return, i = i.sibling } }, commitDeletion(e) { g(e), e.return = null, e.child = null, e.alternate && (e.alternate.child = null, e.alternate.return = null) }, commitWork(e, t) { switch (t.tag) { case 2: break; case 5: var r = t.stateNode; if (r != null) { const n = t.memoizedProps; e = e !== null ? e.memoizedProps : n; const i = t.type; const a = t.updateQueue; t.updateQueue = null, a !== null && o(r, a, i, e, n, t) } break; case 6: t.stateNode === null && E('162'), r = t.memoizedProps, u(t.stateNode, e !== null ? e.memoizedProps : r, r); break; case 3: break; default: E('163'); } }, commitLifeCycles(e, t) { switch (t.tag) { case 2: var r = t.stateNode; if (4 & t.effectTag) if (e === null)r.props = t.memoizedProps, r.state = t.memoizedState, r.componentDidMount(); else { const n = e.memoizedProps; e = e.memoizedState, r.props = t.memoizedProps, r.state = t.memoizedState, r.componentDidUpdate(n, e) }(t = t.updateQueue) !== null && Ke(t, r); break; case 3: (r = t.updateQueue) !== null && Ke(r, t.child !== null ? t.child.stateNode : null); break; case 5: r = t.stateNode, e === null && 4 & t.effectTag && a(r, t.type, t.memoizedProps, t); break; case 6: case 4: break; default: E('163'); } }, commitAttachRef(e) { const t = e.ref; if (t !== null) { const r = e.stateNode; switch (e.tag) { case 5: t(n(r)); break; default: t(r); } } }, commitDetachRef(e) { (e = e.ref) !== null && e(null) },
      };
    }(t, h))).commitResetTextContent; var _ = r.commitPlacement; var S = r.commitDeletion; var T = r.commitWork; var P = r.commitLifeCycles; var R = r.commitAttachRef; var O = r.commitDetachRef; var F = t.now; var M = t.scheduleDeferredCallback; var j = t.cancelDeferredCallback; var B = t.useSyncScheduling; var U = t.prepareForCommit; var H = t.resetAfterCommit; var $ = F(); var K = 2; var X = 0; var Q = !1; var Z = null; var ee = null; var te = 0; var re = null; var ie = null; var ae = null; var oe = null; var ue = null; var le = !1; var ce = !1; var pe = !1; var fe = null; var de = null; var he = 0; var me = -1; var ge = !1; var ve = null; var ye = 0; var be = !1; var xe = !1; var _e = null; var Ce = null; var we = !1; var Se = !1; var ke = 1e3; var Ae = 0; var Te = 1; return {
      computeAsyncExpiration: v, computeExpirationForFiber: y, scheduleWork: u, batchedUpdates(e, t) { const r = we; we = !0; try { return e(t) } finally { (we = r) || ge || w(1, null) } }, unbatchedUpdates(e) { if (we && !Se) { Se = !0; try { return e() } finally { Se = !1 } } return e() }, flushSync(e) { const t = we; we = !0; try { e: { const r = X; X = 1; try { var n = e(); break e } finally { X = r }n = void 0 } return n } finally { we = t, ge && E('187'), w(1, null) } }, deferredUpdates(e) { const t = X; X = v(); try { return e() } finally { X = t } },
    };
  } function lf(e) {
    function b(e) { return (e = (function od(e) { if (!(e = nd(e))) return null; for (let t = e; ;) { if (t.tag === 5 || t.tag === 6) return t; if (t.child)t.child.return = t, t = t.child; else { if (t === e) break; for (;!t.sibling;) { if (!t.return || t.return === e) return null; t = t.return }t.sibling.return = t.return, t = t.sibling } } return null }(e))) === null ? null : e.stateNode } const t = e.getPublicInstance; const r = (e = kf(e)).computeAsyncExpiration; const n = e.computeExpirationForFiber; const i = e.scheduleWork; return {
      createContainer(e, t) {
        const r = new Y(3, null, 0); return e = {
          current: r, containerInfo: e, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: t, nextScheduledRoot: null,
        }, r.stateNode = e;
      },
      updateContainer(e, t, a, o) {
        const s = t.current; if (a) { let u; a = a._reactInternalFiber; e: { for (kd(a) === 2 && a.tag === 2 || E('170'), u = a; u.tag !== 3;) { if (le(u)) { u = u.stateNode.__reactInternalMemoizedMergedChildContext; break e }(u = u.return) || E('171') }u = u.stateNode.context }a = le(a) ? pe(a, u) : u } else a = C; t.context === null ? t.context = a : t.pendingContext = a, t = void 0 === (t = o) ? null : t, He(s, {
          expirationTime: o = e != null && e.type != null && e.type.prototype != null && !0 === e.type.prototype.unstable_isAsyncReactComponent ? r() : n(s), partialState: { element: e }, callback: t, isReplace: !1, isForced: !1, nextCallback: null, next: null,
        }), i(s, o);
      },
      batchedUpdates: e.batchedUpdates,
      unbatchedUpdates: e.unbatchedUpdates,
      deferredUpdates: e.deferredUpdates,
      flushSync: e.flushSync,
      getPublicRootInstance(e) { if (!(e = e.current).child) return null; switch (e.child.tag) { case 5: return t(e.child.stateNode); default: return e.child.stateNode; } },
      findHostInstance: b,
      findHostInstanceWithNoPortals(e) { return (e = (function pd(e) { if (!(e = nd(e))) return null; for (let t = e; ;) { if (t.tag === 5 || t.tag === 6) return t; if (t.child && t.tag !== 4)t.child.return = t, t = t.child; else { if (t === e) break; for (;!t.sibling;) { if (!t.return || t.return === e) return null; t = t.return }t.sibling.return = t.return, t = t.sibling } } return null }(e))) === null ? null : e.stateNode },
      injectIntoDevTools(e) { const t = e.findFiberByHostInstance; return (function Ce(e) { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') return !1; const t = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (t.isDisabled || !t.supportsFiber) return !0; try { const r = t.inject(e); or = Be(e => t.onCommitFiberRoot(r, e)), sr = Be(e => t.onCommitFiberUnmount(r, e)) } catch (e) {} return !0 }(o({}, e, { findHostInstanceByFiber(e) { return b(e) }, findFiberByHostInstance(e) { return t ? t(e) : null } }))) },
    };
  } const br = Object.freeze({ default: lf }); const xr = br && lf || br; const Dr = xr.default ? xr.default : xr; const _r = typeof performance === 'object' && typeof performance.now === 'function'; let Cr = void 0; Cr = _r ? function () { return performance.now() } : function () { return Date.now() }; let wr = void 0; let Er = void 0; if (a.canUseDOM) if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') { let Sr; let kr = null; let Ar = !1; let Tr = -1; let Pr = !1; let Rr = 0; let Or = 33; let Fr = 33; Sr = _r ? { didTimeout: !1, timeRemaining() { const e = Rr - performance.now(); return e > 0 ? e : 0 } } : { didTimeout: !1, timeRemaining() { const e = Rr - Date.now(); return e > 0 ? e : 0 } }; const Lr = `__reactIdleCallback$${Math.random().toString(36).slice(2)}`; window.addEventListener('message', (e) => { if (e.source === window && e.data === Lr) { if (Ar = !1, e = Cr(), Rr - e <= 0) { if (!(Tr !== -1 && Tr <= e)) return void (Pr || (Pr = !0, requestAnimationFrame(Mr))); Sr.didTimeout = !0 } else Sr.didTimeout = !1; Tr = -1, e = kr, kr = null, e !== null && e(Sr) } }, !1); var Mr = function (e) { Pr = !1; let t = e - Rr + Fr; t < Fr && Or < Fr ? (t < 8 && (t = 8), Fr = t < Or ? Or : t) : Or = t, Rr = e + Fr, Ar || (Ar = !0, window.postMessage(Lr, '*')) }; wr = function (e, t) { return kr = e, t != null && typeof t.timeout === 'number' && (Tr = Cr() + t.timeout), Pr || (Pr = !0, requestAnimationFrame(Mr)), 0 }, Er = function () { kr = null, Ar = !1, Tr = -1 } } else wr = window.requestIdleCallback, Er = window.cancelIdleCallback; else wr = function (e) { return setTimeout(() => { e({ timeRemaining() { return 1 / 0 } }) }) }, Er = function (e) { clearTimeout(e) }; const jr = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/; const Nr = {}; const Ir = {}; function If(e, t, r) { const n = wa(t); if (n && va(t, r)) { let i = n.mutationMethod; i ? i(e, r) : r == null || n.hasBooleanValue && !r || n.hasNumericValue && isNaN(r) || n.hasPositiveNumericValue && r < 1 || n.hasOverloadedBooleanValue && !1 === r ? Jf(e, t) : n.mustUseProperty ? e[n.propertyName] = r : (t = n.attributeName, (i = n.attributeNamespace) ? e.setAttributeNS(i, t, `${r}`) : n.hasBooleanValue || n.hasOverloadedBooleanValue && !0 === r ? e.setAttribute(t, '') : e.setAttribute(t, `${r}`)) } else Kf(e, t, va(t, r) ? r : null); } function Kf(e, t, r) { (function Hf(e) { return !!Ir.hasOwnProperty(e) || !Nr.hasOwnProperty(e) && (jr.test(e) ? Ir[e] = !0 : (Nr[e] = !0, !1)) }(t)) && (r == null ? e.removeAttribute(t) : e.setAttribute(t, `${r}`)) } function Jf(e, t) { const r = wa(t); r ? (t = r.mutationMethod) ? t(e, void 0) : r.mustUseProperty ? e[r.propertyName] = !r.hasBooleanValue && '' : e.removeAttribute(r.attributeName) : e.removeAttribute(t) } function Lf(e, t) {
    const r = t.value; const n = t.checked; return o({
      type: void 0, step: void 0, min: void 0, max: void 0,
    }, t, {
      defaultChecked: void 0, defaultValue: void 0, value: r != null ? r : e._wrapperState.initialValue, checked: n != null ? n : e._wrapperState.initialChecked,
    });
  } function Mf(e, t) { const r = t.defaultValue; e._wrapperState = { initialChecked: t.checked != null ? t.checked : t.defaultChecked, initialValue: t.value != null ? t.value : r, controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null } } function Nf(e, t) { (t = t.checked) != null && If(e, 'checked', t) } function Of(e, t) { Nf(e, t); const r = t.value; r != null ? r === 0 && e.value === '' ? e.value = '0' : t.type === 'number' ? (r != (t = parseFloat(e.value) || 0) || r == t && e.value != r) && (e.value = `${r}`) : e.value !== `${r}` && (e.value = `${r}`) : (t.value == null && t.defaultValue != null && e.defaultValue !== `${t.defaultValue}` && (e.defaultValue = `${t.defaultValue}`), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)) } function Pf(e, t) { switch (t.type) { case 'submit': case 'reset': break; case 'color': case 'date': case 'datetime': case 'datetime-local': case 'month': case 'time': case 'week': e.value = '', e.value = e.defaultValue; break; default: e.value = e.value; }(t = e.name) !== '' && (e.name = ''), e.defaultChecked = !e.defaultChecked, e.defaultChecked = !e.defaultChecked, t !== '' && (e.name = t) } function Rf(e, t) { return e = o({ children: void 0 }, t), (t = (function Qf(e) { let t = ''; return i.Children.forEach(e, (e) => { e == null || typeof e !== 'string' && typeof e !== 'number' || (t += e) }), t }(t.children))) && (e.children = t), e } function Sf(e, t, r, n) { if (e = e.options, t) { t = {}; for (var i = 0; i < r.length; i++)t[`$${r[i]}`] = !0; for (r = 0; r < e.length; r++)i = t.hasOwnProperty(`$${e[r].value}`), e[r].selected !== i && (e[r].selected = i), i && n && (e[r].defaultSelected = !0); } else { for (r = `${r}`, t = null, i = 0; i < e.length; i++) { if (e[i].value === r) return e[i].selected = !0, void (n && (e[i].defaultSelected = !0)); t !== null || e[i].disabled || (t = e[i]) }t !== null && (t.selected = !0) } } function Tf(e, t) { const r = t.value; e._wrapperState = { initialValue: r != null ? r : t.defaultValue, wasMultiple: !!t.multiple } } function Uf(e, t) { return t.dangerouslySetInnerHTML != null && E('91'), o({}, t, { value: void 0, defaultValue: void 0, children: `${e._wrapperState.initialValue}` }) } function Vf(e, t) { let r = t.value; r == null && (r = t.defaultValue, (t = t.children) != null && (r != null && E('92'), Array.isArray(t) && (t.length <= 1 || E('93'), t = t[0]), r = `${t}`), r == null && (r = '')), e._wrapperState = { initialValue: `${r}` } } function Wf(e, t) { let r = t.value; r != null && ((r = `${r}`) !== e.value && (e.value = r), t.defaultValue == null && (e.defaultValue = r)), t.defaultValue != null && (e.defaultValue = t.defaultValue) } function Xf(e) { const t = e.textContent; t === e._wrapperState.initialValue && (e.value = t) } const Br = 'http://www.w3.org/1999/xhtml'; const qr = 'http://www.w3.org/2000/svg'; function Zf(e) { switch (e) { case 'svg': return 'http://www.w3.org/2000/svg'; case 'math': return 'http://www.w3.org/1998/Math/MathML'; default: return 'http://www.w3.org/1999/xhtml'; } } function $f(e, t) { return e == null || e === 'http://www.w3.org/1999/xhtml' ? Zf(t) : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : e } let Ur; let zr = void 0; const Vr = (Ur = function (e, t) { if (e.namespaceURI !== qr || 'innerHTML' in e)e.innerHTML = t; else { for ((zr = zr || document.createElement('div')).innerHTML = `<svg>${t}</svg>`, t = zr.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (;t.firstChild;)e.appendChild(t.firstChild); } }, typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction ? function (e, t, r, n) { MSApp.execUnsafeLocalFunction(() => Ur(e, t)) } : Ur); function cg(e, t) { if (t) { const r = e.firstChild; if (r && r === e.lastChild && r.nodeType === 3) return void (r.nodeValue = t); }e.textContent = t } const Hr = {
    animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0,
  }; const $r = ['Webkit', 'ms', 'Moz', 'O']; function fg(e, t) { for (let r in e = e.style, t) if (t.hasOwnProperty(r)) { const n = r.indexOf('--') === 0; let i = r; const a = t[r]; i = a == null || typeof a === 'boolean' || a === '' ? '' : n || typeof a !== 'number' || a === 0 || Hr.hasOwnProperty(i) && Hr[i] ? (`${a}`).trim() : `${a}px`, r === 'float' && (r = 'cssFloat'), n ? e.setProperty(r, i) : e[r] = i } }Object.keys(Hr).forEach((e) => { $r.forEach((t) => { t = t + e.charAt(0).toUpperCase() + e.substring(1), Hr[t] = Hr[e] }) }); const Gr = o({ menuitem: !0 }, {
    area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0,
  }); function hg(e, t, r) { t && (Gr[e] && (t.children != null || t.dangerouslySetInnerHTML != null) && E('137', e, r()), t.dangerouslySetInnerHTML != null && (t.children != null && E('60'), typeof t.dangerouslySetInnerHTML === 'object' && '__html' in t.dangerouslySetInnerHTML || E('61')), t.style != null && typeof t.style !== 'object' && E('62', r())) } function ig(e, t) { if (e.indexOf('-') === -1) return typeof t.is === 'string'; switch (e) { case 'annotation-xml': case 'color-profile': case 'font-face': case 'font-face-src': case 'font-face-uri': case 'font-face-format': case 'font-face-name': case 'missing-glyph': return !1; default: return !0; } } const Jr = Br; const Wr = s.thatReturns(''); function lg(e, t) { const r = Hd(e = e.nodeType === 9 || e.nodeType === 11 ? e : e.ownerDocument); t = Ae[t]; for (let n = 0; n < t.length; n++) { const i = t[n]; r.hasOwnProperty(i) && r[i] || (i === 'topScroll' ? wd('topScroll', 'scroll', e) : i === 'topFocus' || i === 'topBlur' ? (wd('topFocus', 'focus', e), wd('topBlur', 'blur', e), r.topBlur = !0, r.topFocus = !0) : i === 'topCancel' ? (yc('cancel', !0) && wd('topCancel', 'cancel', e), r.topCancel = !0) : i === 'topClose' ? (yc('close', !0) && wd('topClose', 'close', e), r.topClose = !0) : Bt.hasOwnProperty(i) && U(i, Bt[i], e), r[i] = !0) } } const Kr = {
    topAbort: 'abort', topCanPlay: 'canplay', topCanPlayThrough: 'canplaythrough', topDurationChange: 'durationchange', topEmptied: 'emptied', topEncrypted: 'encrypted', topEnded: 'ended', topError: 'error', topLoadedData: 'loadeddata', topLoadedMetadata: 'loadedmetadata', topLoadStart: 'loadstart', topPause: 'pause', topPlay: 'play', topPlaying: 'playing', topProgress: 'progress', topRateChange: 'ratechange', topSeeked: 'seeked', topSeeking: 'seeking', topStalled: 'stalled', topSuspend: 'suspend', topTimeUpdate: 'timeupdate', topVolumeChange: 'volumechange', topWaiting: 'waiting',
  }; function ng(e, t, r, n) { return r = r.nodeType === 9 ? r : r.ownerDocument, n === Jr && (n = Zf(e)), n === Jr ? e === 'script' ? ((e = r.createElement('div')).innerHTML = '<script><\/script>', e = e.removeChild(e.firstChild)) : e = typeof t.is === 'string' ? r.createElement(e, { is: t.is }) : r.createElement(e) : e = r.createElementNS(n, e), e } function og(e, t) { return (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(e) } function pg(e, t, r, n) { const i = ig(t, r); switch (t) { case 'iframe': case 'object': U('topLoad', 'load', e); var a = r; break; case 'video': case 'audio': for (a in Kr)Kr.hasOwnProperty(a) && U(a, Kr[a], e); a = r; break; case 'source': U('topError', 'error', e), a = r; break; case 'img': case 'image': U('topError', 'error', e), U('topLoad', 'load', e), a = r; break; case 'form': U('topReset', 'reset', e), U('topSubmit', 'submit', e), a = r; break; case 'details': U('topToggle', 'toggle', e), a = r; break; case 'input': Mf(e, r), a = Lf(e, r), U('topInvalid', 'invalid', e), lg(n, 'onChange'); break; case 'option': a = Rf(e, r); break; case 'select': Tf(e, r), a = o({}, r, { value: void 0 }), U('topInvalid', 'invalid', e), lg(n, 'onChange'); break; case 'textarea': Vf(e, r), a = Uf(e, r), U('topInvalid', 'invalid', e), lg(n, 'onChange'); break; default: a = r; }hg(t, a, Wr); let u; const l = a; for (u in l) if (l.hasOwnProperty(u)) { let c = l[u]; u === 'style' ? fg(e, c) : u === 'dangerouslySetInnerHTML' ? (c = c ? c.__html : void 0) != null && Vr(e, c) : u === 'children' ? typeof c === 'string' ? (t !== 'textarea' || c !== '') && cg(e, c) : typeof c === 'number' && cg(e, `${c}`) : u !== 'suppressContentEditableWarning' && u !== 'suppressHydrationWarning' && u !== 'autoFocus' && (Se.hasOwnProperty(u) ? c != null && lg(n, u) : i ? Kf(e, u, c) : c != null && If(e, u, c)) } switch (t) { case 'input': Bc(e), Pf(e, r); break; case 'textarea': Bc(e), Xf(e); break; case 'option': r.value != null && e.setAttribute('value', r.value); break; case 'select': e.multiple = !!r.multiple, (t = r.value) != null ? Sf(e, !!r.multiple, t, !1) : r.defaultValue != null && Sf(e, !!r.multiple, r.defaultValue, !0); break; default: typeof a.onClick === 'function' && (e.onclick = s); } } function sg(e, t, r, n, i) { let a; let u; let l = null; switch (t) { case 'input': r = Lf(e, r), n = Lf(e, n), l = []; break; case 'option': r = Rf(e, r), n = Rf(e, n), l = []; break; case 'select': r = o({}, r, { value: void 0 }), n = o({}, n, { value: void 0 }), l = []; break; case 'textarea': r = Uf(e, r), n = Uf(e, n), l = []; break; default: typeof r.onClick !== 'function' && typeof n.onClick === 'function' && (e.onclick = s); } for (a in hg(t, n, Wr), e = null, r) if (!n.hasOwnProperty(a) && r.hasOwnProperty(a) && r[a] != null) if (a === 'style') for (u in t = r[a])t.hasOwnProperty(u) && (e || (e = {}), e[u] = ''); else a !== 'dangerouslySetInnerHTML' && a !== 'children' && a !== 'suppressContentEditableWarning' && a !== 'suppressHydrationWarning' && a !== 'autoFocus' && (Se.hasOwnProperty(a) ? l || (l = []) : (l = l || []).push(a, null)); for (a in n) { let c = n[a]; if (t = r != null ? r[a] : void 0, n.hasOwnProperty(a) && c !== t && (c != null || t != null)) if (a === 'style') if (t) { for (u in t)!t.hasOwnProperty(u) || c && c.hasOwnProperty(u) || (e || (e = {}), e[u] = ''); for (u in c)c.hasOwnProperty(u) && t[u] !== c[u] && (e || (e = {}), e[u] = c[u]); } else e || (l || (l = []), l.push(a, e)), e = c; else a === 'dangerouslySetInnerHTML' ? (c = c ? c.__html : void 0, t = t ? t.__html : void 0, c != null && t !== c && (l = l || []).push(a, `${c}`)) : a === 'children' ? t === c || typeof c !== 'string' && typeof c !== 'number' || (l = l || []).push(a, `${c}`) : a !== 'suppressContentEditableWarning' && a !== 'suppressHydrationWarning' && (Se.hasOwnProperty(a) ? (c != null && lg(i, a), l || t === c || (l = [])) : (l = l || []).push(a, c)); } return e && (l = l || []).push('style', e), l } function tg(e, t, r, n, i) { r === 'input' && i.type === 'radio' && i.name != null && Nf(e, i), ig(r, n), n = ig(r, i); for (let a = 0; a < t.length; a += 2) { const o = t[a]; const s = t[a + 1]; o === 'style' ? fg(e, s) : o === 'dangerouslySetInnerHTML' ? Vr(e, s) : o === 'children' ? cg(e, s) : n ? s != null ? Kf(e, o, s) : e.removeAttribute(o) : s != null ? If(e, o, s) : Jf(e, o) } switch (r) { case 'input': Of(e, i); break; case 'textarea': Wf(e, i); break; case 'select': e._wrapperState.initialValue = void 0, t = e._wrapperState.wasMultiple, e._wrapperState.wasMultiple = !!i.multiple, (r = i.value) != null ? Sf(e, !!i.multiple, r, !1) : t !== !!i.multiple && (i.defaultValue != null ? Sf(e, !!i.multiple, i.defaultValue, !0) : Sf(e, !!i.multiple, i.multiple ? [] : '', !1)); } } function ug(e, t, r, n, i) { switch (t) { case 'iframe': case 'object': U('topLoad', 'load', e); break; case 'video': case 'audio': for (var a in Kr)Kr.hasOwnProperty(a) && U(a, Kr[a], e); break; case 'source': U('topError', 'error', e); break; case 'img': case 'image': U('topError', 'error', e), U('topLoad', 'load', e); break; case 'form': U('topReset', 'reset', e), U('topSubmit', 'submit', e); break; case 'details': U('topToggle', 'toggle', e); break; case 'input': Mf(e, r), U('topInvalid', 'invalid', e), lg(i, 'onChange'); break; case 'select': Tf(e, r), U('topInvalid', 'invalid', e), lg(i, 'onChange'); break; case 'textarea': Vf(e, r), U('topInvalid', 'invalid', e), lg(i, 'onChange'); } for (const o in hg(t, r, Wr), n = null, r)r.hasOwnProperty(o) && (a = r[o], o === 'children' ? typeof a === 'string' ? e.textContent !== a && (n = ['children', a]) : typeof a === 'number' && e.textContent !== `${a}` && (n = ['children', `${a}`]) : Se.hasOwnProperty(o) && a != null && lg(i, o)); switch (t) { case 'input': Bc(e), Pf(e, r); break; case 'textarea': Bc(e), Xf(e); break; case 'select': case 'option': break; default: typeof r.onClick === 'function' && (e.onclick = s); } return n } function vg(e, t) { return e.nodeValue !== t } const Xr = Object.freeze({
    createElement: ng, createTextNode: og, setInitialProperties: pg, diffProperties: sg, updateProperties: tg, diffHydratedProperties: ug, diffHydratedText: vg, warnForUnmatchedText() {}, warnForDeletedHydratableElement() {}, warnForDeletedHydratableText() {}, warnForInsertedHydratedElement() {}, warnForInsertedHydratedText() {}, restoreControlledState(e, t, r) { switch (t) { case 'input': if (Of(e, r), t = r.name, r.type === 'radio' && t != null) { for (r = e; r.parentNode;)r = r.parentNode; for (r = r.querySelectorAll(`input[name=${JSON.stringify(`${t}`)}][type="radio"]`), t = 0; t < r.length; t++) { const n = r[t]; if (n !== e && n.form === e.form) { const i = rb(n); i || E('90'), Cc(n), Of(n, i) } } } break; case 'textarea': Wf(e, r); break; case 'select': (t = r.value) != null && Sf(e, !!r.multiple, t, !1); } },
  }); yt.injectFiberControlledHostComponent(Xr); let Yr = null; let Qr = null; function Ng(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable ')) } const Zr = Dr({
    getRootHostContext(e) { let t = e.nodeType; switch (t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : $f(null, ''); break; default: e = $f(e = (t = t === 8 ? e.parentNode : e).namespaceURI || null, t = t.tagName); } return e },
    getChildHostContext(e, t) { return $f(e, t) },
    getPublicInstance(e) { return e },
    prepareForCommit() { Yr = Ft; const e = p(); if (Kd(e)) { if ('selectionStart' in e) var t = { start: e.selectionStart, end: e.selectionEnd }; else e: { let r = window.getSelection && window.getSelection(); if (r && r.rangeCount !== 0) { t = r.anchorNode; const n = r.anchorOffset; const i = r.focusNode; r = r.focusOffset; try { t.nodeType, i.nodeType } catch (e) { t = null; break e } let a = 0; let o = -1; let s = -1; let u = 0; let l = 0; let c = e; let f = null; t:for (;;) { for (var d; c !== t || n !== 0 && c.nodeType !== 3 || (o = a + n), c !== i || r !== 0 && c.nodeType !== 3 || (s = a + r), c.nodeType === 3 && (a += c.nodeValue.length), (d = c.firstChild) !== null;)f = c, c = d; for (;;) { if (c === e) break t; if (f === t && ++u === n && (o = a), f === i && ++l === r && (s = a), (d = c.nextSibling) !== null) break; f = (c = f).parentNode }c = d }t = o === -1 || s === -1 ? null : { start: o, end: s } } else t = null; }t = t || { start: 0, end: 0 } } else t = null; Qr = { focusedElem: e, selectionRange: t }, ud(!1) },
    resetAfterCommit() { let e = Qr; let t = p(); let r = e.focusedElem; let n = e.selectionRange; if (t !== r && D(document.documentElement, r)) { if (Kd(r)) if (t = n.start, void 0 === (e = n.end) && (e = t), 'selectionStart' in r)r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length); else if (window.getSelection) { t = window.getSelection(); let i = r[Eb()].length; e = Math.min(n.start, i), n = void 0 === n.end ? e : Math.min(n.end, i), !t.extend && e > n && (i = n, n = e, e = i), i = Jd(r, e); const a = Jd(r, n); if (i && a && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== a.node || t.focusOffset !== a.offset)) { const o = document.createRange(); o.setStart(i.node, i.offset), t.removeAllRanges(), e > n ? (t.addRange(o), t.extend(a.node, a.offset)) : (o.setEnd(a.node, a.offset), t.addRange(o)) } } for (t = [], e = r; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (_(r), r = 0; r < t.length; r++)(e = t[r]).element.scrollLeft = e.left, e.element.scrollTop = e.top; }Qr = null, ud(Yr), Yr = null },
    createInstance(e, t, r, n, i) { return (e = ng(e, t, r, n))[ze] = i, e[Ve] = t, e },
    appendInitialChild(e, t) { e.appendChild(t) },
    finalizeInitialChildren(e, t, r, n) { pg(e, t, r, n); e: { switch (t) { case 'button': case 'input': case 'select': case 'textarea': e = !!r.autoFocus; break e; }e = !1 } return e },
    prepareUpdate(e, t, r, n, i) { return sg(e, t, r, n, i) },
    shouldSetTextContent(e, t) { return e === 'textarea' || typeof t.children === 'string' || typeof t.children === 'number' || typeof t.dangerouslySetInnerHTML === 'object' && t.dangerouslySetInnerHTML !== null && typeof t.dangerouslySetInnerHTML.__html === 'string' },
    shouldDeprioritizeSubtree(e, t) { return !!t.hidden },
    createTextInstance(e, t, r, n) { return (e = og(e, t))[ze] = n, e },
    now: Cr,
    mutation: {
      commitMount(e) { e.focus() }, commitUpdate(e, t, r, n, i) { e[Ve] = i, tg(e, t, r, n, i) }, resetTextContent(e) { e.textContent = '' }, commitTextUpdate(e, t, r) { e.nodeValue = r }, appendChild(e, t) { e.appendChild(t) }, appendChildToContainer(e, t) { e.nodeType === 8 ? e.parentNode.insertBefore(t, e) : e.appendChild(t) }, insertBefore(e, t, r) { e.insertBefore(t, r) }, insertInContainerBefore(e, t, r) { e.nodeType === 8 ? e.parentNode.insertBefore(t, r) : e.insertBefore(t, r) }, removeChild(e, t) { e.removeChild(t) }, removeChildFromContainer(e, t) { e.nodeType === 8 ? e.parentNode.removeChild(t) : e.removeChild(t) },
    },
    hydration: {
      canHydrateInstance(e, t) { return e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e }, canHydrateTextInstance(e, t) { return t === '' || e.nodeType !== 3 ? null : e }, getNextHydratableSibling(e) { for (e = e.nextSibling; e && e.nodeType !== 1 && e.nodeType !== 3;)e = e.nextSibling; return e }, getFirstHydratableChild(e) { for (e = e.firstChild; e && e.nodeType !== 1 && e.nodeType !== 3;)e = e.nextSibling; return e }, hydrateInstance(e, t, r, n, i, a) { return e[ze] = a, e[Ve] = r, ug(e, t, r, i, n) }, hydrateTextInstance(e, t, r) { return e[ze] = r, vg(e, t) }, didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance() {}, didNotHydrateContainerInstance() {}, didNotHydrateInstance() {}, didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance() {},
    },
    scheduleDeferredCallback: wr,
    cancelDeferredCallback: Er,
    useSyncScheduling: !0,
  }); function Pg(e, t, r, n, i) { Ng(r) || E('200'); let a = r._reactRootContainer; if (a)Zr.updateContainer(t, a, e, i); else { if (!(n = n || (function Og(e) { return !(!(e = e ? e.nodeType === 9 ? e.documentElement : e.firstChild : null) || e.nodeType !== 1 || !e.hasAttribute('data-reactroot')) }(r)))) for (a = void 0; a = r.lastChild;)r.removeChild(a); const o = Zr.createContainer(r, n); a = r._reactRootContainer = o, Zr.unbatchedUpdates(() => { Zr.updateContainer(t, o, e, i) }) } return Zr.getPublicRootInstance(a) } function Qg(e, t) {
    const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; return Ng(t) || E('200'), (function pf(e, t, r) {
      const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return {
        $$typeof: fr, key: n == null ? null : `${n}`, children: e, containerInfo: t, implementation: r,
      };
    }(e, t, null, r));
  } function Rg(e, t) { this._reactRootContainer = Zr.createContainer(e, t) }rc = Zr.batchedUpdates, Rg.prototype.render = function (e, t) { Zr.updateContainer(e, this._reactRootContainer, null, t) }, Rg.prototype.unmount = function (e) { Zr.updateContainer(null, this._reactRootContainer, null, e) }; const en = {
    createPortal: Qg,
    findDOMNode(e) { if (e == null) return null; if (e.nodeType === 1) return e; const t = e._reactInternalFiber; if (t) return Zr.findHostInstance(t); typeof e.render === 'function' ? E('188') : E('213', Object.keys(e)) },
    hydrate(e, t, r) { return Pg(null, e, t, !0, r) },
    render(e, t, r) { return Pg(null, e, t, !1, r) },
    unstable_renderSubtreeIntoContainer(e, t, r, n) { return (e == null || void 0 === e._reactInternalFiber) && E('38'), Pg(e, t, r, !1, n) },
    unmountComponentAtNode(e) { return Ng(e) || E('40'), !!e._reactRootContainer && (Zr.unbatchedUpdates(() => { Pg(null, null, e, !1, () => { e._reactRootContainer = null }) }), !0) },
    unstable_createPortal: Qg,
    unstable_batchedUpdates: tc,
    unstable_deferredUpdates: Zr.deferredUpdates,
    flushSync: Zr.flushSync,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      EventPluginHub: Ne, EventPluginRegistry: Te, EventPropagators: Ye, ReactControlledComponent: bt, ReactDOMComponentTree: We, ReactDOMEventListener: Mt,
    },
  }; Zr.injectIntoDevTools({
    findFiberByHostInstance: pb, bundleType: 0, version: '16.2.0', rendererPackageName: 'react-dom',
  }); const tn = Object.freeze({ default: en }); const rn = tn && en || tn; t.exports = rn.default ? rn.default : rn;
}, function (e, t, r) {
  /** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const n = r(124); const i = r(125); const a = r(48); const o = typeof Symbol === 'function' && Symbol.for; const s = o ? Symbol.for('react.element') : 60103; const u = o ? Symbol.for('react.call') : 60104; const l = o ? Symbol.for('react.return') : 60105; const c = o ? Symbol.for('react.portal') : 60106; const p = o ? Symbol.for('react.fragment') : 60107; const f = typeof Symbol === 'function' && Symbol.iterator; function y(e) { for (var t = arguments.length - 1, r = `Minified React error #${e}; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=${e}`, n = 0; n < t; n++)r += `&args[]=${encodeURIComponent(arguments[n + 1])}`; throw (t = Error(`${r} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)).name = 'Invariant Violation', t.framesToPop = 1, t } const d = {
    isMounted() { return !1 }, enqueueForceUpdate() {}, enqueueReplaceState() {}, enqueueSetState() {},
  }; function A(e, t, r) { this.props = e, this.context = t, this.refs = i, this.updater = r || d } function B(e, t, r) { this.props = e, this.context = t, this.refs = i, this.updater = r || d } function C() {}A.prototype.isReactComponent = {}, A.prototype.setState = function (e, t) { typeof e !== 'object' && typeof e !== 'function' && e != null && y('85'), this.updater.enqueueSetState(this, e, t, 'setState') }, A.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate') }, C.prototype = A.prototype; const h = B.prototype = new C(); function E(e, t, r) { this.props = e, this.context = t, this.refs = i, this.updater = r || d }h.constructor = B, n(h, A.prototype), h.isPureReactComponent = !0; const m = E.prototype = new C(); m.constructor = E, n(m, A.prototype), m.unstable_isAsyncReactComponent = !0, m.render = function () { return this.props.children }; const g = { current: null }; const v = Object.prototype.hasOwnProperty; const b = {
    key: !0, ref: !0, __self: !0, __source: !0,
  }; function J(e, t, r) {
    let n; const i = {}; let a = null; let o = null; if (t != null) for (n in void 0 !== t.ref && (o = t.ref), void 0 !== t.key && (a = `${t.key}`), t)v.call(t, n) && !b.hasOwnProperty(n) && (i[n] = t[n]); let u = arguments.length - 2; if (u === 1)i.children = r; else if (u > 1) { for (var l = Array(u), c = 0; c < u; c++)l[c] = arguments[c + 2]; i.children = l } if (e && e.defaultProps) for (n in u = e.defaultProps) void 0 === i[n] && (i[n] = u[n]); return {
      $$typeof: s, type: e, key: a, ref: o, props: i, _owner: g.current,
    };
  } function K(e) { return typeof e === 'object' && e !== null && e.$$typeof === s } const x = /\/+/g; const D = []; function N(e, t, r, n) {
    if (D.length) { const i = D.pop(); return i.result = e, i.keyPrefix = t, i.func = r, i.context = n, i.count = 0, i } return {
      result: e, keyPrefix: t, func: r, context: n, count: 0,
    };
  } function O(e) { e.result = null, e.keyPrefix = null, e.func = null, e.context = null, e.count = 0, D.length < 10 && D.push(e) } function P(e, t, r, n) { let i = typeof e; i !== 'undefined' && i !== 'boolean' || (e = null); let a = !1; if (e === null)a = !0; else switch (i) { case 'string': case 'number': a = !0; break; case 'object': switch (e.$$typeof) { case s: case u: case l: case c: a = !0; } } if (a) return r(n, e, t === '' ? `.${Q(e, 0)}` : t), 1; if (a = 0, t = t === '' ? '.' : `${t}:`, Array.isArray(e)) for (var o = 0; o < e.length; o++) { var p = t + Q(i = e[o], o); a += P(i, p, r, n) } else if (e === null || void 0 === e ? p = null : p = typeof (p = f && e[f] || e['@@iterator']) === 'function' ? p : null, typeof p === 'function') for (e = p.call(e), o = 0; !(i = e.next()).done;)a += P(i = i.value, p = t + Q(i, o++), r, n); else i === 'object' && y('31', (r = `${e}`) === '[object Object]' ? `object with keys {${Object.keys(e).join(', ')}}` : r, ''); return a } function Q(e, t) { return typeof e === 'object' && e !== null && e.key != null ? (function escape(e) { const t = { '=': '=0', ':': '=2' }; return `$${(`${e}`).replace(/[=:]/g, e => t[e])}` }(e.key)) : t.toString(36) } function R(e, t) { e.func.call(e.context, t, e.count++) } function S(e, t, r) {
    const n = e.result; const i = e.keyPrefix; e = e.func.call(e.context, t, e.count++), Array.isArray(e) ? T(e, n, r, a.thatReturnsArgument) : e != null && (K(e) && (t = i + (!e.key || t && t.key === e.key ? '' : `${(`${e.key}`).replace(x, '$&/')}/`) + r, e = {
      $$typeof: s, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner,
    }), n.push(e));
  } function T(e, t, r, n, i) { let a = ''; r != null && (a = `${(`${r}`).replace(x, '$&/')}/`), t = N(t, a, n, i), e == null || P(e, '', S, t), O(t) } const _ = {
    Children: {
      map(e, t, r) { if (e == null) return e; const n = []; return T(e, n, null, t, r), n }, forEach(e, t, r) { if (e == null) return e; t = N(null, null, t, r), e == null || P(e, '', R, t), O(t) }, count(e) { return e == null ? 0 : P(e, '', a.thatReturnsNull, null) }, toArray(e) { const t = []; return T(e, t, null, a.thatReturnsArgument), t }, only(e) { return K(e) || y('143'), e },
    },
    Component: A,
    PureComponent: B,
    unstable_AsyncComponent: E,
    Fragment: p,
    createElement: J,
    cloneElement(e, t, r) {
      const i = n({}, e.props); let a = e.key; let o = e.ref; let u = e._owner; if (t != null) { if (void 0 !== t.ref && (o = t.ref, u = g.current), void 0 !== t.key && (a = `${t.key}`), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t)v.call(t, c) && !b.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]); } var c = arguments.length - 2; if (c === 1)i.children = r; else if (c > 1) { l = Array(c); for (let p = 0; p < c; p++)l[p] = arguments[p + 2]; i.children = l } return {
        $$typeof: s, type: e.type, key: a, ref: o, props: i, _owner: u,
      };
    },
    createFactory(e) { const t = J.bind(null, e); return t.type = e, t },
    isValidElement: K,
    version: '16.2.0',
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: g, assign: n },
  }; const w = Object.freeze({ default: _ }); const k = w && _ || w; e.exports = k.default ? k.default : k;
}, function (e, t, r) {
  const n = !(typeof window === 'undefined' || !window.document || !window.document.createElement); const i = {
    canUseDOM: n, canUseWorkers: typeof Worker !== 'undefined', canUseEventListeners: n && !(!window.addEventListener && !window.attachEvent), canUseViewport: n && !!window.screen, isInWorker: !n,
  }; e.exports = i;
}, function (e, t, r) {
  const n = r(48); const i = { listen: function listen(e, t, r) { return e.addEventListener ? (e.addEventListener(t, r, !1), { remove: function remove() { e.removeEventListener(t, r, !1) } }) : e.attachEvent ? (e.attachEvent(`on${t}`, r), { remove: function remove() { e.detachEvent(`on${t}`, r) } }) : void 0 }, capture: function capture(e, t, r) { return e.addEventListener ? (e.addEventListener(t, r, !0), { remove: function remove() { e.removeEventListener(t, r, !0) } }) : { remove: n } }, registerDefault: function registerDefault() {} }; e.exports = i;
}, function (e, t, r) {
  e.exports = function getActiveElement(e) { if (void 0 === (e = e || (typeof document !== 'undefined' ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } };
}, function (e, t, r) {
  const n = Object.prototype.hasOwnProperty; function is(e, t) { return e === t ? e !== 0 || t !== 0 || 1 / e == 1 / t : e != e && t != t }e.exports = function shallowEqual(e, t) { if (is(e, t)) return !0; if (typeof e !== 'object' || e === null || typeof t !== 'object' || t === null) return !1; const r = Object.keys(e); const i = Object.keys(t); if (r.length !== i.length) return !1; for (let a = 0; a < r.length; a++) if (!n.call(t, r[a]) || !is(e[r[a]], t[r[a]])) return !1; return !0 };
}, function (e, t, r) {
  const n = r(282); e.exports = function containsNode(e, t) { return !(!e || !t) && (e === t || !n(e) && (n(t) ? containsNode(e, t.parentNode) : 'contains' in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) };
}, function (e, t, r) {
  const n = r(283); e.exports = function isTextNode(e) { return n(e) && e.nodeType == 3 };
}, function (e, t, r) {
  e.exports = function isNode(e) { const t = (e ? e.ownerDocument || e : document).defaultView || window; return !(!e || !(typeof t.Node === 'function' ? e instanceof t.Node : typeof e === 'object' && typeof e.nodeType === 'number' && typeof e.nodeName === 'string')) };
}, function (e, t, r) {
  e.exports = function focusNode(e) { try { e.focus() } catch (e) {} };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function renderStyleguide(e, t) {
    const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.location; const p = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : document; const f = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : window.history; const d = (0, l.default)(e.sections, e.vuex); (0, c.default)(e.mixins), (0, u.default)(d); const h = e.config; const m = h.title; const g = h.navigation; const v = (0, s.default)(d, r.hash, g); const y = v.sections; const b = v.displayMode; if (p.title = (0, o.default)(y, m, b), r.hash === '#/') { const x = r.pathname + r.search; f.replaceState('', p.title, x) } return n.default.createElement(a.default, {
      codeRevision: t, config: e.config, slots: (0, i.default)(e.config), welcomeScreen: e.welcomeScreen, patterns: e.patterns, sections: y, allSections: d, displayMode: b,
    });
  }; var n = _interopRequireDefault(r(0)); var i = _interopRequireDefault(r(71)); var a = _interopRequireDefault(r(456)); var o = _interopRequireDefault(r(531)); var s = _interopRequireDefault(r(532)); var u = _interopRequireDefault(r(545)); var l = _interopRequireDefault(r(547)); var c = _interopRequireDefault(r(549)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(287); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = r(0); const a = _interopRequireDefault(i); const o = _interopRequireDefault(r(288)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t } const s = (function (e) {
    function EditorLoader() { let e; let t; let r; !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, EditorLoader)); for (var n = arguments.length, i = Array(n), a = 0; a < n; a++)i[a] = arguments[a]; return t = r = _possibleConstructorReturn(this, (e = EditorLoader.__proto__ || Object.getPrototypeOf(EditorLoader)).call.apply(e, [this].concat(i))), r.state = { editor: null }, _possibleConstructorReturn(r, t) } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(EditorLoader, i.Component)), n(EditorLoader, [{ key: 'componentDidMount', value: function componentDidMount() { const e = this; r.e(0).then(r.bind(null, 762)).then((t) => { e.setState({ editor: t.default }) }) } }, { key: 'render', value: function render() { const e = this.state.editor; return e ? a.default.createElement(e, this.props) : a.default.createElement(o.default, null) } }]), EditorLoader;
  }()); t.default = s;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.EditorLoaderRenderer = EditorLoaderRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function EditorLoaderRenderer(e) { const t = e.classes; return n.default.createElement('div', { className: t.root }, 'Loading') }EditorLoaderRenderer.propTypes = { classes: i.default.object.isRequired }, t.default = (0, a.default)((e) => {
    const t = e.fontFamily; const r = e.color; const n = e.space; const i = e.fontSize; return {
      root: {
        padding: [[n[1], n[2], n[1], n[1]]], fontFamily: t.base, fontSize: i.small, color: r.light, backgroundColor: r.codeBackground,
      },
      '@global': {
        '.CodeMirror.CodeMirror': {
          isolate: !1, fontFamily: t.monospace, height: 'auto', padding: [[n[1], n[2]]], fontSize: i.small,
        },
        '.CodeMirror.CodeMirror pre': { isolate: !1, padding: 0 },
        '.CodeMirror-scroll.CodeMirror-scroll': {
          isolate: !1, height: 'auto', overflowY: 'hidden', overflowX: 'auto',
        },
        '.cm-error.cm-error': { isolate: !1, background: 'none' },
      },
    };
  })(EditorLoaderRenderer);
}, function (e, t, r) {
  const n = r(48); const i = r(290); const a = r(291); e.exports = function () {
    function shim(e, t, r, n, o, s) { s !== a && i(!1, 'Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types') } function getShim() { return shim }shim.isRequired = shim; const e = {
      array: shim, bool: shim, func: shim, number: shim, object: shim, string: shim, symbol: shim, any: shim, arrayOf: getShim, element: shim, instanceOf: getShim, node: shim, objectOf: getShim, oneOf: getShim, oneOfType: getShim, shape: getShim, exact: getShim,
    }; return e.checkPropTypes = n, e.PropTypes = e, e;
  };
}, function (e, t, r) {
  const n = function validateFormat(e) {}; e.exports = function invariant(e, t, r, i, a, o, s, u) { if (n(t), !e) { let l; if (void 0 === t)l = new Error('Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'); else { const c = [r, i, a, o, s, u]; let p = 0; (l = new Error(t.replace(/%s/g, () => c[p++]))).name = 'Invariant Violation' } throw l.framesToPop = 1, l } };
}, function (e, t, r) {
  e.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = r(0); const o = _interopRequireDefault(a); const s = _interopRequireDefault(r(1)); const u = _interopRequireDefault(r(293)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = function (e) {
    return function (t) {
      let r; let l; const c = t.name.replace(/Renderer$/, ''); return l = r = (function (r) {
        function _class() { return (function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, _class)), (function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t }(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments))) } return (function _inherits(e, t) {
          if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e, enumerable: !1, writable: !0, configurable: !0,
            },
          }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
        }(_class, a.Component)), i(_class, [{ key: 'componentWillMount', value: function componentWillMount() { this.sheet = (0, u.default)(e, this.context.config || {}, c), this.sheet.update(this.props).attach() } }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(e) { this.sheet.update(e) } }, { key: 'render', value: function render() { return o.default.createElement(t, n({}, this.props, { classes: this.sheet.classes })) } }]), _class;
      }()), r.displayName = `Styled(${c})`, r.contextTypes = { config: s.default.object }, l;
    };
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(294)); const i = _interopRequireDefault(r(136)); const a = _interopRequireDefault(r(68)); const o = (function _interopRequireWildcard(e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(r(353))); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = (0, i.default)((e, t, r) => { const i = (0, n.default)({}, o, t.theme); const s = (0, n.default)({}, e(i), t.styles && t.styles[r]); return a.default.createStyleSheet(s, { meta: r, link: !0 }) });
}, function (e, t, r) { const n = r(295); const i = r(344)((e, t, r) => { n(e, t, r) }); e.exports = i }, function (e, t, r) { const n = r(72); const i = r(128); const a = r(130); const o = r(325); const s = r(15); const u = r(84); const l = r(133); e.exports = function baseMerge(e, t, r, c, p) { e !== t && a(t, (a, u) => { if (s(a))p || (p = new n()), o(e, t, u, r, baseMerge, c, p); else { let f = c ? c(l(e, u), a, `${u}`, e, t, p) : void 0; void 0 === f && (f = a), i(e, u, f) } }, u) } }, function (e, t) { e.exports = function listCacheClear() { this.__data__ = [], this.size = 0 } }, function (e, t, r) { const n = r(50); const i = Array.prototype.splice; e.exports = function listCacheDelete(e) { const t = this.__data__; const r = n(t, e); return !(r < 0 || (r == t.length - 1 ? t.pop() : i.call(t, r, 1), --this.size, 0)) } }, function (e, t, r) { const n = r(50); e.exports = function listCacheGet(e) { const t = this.__data__; const r = n(t, e); return r < 0 ? void 0 : t[r][1] } }, function (e, t, r) { const n = r(50); e.exports = function listCacheHas(e) { return n(this.__data__, e) > -1 } }, function (e, t, r) { const n = r(50); e.exports = function listCacheSet(e, t) { const r = this.__data__; const i = n(r, e); return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this } }, function (e, t, r) { const n = r(49); e.exports = function stackClear() { this.__data__ = new n(), this.size = 0 } }, function (e, t) { e.exports = function stackDelete(e) { const t = this.__data__; const r = t.delete(e); return this.size = t.size, r } }, function (e, t) { e.exports = function stackGet(e) { return this.__data__.get(e) } }, function (e, t) { e.exports = function stackHas(e) { return this.__data__.has(e) } }, function (e, t, r) { const n = r(49); const i = r(73); const a = r(75); const o = 200; e.exports = function stackSet(e, t) { let r = this.__data__; if (r instanceof n) { const s = r.__data__; if (!i || s.length < o - 1) return s.push([e, t]), this.size = ++r.size, this; r = this.__data__ = new a(s) } return r.set(e, t), this.size = r.size, this } }, function (e, t, r) { const n = r(74); const i = r(309); const a = r(15); const o = r(127); const s = /^\[object .+?Constructor\]$/; const u = Function.prototype; const l = Object.prototype; const c = u.toString; const p = l.hasOwnProperty; const f = RegExp(`^${c.call(p).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?')}$`); e.exports = function baseIsNative(e) { return !(!a(e) || i(e)) && (n(e) ? f : s).test(o(e)) } }, function (e, t, r) { const n = r(51); const i = Object.prototype; const a = i.hasOwnProperty; const o = i.toString; const s = n ? n.toStringTag : void 0; e.exports = function getRawTag(e) { const t = a.call(e, s); const r = e[s]; try { e[s] = void 0; var n = !0 } catch (e) {} const i = o.call(e); return n && (t ? e[s] = r : delete e[s]), i } }, function (e, t) { const r = Object.prototype.toString; e.exports = function objectToString(e) { return r.call(e) } }, function (e, t, r) { let n; const i = r(310); const a = (n = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || '')) ? `Symbol(src)_1.${n}` : ''; e.exports = function isMasked(e) { return !!a && a in e } }, function (e, t, r) { const n = r(10)['__core-js_shared__']; e.exports = n }, function (e, t) { e.exports = function getValue(e, t) { return e == null ? void 0 : e[t] } }, function (e, t, r) { const n = r(313); const i = r(49); const a = r(73); e.exports = function mapCacheClear() { this.size = 0, this.__data__ = { hash: new n(), map: new (a || i)(), string: new n() } } }, function (e, t, r) { const n = r(314); const i = r(315); const a = r(316); const o = r(317); const s = r(318); function Hash(e) { let t = -1; const r = e == null ? 0 : e.length; for (this.clear(); ++t < r;) { const n = e[t]; this.set(n[0], n[1]) } }Hash.prototype.clear = n, Hash.prototype.delete = i, Hash.prototype.get = a, Hash.prototype.has = o, Hash.prototype.set = s, e.exports = Hash }, function (e, t, r) { const n = r(52); e.exports = function hashClear() { this.__data__ = n ? n(null) : {}, this.size = 0 } }, function (e, t) { e.exports = function hashDelete(e) { const t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } }, function (e, t, r) { const n = r(52); const i = '__lodash_hash_undefined__'; const a = Object.prototype.hasOwnProperty; e.exports = function hashGet(e) { const t = this.__data__; if (n) { const r = t[e]; return r === i ? void 0 : r } return a.call(t, e) ? t[e] : void 0 } }, function (e, t, r) { const n = r(52); const i = Object.prototype.hasOwnProperty; e.exports = function hashHas(e) { const t = this.__data__; return n ? void 0 !== t[e] : i.call(t, e) } }, function (e, t, r) { const n = r(52); const i = '__lodash_hash_undefined__'; e.exports = function hashSet(e, t) { const r = this.__data__; return this.size += this.has(e) ? 0 : 1, r[e] = n && void 0 === t ? i : t, this } }, function (e, t, r) { const n = r(53); e.exports = function mapCacheDelete(e) { const t = n(this, e).delete(e); return this.size -= t ? 1 : 0, t } }, function (e, t) { e.exports = function isKeyable(e) { const t = typeof e; return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean' ? e !== '__proto__' : e === null } }, function (e, t, r) { const n = r(53); e.exports = function mapCacheGet(e) { return n(this, e).get(e) } }, function (e, t, r) { const n = r(53); e.exports = function mapCacheHas(e) { return n(this, e).has(e) } }, function (e, t, r) { const n = r(53); e.exports = function mapCacheSet(e, t) { const r = n(this, e); const i = r.size; return r.set(e, t), this.size += r.size == i ? 0 : 1, this } }, function (e, t) { e.exports = function createBaseFor(e) { return function (t, r, n) { for (let i = -1, a = Object(t), o = n(t), s = o.length; s--;) { const u = o[e ? s : ++i]; if (!1 === r(a[u], u, a)) break; } return t } } }, function (e, t, r) { const n = r(128); const i = r(326); const a = r(327); const o = r(329); const s = r(330); const u = r(80); const l = r(17); const c = r(333); const p = r(82); const f = r(74); const d = r(15); const h = r(335); const m = r(83); const g = r(133); const v = r(339); e.exports = function baseMergeDeep(e, t, r, y, b, x, D) { const _ = g(e, r); const C = g(t, r); const w = D.get(C); if (w)n(e, r, w); else { let E = x ? x(_, C, `${r}`, e, t, D) : void 0; let S = void 0 === E; if (S) { const k = l(C); const A = !k && p(C); const T = !k && !A && m(C); E = C, k || A || T ? l(_) ? E = _ : c(_) ? E = o(_) : A ? (S = !1, E = i(C, !0)) : T ? (S = !1, E = a(C, !0)) : E = [] : h(C) || u(C) ? (E = _, u(_) ? E = v(_) : (!d(_) || y && f(_)) && (E = s(C))) : S = !1 }S && (D.set(C, E), b(E, C, y, x, D), D.delete(C)), n(e, r, E) } } }, function (e, t, r) { (function (e) { const n = r(10); const i = typeof t === 'object' && t && !t.nodeType && t; const a = i && typeof e === 'object' && e && !e.nodeType && e; const o = a && a.exports === i ? n.Buffer : void 0; const s = o ? o.allocUnsafe : void 0; e.exports = function cloneBuffer(e, t) { if (t) return e.slice(); const r = e.length; const n = s ? s(r) : new e.constructor(r); return e.copy(n), n } }).call(t, r(77)(e)) }, function (e, t, r) { const n = r(328); e.exports = function cloneTypedArray(e, t) { const r = t ? n(e.buffer) : e.buffer; return new e.constructor(r, e.byteOffset, e.length) } }, function (e, t, r) { const n = r(131); e.exports = function cloneArrayBuffer(e) { const t = new e.constructor(e.byteLength); return new n(t).set(new n(e)), t } }, function (e, t) { e.exports = function copyArray(e, t) { let r = -1; const n = e.length; for (t || (t = Array(n)); ++r < n;)t[r] = e[r]; return t } }, function (e, t, r) { const n = r(331); const i = r(78); const a = r(79); e.exports = function initCloneObject(e) { return typeof e.constructor !== 'function' || a(e) ? {} : n(i(e)) } }, function (e, t, r) { const n = r(15); const i = Object.create; const a = (function () { function object() {} return function (e) { if (!n(e)) return {}; if (i) return i(e); object.prototype = e; const t = new object(); return object.prototype = void 0, t } }()); e.exports = a }, function (e, t, r) { const n = r(27); const i = r(22); const a = '[object Arguments]'; e.exports = function baseIsArguments(e) { return i(e) && n(e) == a } }, function (e, t, r) { const n = r(31); const i = r(22); e.exports = function isArrayLikeObject(e) { return i(e) && n(e) } }, function (e, t) { e.exports = function stubFalse() { return !1 } }, function (e, t, r) { const n = r(27); const i = r(78); const a = r(22); const o = '[object Object]'; const s = Function.prototype; const u = Object.prototype; const l = s.toString; const c = u.hasOwnProperty; const p = l.call(Object); e.exports = function isPlainObject(e) { if (!a(e) || n(e) != o) return !1; const t = i(e); if (t === null) return !0; const r = c.call(t, 'constructor') && t.constructor; return typeof r === 'function' && r instanceof r && l.call(r) == p } }, function (e, t, r) { const n = r(27); const i = r(81); const a = r(22); const o = {}; o['[object Float32Array]'] = o['[object Float64Array]'] = o['[object Int8Array]'] = o['[object Int16Array]'] = o['[object Int32Array]'] = o['[object Uint8Array]'] = o['[object Uint8ClampedArray]'] = o['[object Uint16Array]'] = o['[object Uint32Array]'] = !0, o['[object Arguments]'] = o['[object Array]'] = o['[object ArrayBuffer]'] = o['[object Boolean]'] = o['[object DataView]'] = o['[object Date]'] = o['[object Error]'] = o['[object Function]'] = o['[object Map]'] = o['[object Number]'] = o['[object Object]'] = o['[object RegExp]'] = o['[object Set]'] = o['[object String]'] = o['[object WeakMap]'] = !1, e.exports = function baseIsTypedArray(e) { return a(e) && i(e.length) && !!o[n(e)] } }, function (e, t) { e.exports = function baseUnary(e) { return function (t) { return e(t) } } }, function (e, t, r) { (function (e) { const n = r(126); const i = typeof t === 'object' && t && !t.nodeType && t; const a = i && typeof e === 'object' && e && !e.nodeType && e; const o = a && a.exports === i && n.process; const s = (function () { try { return o && o.binding && o.binding('util') } catch (e) {} }()); e.exports = s }).call(t, r(77)(e)) }, function (e, t, r) { const n = r(340); const i = r(84); e.exports = function toPlainObject(e) { return n(e, i(e)) } }, function (e, t, r) { const n = r(134); const i = r(76); e.exports = function copyObject(e, t, r, a) { const o = !r; r || (r = {}); for (let s = -1, u = t.length; ++s < u;) { const l = t[s]; let c = a ? a(r[l], e[l], l, r, e) : void 0; void 0 === c && (c = e[l]), o ? i(r, l, c) : n(r, l, c) } return r } }, function (e, t) { e.exports = function baseTimes(e, t) { for (var r = -1, n = Array(e); ++r < e;)n[r] = t(r); return n } }, function (e, t, r) { const n = r(15); const i = r(79); const a = r(343); const o = Object.prototype.hasOwnProperty; e.exports = function baseKeysIn(e) { if (!n(e)) return a(e); const t = i(e); const r = []; for (const s in e)(s != 'constructor' || !t && o.call(e, s)) && r.push(s); return r } }, function (e, t) { e.exports = function nativeKeysIn(e) { const t = []; if (e != null) for (const r in Object(e))t.push(r); return t } }, function (e, t, r) { const n = r(345); const i = r(352); e.exports = function createAssigner(e) { return n((t, r) => { let n = -1; let a = r.length; let o = a > 1 ? r[a - 1] : void 0; const s = a > 2 ? r[2] : void 0; for (o = e.length > 3 && typeof o === 'function' ? (a--, o) : void 0, s && i(r[0], r[1], s) && (o = a < 3 ? void 0 : o, a = 1), t = Object(t); ++n < a;) { const u = r[n]; u && e(t, u, n, o) } return t }) } }, function (e, t, r) { const n = r(85); const i = r(346); const a = r(348); e.exports = function baseRest(e, t) { return a(i(e, t, n), `${e}`) } }, function (e, t, r) { const n = r(347); const i = Math.max; e.exports = function overRest(e, t, r) { return t = i(void 0 === t ? e.length - 1 : t, 0), function () { for (var a = arguments, o = -1, s = i(a.length - t, 0), u = Array(s); ++o < s;)u[o] = a[t + o]; o = -1; for (var l = Array(t + 1); ++o < t;)l[o] = a[o]; return l[t] = r(u), n(e, this, l) } } }, function (e, t) { e.exports = function apply(e, t, r) { switch (r.length) { case 0: return e.call(t); case 1: return e.call(t, r[0]); case 2: return e.call(t, r[0], r[1]); case 3: return e.call(t, r[0], r[1], r[2]); } return e.apply(t, r) } }, function (e, t, r) { const n = r(349); const i = r(351)(n); e.exports = i }, function (e, t, r) {
  const n = r(350); const i = r(129); const a = r(85); const o = i ? function (e, t) {
    return i(e, 'toString', {
      configurable: !0, enumerable: !1, value: n(t), writable: !0,
    });
  } : a; e.exports = o;
}, function (e, t) { e.exports = function constant(e) { return function () { return e } } }, function (e, t) { const r = 800; const n = 16; const i = Date.now; e.exports = function shortOut(e) { let t = 0; let a = 0; return function () { const o = i(); const s = n - (o - a); if (a = o, s > 0) { if (++t >= r) return arguments[0]; } else t = 0; return e(...arguments) } } }, function (e, t, r) { const n = r(35); const i = r(31); const a = r(54); const o = r(15); e.exports = function isIterateeCall(e, t, r) { if (!o(r)) return !1; const s = typeof t; return !!(s == 'number' ? i(r) && a(t, r.length) : s == 'string' && t in r) && n(r[t], e) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = t.spaceFactor = 8; t.space = [n / 2, n, 2 * n, 3 * n, 4 * n, 5 * n, 6 * n], t.color = {
    base: '#333', light: '#767676', lightest: '#ccc', link: '#1978c8', linkHover: '#f28a25', border: '#e8e8e8', name: '#7f9a44', type: '#b77daa', error: '#c00', baseBackground: '#fff', codeBackground: '#f5f5f5', sidebarBackground: '#f5f5f5', ribbonBackground: '#f9970d', ribbonText: '#fff',
  }, t.fontFamily = { base: ['-apple-system', 'BlinkMacSystemFont', '"Segoe UI"', '"Roboto"', '"Oxygen"', '"Ubuntu"', '"Cantarell"', '"Fira Sans"', '"Droid Sans"', '"Helvetica Neue"', 'sans-serif'], monospace: ['Consolas', '"Liberation Mono"', 'Menlo', 'monospace'] }, t.fontSize = {
    base: 15, text: 16, small: 13, h1: 48, h2: 36, h3: 24, h4: 18, h5: 16, h6: 16,
  }, t.mq = { small: '@media (max-width: 600px)' }, t.borderRadius = 3, t.maxWidth = 1e3, t.sidebarWidth = 200, t.buttonTextTransform = 'uppercase';
}, function (e, t, r) { const n = r(10); e.exports = function () { return n.Date.now() } }, function (e, t, r) { const n = r(15); const i = r(55); const a = NaN; const o = /^\s+|\s+$/g; const s = /^[-+]0x[0-9a-f]+$/i; const u = /^0b[01]+$/i; const l = /^0o[0-7]+$/i; const c = parseInt; e.exports = function toNumber(e) { if (typeof e === 'number') return e; if (i(e)) return a; if (n(e)) { const t = typeof e.valueOf === 'function' ? e.valueOf() : e; e = n(t) ? `${t}` : t } if (typeof e !== 'string') return e === 0 ? e : +e; e = e.replace(o, ''); const r = u.test(e); return r || l.test(e) ? c(e.slice(2), r ? 2 : 8) : s.test(e) ? a : +e } }, function (e, t) { e.exports = function (e) { const t = typeof window !== 'undefined' && window.location; if (!t) throw new Error('fixUrls requires window.location'); if (!e || typeof e !== 'string') return e; const r = `${t.protocol}//${t.host}`; const n = r + t.pathname.replace(/\/[^\/]*$/, '/'); return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, (e, t) => { let i; const a = t.trim().replace(/^"(.*)"$/, (e, t) => t).replace(/^'(.*)'$/, (e, t) => t); return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(a) ? e : (i = a.indexOf('//') === 0 ? a : a.indexOf('/') === 0 ? r + a : n + a.replace(/^\.\//, ''), `url(${JSON.stringify(i)})`) }) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(358); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Usage; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(359)); const o = _interopRequireDefault(r(438)); const s = _interopRequireDefault(r(440)); const u = _interopRequireDefault(r(442)); const l = _interopRequireDefault(r(444)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Usage(e) { const t = e.props; const r = t.props; const i = t.methods; const c = t.events; let p = t.slots; let f = void 0; (p = (0, l.default)(p, e => !!e.description)) && Object.keys(p).length > 0 && (f = p && n.default.createElement(u.default, { props: p })); const d = r && n.default.createElement(a.default, { props: r }); let h = void 0; c && Object.keys(c).length > 0 && (h = c && n.default.createElement(s.default, { props: c })); const m = i && i.length > 0 && n.default.createElement(o.default, { methods: i }); return d || m || f || h ? n.default.createElement('div', null, d, m, h, f) : null }Usage.propTypes = {
    props: i.default.shape({
      props: i.default.array, methods: i.default.array, eventsNode: i.default.object, slotsNode: i.default.object,
    }).isRequired,
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(360); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (module, exports, __webpack_require__) {
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.columns = void 0; const _extends = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; exports.getRowKey = getRowKey, exports.default = PropsRenderer; const _react = __webpack_require__(0); const _react2 = _interopRequireDefault(_react); const _propTypes = __webpack_require__(1); const _propTypes2 = _interopRequireDefault(_propTypes); const _reactGroup = __webpack_require__(86); const _reactGroup2 = _interopRequireDefault(_reactGroup); const _javascriptStringify = __webpack_require__(361); const _javascriptStringify2 = _interopRequireDefault(_javascriptStringify); const _Arguments = __webpack_require__(87); const _Arguments2 = _interopRequireDefault(_Arguments); const _Argument = __webpack_require__(88); const _Argument2 = _interopRequireDefault(_Argument); const _Code = __webpack_require__(36); const _Code2 = _interopRequireDefault(_Code); const _JsDoc = __webpack_require__(57); const _JsDoc2 = _interopRequireDefault(_JsDoc); const _Markdown = __webpack_require__(16); const _Markdown2 = _interopRequireDefault(_Markdown); const _Name = __webpack_require__(37); const _Name2 = _interopRequireDefault(_Name); const _Type = __webpack_require__(90); const _Type2 = _interopRequireDefault(_Type); const _Text = __webpack_require__(139); const _Text2 = _interopRequireDefault(_Text); const _Para = __webpack_require__(56); const _Para2 = _interopRequireDefault(_Para); const _Table = __webpack_require__(59); const _Table2 = _interopRequireDefault(_Table); const _util = __webpack_require__(437); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) } function renderType(e) { if (!e) return 'unknown'; const t = e.name; switch (t) { case 'arrayOf': return `${e.value.name}[]`; case 'objectOf': return `{${renderType(e.value)}}`; case 'instanceOf': return e.value; default: return t; } } function renderFlowType(e) { if (!e) return 'unknown'; const t = e.name; const r = e.raw; const n = e.value; switch (t) { case 'literal': return n; case 'signature': return renderComplexType(e.type, r); case 'union': case 'tuple': return renderComplexType(t, r); default: return r || t; } } function renderComplexType(e, t) { return _react2.default.createElement(_Text2.default, { size: 'small', underlined: !0, title: t }, _react2.default.createElement(_Type2.default, null, e)) } function renderEnum(e) { if (!Array.isArray((0, _util.getType)(e).value)) return _react2.default.createElement('span', null, (0, _util.getType)(e).value); const t = (0, _util.getType)(e).value.map((e) => { const t = e.value; return _react2.default.createElement(_Code2.default, { key: t }, (0, _util.showSpaces)((0, _util.unquote)(t))) }); return _react2.default.createElement('span', null, 'One of:', ' ', _react2.default.createElement(_reactGroup2.default, { separator: ', ', inline: !0 }, t)) } function renderShape(e) { const t = []; for (const r in e) { const n = e[r]; const i = renderDefault(n); const a = n.description; t.push(_react2.default.createElement('div', { key: r }, _react2.default.createElement(_Name2.default, null, r), ': ', _react2.default.createElement(_Type2.default, null, renderType(n)), i && '  ', i, a && '  ', a && _react2.default.createElement(_Markdown2.default, { text: a, inline: !0 }))) } return t } const defaultValueBlacklist = ['null', 'undefined']; function renderDefault(prop) {
    if (prop.defaultValue) {
      if (prop.type || prop.flowType) {
        const propName = prop.type ? prop.type.name : prop.flowType.type; if (defaultValueBlacklist.indexOf(prop.defaultValue.value) > -1) return _react2.default.createElement(_Code2.default, null, (0, _util.showSpaces)((0, _util.unquote)(prop.defaultValue.value))); if (propName === 'func' || prop.defaultValue.func) {
          return _react2.default.createElement(_Text2.default, {
            size: 'small', color: 'light', underlined: !0, title: (0, _util.showSpaces)((0, _util.unquote)(prop.defaultValue.value)),
          }, 'Function');
        } if (propName === 'shape' || propName === 'object') {
          try {
            const object = eval(`(${prop.defaultValue.value})`); return _react2.default.createElement(_Text2.default, {
              size: 'small', color: 'light', underlined: !0, title: (0, _javascriptStringify2.default)(object, null, 2),
            }, 'Shape');
          } catch (e) {
            return _react2.default.createElement(_Text2.default, {
              size: 'small', color: 'light', underlined: !0, title: prop.defaultValue.value,
            }, 'Shape');
          }
        }
      } return _react2.default.createElement(_Code2.default, null, (0, _util.showSpaces)((0, _util.unquote)(prop.defaultValue.value)));
    } return prop.required ? _react2.default.createElement(_Text2.default, { size: 'small', color: 'light' }, 'Required') : '';
  } function renderDescription(e) { const t = e.description; const r = e.tags; const n = void 0 === r ? {} : r; const i = renderExtra(e); const a = [].concat(_toConsumableArray(n.arg || []), _toConsumableArray(n.argument || []), _toConsumableArray(n.param || [])); const o = n.return && n.return[0] || n.returns && n.returns[0]; return _react2.default.createElement('div', null, t && _react2.default.createElement(_Markdown2.default, { text: t }), i && _react2.default.createElement(_Para2.default, null, i), _react2.default.createElement(_JsDoc2.default, n), a.length > 0 && _react2.default.createElement(_Arguments2.default, { args: a, heading: !0 }), o && _react2.default.createElement(_Argument2.default, _extends({}, o, { returns: !0 }))) } function renderExtra(e) { const t = (0, _util.getType)(e); if (!t) return null; switch (t.name) { case 'enum': return renderEnum(e); case 'union': return renderUnion(e); case 'shape': return renderShape(e.type.value); case 'arrayOf': case 'objectOf': return t.value.name === 'shape' ? renderShape(e.type.value.value) : null; default: return null; } } function renderUnion(e) { if (!Array.isArray((0, _util.getType)(e).value)) return _react2.default.createElement('span', null, (0, _util.getType)(e).value); const t = (0, _util.getType)(e).value.map((e, t) => _react2.default.createElement(_Type2.default, { key: `${e.name}-${t}` }, renderType(e))); return _react2.default.createElement('span', null, 'One of type:', ' ', _react2.default.createElement(_reactGroup2.default, { separator: ', ', inline: !0 }, t)) } function renderName(e) { const t = e.name; const r = e.tags; const n = void 0 === r ? {} : r; return _react2.default.createElement(_Name2.default, { deprecated: !!n.deprecated }, t) } function renderTypeColumn(e) { return e.flowType ? _react2.default.createElement(_Type2.default, null, renderFlowType((0, _util.getType)(e))) : _react2.default.createElement(_Type2.default, null, renderType((0, _util.getType)(e))) } function getRowKey(e) { return e.name } const columns = exports.columns = [{ caption: 'Prop name', render: renderName }, { caption: 'Type', render: renderTypeColumn }, { caption: 'Default', render: renderDefault }, { caption: 'Description', render: renderDescription }]; function PropsRenderer(e) { const t = e.props; return _react2.default.createElement(_Table2.default, { columns, rows: t, getRowKey }) }PropsRenderer.propTypes = { props: _propTypes2.default.array.isRequired };
}, function (e, t, r) {
  (function (t) {
    let r; r = function () {
      const e = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g; const r = {
        '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '"': '\\"', '\\': '\\\\',
      }; function escapeChar(e) { return r[e] || `\\u${(`0000${e.charCodeAt(0).toString(16)}`).slice(-4)}` } const n = {}; 'break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield'.split(' ').map((e) => { n[e] = !0 }); const i = /^[A-Za-z_$][A-Za-z0-9_$]*$/; function isValidVariableName(e) { return !n[e] && i.test(e) } function toGlobalVariable(e) { return `Function(${stringify('return this;')})()` } function toPath(e) { for (var t = '', r = 0; r < e.length; r++)isValidVariableName(e[r]) ? t += `.${e[r]}` : t += `[${stringify(e[r])}]`; return t } function stringifyArray(e, t, r) { const n = e.map((e, n) => { const i = r(e, n); return void 0 === i ? String(i) : t + i.split('\n').join(`\n${t}`) }).join(t ? ',\n' : ','); return t && n ? `[\n${n}\n]` : `[${n}]` } const a = {
        '[object Array]': stringifyArray, '[object Object]': function stringifyObject(e, t, r) { const n = Object.keys(e).reduce((n, i) => { let a = r(e[i], i); return void 0 === a ? n : (i = isValidVariableName(i) ? i : stringify(i), a = String(a).split('\n').join(`\n${t}`), n.push(`${t + i}:${t ? ' ' : ''}${a}`), n) }, []).join(t ? ',\n' : ','); return t && n ? `{\n${n}\n}` : `{${n}}` }, '[object Error]': function (e) { return `new Error(${stringify(e.message)})` }, '[object Date]': function (e) { return `new Date(${e.getTime()})` }, '[object String]': function (e) { return `new String(${stringify(e.toString())})` }, '[object Number]': function (e) { return `new Number(${e})` }, '[object Boolean]': function (e) { return `new Boolean(${e})` }, '[object Uint8Array]': function (e, t) { return `new Uint8Array(${stringifyArray(e)})` }, '[object Set]': function (e, t, r) { return typeof Array.from === 'function' ? `new Set(${stringify(Array.from(e), t, r)})` : void 0 }, '[object Map]': function (e, t, r) { return typeof Array.from === 'function' ? `new Map(${stringify(Array.from(e), t, r)})` : void 0 }, '[object RegExp]': String, '[object Function]': String, '[object global]': toGlobalVariable, '[object Window]': toGlobalVariable,
      }; const o = {
        string(t) { return `'${t.replace(e, escapeChar)}'` }, number: String, object: String, boolean: String, symbol: String, undefined: String,
      }; function stringify(e, r, n) { if (Object(e) !== e) return o[typeof e](e, r, n); if (typeof t === 'function' && t.isBuffer(e)) return `new Buffer(${n(e.toString())})`; const i = a[Object.prototype.toString.call(e)]; return i ? i(e, r, n) : void 0 } return function (e, t, r, n) { n = n || {}, typeof r !== 'string' && (r = new Array(Math.max(0, 0 | r) + 1).join(' ')); const i = Number(n.maxDepth) || 100; const a = !!n.references; const o = !!n.skipUndefinedProperties; let s = Number(n.maxValues) || 1e5; const u = []; const l = []; const c = []; const p = []; const f = []; function next(e, t) { if (!o || void 0 !== e) { u.push(t); const r = d(e, stringify); return u.pop(), r } } var d = a ? function (e, t) { if (e && (typeof e === 'object' || typeof e === 'function')) { const n = c.indexOf(e); if (n > -1) return void f.push(u.slice(), p[n]); c.push(e), p.push(u.slice()) } if (!(u.length > i || s-- <= 0)) return t(e, r, next); } : function (e, t) { if (!(l.indexOf(e) > -1 || u.length > i || s-- <= 0)) { l.push(e); e = t(e, r, next); return l.pop(), e } }; if (typeof t === 'function') { var h = d; d = function (e, r) { return h(e, (e, n, i) => t(e, n, e => r(e, n, i))) } } const m = d(e, stringify); if (f.length) { for (var g = r ? '\n' : '', v = r ? ' = ' : '=', y = `;${g}`, b = (h = r ? '(function () {' : '(function(){', [`var x${v}${m}`]), x = 0; x < f.length; x += 2)b.push(`x${toPath(f[x])}${v}x${toPath(f[x + 1])}`); return b.push('return x'), `${h + g + b.join(y) + y}}())` } return m };
    }, e.exports = r();
  }).call(t, r(137).Buffer);
}, function (e, t, r) {
  t.byteLength = function byteLength(e) { return 3 * e.length / 4 - placeHoldersCount(e) }, t.toByteArray = function toByteArray(e) { let t; let r; let n; let o; let s; const u = e.length; o = placeHoldersCount(e), s = new a(3 * u / 4 - o), r = o > 0 ? u - 4 : u; let l = 0; for (t = 0; t < r; t += 4)n = i[e.charCodeAt(t)] << 18 | i[e.charCodeAt(t + 1)] << 12 | i[e.charCodeAt(t + 2)] << 6 | i[e.charCodeAt(t + 3)], s[l++] = n >> 16 & 255, s[l++] = n >> 8 & 255, s[l++] = 255 & n; o === 2 ? (n = i[e.charCodeAt(t)] << 2 | i[e.charCodeAt(t + 1)] >> 4, s[l++] = 255 & n) : o === 1 && (n = i[e.charCodeAt(t)] << 10 | i[e.charCodeAt(t + 1)] << 4 | i[e.charCodeAt(t + 2)] >> 2, s[l++] = n >> 8 & 255, s[l++] = 255 & n); return s }, t.fromByteArray = function fromByteArray(e) { for (var t, r = e.length, i = r % 3, a = '', o = [], s = 0, u = r - i; s < u; s += 16383)o.push(encodeChunk(e, s, s + 16383 > u ? u : s + 16383)); i === 1 ? (t = e[r - 1], a += n[t >> 2], a += n[t << 4 & 63], a += '==') : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], a += n[t >> 10], a += n[t >> 4 & 63], a += n[t << 2 & 63], a += '='); return o.push(a), o.join('') }; for (var n = [], i = [], a = typeof Uint8Array !== 'undefined' ? Uint8Array : Array, o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', s = 0, u = o.length; s < u; ++s)n[s] = o[s], i[o.charCodeAt(s)] = s; function placeHoldersCount(e) { const t = e.length; if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4'); return e[t - 2] === '=' ? 2 : e[t - 1] === '=' ? 1 : 0 } function encodeChunk(e, t, r) { for (var i, a, o = [], s = t; s < r; s += 3)i = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], o.push(n[(a = i) >> 18 & 63] + n[a >> 12 & 63] + n[a >> 6 & 63] + n[63 & a]); return o.join('') }i['-'.charCodeAt(0)] = 62, i['_'.charCodeAt(0)] = 63;
}, function (e, t) { t.read = function (e, t, r, n, i) { let a; let o; const s = 8 * i - n - 1; const u = (1 << s) - 1; const l = u >> 1; let c = -7; let p = r ? i - 1 : 0; const f = r ? -1 : 1; let d = e[t + p]; for (p += f, a = d & (1 << -c) - 1, d >>= -c, c += s; c > 0; a = 256 * a + e[t + p], p += f, c -= 8);for (o = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; o = 256 * o + e[t + p], p += f, c -= 8);if (a === 0)a = 1 - l; else { if (a === u) return o ? NaN : 1 / 0 * (d ? -1 : 1); o += Math.pow(2, n), a -= l } return (d ? -1 : 1) * o * Math.pow(2, a - n) }, t.write = function (e, t, r, n, i, a) { let o; let s; let u; let l = 8 * a - i - 1; const c = (1 << l) - 1; const p = c >> 1; const f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let d = n ? 0 : a - 1; const h = n ? 1 : -1; const m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = c) : (o = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), (t += o + p >= 1 ? f / u : f * Math.pow(2, 1 - p)) * u >= 2 && (o++, u /= 2), o + p >= c ? (s = 0, o = c) : o + p >= 1 ? (s = (t * u - 1) * Math.pow(2, i), o += p) : (s = t * Math.pow(2, p - 1) * Math.pow(2, i), o = 0)); i >= 8; e[r + d] = 255 & s, d += h, s /= 256, i -= 8);for (o = o << i | s, l += i; l > 0; e[r + d] = 255 & o, d += h, o /= 256, l -= 8);e[r + d - h] |= 128 * m } }, function (e, t) { const r = {}.toString; e.exports = Array.isArray || function (e) { return r.call(e) == '[object Array]' } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.ArgumentsRenderer = ArgumentsRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(88)); const s = _interopRequireDefault(r(89)); const u = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = t.styles = function styles(e) { const t = e.space; return { root: { marginBottom: t[2], fontSize: 'inherit' }, headingWrapper: { marginBottom: t[0] } } }; function ArgumentsRenderer(e) { const t = e.classes; const r = e.args; const a = e.heading; return r.length === 0 ? null : i.default.createElement('div', { className: t.root }, a && i.default.createElement('div', { className: t.headingWrapper }, i.default.createElement(s.default, { level: 5 }, 'Arguments')), r.map(e => i.default.createElement(o.default, n({ key: e.name }, e)))) }ArgumentsRenderer.propTypes = { classes: a.default.object.isRequired, args: a.default.arrayOf(a.default.shape({ name: a.default.string.isRequired, type: a.default.object, description: a.default.string })).isRequired, heading: a.default.bool }, t.default = (0, u.default)(l)(ArgumentsRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.ArgumentRenderer = ArgumentRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(2)); const s = _interopRequireDefault(r(16)); const u = _interopRequireDefault(r(37)); const l = _interopRequireDefault(r(90)); const c = _interopRequireDefault(r(86)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const p = t.styles = function styles(e) { return { block: { marginBottom: e.space[2] } } }; function ArgumentRenderer(e) { const t = e.classes; const r = e.name; const a = e.type; const o = e.description; const p = e.returns; const f = e.block; const d = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['classes', 'name', 'type', 'description', 'returns', 'block'])); return i.default.createElement(c.default, n({ className: f && t.block }, d), p && 'Returns', r && i.default.createElement('span', null, i.default.createElement(u.default, null, r), a && ':'), a && i.default.createElement(l.default, null, a.name), a && o && '  ', o && i.default.createElement(s.default, { text: `${o}`, inline: !0 })) }ArgumentRenderer.propTypes = {
    classes: a.default.object.isRequired, name: a.default.string, type: a.default.object, description: a.default.string, returns: a.default.bool, block: a.default.bool,
  }, t.default = (0, o.default)(p)(ArgumentRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(1)); const a = r(368); const o = _interopRequireDefault(r(138)); const s = _interopRequireDefault(r(139)); const u = _interopRequireDefault(r(56)); const l = _interopRequireDefault(r(373)); const c = _interopRequireDefault(r(376)); const p = _interopRequireDefault(r(378)); const f = _interopRequireDefault(r(380)); const d = _interopRequireDefault(r(36)); const h = _interopRequireDefault(r(383)); const m = _interopRequireDefault(r(385)); const g = r(387); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }r(393); const v = {
    a: { component: o.default }, h1: { component: l.default, props: { level: 1 } }, h2: { component: l.default, props: { level: 2 } }, h3: { component: l.default, props: { level: 3 } }, h4: { component: l.default, props: { level: 4 } }, h5: { component: l.default, props: { level: 5 } }, h6: { component: l.default, props: { level: 6 } }, p: { component: u.default, props: { semantic: 'p' } }, em: { component: s.default, props: { semantic: 'em' } }, strong: { component: s.default, props: { semantic: 'strong' } }, ul: { component: c.default }, ol: { component: c.default, props: { ordered: !0 } }, blockquote: { component: p.default }, code: { component: d.default }, pre: { component: f.default }, input: { component: h.default }, hr: { component: m.default }, table: { component: g.Table }, thead: { component: g.TableHead }, th: { component: g.TableCell, props: { header: !0 } }, tbody: { component: g.TableBody }, tr: { component: g.TableRow }, td: { component: g.TableCell },
  }; const y = n({}, v, { p: { component: s.default } }); function Markdown(e) { const t = e.text; const r = e.inline ? y : v; return (0, a.compiler)(t, { overrides: r, forceBlock: !0 }) }Markdown.propTypes = { text: i.default.string.isRequired, inline: i.default.bool }, t.default = Markdown;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.compiler = compiler, t.default = Markdown; const n = r(0); const i = r.n(n); const a = r(369); const o = r.n(a); const s = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const u = {
    accesskey: 'accessKey', allowfullscreen: 'allowFullScreen', allowtransparency: 'allowTransparency', autocomplete: 'autoComplete', autofocus: 'autoFocus', autoplay: 'autoPlay', cellpadding: 'cellPadding', cellspacing: 'cellSpacing', charset: 'charSet', class: 'className', classid: 'classId', colspan: 'colSpan', contenteditable: 'contentEditable', contextmenu: 'contextMenu', crossorigin: 'crossOrigin', enctype: 'encType', for: 'htmlFor', formaction: 'formAction', formenctype: 'formEncType', formmethod: 'formMethod', formnovalidate: 'formNoValidate', formtarget: 'formTarget', frameborder: 'frameBorder', hreflang: 'hrefLang', inputmode: 'inputMode', keyparams: 'keyParams', keytype: 'keyType', marginheight: 'marginHeight', marginwidth: 'marginWidth', maxlength: 'maxLength', mediagroup: 'mediaGroup', minlength: 'minLength', novalidate: 'noValidate', radiogroup: 'radioGroup', readonly: 'readOnly', rowspan: 'rowSpan', spellcheck: 'spellCheck', srcdoc: 'srcDoc', srclang: 'srcLang', srcset: 'srcSet', tabindex: 'tabIndex', usemap: 'useMap',
  }; const l = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi; const c = /mailto:/i; const p = /\n{2,}$/; const f = /^( *>[^\n]+(\n[^\n]+)*\n*)+\n{2,}/; const d = /^ *> ?/gm; const m = /^ {2,}\n/; const g = /^(?:( *[-*_]) *){3,}(?:\n *)+\n/; const v = /^\s*(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n *)+\n/; const y = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n/; const b = /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/; const x = /^(?:\n *)*\n/; const D = /\r\n?/g; const _ = /(^[-*] |^#+ ?\w|^ {2,}|^-{2,}|^> )/m; const C = /^\[\^(.*)\](:.*)\n/; const w = /^\[\^(.*)\]/; const E = /\f/g; const S = /^\s*?\[(x|\s)\]/; const k = /^ *(#{1,6}) *([^\n]+?) *#* *\n+/; const A = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/; const T = /^ *<([^ >/]+) ?([^>]*)\/{0}>\s*((?:<\1>[\s\S]*<\/\1>|(?!<\1)[\s\S])*)<\/\1>\n*/; const P = /^<!--.*?-->/; const R = /^(data|aria)-[a-z_][a-z\d_.-]*$/; const O = /^ *<([\w:]+)\s*((?:<.*?>|[^>])*)>(?!<\/\1>)\s*/; const F = /^\{.*\}$/; const L = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/; const M = /^<([^ >]+@[^ >]+)>/; const j = /^<([^ >]+:\/[^ >]+)>/; const N = / *\n+$/; const I = /(?:^|\n)( *)$/; const B = /-([a-z])?/gi; const q = /^(.*\|?.*)\n *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*)\n?/; const U = /^((?:[^\n]|\n(?! *\n))+)(?:\n *)+\n/; const z = /^\[([^\]]*)\]:\s*(\S+)\s*("([^"]*)")?/; const V = /^!\[([^\]]*)\] ?\[([^\]]*)\]/; const H = /^\[([^\]]*)\] ?\[([^\]]*)\]/; const $ = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/; const G = /\t/g; const J = /(^ *\||\| *$)/g; const W = /^ *:-+: *$/; const K = /^ *:-+ *$/; const X = /^ *-+: *$/; const Y = / *\| */; const Q = /^[*_]{2}([\s\S]+?)[*_]{2}(?!\*|_)/; const Z = /^[*_]{1}([\s\S]+?)[*_]{1}(?!\*|_)/; const ee = /^\\([^0-9A-Za-z\s])/; const te = /^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i; const re = /^~~(?=\S)([\s\S]*?\S)~~/; const ne = /(^\n+|(\n|\s)+$)/g; const ie = /^\s*| {4,}|\s*$/g; const ae = /\\([^0-9A-Z\s])/gi; const oe = new RegExp('^( *)((?:[*+-]|\\d+\\.)) +'); const se = new RegExp('( *)((?:[*+-]|\\d+\\.)) +[^\\n]*(?:\\n(?!\\1(?:[*+-]|\\d+\\.) )[^\\n]*)*(\\n|$)', 'gm'); const ue = new RegExp('^( *)((?:[*+-]|\\d+\\.)) [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1(?:[*+-]|\\d+\\.) )\\n*|\\s*\\n*$)'); const le = '(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'; const ce = "\\s*<?((?:[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*"; const pe = new RegExp(`^\\[(${le})\\]\\(${ce}\\)`); const fe = new RegExp(`^!\\[(${le})\\]\\(${ce}\\)`); function parseTableAlignCapture(e) { return X.test(e) ? 'right' : W.test(e) ? 'center' : K.test(e) ? 'left' : null } function parseTable(e, t, r) {
    r.inline = !0; const n = (function parseTableHeader(e, t, r) { return e[1].replace(J, '').trim().split(Y).map(e => t(e, r)) }(e, t, r)); const i = (function parseTableAlign(e) { return e[2].replace(J, '').trim().split(Y).map(parseTableAlignCapture) }(e)); const a = (function parseTableCells(e, t, r) { return e[3].replace(J, '').trim().split('\n').map(e => e.replace(J, '').split(Y).map(e => t(e.trim(), r))) }(e, t, r)); return r.inline = !1, {
      align: i, cells: a, header: n, type: 'table',
    };
  } function getTableStyle(e, t) { return e.align[t] == null ? {} : { textAlign: e.align[t] } } function attributeValueToJSXPropValue(e, t) { return e === 'style' ? t.split(/;\s?/).reduce((e, t) => { const r = t.slice(0, t.indexOf(':')); return e[r.replace(/(-[a-z])/g, e => e[1].toUpperCase())] = t.slice(r.length + 1).trim(), e }, {}) : ((function isInterpolation(e) { return F.test(e) }(t)) && (t = t.slice(1, t.length - 1)), t === 'true' || t !== 'false' && t) } function parserFor(e) { const t = Object.keys(e); function nestedParse(r, n) { for (var i = [], a = ''; r;) for (let o = 0; o < t.length;) { const s = t[o]; const u = e[s]; const l = u.match(r, n, a); if (l) { const c = l[0]; r = r.substring(c.length); const p = u.parse(l, nestedParse, n); p.type == null && (p.type = s), i.push(p), a = c; break }o++ } return i } return t.sort((t, r) => { const n = e[t].order; const i = e[r].order; return n !== i ? n - i : t < r ? -1 : 1 }), function outerParse(e, t) { return nestedParse((function normalizeWhitespace(e) { return e.replace(D, '\n').replace(E, '').replace(G, '    ') }(e)), t) } } function inlineRegex(e) { return function match(t, r) { return r.inline ? e.exec(t) : null } } function simpleInlineRegex(e) { return function match(t, r) { return r.inline || r.simple ? e.exec(t) : null } } function blockRegex(e) { return function match(t, r) { return r.inline || r.simple ? null : e.exec(t) } } function anyScopeRegex(e) { return function match(t) { return e.exec(t) } } function sanitizeUrl(e) { try { if (decodeURIComponent(e).replace(/[^A-Z0-9/:]/gi, '').toLowerCase().indexOf('javascript:') === 0) return null; } catch (e) { return null } return e } function unescapeUrl(e) { return e.replace(ae, '$1') } function parseInline(e, t, r) { const n = r.inline || !1; const i = r.simple || !1; r.inline = !0, r.simple = !0; const a = e(t, r); return r.inline = n, r.simple = i, a } function parseBlock(e, t, r) { return r.inline = !1, e(`${t}\n\n`, r) } function parseCaptureInline(e, t, r) { return { content: parseInline(t, e[1], r) } } function captureNothing() { return {} } function renderNothing() { return null } function get(e, t, r) { for (var n = e, i = t.split('.'); i.length && void 0 !== (n = n[i[0]]);)i.shift(); return n || r } const de = 1; const he = 2; const me = 3; const ge = 4; const ve = 5; function compiler(e, t) {
    (t = t || {}).overrides = t.overrides || {}; const r = t.createElement || i.a.createElement; function h(e, n) { for (var i = get(t.overrides, `${e}.props`, {}), a = arguments.length, o = Array(a > 2 ? a - 2 : 0), u = 2; u < a; u++)o[u - 2] = arguments[u]; return r(...[(function getTag(e, t) { const r = get(t, e); return typeof r === 'function' ? r : get(t, `${e}.component`, e) }(e, t.overrides)), s({}, i, n, { className: (function cx() { return Array.prototype.slice.call(arguments).filter(Boolean).join(' ') }(n && n.className, i.className)) || void 0 })].concat(o)) } function compile(e) { let r = !1; t.forceInline ? r = !0 : t.forceBlock || (r = !1 === $.test(e)); const n = F(E(r ? e : `${e.replace(ne, '')}\n\n`, { inline: r })); let i = void 0; return n.length > 1 ? i = h(r ? 'span' : 'div', null, n) : n.length === 1 ? typeof (i = n[0]) === 'string' && (i = h('span', null, i)) : i = h('span', null), i } function attrStringToMap(e) { const t = e.match(l); return t ? t.reduce((e, t, r) => { const n = t.indexOf('='); if (n !== -1) { const a = (function normalizeAttributeKey(e) { return e.indexOf('-') !== -1 && e.match(R) === null && (e = e.replace(B, (e, t) => t.toUpperCase())), e }(t.slice(0, n))).trim(); const s = o()(t.slice(n + 1).trim()); const l = u[a] || a; const c = e[l] = attributeValueToJSXPropValue(a, s); (T.test(c) || O.test(c)) && (e[l] = i.a.cloneElement(compile(c.trim()), { key: r })) } else e[u[t] || t] = !0; return e }, {}) : void 0 } const n = []; const a = {}; const D = {
      blockQuote: {
        match: blockRegex(f), order: he, parse: function parse(e, t, r) { return { content: t(e[0].replace(d, ''), r) } }, react: function react(e, t, r) { return h('blockquote', { key: r.key }, t(e.content, r)) },
      },
      breakLine: {
        match: anyScopeRegex(m), order: he, parse: captureNothing, react: function react(e, t, r) { return h('br', { key: r.key }) },
      },
      breakThematic: {
        match: blockRegex(g), order: he, parse: captureNothing, react: function react(e, t, r) { return h('hr', { key: r.key }) },
      },
      codeBlock: {
        match: blockRegex(y), order: de, parse: function parse(e) { return { content: e[0].replace(/^ {4}/gm, '').replace(/\n+$/, ''), lang: void 0 } }, react: function react(e, t, r) { return h('pre', { key: r.key }, h('code', { className: e.lang ? `lang-${e.lang}` : '' }, e.content)) },
      },
      codeFenced: { match: blockRegex(v), order: de, parse: function parse(e) { return { content: e[3], lang: e[2] || void 0, type: 'codeBlock' } } },
      codeInline: {
        match: simpleInlineRegex(b), order: ge, parse: function parse(e) { return { content: e[2] } }, react: function react(e, t, r) { return h('code', { key: r.key }, e.content) },
      },
      footnote: {
        match: blockRegex(C), order: de, parse: function parse(e) { return n.push({ footnote: e[2], identifier: e[1] }), {} }, react: renderNothing,
      },
      footnoteReference: {
        match: inlineRegex(w), order: he, parse: function parse(e) { return { content: e[1], target: `#${e[1]}` } }, react: function react(e, t, r) { return h('a', { key: r.key, href: sanitizeUrl(e.target) }, h('sup', { key: r.key }, e.content)) },
      },
      gfmTask: {
        match: inlineRegex(S),
        order: he,
        parse: function parse(e) { return { completed: e[1].toLowerCase() === 'x' } },
        react: function react(e, t, r) {
          return h('input', {
            checked: e.completed, key: r.key, readOnly: !0, type: 'checkbox',
          });
        },
      },
      heading: {
        match: blockRegex(k),
        order: he,
        parse: function parse(e, t, r) {
          return {
            content: parseInline(t, e[2], r),
            id: (function slugify(e) {
              return e.replace(/[]/g, 'a').replace(/[]/g, 'c').replace(/[]/g, 'd').replace(/[]/g, 'e')
                .replace(/[]/g, 'i')
                .replace(/[]/g, 'n')
                .replace(/[]/g, 'o')
                .replace(/[]/g, 'u')
                .replace(/[]/g, 'y')
                .replace(/[^a-z0-9- ]/gi, '')
                .replace(/ /gi, '-')
                .toLowerCase();
            }(e[2])),
            level: e[1].length,
          };
        },
        react: function react(e, t, r) { return h(`h${e.level}`, { id: e.id, key: r.key }, t(e.content, r)) },
      },
      headingSetext: { match: blockRegex(A), order: de, parse: function parse(e, t, r) { return { content: parseInline(t, e[1], r), level: e[2] === '=' ? 1 : 2, type: 'heading' } } },
      htmlBlock: {
        match: anyScopeRegex(T), order: he, parse: function parse(e, t, r) { const n = e[3].match(T) || _.test(e[3]) ? parseBlock : parseInline; return { attrs: attrStringToMap(e[2]), content: n(t, e[3].replace(ie, ''), r), tag: e[1] } }, react: function react(e, t, r) { return h(e.tag, s({ key: r.key }, e.attrs), t(e.content, r)) },
      },
      htmlComment: {
        match: anyScopeRegex(P), order: he, parse: function parse() { return {} }, react: renderNothing,
      },
      htmlSelfClosing: {
        match: anyScopeRegex(O), order: he, parse: function parse(e) { return { attrs: attrStringToMap(e[2]), tag: e[1] } }, react: function react(e, t, r) { return h(e.tag, s({}, e.attrs, { key: r.key })) },
      },
      image: {
        match: simpleInlineRegex(fe),
        order: he,
        parse: function parse(e) { return { alt: e[1], target: unescapeUrl(e[2]), title: e[3] } },
        react: function react(e, t, r) {
          return h('img', {
            key: r.key, alt: e.alt || void 0, title: e.title || void 0, src: sanitizeUrl(e.target),
          });
        },
      },
      link: {
        match: inlineRegex(pe), order: ge, parse: function parse(e, t, r) { return { content: (function parseSimpleInline(e, t, r) { const n = r.inline || !1; const i = r.simple || !1; r.inline = !1, r.simple = !0; const a = e(t, r); return r.inline = n, r.simple = i, a }(t, e[1], r)), target: unescapeUrl(e[2]), title: e[3] } }, react: function react(e, t, r) { return h('a', { key: r.key, href: sanitizeUrl(e.target), title: e.title }, t(e.content, r)) },
      },
      linkAngleBraceStyleDetector: { match: inlineRegex(j), order: de, parse: function parse(e) { return { content: [{ content: e[1], type: 'text' }], target: e[1], type: 'link' } } },
      linkBareUrlDetector: {
        match: inlineRegex(L),
        order: de,
        parse: function parse(e) {
          return {
            content: [{ content: e[1], type: 'text' }], target: e[1], title: void 0, type: 'link',
          };
        },
      },
      linkMailtoDetector: { match: inlineRegex(M), order: de, parse: function parse(e) { const t = e[1]; let r = e[1]; return c.test(r) || (r = `mailto:${r}`), { content: [{ content: t.replace('mailto:', ''), type: 'text' }], target: r, type: 'link' } } },
      list: {
        match: function match(e, t, r) { const n = I.exec(r); const i = t._list || !t.inline; return n && i ? (e = n[1] + e, ue.exec(e)) : null }, order: he, parse: function parse(e, t, r) { const n = e[2]; const i = n.length > 1; const a = i ? +n : void 0; const o = e[0].replace(p, '\n').match(se); let s = !1; return { items: o.map((e, n) => { const i = oe.exec(e)[0].length; const a = new RegExp(`^ {1,${i}}`, 'gm'); const u = e.replace(a, '').replace(oe, ''); const l = n === o.length - 1; const c = u.indexOf('\n\n') !== -1 || l && s; s = c; const p = r.inline; const f = r._list; r._list = !0; let d = void 0; c ? (r.inline = !1, d = u.replace(N, '\n\n')) : (r.inline = !0, d = u.replace(N, '')); const h = t(d, r); return r.inline = p, r._list = f, h }), ordered: i, start: a } }, react: function react(e, t, r) { return h(e.ordered ? 'ol' : 'ul', { key: r.key, start: e.start }, e.items.map((e, n) => h('li', { key: n }, t(e, r)))) },
      },
      newlineCoalescer: {
        match: blockRegex(x), order: ge, parse: captureNothing, react: function react() { return '\n' },
      },
      paragraph: {
        match: blockRegex(U), order: ge, parse: parseCaptureInline, react: function react(e, t, r) { return h('p', { key: r.key }, t(e.content, r)) },
      },
      ref: {
        match: inlineRegex(z), order: de, parse: function parse(e) { return a[e[1]] = { target: e[2], title: e[4] }, {} }, react: renderNothing,
      },
      refImage: {
        match: simpleInlineRegex(V),
        order: de,
        parse: function parse(e) { return { alt: e[1] || void 0, ref: e[2] } },
        react: function react(e, t, r) {
          return h('img', {
            key: r.key, alt: e.alt, src: sanitizeUrl(a[e.ref].target), title: a[e.ref].title,
          });
        },
      },
      refLink: {
        match: inlineRegex(H), order: de, parse: function parse(e, t, r) { return { content: t(e[1], r), ref: e[2] } }, react: function react(e, t, r) { return h('a', { key: r.key, href: sanitizeUrl(a[e.ref].target), title: a[e.ref].title }, t(e.content, r)) },
      },
      table: {
        match: blockRegex(q), order: he, parse: parseTable, react: function react(e, t, r) { return h('table', { key: r.key }, h('thead', null, h('tr', null, e.header.map((n, i) => h('th', { key: i, style: getTableStyle(e, i), scope: 'col' }, t(n, r))))), h('tbody', null, e.cells.map((n, i) => h('tr', { key: i }, n.map((n, i) => h('td', { key: i, style: getTableStyle(e, i) }, t(n, r))))))) },
      },
      text: {
        match: anyScopeRegex(te), order: ve, parse: function parse(e) { return { content: e[0] } }, react: function react(e) { return e.content },
      },
      textBolded: {
        match: simpleInlineRegex(Q), order: me, parse: parseCaptureInline, react: function react(e, t, r) { return h('strong', { key: r.key }, t(e.content, r)) },
      },
      textEmphasized: {
        match: simpleInlineRegex(Z), order: ge, parse: function parse(e, t, r) { return { content: t(e[2] || e[1], r) } }, react: function react(e, t, r) { return h('em', { key: r.key }, t(e.content, r)) },
      },
      textEscaped: { match: simpleInlineRegex(ee), order: he, parse: function parse(e) { return { content: e[1], type: 'text' } } },
      textStrikethroughed: {
        match: simpleInlineRegex(re), order: ge, parse: parseCaptureInline, react: function react(e, t, r) { return h('del', { key: r.key }, t(e.content, r)) },
      },
    }; var E = parserFor(D); var F = (function reactFor(e) { return function nestedReactOutput(t, r) { if (r = r || {}, Array.isArray(t)) { for (var n = r.key, i = [], a = !1, o = 0; o < t.length; o++) { r.key = o; const s = nestedReactOutput(t[o], r); const u = typeof s === 'string'; u && a ? i[i.length - 1] += s : i.push(s), a = u } return r.key = n, i } return e(t, nestedReactOutput, r) } }(function ruleOutput(e) { return function nestedRuleOutput(t, r, n) { return e[t.type].react(t, r, n) } }(D))); const G = compile(e); return n.length && G.props.children.push(h('footer', null, n.map(e => h('div', { id: e.identifier, key: e.identifier }, e.identifier, F(E(e.footnote, { inline: !0 })))))), G;
  } function Markdown(e) { return compiler(e.children, e.options) }
}, function (e, t) { const r = /[\'\"]/; e.exports = function unquote(e) { return e ? (r.test(e.charAt(0)) && (e = e.substr(1)), r.test(e.charAt(e.length - 1)) && (e = e.substr(0, e.length - 1)), e) : '' } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.LinkRenderer = LinkRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(11)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function LinkRenderer(e) { const t = e.classes; const r = e.children; const a = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['classes', 'children'])); return i.default.createElement('a', n({}, a, { className: (0, o.default)(t.link, a.className) }), r) }LinkRenderer.propTypes = { children: a.default.node, className: a.default.string, classes: a.default.object.isRequired }, t.default = (0, s.default)((e) => { const t = e.color; return { link: { '&, &:link, &:visited': { fontSize: 'inherit', color: t.link, textDecoration: 'none' }, '&:hover, &:active': { isolate: !1, color: t.linkHover, cursor: 'pointer' } } } })(LinkRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.TextRenderer = TextRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(2)); const s = _interopRequireDefault(r(11)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _defineProperty(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
      value: r, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = r, e;
  } const u = t.styles = function styles(e) {
    const t = e.fontFamily; const r = e.fontSize; const n = e.color; return {
      text: { fontFamily: t.base }, inheritSize: { fontSize: 'inherit' }, smallSize: { fontSize: r.small }, baseSize: { fontSize: r.base }, textSize: { fontSize: r.text }, baseColor: { color: n.base }, lightColor: { color: n.light }, em: { fontStyle: 'italic' }, strong: { fontWeight: 'bold' }, isUnderlined: { borderBottom: [[1, 'dotted', n.lightest]] },
    };
  }; function TextRenderer(e) { let t; const r = e.classes; const a = e.semantic; const o = e.size; const u = e.color; const l = e.underlined; const c = e.children; const p = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['classes', 'semantic', 'size', 'color', 'underlined', 'children'])); const f = a || 'span'; const d = (0, s.default)(r.text, r[`${o}Size`], r[`${u}Color`], (_defineProperty(t = {}, r[a], a), _defineProperty(t, r.isUnderlined, l), t)); return i.default.createElement(f, n({}, p, { className: d }), c) }TextRenderer.propTypes = {
    classes: a.default.object.isRequired, semantic: a.default.oneOf(['em', 'strong']), size: a.default.oneOf(['inherit', 'small', 'base', 'text']), color: a.default.oneOf(['base', 'light']), underlined: a.default.bool, children: a.default.node.isRequired,
  }, TextRenderer.defaultProps = { size: 'inherit', color: 'base', underlined: !1 }, t.default = (0, o.default)(u)(TextRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.ParaRenderer = ParaRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = t.styles = function styles(e) {
    const t = e.space; const r = e.color; const n = e.fontFamily; return {
      para: {
        marginTop: 0, marginBottom: t[2], color: r.base, fontFamily: n.base, fontSize: 'inherit', lineHeight: 1.5,
      },
    };
  }; function ParaRenderer(e) { const t = e.classes; const r = e.semantic; const i = e.children; const a = r || 'div'; return n.default.createElement(a, { className: t.para }, i) }ParaRenderer.propTypes = { classes: i.default.object.isRequired, semantic: i.default.oneOf(['p']), children: i.default.node.isRequired }, t.default = (0, a.default)(o)(ParaRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(374); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); const o = _interopRequireDefault(r(89)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function MarkdownHeadingRenderer(e) { const t = e.classes; const r = e.level; const i = e.children; return n.default.createElement('div', { className: t.spacing }, n.default.createElement(o.default, { level: r }, i)) }MarkdownHeadingRenderer.propTypes = { classes: i.default.object.isRequired, level: i.default.oneOf([1, 2, 3, 4, 5, 6]).isRequired, children: i.default.node }, t.default = (0, a.default)(e => ({ spacing: { marginBottom: e.space[2] } }))(MarkdownHeadingRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(11)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function HeadingRenderer(e) { const t = e.classes; const r = e.level; const a = e.children; const s = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['classes', 'level', 'children'])); const u = `h${r}`; const l = (0, o.default)(t.heading, t[`heading${r}`]); return i.default.createElement(u, n({}, s, { className: l }), a) }HeadingRenderer.propTypes = { classes: a.default.object.isRequired, level: a.default.oneOf([1, 2, 3, 4, 5, 6]).isRequired, children: a.default.node }, t.default = (0, s.default)((e) => {
    const t = e.color; const r = e.fontFamily; const n = e.fontSize; return {
      heading: {
        margin: 0, color: t.base, fontFamily: r.base, fontWeight: 'normal',
      },
      heading1: { fontSize: n.h1 },
      heading2: { fontSize: n.h2 },
      heading3: { fontSize: n.h3 },
      heading4: { fontSize: n.h4 },
      heading5: { fontSize: n.h5 },
      heading6: { fontSize: n.h6 },
    };
  })(HeadingRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(377); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.ListRenderer = ListRenderer; const n = r(0); const i = _interopRequireDefault(n); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(11)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ListRenderer(e) { const t = e.classes; const r = e.ordered; const a = e.children; const s = r ? 'ol' : 'ul'; const u = (0, o.default)(t.list, r && t.ordered); return i.default.createElement(s, { className: u }, n.Children.map(a, e => (0, n.cloneElement)(e, { className: t.li }))) }ListRenderer.propTypes = { classes: a.default.object.isRequired, ordered: a.default.bool, children: a.default.node.isRequired }, ListRenderer.defaultProps = { ordered: !1 }, t.default = (0, s.default)((e) => {
    const t = e.space; const r = e.color; const n = e.fontFamily; return {
      list: {
        marginTop: 0, marginBottom: t[2], paddingLeft: t[3], fontSize: 'inherit',
      },
      ordered: { listStyleType: 'decimal' },
      li: {
        color: r.base, fontFamily: n.base, fontSize: 'inherit', lineHeight: 1.5, listStyleType: 'inherit',
      },
    };
  })(ListRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(379); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.BlockquoteRenderer = BlockquoteRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function BlockquoteRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('blockquote', { className: t.blockquote }, r) }BlockquoteRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired }, t.default = (0, a.default)((e) => {
    const t = e.space; const r = e.color; const n = e.fontSize; const i = e.fontFamily; return {
      blockquote: {
        margin: [[t[2], t[4]]], padding: 0, color: r.base, fontFamily: i.base, fontSize: n.base, lineHeight: 1.5,
      },
    };
  })(BlockquoteRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(381); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.PreRenderer = PreRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function PreRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('pre', { className: t.pre }, r) }PreRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired }, t.default = (0, a.default)((e) => {
    const t = e.space; const r = e.color; const n = e.fontSize; const i = e.fontFamily; const a = e.borderRadius; return {
      pre: {
        fontFamily: i.base, fontSize: n.small, lineHeight: 1.5, color: r.base, whiteSpace: 'pre', backgroundColor: r.codeBackground, padding: [[t[1], t[2]]], border: [[1, r.border, 'solid']], borderRadius: a, marginTop: 0, marginBottom: t[2],
      },
    };
  })(PreRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.CodeRenderer = CodeRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(11)); const o = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function CodeRenderer(e) { const t = e.classes; const r = e.className; const i = e.children; const o = (0, a.default)(r, t.code); return r && r.indexOf('lang-') !== -1 ? n.default.createElement('code', { className: o, dangerouslySetInnerHTML: { __html: i } }) : n.default.createElement('code', { className: o }, i) }CodeRenderer.propTypes = { classes: i.default.object.isRequired, className: i.default.string, children: i.default.node.isRequired }, t.default = (0, o.default)(e => ({
    code: {
      fontFamily: e.fontFamily.monospace, fontSize: 'inherit', color: 'inherit', background: 'transparent', whiteSpace: 'inherit',
    },
  }))(CodeRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(384); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.CheckboxRenderer = CheckboxRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function CheckboxRenderer(e) { const t = e.classes; const r = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['classes'])); return i.default.createElement('input', n({}, r, { type: 'checkbox', className: t.input })) }CheckboxRenderer.propTypes = { classes: a.default.object.isRequired }, t.default = (0, o.default)(() => ({ input: { isolate: !1, display: 'inline-block', verticalAlign: 'middle' } }))(CheckboxRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(386); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.HrRenderer = HrRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function HrRenderer(e) { const t = e.classes; return n.default.createElement('hr', { className: t.hr }) }HrRenderer.propTypes = { classes: i.default.object.isRequired }, t.default = (0, a.default)((e) => { const t = e.space; return { hr: { borderBottom: [[1, e.color.border, 'solid']], marginTop: 0, marginBottom: t[2] } } })(HrRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(388); Object.defineProperty(t, 'Table', { enumerable: !0, get: function get() { return _interopRequireDefault(n).default } }); const i = r(389); Object.defineProperty(t, 'TableHead', { enumerable: !0, get: function get() { return _interopRequireDefault(i).default } }); const a = r(390); Object.defineProperty(t, 'TableBody', { enumerable: !0, get: function get() { return _interopRequireDefault(a).default } }); const o = r(391); Object.defineProperty(t, 'TableRow', { enumerable: !0, get: function get() { return _interopRequireDefault(o).default } }); const s = r(392); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }Object.defineProperty(t, 'TableCell', { enumerable: !0, get: function get() { return _interopRequireDefault(s).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableRenderer = TableRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('table', { className: t.table }, r) }TableRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired }, t.default = (0, a.default)(e => ({ table: { marginTop: 0, marginBottom: e.space[2], borderCollapse: 'collapse' } }))(TableRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableHeadRenderer = TableHeadRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableHeadRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('thead', { className: t.thead }, r) }TableHeadRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired }, t.default = (0, a.default)(e => ({ thead: { borderBottom: [[1, e.color.border, 'solid']] } }))(TableHeadRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableBodyRenderer = TableBodyRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableBodyRenderer(e) { const t = e.children; return n.default.createElement('tbody', null, t) }TableBodyRenderer.propTypes = { children: i.default.node.isRequired }, t.default = TableBodyRenderer;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableRowRenderer = TableRowRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableRowRenderer(e) { const t = e.children; return n.default.createElement('tr', null, t) }TableRowRenderer.propTypes = { children: i.default.node.isRequired }, t.default = TableRowRenderer;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableCellRenderer = TableCellRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableCellRenderer(e) { const t = e.classes; const r = e.header; const i = e.children; return r ? n.default.createElement('th', { className: t.th }, i) : n.default.createElement('td', { className: t.td }, i) }TableCellRenderer.propTypes = { classes: i.default.object.isRequired, header: i.default.bool, children: i.default.node.isRequired }, TableCellRenderer.defaultProps = { header: !1 }, t.default = (0, a.default)((e) => {
    const t = e.space; const r = e.color; const n = e.fontSize; const i = e.fontFamily; return {
      td: {
        padding: [[t[0], t[2], t[0], 0]], fontFamily: i.base, fontSize: n.base, color: r.base, lineHeight: 1.5,
      },
      th: { composes: '$td', fontWeight: 'bold' },
    };
  })(TableCellRenderer);
}, function (e, t, r) { let n = r(394); typeof n === 'string' && (n = [[e.i, n, '']]); const i = { hmr: !0, transform: void 0, insertInto: void 0 }; r(230)(n, i); n.locals && (e.exports = n.locals) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */\n\n/* Tomorrow Comment */\n.hljs-comment,\n.hljs-quote {\n  color: #8e908c;\n}\n\n/* Tomorrow Red */\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag,\n.hljs-name,\n.hljs-selector-id,\n.hljs-selector-class,\n.hljs-regexp,\n.hljs-deletion {\n  color: #c82829;\n}\n\n/* Tomorrow Orange */\n.hljs-number,\n.hljs-built_in,\n.hljs-builtin-name,\n.hljs-literal,\n.hljs-type,\n.hljs-params,\n.hljs-meta,\n.hljs-link {\n  color: #f5871f;\n}\n\n/* Tomorrow Yellow */\n.hljs-attribute {\n  color: #eab700;\n}\n\n/* Tomorrow Green */\n.hljs-string,\n.hljs-symbol,\n.hljs-bullet,\n.hljs-addition {\n  color: #718c00;\n}\n\n/* Tomorrow Blue */\n.hljs-title,\n.hljs-section {\n  color: #4271ae;\n}\n\n/* Tomorrow Purple */\n.hljs-keyword,\n.hljs-selector-tag {\n  color: #8959a8;\n}\n\n.hljs {\n  display: block;\n  overflow-x: auto;\n  background: white;\n  color: #4d4d4c;\n  padding: 0.5em;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}\n', '']) }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.NameRenderer = NameRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(36)); const o = _interopRequireDefault(r(2)); const s = _interopRequireDefault(r(11)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const u = t.styles = function styles(e) { const t = e.fontSize; const r = e.color; return { name: { fontSize: t.small, color: r.name }, isDeprecated: { color: r.light, textDecoration: 'line-through' } } }; function NameRenderer(e) {
    const t = e.classes; const r = e.children; const i = e.deprecated; const o = (0, s.default)(t.name, (function _defineProperty(e, t, r) {
      return t in e ? Object.defineProperty(e, t, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = r, e;
    }({}, t.isDeprecated, i))); return n.default.createElement('span', { className: o }, n.default.createElement(a.default, null, r));
  }NameRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired, deprecated: i.default.bool }, t.default = (0, o.default)(u)(NameRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.TypeRenderer = TypeRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(36)); const o = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = t.styles = function styles(e) { const t = e.fontSize; const r = e.color; return { type: { fontSize: t.small, color: r.type } } }; function TypeRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('span', { className: t.type }, n.default.createElement(a.default, null, r)) }TypeRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node.isRequired }, t.default = (0, o.default)(s)(TypeRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.getMarkdown = getMarkdown, t.default = JsDoc; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(16)); const o = _interopRequireDefault(r(91)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = function paragraphs(e) { return e.map(e => e.description).join('\n\n') }; const u = {
    deprecated: function deprecated(e) { return `**Deprecated:** ${e[0].description}` }, see: function see(e) { return s(e) }, link: function link(e) { return s(e) }, author: function author(e) { return `${(function plural(e, t) { return e.length === 1 ? t : `${t}s` }(e, 'Author'))}: ${(function list(e) { return e.map(e => e.description).join(', ') }(e))}` }, version: function version(e) { return `Version: ${e[0].description}` }, since: function since(e) { return `Since: ${e[0].description}` },
  }; function getMarkdown(e) { return (0, o.default)(u, (t, r) => e[r] && t(e[r])).filter(Boolean).join('\n\n') } function JsDoc(e) { const t = getMarkdown(e); return t ? n.default.createElement(a.default, { text: t }) : null }JsDoc.propTypes = {
    deprecated: i.default.array, see: i.default.array, link: i.default.array, author: i.default.array, version: i.default.array, since: i.default.array,
  };
}, function (e, t, r) { const n = r(399); const i = r(419); const a = r(148); e.exports = function baseMatches(e) { const t = i(e); return t.length == 1 && t[0][2] ? a(t[0][0], t[0][1]) : function (r) { return r === e || n(r, e, t) } } }, function (e, t, r) { const n = r(72); const i = r(141); const a = 1; const o = 2; e.exports = function baseIsMatch(e, t, r, s) { let u = r.length; const l = u; const c = !s; if (e == null) return !l; for (e = Object(e); u--;) { var p = r[u]; if (c && p[2] ? p[1] !== e[p[0]] : !(p[0] in e)) return !1; } for (;++u < l;) { const f = (p = r[u])[0]; const d = e[f]; const h = p[1]; if (c && p[2]) { if (void 0 === d && !(f in e)) return !1; } else { const m = new n(); if (s) var g = s(d, h, f, e, t, m); if (!(void 0 === g ? i(h, d, a | o, s, m) : g)) return !1; } } return !0 } }, function (e, t, r) { const n = r(72); const i = r(142); const a = r(406); const o = r(409); const s = r(414); const u = r(17); const l = r(82); const c = r(83); const p = 1; const f = '[object Arguments]'; const d = '[object Array]'; const h = '[object Object]'; const m = Object.prototype.hasOwnProperty; e.exports = function baseIsEqualDeep(e, t, r, g, v, y) { let b = u(e); const x = u(t); let D = b ? d : s(e); let _ = x ? d : s(t); let C = (D = D == f ? h : D) == h; const w = (_ = _ == f ? h : _) == h; const E = D == _; if (E && l(e)) { if (!l(t)) return !1; b = !0, C = !1 } if (E && !C) return y || (y = new n()), b || c(e) ? i(e, t, r, g, v, y) : a(e, t, D, r, g, v, y); if (!(r & p)) { const S = C && m.call(e, '__wrapped__'); const k = w && m.call(t, '__wrapped__'); if (S || k) { const A = S ? e.value() : e; const T = k ? t.value() : t; return y || (y = new n()), v(A, T, r, g, y) } } return !!E && (y || (y = new n()), o(e, t, r, g, v, y)) } }, function (e, t, r) { const n = r(75); const i = r(402); const a = r(403); function SetCache(e) { let t = -1; const r = e == null ? 0 : e.length; for (this.__data__ = new n(); ++t < r;) this.add(e[t]); }SetCache.prototype.add = SetCache.prototype.push = i, SetCache.prototype.has = a, e.exports = SetCache }, function (e, t) { const r = '__lodash_hash_undefined__'; e.exports = function setCacheAdd(e) { return this.__data__.set(e, r), this } }, function (e, t) { e.exports = function setCacheHas(e) { return this.__data__.has(e) } }, function (e, t) { e.exports = function arraySome(e, t) { for (let r = -1, n = e == null ? 0 : e.length; ++r < n;) if (t(e[r], r, e)) return !0; return !1 } }, function (e, t) { e.exports = function cacheHas(e, t) { return e.has(t) } }, function (e, t, r) { const n = r(51); const i = r(131); const a = r(35); const o = r(142); const s = r(407); const u = r(408); const l = 1; const c = 2; const p = '[object Boolean]'; const f = '[object Date]'; const d = '[object Error]'; const h = '[object Map]'; const m = '[object Number]'; const g = '[object RegExp]'; const v = '[object Set]'; const y = '[object String]'; const b = '[object Symbol]'; const x = '[object ArrayBuffer]'; const D = '[object DataView]'; const _ = n ? n.prototype : void 0; const C = _ ? _.valueOf : void 0; e.exports = function equalByTag(e, t, r, n, _, w, E) { switch (r) { case D: if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case x: return !(e.byteLength != t.byteLength || !w(new i(e), new i(t))); case p: case f: case m: return a(+e, +t); case d: return e.name == t.name && e.message == t.message; case g: case y: return e == `${t}`; case h: var S = s; case v: var k = n & l; if (S || (S = u), e.size != t.size && !k) return !1; var A = E.get(e); if (A) return A == t; n |= c, E.set(e, t); var T = o(S(e), S(t), n, _, w, E); return E.delete(e), T; case b: if (C) return C.call(e) == C.call(t); } return !1 } }, function (e, t) { e.exports = function mapToArray(e) { let t = -1; const r = Array(e.size); return e.forEach((e, n) => { r[++t] = [n, e] }), r } }, function (e, t) { e.exports = function setToArray(e) { let t = -1; const r = Array(e.size); return e.forEach((e) => { r[++t] = e }), r } }, function (e, t, r) { const n = r(410); const i = 1; const a = Object.prototype.hasOwnProperty; e.exports = function equalObjects(e, t, r, o, s, u) { const l = r & i; const c = n(e); const p = c.length; if (p != n(t).length && !l) return !1; for (var f = p; f--;) { var d = c[f]; if (!(l ? d in t : a.call(t, d))) return !1; } const h = u.get(e); if (h && u.get(t)) return h == t; let m = !0; u.set(e, t), u.set(t, e); for (var g = l; ++f < p;) { const v = e[d = c[f]]; const y = t[d]; if (o) var b = l ? o(y, v, d, t, e, u) : o(v, y, d, e, t, u); if (!(void 0 === b ? v === y || s(v, y, r, o, u) : b)) { m = !1; break }g || (g = d == 'constructor') } if (m && !g) { const x = e.constructor; const D = t.constructor; x != D && 'constructor' in e && 'constructor' in t && !(typeof x === 'function' && x instanceof x && typeof D === 'function' && D instanceof D) && (m = !1) } return u.delete(e), u.delete(t), m } }, function (e, t, r) { const n = r(143); const i = r(145); const a = r(93); e.exports = function getAllKeys(e) { return n(e, a, i) } }, function (e, t) { e.exports = function arrayFilter(e, t) { for (var r = -1, n = e == null ? 0 : e.length, i = 0, a = []; ++r < n;) { const o = e[r]; t(o, r, e) && (a[i++] = o) } return a } }, function (e, t, r) { const n = r(79); const i = r(413); const a = Object.prototype.hasOwnProperty; e.exports = function baseKeys(e) { if (!n(e)) return i(e); const t = []; for (const r in Object(e))a.call(e, r) && r != 'constructor' && t.push(r); return t } }, function (e, t, r) { const n = r(132)(Object.keys, Object); e.exports = n }, function (e, t, r) { const n = r(415); const i = r(73); const a = r(416); const o = r(417); const s = r(418); const u = r(27); const l = r(127); const c = l(n); const p = l(i); const f = l(a); const d = l(o); const h = l(s); let m = u; (n && m(new n(new ArrayBuffer(1))) != '[object DataView]' || i && m(new i()) != '[object Map]' || a && m(a.resolve()) != '[object Promise]' || o && m(new o()) != '[object Set]' || s && m(new s()) != '[object WeakMap]') && (m = function (e) { const t = u(e); const r = t == '[object Object]' ? e.constructor : void 0; const n = r ? l(r) : ''; if (n) switch (n) { case c: return '[object DataView]'; case p: return '[object Map]'; case f: return '[object Promise]'; case d: return '[object Set]'; case h: return '[object WeakMap]'; } return t }), e.exports = m }, function (e, t, r) { const n = r(26)(r(10), 'DataView'); e.exports = n }, function (e, t, r) { const n = r(26)(r(10), 'Promise'); e.exports = n }, function (e, t, r) { const n = r(26)(r(10), 'Set'); e.exports = n }, function (e, t, r) { const n = r(26)(r(10), 'WeakMap'); e.exports = n }, function (e, t, r) { const n = r(147); const i = r(93); e.exports = function getMatchData(e) { for (var t = i(e), r = t.length; r--;) { const a = t[r]; const o = e[a]; t[r] = [a, o, n(o)] } return t } }, function (e, t, r) { const n = r(141); const i = r(421); const a = r(426); const o = r(95); const s = r(147); const u = r(148); const l = r(38); const c = 1; const p = 2; e.exports = function baseMatchesProperty(e, t) { return o(e) && s(t) ? u(l(e), t) : function (r) { const o = i(r, e); return void 0 === o && o === t ? a(r, e) : n(t, o, c | p) } } }, function (e, t, r) { const n = r(94); e.exports = function get(e, t, r) { const i = e == null ? void 0 : n(e, t); return void 0 === i ? r : i } }, function (e, t, r) { const n = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; const i = /\\(\\)?/g; const a = r(423)((e) => { const t = []; return e.charCodeAt(0) === 46 && t.push(''), e.replace(n, (e, r, n, a) => { t.push(n ? a.replace(i, '$1') : r || e) }), t }); e.exports = a }, function (e, t, r) { const n = r(136); const i = 500; e.exports = function memoizeCapped(e) { const t = n(e, e => r.size === i && r.clear(), e); var r = t.cache; return t } }, function (e, t, r) { const n = r(425); e.exports = function toString(e) { return e == null ? '' : n(e) } }, function (e, t, r) { const n = r(51); const i = r(92); const a = r(17); const o = r(55); const s = 1 / 0; const u = n ? n.prototype : void 0; const l = u ? u.toString : void 0; e.exports = function baseToString(e) { if (typeof e === 'string') return e; if (a(e)) return `${i(e, baseToString)}`; if (o(e)) return l ? l.call(e) : ''; const t = `${e}`; return t == '0' && 1 / e == -s ? '-0' : t } }, function (e, t, r) { const n = r(427); const i = r(428); e.exports = function hasIn(e, t) { return e != null && i(e, t, n) } }, function (e, t) { e.exports = function baseHasIn(e, t) { return e != null && t in Object(e) } }, function (e, t, r) { const n = r(58); const i = r(80); const a = r(17); const o = r(54); const s = r(81); const u = r(38); e.exports = function hasPath(e, t, r) { for (var l = -1, c = (t = n(t, e)).length, p = !1; ++l < c;) { var f = u(t[l]); if (!(p = e != null && r(e, f))) break; e = e[f] } return p || ++l != c ? p : !!(c = e == null ? 0 : e.length) && s(c) && o(f, c) && (a(e) || i(e)) } }, function (e, t, r) { const n = r(430); const i = r(431); const a = r(95); const o = r(38); e.exports = function property(e) { return a(e) ? n(o(e)) : i(e) } }, function (e, t) { e.exports = function baseProperty(e) { return function (t) { return t == null ? void 0 : t[e] } } }, function (e, t, r) { const n = r(94); e.exports = function basePropertyDeep(e) { return function (t) { return n(t, e) } } }, function (e, t, r) { const n = r(433); const i = r(31); e.exports = function baseMap(e, t) { let r = -1; const a = i(e) ? Array(e.length) : []; return n(e, (e, n, i) => { a[++r] = t(e, n, i) }), a } }, function (e, t, r) { const n = r(434); const i = r(435)(n); e.exports = i }, function (e, t, r) { const n = r(130); const i = r(93); e.exports = function baseForOwn(e, t) { return e && n(e, t, i) } }, function (e, t, r) { const n = r(31); e.exports = function createBaseEach(e, t) { return function (r, i) { if (r == null) return r; if (!n(r)) return e(r, i); for (let a = r.length, o = t ? a : -1, s = Object(r); (t ? o-- : ++o < a) && !1 !== i(s[o], o, s););return r } } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.TableRenderer = TableRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = t.styles = function styles(e) {
    const t = e.space; const r = e.color; const n = e.fontFamily; const i = e.fontSize; return {
      table: { width: '100%', borderCollapse: 'collapse', marginBottom: t[4] },
      tableHead: { borderBottom: [[1, r.border, 'solid']] },
      cellHeading: {
        color: r.base, paddingRight: t[2], paddingBottom: t[1], textAlign: 'left', fontFamily: n.base, fontWeight: 'bold', fontSize: i.small, whiteSpace: 'nowrap',
      },
      cell: {
        color: r.base, paddingRight: t[2], paddingTop: t[1], paddingBottom: t[1], verticalAlign: 'top', fontFamily: n.base, fontSize: i.small, '&:last-child': { isolate: !1, width: '80%', paddingRight: 0 }, '& p:last-child': { isolate: !1, marginBottom: 0 },
      },
    };
  }; function TableRenderer(e) { const t = e.classes; const r = e.columns; const i = e.rows; const a = e.getRowKey; return n.default.createElement('table', { className: t.table }, n.default.createElement('thead', { className: t.tableHead }, n.default.createElement('tr', null, r.map((e) => { const r = e.caption; return n.default.createElement('th', { key: r, className: t.cellHeading }, r) }))), n.default.createElement('tbody', null, i.map(e => n.default.createElement('tr', { key: a(e) }, r.map((r, i) => { const a = r.render; return n.default.createElement('td', { key: i, className: t.cell }, a(e)) }))))) }TableRenderer.propTypes = {
    classes: i.default.object.isRequired, columns: i.default.arrayOf(i.default.shape({ caption: i.default.string.isRequired, render: i.default.func.isRequired })).isRequired, rows: i.default.arrayOf(i.default.object).isRequired, getRowKey: i.default.func.isRequired,
  }, t.default = (0, a.default)(o)(TableRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.unquote = function unquote(e) { return e.replace(/^['"]|['"]$/g, '') }, t.getType = function getType(e) { return e.flowType || e.type }, t.showSpaces = function showSpaces(e) { return e.replace(/^\s|\s$/g, '') };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(439); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.columns = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = MethodsRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(16)); const s = _interopRequireDefault(r(88)); const u = _interopRequireDefault(r(87)); const l = _interopRequireDefault(r(37)); const c = _interopRequireDefault(r(57)); const p = _interopRequireDefault(r(59)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const f = function getRowKey(e) { return e.name }; const d = t.columns = [{ caption: 'Method name', render: function render(e) { const t = e.name; const r = e.tags; const n = void 0 === r ? {} : r; return i.default.createElement(l.default, { deprecated: !!n.deprecated }, `${t}()`) } }, { caption: 'Parameters', render: function render(e) { const t = e.params; const r = void 0 === t ? [] : t; return i.default.createElement(u.default, { args: r }) } }, { caption: 'Description', render: function render(e) { const t = e.description; const r = e.returns; const a = e.tags; const u = void 0 === a ? {} : a; return i.default.createElement('div', null, t && i.default.createElement(o.default, { text: t }), r && i.default.createElement(s.default, n({ block: !0, returns: !0 }, r)), i.default.createElement(c.default, u)) } }]; function MethodsRenderer(e) { const t = e.methods; return i.default.createElement(p.default, { columns: d, rows: t, getRowKey: f }) }MethodsRenderer.propTypes = {
    methods: a.default.arrayOf(a.default.shape({
      name: a.default.string.isRequired, description: a.default.string, returns: a.default.object, params: a.default.array, tags: a.default.object,
    })).isRequired,
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(441); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.columns = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.getRowKey = getRowKey, t.propsToArray = propsToArray, t.default = EventsRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(86)); const s = _interopRequireDefault(r(87)); const u = _interopRequireDefault(r(36)); const l = _interopRequireDefault(r(57)); const c = _interopRequireDefault(r(16)); const p = _interopRequireDefault(r(37)); const f = _interopRequireDefault(r(90)); const d = _interopRequireDefault(r(56)); const h = _interopRequireDefault(r(59)); const m = _interopRequireDefault(r(91)); const g = r(60); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) } function renderType(e) { if (!e) return 'unknown'; let t = e.name; const r = e.names; switch (r && (t = r.join('|')), t) { case 'arrayOf': return `${e.value.name}[]`; case 'objectOf': return `{${renderType(e.value)}}`; case 'instanceOf': return e.value; default: return t; } } function renderShape(e) { const t = []; for (const r in e) { const n = e[r]; const a = n.description; t.push(i.default.createElement('div', { key: r }, i.default.createElement(p.default, null, r), ': ', i.default.createElement(f.default, null, renderType(n)), a && '  ', a && i.default.createElement(c.default, { text: a, inline: !0 }))) } return t } function getRowKey(e) { return e.name } function propsToArray(e) { return (0, m.default)(e, (e, t) => n({}, e, { name: t })) } const v = t.columns = [{ caption: 'Event name', render: function renderName(e) { const t = e.name; const r = e.tags; const n = void 0 === r ? {} : r; return i.default.createElement(p.default, { deprecated: !!n.deprecated }, t) } }, { caption: 'Type', render: function renderTypeColumn(e) { return i.default.createElement(f.default, null, renderType((0, g.getType)(e))) } }, { caption: 'Description', render: function renderDescription(e) { const t = e.description; const r = e.tags; const n = void 0 === r ? {} : r; const a = (function renderExtra(e) { const t = (0, g.getType)(e); if (!t) return null; switch (t.name) { case 'enum': return (function renderEnum(e) { if (!Array.isArray((0, g.getType)(e).value)) return i.default.createElement('span', null, (0, g.getType)(e).value); const t = (0, g.getType)(e).value.map((e) => { const t = e.value; return i.default.createElement(u.default, { key: t }, (0, g.showSpaces)((0, g.unquote)(t))) }); return i.default.createElement('span', null, 'One of:', ' ', i.default.createElement(o.default, { separator: ', ', inline: !0 }, t)) }(e)); case 'union': return (function renderUnion(e) { if (!Array.isArray((0, g.getType)(e).value)) return i.default.createElement('span', null, (0, g.getType)(e).value); const t = (0, g.getType)(e).value.map((e, t) => i.default.createElement(f.default, { key: `${e.name}-${t}` }, renderType(e))); return i.default.createElement('span', null, 'One of type:', ' ', i.default.createElement(o.default, { separator: ', ', inline: !0 }, t)) }(e)); case 'shape': return renderShape(e.type.value); case 'arrayOf': case 'objectOf': return t.value.name === 'shape' ? renderShape(e.type.value.value) : null; default: return null; } }(e)); const p = [].concat(_toConsumableArray(n.arg || []), _toConsumableArray(n.argument || []), _toConsumableArray(n.param || [])); return i.default.createElement('div', null, t && i.default.createElement(c.default, { text: t }), a && i.default.createElement(d.default, null, a), i.default.createElement(l.default, n), p.length > 0 && i.default.createElement(s.default, { args: p, heading: !0 })) } }]; function EventsRenderer(e) { const t = e.props; return i.default.createElement(h.default, { columns: v, rows: propsToArray(t), getRowKey }) }EventsRenderer.propTypes = { props: a.default.object.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(443); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.columns = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.getRowKey = getRowKey, t.propsToArray = propsToArray, t.default = SlotsTableRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(16)); const s = _interopRequireDefault(r(37)); const u = _interopRequireDefault(r(59)); const l = _interopRequireDefault(r(91)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function getRowKey(e) { return e.name } function propsToArray(e) { return (0, l.default)(e, (e, t) => n({}, e, { name: t })) } const c = t.columns = [{ caption: 'Slot', render: function renderName(e) { const t = e.name; const r = e.tags; const n = void 0 === r ? {} : r; return i.default.createElement(s.default, { deprecated: !!n.deprecated }, t) } }, { caption: 'Description', render: function renderDescription(e) { const t = e.description; return i.default.createElement('div', null, t && i.default.createElement(o.default, { text: t })) } }]; function SlotsTableRenderer(e) { const t = e.props; return i.default.createElement(u.default, { columns: c, rows: propsToArray(t), getRowKey }) }SlotsTableRenderer.propTypes = { props: a.default.object.isRequired };
}, function (e, t, r) { const n = r(92); const i = r(140); const a = r(445); const o = r(447); e.exports = function pickBy(e, t) { if (e == null) return {}; const r = n(o(e), e => [e]); return t = i(t), a(e, r, (e, r) => t(e, r[0])) } }, function (e, t, r) { const n = r(94); const i = r(446); const a = r(58); e.exports = function basePickBy(e, t, r) { for (var o = -1, s = t.length, u = {}; ++o < s;) { const l = t[o]; const c = n(e, l); r(c, l) && i(u, a(l, e), c) } return u } }, function (e, t, r) { const n = r(134); const i = r(58); const a = r(54); const o = r(15); const s = r(38); e.exports = function baseSet(e, t, r, u) { if (!o(e)) return e; for (let l = -1, c = (t = i(t, e)).length, p = c - 1, f = e; f != null && ++l < c;) { const d = s(t[l]); let h = r; if (l != p) { const m = f[d]; void 0 === (h = u ? u(m, d, f) : void 0) && (h = o(m) ? m : a(t[l + 1]) ? [] : {}) }n(f, d, h), f = f[d] } return e } }, function (e, t, r) { const n = r(143); const i = r(448); const a = r(84); e.exports = function getAllKeysIn(e) { return n(e, a, i) } }, function (e, t, r) { const n = r(144); const i = r(78); const a = r(145); const o = r(146); const s = Object.getOwnPropertySymbols ? function (e) { for (var t = []; e;)n(t, a(e)), e = i(e); return t } : o; e.exports = s }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(450)); const o = _interopRequireDefault(r(451)); const s = _interopRequireDefault(r(149)); const u = _interopRequireDefault(r(96)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = function IsolateButton(e) { const t = e.name; const r = e.example; return e.isolated ? n.default.createElement(s.default, { href: (0, u.default)({ anchor: !0, slug: '/' }), title: 'Show all components' }, n.default.createElement(o.default, null)) : n.default.createElement(s.default, { href: (0, u.default)({ name: t, example: r, isolated: !0 }), title: 'Open isolated' }, n.default.createElement(a.default, null)) }; l.propTypes = { name: i.default.string.isRequired, example: i.default.number, isolated: i.default.bool }, t.default = l;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(97)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = function MdFullscreen(e) { return i.default.createElement(a.default, n({ viewBox: '0 0 40 40' }, e), i.default.createElement('g', null, i.default.createElement('path', { d: 'm23.4 8.4h8.2v8.2h-3.2v-5h-5v-3.2z m5 20v-5h3.2v8.2h-8.2v-3.2h5z m-20-11.8v-8.2h8.2v3.2h-5v5h-3.2z m3.2 6.8v5h5v3.2h-8.2v-8.2h3.2z' }))) }, e.exports = t.default;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(97)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = function MdFullscreenExit(e) { return i.default.createElement(a.default, n({ viewBox: '0 0 40 40' }, e), i.default.createElement('g', null, i.default.createElement('path', { d: 'm26.6 13.4h5v3.2h-8.2v-8.2h3.2v5z m-3.2 18.2v-8.2h8.2v3.2h-5v5h-3.2z m-10-18.2v-5h3.2v8.2h-8.2v-3.2h5z m-5 13.2v-3.2h8.2v8.2h-3.2v-5h-5z' }))) }, e.exports = t.default;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.ToolbarButtonRenderer = ToolbarButtonRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); const o = _interopRequireDefault(r(11)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = t.styles = function styles(e) {
    const t = e.space; const r = e.color; return {
      button: {
        padding: 2,
        color: r.light,
        background: 'transparent',
        transition: 'color 750ms ease-out',
        cursor: 'pointer',
        '&:hover, &:focus': { isolate: !1, color: r.linkHover, transition: 'color 150ms ease-in' },
        '&:focus': { isolate: !1, outline: [[1, 'dotted', r.linkHover]] },
        '& + &': { isolate: !1, marginLeft: t[1] },
        '& svg': {
          width: t[3], height: t[3], color: 'currentColor', cursor: 'inherit',
        },
      },
      isSmall: { '& svg': { width: 14, height: 14 } },
    };
  }; function ToolbarButtonRenderer(e) {
    const t = e.classes; const r = e.className; const i = e.onClick; const a = e.href; const s = e.title; const u = e.small; const l = e.children; const c = (0, o.default)(t.button, r, (function _defineProperty(e, t, r) {
      return t in e ? Object.defineProperty(e, t, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = r, e;
    }({}, t.isSmall, u))); return void 0 !== a ? n.default.createElement('a', {
      href: a, title: s, className: c, 'aria-label': s,
    }, l) : n.default.createElement('button', {
      type: 'button', onClick: i, title: s, className: c, 'aria-label': s,
    }, l);
  }ToolbarButtonRenderer.propTypes = {
    classes: i.default.object.isRequired, className: i.default.string, href: i.default.string, onClick: i.default.func, title: i.default.string, small: i.default.bool, children: i.default.node,
  }, t.default = (0, a.default)(s)(ToolbarButtonRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(150)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = function CodeTabButton(e) { return n.default.createElement(a.default, e, 'View Code') }; o.propTypes = { onClick: i.default.func.isRequired, name: i.default.string.isRequired, active: i.default.bool }, t.default = o;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.TabButtonRenderer = TabButtonRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); const o = _interopRequireDefault(r(11)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = t.styles = function styles(e) {
    const t = e.space; const r = e.color; const n = e.fontFamily; const i = e.fontSize; const a = e.buttonTextTransform; return {
      button: {
        padding: [[t[1], 0]],
        fontFamily: n.base,
        fontSize: i.base,
        color: r.light,
        background: 'transparent',
        textTransform: a,
        transition: 'color 750ms ease-out',
        border: 'none',
        cursor: 'pointer',
        '&:hover, &:focus': {
          isolate: !1, outline: 0, color: r.linkHover, transition: 'color 150ms ease-in',
        },
        '&:focus:not($isActive)': { isolate: !1, outline: [[1, 'dotted', r.linkHover]] },
        '& + &': { isolate: !1, marginLeft: t[1] },
      },
      isActive: { borderBottom: [[2, r.linkHover, 'solid']] },
    };
  }; function TabButtonRenderer(e) {
    const t = e.classes; const r = e.name; const i = e.className; const a = e.onClick; const s = e.active; const u = e.children; const l = (0, o.default)(t.button, i, (function _defineProperty(e, t, r) {
      return t in e ? Object.defineProperty(e, t, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = r, e;
    }({}, t.isActive, s))); return n.default.createElement('button', {
      type: 'button', name: r, className: l, onClick: a,
    }, u);
  }TabButtonRenderer.propTypes = {
    classes: i.default.object.isRequired, name: i.default.string, className: i.default.string, onClick: i.default.func, active: i.default.bool, children: i.default.node,
  }, t.default = (0, a.default)(s)(TabButtonRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(150)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = function UsageTabButton(e) { const t = e.props; return t.props || t.methods && t.methods.length > 0 || t.slots && Object.keys(t.slots).length > 0 || t.events && Object.keys(t.events).length > 0 ? n.default.createElement(a.default, e, 'Props, methods, events & slots') : null }; o.propTypes = {
    onClick: i.default.func.isRequired, name: i.default.string.isRequired, props: i.default.shape({ props: i.default.array, methods: i.default.array }).isRequired, active: i.default.bool,
  }, t.default = o;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(457); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = r(0); const a = _interopRequireDefault(i); const o = _interopRequireDefault(r(1)); const s = _interopRequireDefault(r(458)); const u = _interopRequireDefault(r(466)); const l = _interopRequireDefault(r(152)); const c = _interopRequireDefault(r(526)); const p = _interopRequireDefault(r(528)); const f = r(157); const d = r(32); const h = _interopRequireDefault(r(530)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t } const m = (function (e) {
    function StyleGuide() { let e; let t; let r; !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, StyleGuide)); for (var n = arguments.length, i = Array(n), a = 0; a < n; a++)i[a] = arguments[a]; return t = r = _possibleConstructorReturn(this, (e = StyleGuide.__proto__ || Object.getPrototypeOf(StyleGuide)).call.apply(e, [this].concat(i))), r.state = { error: !1, info: null }, _possibleConstructorReturn(r, t) } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(StyleGuide, i.Component)), n(StyleGuide, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          codeRevision: this.props.codeRevision, config: this.props.config, slots: this.props.slots, displayMode: this.props.displayMode,
        };
      },
    }, { key: 'componentDidMount', value: function componentDidMount() { this.scrollToId() } }, { key: 'componentDidUpdate', value: function componentDidUpdate() { this.scrollToId() } }, { key: 'componentDidCatch', value: function componentDidCatch(e, t) { this.setState({ error: e, info: t }) } }, { key: 'scrollToId', value: function scrollToId() { this.props.config.navigation && (0, h.default)() } }, {
      key: 'render',
      value: function render() {
        const e = this.props; const t = e.config; const r = e.sections; const n = e.welcomeScreen; const i = e.patterns; const o = e.displayMode; const h = e.allSections; return this.state.error ? a.default.createElement(p.default, { error: this.state.error, info: this.state.info }) : n ? a.default.createElement(c.default, { patterns: i }) : a.default.createElement(u.default, {
          title: t.title, homepageUrl: f.HOMEPAGE, toc: a.default.createElement(s.default, { sections: h, useIsolatedLinks: t.navigation }), hasSidebar: t.navigation || t.showSidebar && o === d.DisplayModes.all,
        }, a.default.createElement(l.default, { sections: r, depth: 1 }));
      },
    }]), StyleGuide;
  }()); m.propTypes = {
    codeRevision: o.default.number.isRequired, config: o.default.object.isRequired, slots: o.default.object.isRequired, sections: o.default.array.isRequired, welcomeScreen: o.default.bool, patterns: o.default.array, displayMode: o.default.string, allSections: o.default.array.isRequired,
  }, m.childContextTypes = {
    codeRevision: o.default.number.isRequired, config: o.default.object.isRequired, slots: o.default.object.isRequired, displayMode: o.default.string,
  }, m.defaultProps = { displayMode: d.DisplayModes.all }, t.default = m;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(459); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = r(0); const a = _interopRequireDefault(i); const o = _interopRequireDefault(r(1)); const s = _interopRequireDefault(r(460)); const u = _interopRequireDefault(r(463)); const l = _interopRequireDefault(r(464)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) } function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t } const c = (function (e) {
    function TableOfContents() { let e; let t; let r; !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, TableOfContents)); for (var n = arguments.length, i = Array(n), a = 0; a < n; a++)i[a] = arguments[a]; return t = r = _possibleConstructorReturn(this, (e = TableOfContents.__proto__ || Object.getPrototypeOf(TableOfContents)).call.apply(e, [this].concat(i))), r.state = { searchTerm: '' }, _possibleConstructorReturn(r, t) } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(TableOfContents, i.Component)), n(TableOfContents, [{ key: 'renderLevel', value: function renderLevel(e) { const t = this; const r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = e.map((e) => { const n = [].concat(_toConsumableArray(e.sections || []), _toConsumableArray(e.components || [])); return Object.assign({}, e, { heading: !!e.name && n.length > 0, content: n.length > 0 && t.renderLevel(n, r) }) }); return a.default.createElement(s.default, { items: n, useIsolatedLinks: r }) } }, { key: 'renderSections', value: function renderSections() { const e = this.state.searchTerm; const t = this.props; const r = t.sections; const n = t.useIsolatedLinks; const i = r.length === 1 ? r[0].components : r; const a = (0, l.default)(i, e); return this.renderLevel(a, n) } }, { key: 'render', value: function render() { const e = this; const t = this.state.searchTerm; return a.default.createElement(u.default, { searchTerm: t, onSearchTermChange: function onSearchTermChange(t) { return e.setState({ searchTerm: t }) } }, this.renderSections()) } }]), TableOfContents;
  }()); c.propTypes = { sections: o.default.array.isRequired, useIsolatedLinks: o.default.bool }, t.default = c;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(461); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(462)); const o = _interopRequireDefault(r(1)); const s = r(60); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ComponentsList(e, t) {
    const r = e.classes; const o = e.items; const u = e.useIsolatedLinks; const l = void 0 !== u && u; const c = t.config.navigation; const p = o.map(e => n({}, e, {
      href: (0, s.getUrlNavigation)(c, {
        name: e.name, slug: e.slug, nameParent: e.nameParent, level: e.level, sections: e.sections, components: e.components, anchor: !l, isolated: l,
      }),
    })); return i.default.createElement(a.default, { classes: r, items: p });
  }ComponentsList.propTypes = { items: o.default.array.isRequired, classes: o.default.object, useIsolatedLinks: o.default.bool }, ComponentsList.contextTypes = { config: o.default.object }, t.default = ComponentsList;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.ComponentsListRenderer = ComponentsListRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(11)); const o = _interopRequireDefault(r(138)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ComponentsListRenderer(e) { const t = e.classes; let r = e.items; return (r = r.filter(e => e.name)).length ? n.default.createElement('ul', { className: t.list }, r.map((e) => { const r = e.heading; const i = e.name; const s = e.href; const u = e.content; return n.default.createElement('li', { className: (0, a.default)(t.item, (!u || !u.props.items.length) && t.isChild), key: i }, n.default.createElement(o.default, { className: (0, a.default)(r && t.heading), href: s }, i), u) })) : null }ComponentsListRenderer.propTypes = { items: i.default.array.isRequired, classes: i.default.object.isRequired, useIsolatedLinks: i.default.bool }, t.default = (0, s.default)((e) => {
    const t = e.color; const r = e.fontFamily; const n = e.fontSize; const i = e.space; const a = e.mq; return {
      list: { margin: 0, paddingLeft: i[2] },
      item: {
        color: t.base, display: 'block', margin: [[i[1], 0, i[1], 0]], fontFamily: r.base, fontSize: n.base, listStyle: 'none', overflow: 'hidden', textOverflow: 'ellipsis',
      },
      isChild: (function _defineProperty(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r, enumerable: !0, configurable: !0, writable: !0,
        }) : e[t] = r, e;
      }({}, a.small, { display: 'inline-block', margin: [[0, i[1], 0, 0]] })),
      heading: {
        color: t.base, marginTop: i[1], fontFamily: r.base, fontWeight: 'bold',
      },
    };
  })(ComponentsListRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.TableOfContentsRenderer = TableOfContentsRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function TableOfContentsRenderer(e) {
    const t = e.classes; const r = e.children; const i = e.searchTerm; const a = e.onSearchTermChange; return n.default.createElement('div', null, n.default.createElement('div', { className: t.root }, n.default.createElement('div', { className: t.search }, n.default.createElement('input', {
      value: i, className: t.input, placeholder: 'Filter by name', 'aria-label': 'Filter by name', onChange: function onChange(e) { return a(e.target.value) },
    })), n.default.createElement('nav', null, r)));
  }TableOfContentsRenderer.propTypes = {
    classes: i.default.object.isRequired, children: i.default.node, searchTerm: i.default.string.isRequired, onSearchTermChange: i.default.func.isRequired,
  }, t.default = (0, a.default)((e) => {
    const t = e.space; const r = e.color; const n = e.fontFamily; const i = e.fontSize; const a = e.borderRadius; return {
      root: { fontFamily: n.base },
      search: { padding: t[2] },
      input: {
        display: 'block',
        width: '100%',
        padding: t[1],
        color: r.base,
        backgroundColor: r.baseBackground,
        fontFamily: n.base,
        fontSize: i.base,
        border: [[1, r.border, 'solid']],
        borderRadius: a,
        transition: 'border-color ease-in-out .15s',
        '&:focus': { isolate: !1, borderColor: r.link, outline: 0 },
        '&::placeholder': {
          isolate: !1, fontFamily: n.base, fontSize: i.base, color: r.light,
        },
      },
    };
  })(TableOfContentsRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function filterSectionsByName(e, t) { const r = (0, i.default)(t); return e.map(e => n({}, e, { sections: e.sections ? filterSectionsByName(e.sections, t) : [], components: e.components ? (0, a.default)(e.components, t) : [] })).filter(e => e.components.length > 0 || e.sections.length > 0 || r.test(e.name)) }; var i = _interopRequireDefault(r(151)); var a = _interopRequireDefault(r(465)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function filterComponentsByName(e, t) { const r = (0, n.default)(t); return e.filter((e) => { const t = e.name; return r.test(t) }) }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(151)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.StyleGuideRenderer = StyleGuideRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(467)); const o = _interopRequireDefault(r(16)); const s = _interopRequireDefault(r(2)); const u = _interopRequireDefault(r(11)); const l = _interopRequireDefault(r(469)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _defineProperty(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
      value: r, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = r, e;
  } function StyleGuideRenderer(e) { const t = e.classes; const r = e.title; const i = e.homepageUrl; const s = e.children; const c = e.toc; const p = e.hasSidebar; return n.default.createElement('div', { className: (0, u.default)(t.root, p && t.hasSidebar) }, n.default.createElement('main', { className: t.content }, s, n.default.createElement('footer', { className: t.footer }, n.default.createElement(o.default, { text: `Generated with [Vue Styleguidist](${i})` }))), p && n.default.createElement('div', { className: t.sidebar }, n.default.createElement('div', { className: t.logo }, n.default.createElement(a.default, null, r)), c), n.default.createElement(l.default, null)) }StyleGuideRenderer.propTypes = {
    classes: i.default.object.isRequired, title: i.default.string.isRequired, homepageUrl: i.default.string.isRequired, children: i.default.node.isRequired, toc: i.default.node.isRequired, hasSidebar: i.default.bool,
  }, t.default = (0, s.default)((e) => {
    let t; const r = e.color; const n = e.fontFamily; const i = e.fontSize; const a = e.sidebarWidth; const o = e.mq; const s = e.space; const u = e.maxWidth; return {
      root: { backgroundColor: r.baseBackground },
      hasSidebar: _defineProperty({ paddingLeft: a }, o.small, { paddingLeft: 0 }),
      content: (t = { maxWidth: u, padding: [[s[2], s[4]]], margin: [[0, 'auto']] }, _defineProperty(t, o.small, { padding: s[2] }), _defineProperty(t, 'display', 'block'), t),
      sidebar: _defineProperty({
        backgroundColor: r.sidebarBackground, border: [[r.border, 'solid']], borderWidth: [[0, 1, 0, 0]], position: 'fixed', top: 0, left: 0, bottom: 0, width: a, overflow: 'auto', '-webkit-overflow-scrolling': 'touch',
      }, o.small, {
        position: 'static', width: 'auto', borderWidth: [[1, 0, 0, 0]], paddingBottom: s[0],
      }),
      logo: { padding: s[2], borderBottom: [[1, r.border, 'solid']] },
      footer: {
        display: 'block', color: r.light, fontFamily: n.base, fontSize: i.small,
      },
    };
  })(StyleGuideRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(468); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.LogoRenderer = LogoRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function LogoRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('h1', { className: t.logo }, r) }LogoRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node }, t.default = (0, a.default)((e) => {
    const t = e.color; const r = e.fontFamily; const n = e.fontSize; return {
      logo: {
        color: t.base, margin: 0, fontFamily: r.base, fontSize: n.h4, fontWeight: 'normal',
      },
    };
  })(LogoRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(470); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Ribbon; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(471)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Ribbon(e, t) { const r = t.config.ribbon; return r ? n.default.createElement(a.default, r) : null }Ribbon.contextTypes = { config: i.default.object };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.RibbonRenderer = RibbonRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = t.styles = function styles(e) {
    const t = e.color; const r = e.space; const n = e.fontSize; return {
      root: {
        position: 'fixed', top: 0, right: 0, width: 149, height: 149, zIndex: 999,
      },
      link: {
        fontFamily: e.fontFamily.base, position: 'relative', right: -37, top: -22, display: 'block', width: 190, padding: [[r[0], r[2]]], textAlign: 'center', color: t.ribbonText, fontSize: n.base, background: t.ribbonBackground, textDecoration: 'none', textShadow: [[0, '-1px', 0, 'rgba(0,0,0,.15)']], transformOrigin: [[0, 0]], transform: 'rotate(45deg)', cursor: 'pointer',
      },
    };
  }; function RibbonRenderer(e) { const t = e.classes; const r = e.url; const i = e.text; return n.default.createElement('div', { className: t.root }, n.default.createElement('a', { href: r, className: t.link }, i)) }RibbonRenderer.defaultProps = { text: 'Fork me on GitHub' }, RibbonRenderer.propTypes = { classes: i.default.object.isRequired, url: i.default.string.isRequired, text: i.default.string }, t.default = (0, a.default)(o)(RibbonRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Sections; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(473)); const o = _interopRequireDefault(r(525)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Sections(e) { const t = e.sections; const r = e.depth; return n.default.createElement(o.default, null, t.map((e, t) => n.default.createElement(a.default, { key: t, section: e, depth: r }))) }Sections.propTypes = { sections: i.default.array.isRequired, root: i.default.bool, depth: i.default.number.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(474); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Section; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(153)); const o = _interopRequireDefault(r(512)); const s = _interopRequireDefault(r(152)); const u = _interopRequireDefault(r(524)); const l = r(32); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Section(e, t) {
    const r = e.section; const i = e.depth; const c = t.displayMode; const p = r.name; const f = r.slug; const d = r.filepath; const h = r.content; const m = r.components; const g = r.sections; const v = r.description; const y = r.level; const b = r.nameParent; const x = h && n.default.createElement(a.default, { examples: h, name: p }); const D = m && n.default.createElement(o.default, { components: m, depth: i + 1 }); const _ = g && n.default.createElement(s.default, { sections: g, depth: i + 1 }); const C = { components: m, sections: g }; return n.default.createElement(u.default, {
      description: v, name: p, level: y, nameParent: b, slug: f, filepath: d, content: x, components: D, sections: _, collection: C, isolated: c !== l.DisplayModes.all, depth: i,
    });
  }Section.propTypes = { section: i.default.object.isRequired, depth: i.default.number.isRequired }, Section.contextTypes = { displayMode: i.default.string };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Examples; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(476)); const o = _interopRequireDefault(r(16)); const s = _interopRequireDefault(r(511)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Examples(e, t) {
    const r = e.examples; const i = e.name; const u = t.codeRevision; return n.default.createElement(s.default, null, r.map((e, t) => {
      switch (e.type) {
        case 'code': return n.default.createElement(a.default, {
          code: e.content, evalInContext: e.evalInContext, vuex: e.vuex, key: `${u}/${t}`, name: i, index: t, settings: e.settings,
        }); case 'markdown': return n.default.createElement(o.default, { text: e.content, key: t }); default: return null;
      }
    }));
  }Examples.propTypes = { examples: i.default.array.isRequired, name: i.default.string.isRequired }, Examples.contextTypes = { codeRevision: i.default.number.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(477); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = r(0); const a = _interopRequireDefault(i); const o = _interopRequireDefault(r(1)); const s = _interopRequireDefault(r(231)); const u = _interopRequireDefault(r(478)); const l = _interopRequireDefault(r(56)); const c = _interopRequireDefault(r(99)); const p = _interopRequireDefault(r(510)); const f = r(71); const d = r(32); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const h = (function (e) {
    function Playground(e, t) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, Playground)); const r = (function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t }(this, (Playground.__proto__ || Object.getPrototypeOf(Playground)).call(this, e, t))); const n = e.code; const i = e.settings; const a = t.config; const o = void 0 !== i.showcode ? i.showcode : a.showCode; return r.showCode = o, r.handleTabChange = r.handleTabChange.bind(r), r.handleChange = (0, s.default)(r.handleChange.bind(r), a.previewDelay), r.state = { code: n, activeTab: void 0 }, r } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(Playground, i.Component)), n(Playground, [{ key: 'componentDidMount', value: function componentDidMount() { const e = this; this.showCode && setTimeout(() => { e.setState({ activeTab: f.EXAMPLE_TAB_CODE_EDITOR }) }, 0) } }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(e) { const t = e.code; this.setState({ code: t }) } }, { key: 'shouldComponentUpdate', value: function shouldComponentUpdate(e, t) { return t.code !== this.state.code || t.activeTab !== this.state.activeTab } }, { key: 'componentWillUnmount', value: function componentWillUnmount() { this.handleChange.cancel() } }, { key: 'handleChange', value: function handleChange(e) { this.setState({ code: e }) } }, { key: 'handleTabChange', value: function handleTabChange(e) { this.setState(t => ({ activeTab: t.activeTab !== e ? e : void 0 })) } }, {
      key: 'render',
      value: function render() {
        const e = this.state; const t = e.code; const r = e.activeTab; const n = this.props; const i = n.evalInContext; const o = n.index; const s = n.name; const f = n.vuex; const h = n.settings; const m = this.context.displayMode; const g = a.default.createElement(u.default, { code: t, vuex: f, evalInContext: i }); return h.noeditor ? a.default.createElement(l.default, null, g) : (h.classname && (h.props = { className: h.classname }), a.default.createElement(p.default, {
          name: s,
          preview: g,
          previewProps: h.props || {},
          tabButtons: a.default.createElement(c.default, { name: 'exampleTabButtons', active: r, props: { onClick: this.handleTabChange } }),
          tabBody: a.default.createElement(c.default, {
            name: 'exampleTabs', active: r, onlyActive: !0, props: { code: t, onChange: this.handleChange },
          }),
          toolbar: a.default.createElement(c.default, { name: 'exampleToolbar', props: { name: s, isolated: m === d.DisplayModes.example, example: o } }),
        }));
      },
    }]), Playground;
  }()); h.propTypes = {
    code: o.default.string.isRequired, evalInContext: o.default.func.isRequired, vuex: o.default.object, index: o.default.number.isRequired, name: o.default.string.isRequired, settings: o.default.object,
  }, h.contextTypes = { config: o.default.object.isRequired, displayMode: o.default.string }, t.default = h;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(479); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const i = r(0); const a = _interopRequireDefault(i); const o = _interopRequireDefault(r(1)); const s = r(480); const u = _interopRequireDefault(r(484)); const l = r(486); const c = _interopRequireDefault(r(23)); const p = r(488); const f = _interopRequireDefault(r(508)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t } const d = (function (e) {
    function Preview() { let e; let t; let r; !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, Preview)); for (var n = arguments.length, i = Array(n), a = 0; a < n; a++)i[a] = arguments[a]; return t = r = _possibleConstructorReturn(this, (e = Preview.__proto__ || Object.getPrototypeOf(Preview)).call.apply(e, [this].concat(i))), r.state = { error: null }, _possibleConstructorReturn(r, t) } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(Preview, i.Component)), n(Preview, [{ key: 'componentDidMount', value: function componentDidMount() { console.clear(), this.executeCode() } }, { key: 'shouldComponentUpdate', value: function shouldComponentUpdate(e, t) { return this.state.error !== t.error || this.props.code !== e.code } }, { key: 'componentDidUpdate', value: function componentDidUpdate(e) { this.props.code !== e.code && this.executeCode() } }, { key: 'executeCode', value: function executeCode() { this.setState({ error: null }); const e = this.props; const t = e.code; const r = e.vuex; let n = {}; let i = void 0; let a = void 0; let o = []; let s = void 0; if (t) { try { n = (function separateScript(e, t) { let r = void 0; const n = e.split('\n'); if (e.indexOf('new Vue') > -1) { const i = e.indexOf('new Vue'); return { js: e.slice(0, i), vueComponent: `${e.slice(i)}\n\n\n\n\n\t\t// Ignore: Extract the configuration of the example component\n\t\tfunction Vue(params){ __component__ = params }`, style: t } } if ((0, p.isSingleFileComponent)(e)) { const a = (0, p.transformSingleFileComponent)(e); return separateScript(a.component, a.style) } for (let o = 0; o < n.length; o++) if (n[o].trim().charAt(0) === '<') { r = o; break } return { js: n.slice(0, r).join('\n'), html: n.slice(r).join('\n') } }(t)), i = this.compileCode(n.js), n.vueComponent && (a = this.compileCode(n.vueComponent)), o = (function getVars(e) { let t = []; return (t = e.body.filter(e => e.type === 'VariableDeclaration' || e.type === 'FunctionDeclaration')).unshift([]), t.reduce((e, t) => e = e.concat(function getId(e) { return e.declarations ? Array.prototype.concat.apply([], e.declarations.map(e => e.id.name)) : [e.id.name] }(t))) }((0, l.parse)(n.js))), s = this.evalInContext(i, o, a) } catch (e) { this.handleError(e), n.html = '' } let u = this.mountNode.children[0]; if (u || (this.mountNode.innerHTML = ' ', this.mountNode.append(document.createElement('div')), u = this.mountNode.children[0]), s) { let d = {}; let h = {}; if (a)h = s(), Object.keys(h).forEach((e) => { e === 'el' && delete h.el }); else { const m = s(); const g = n.html; h = { data: m, template: g } }r && (d = { store: r.default }), h = Object.assign({ el: u }, d, h); const v = `data-v-${Math.floor(1e3 * Math.random())}${1}`; h._scopeId = v; const y = new c.default(h); if (n.style) { const b = document.createElement('div'); b.innerHTML = n.style, b.firstChild.id = v, y.$el.appendChild(b.firstChild) } }(0, f.default)() } } }, { key: 'compileCode', value: function compileCode(e) { try { return (function _compileCode(e, t) { return (0, s.transform)(e, t).code }(e, this.context.config.compilerConfig)) } catch (e) { this.handleError(e) } return !1 } }, { key: 'evalInContext', value: function evalInContext(e, t, r) { let n = ''; return r ? n = `\n\t\t\t\tfunction getConfig() {\n\t\t\t\t\teval(\n\t\t\t\t\t\t${JSON.stringify(e)}\n\t\t\t\t\t\t + ";" +\n\t\t\t\t\t\t${JSON.stringify(r)}\n\t\t\t\t\t);\n\t\t\t\t\treturn __component__;\n\t\t\t\t}\n\t\t\t\treturn getConfig();\n\t\t\t` : (t = t.map(e => `${e} : ${e}`), n = `\n\t\t\t\tfunction getData() {\n\t\t\t\t\teval(${JSON.stringify(e)})\n\t\t\t\t\treturn {\n\t\t\t\t\t\t${t.join(',')}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn getData();\n\t\t\t`), this.props.evalInContext(n) } }, { key: 'handleError', value: function handleError(e) { if (this.mountNode) { let t = this.mountNode.children[0]; t || (this.mountNode.innerHTML = ' ', this.mountNode.append(document.createElement('div')), t = this.mountNode.children[0]), t = new c.default({ el: t, data: {}, template: '<div></div> ' }) } this.setState({ error: e.toString() }), console.error(e) } }, { key: 'render', value: function render() { const e = this; const t = this.state.error; return a.default.createElement('div', null, a.default.createElement('div', { ref: function ref(t) { return e.mountNode = t } }, a.default.createElement('div', null)), t && a.default.createElement(u.default, { message: t })) } }]), Preview;
  }()); d.propTypes = { code: o.default.string.isRequired, evalInContext: o.default.func.isRequired, vuex: o.default.object }, d.contextTypes = { config: o.default.object.isRequired }, t.default = d;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), function (e) {
    r.d(t, 'target', () => target), r.d(t, 'transform', () => transform), r.d(t, 'VERSION', () => fe); const n = r(481); const i = r(483); const a = {
      quot: '"', amp: '&', apos: "'", lt: '<', gt: '>', nbsp: '', iexcl: '', cent: '', pound: '', curren: '', yen: '', brvbar: '', sect: '', uml: '', copy: '', ordf: '', laquo: '', not: '', shy: '', reg: '', macr: '', deg: '', plusmn: '', sup2: '', sup3: '', acute: '', micro: '', para: '', middot: '', cedil: '', sup1: '', ordm: '', raquo: '', frac14: '', frac12: '', frac34: '', iquest: '', Agrave: '', Aacute: '', Acirc: '', Atilde: '', Auml: '', Aring: '', AElig: '', Ccedil: '', Egrave: '', Eacute: '', Ecirc: '', Euml: '', Igrave: '', Iacute: '', Icirc: '', Iuml: '', ETH: '', Ntilde: '', Ograve: '', Oacute: '', Ocirc: '', Otilde: '', Ouml: '', times: '', Oslash: '', Ugrave: '', Uacute: '', Ucirc: '', Uuml: '', Yacute: '', THORN: '', szlig: '', agrave: '', aacute: '', acirc: '', atilde: '', auml: '', aring: '', aelig: '', ccedil: '', egrave: '', eacute: '', ecirc: '', euml: '', igrave: '', iacute: '', icirc: '', iuml: '', eth: '', ntilde: '', ograve: '', oacute: '', ocirc: '', otilde: '', ouml: '', divide: '', oslash: '', ugrave: '', uacute: '', ucirc: '', uuml: '', yacute: '', thorn: '', yuml: '', OElig: '', oelig: '', Scaron: '', scaron: '', Yuml: '', fnof: '', circ: '', tilde: '', Alpha: '', Beta: '', Gamma: '', Delta: '', Epsilon: '', Zeta: '', Eta: '', Theta: '', Iota: '', Kappa: '', Lambda: '', Mu: '', Nu: '', Xi: '', Omicron: '', Pi: '', Rho: '', Sigma: '', Tau: '', Upsilon: '', Phi: '', Chi: '', Psi: '', Omega: '', alpha: '', beta: '', gamma: '', delta: '', epsilon: '', zeta: '', eta: '', theta: '', iota: '', kappa: '', lambda: '', mu: '', nu: '', xi: '', omicron: '', pi: '', rho: '', sigmaf: '', sigma: '', tau: '', upsilon: '', phi: '', chi: '', psi: '', omega: '', thetasym: '', upsih: '', piv: '', ensp: '', emsp: '', thinsp: '', zwnj: '', zwj: '', lrm: '', rlm: '', ndash: '', mdash: '', lsquo: '', rsquo: '', sbquo: '', ldquo: '', rdquo: '', bdquo: '', dagger: '', Dagger: '', bull: '', hellip: '', permil: '', prime: '', Prime: '', lsaquo: '', rsaquo: '', oline: '', frasl: '', euro: '', image: '', weierp: '', real: '', trade: '', alefsym: '', larr: '', uarr: '', rarr: '', darr: '', harr: '', crarr: '', lArr: '', uArr: '', rArr: '', dArr: '', hArr: '', forall: '', part: '', exist: '', empty: '', nabla: '', isin: '', notin: '', ni: '', prod: '', sum: '', minus: '', lowast: '', radic: '', prop: '', infin: '', ang: '', and: '', or: '', cap: '', cup: '', int: '', there4: '', sim: '', cong: '', asymp: '', ne: '', equiv: '', le: '', ge: '', sub: '', sup: '', nsub: '', sube: '', supe: '', oplus: '', otimes: '', perp: '', sdot: '', lceil: '', rceil: '', lfloor: '', rfloor: '', lang: '', rang: '', loz: '', spades: '', clubs: '', hearts: '', diams: '',
    }; const o = /^[\da-fA-F]+$/; const s = /^\d+$/; const u = typeof window !== 'undefined' ? window : void 0 !== e ? e : typeof self !== 'undefined' ? self : {}; function createCommonjsModule(e, t) { return e(t = { exports: {} }, t.exports), t.exports } const l = createCommonjsModule((e, t) => { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function injectDynamicImport(e) { const t = e.tokTypes; return t._import.startsExpr = !0, e.plugins.dynamicImport = function dynamicImportPlugin(e) { e.extend('parseStatement', e => function parseStatement() { const r = this.startNode(); if (this.type === t._import && function peekNext() { return this.input[this.pos] }.call(this) === t.parenL.label) { const n = this.parseExpression(); return this.parseExpressionStatement(r, n) } for (var i = arguments.length, a = Array(i), o = 0; o < i; o++)a[o] = arguments[o]; return e.apply(this, a) }), e.extend('parseExprAtom', e => function parseExprAtom(n) { return this.type === t._import ? function parseDynamicImport() { const e = this.startNode(); return this.next(), this.type !== t.parenL && this.unexpected(), this.finishNode(e, r) }.call(this) : e.call(this, n) }) }, e }; var r = t.DynamicImportKey = 'Import' }); const c = (function unwrapExports(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e }(l)); l.DynamicImportKey; function toJSON(e) { const t = {}; return Object.keys(e).forEach((r) => { r !== 'parent' && r !== 'program' && r !== 'keys' && r !== '__wrapped' && (Array.isArray(e[r]) ? t[r] = e[r].map(toJSON) : e[r] && e[r].toJSON ? t[r] = e[r].toJSON() : t[r] = e[r]) }), t } const p = function Node() {}; function extractNames(e) { const t = []; return f[e.type](t, e), t }p.prototype.ancestor = function ancestor(e) { for (var t = this; e--;) if (!(t = t.parent)) return null; return t }, p.prototype.contains = function contains(e) { for (;e;) { if (e === this) return !0; e = e.parent } return !1 }, p.prototype.findLexicalBoundary = function findLexicalBoundary() { return this.parent.findLexicalBoundary() }, p.prototype.findNearest = function findNearest(e) { return typeof e === 'string' && (e = new RegExp(`^${e}$`)), e.test(this.type) ? this : this.parent.findNearest(e) }, p.prototype.unparenthesizedParent = function unparenthesizedParent() { for (var e = this.parent; e && e.type === 'ParenthesizedExpression';)e = e.parent; return e }, p.prototype.unparenthesize = function unparenthesize() { for (var e = this; e.type === 'ParenthesizedExpression';)e = e.expression; return e }, p.prototype.findScope = function findScope(e) { return this.parent.findScope(e) }, p.prototype.getIndentation = function getIndentation() { return this.parent.getIndentation() }, p.prototype.initialise = function initialise(e) { for (let t = 0, r = this.keys; t < r.length; t += 1) { const n = this[r[t]]; Array.isArray(n) ? n.forEach(t => t && t.initialise(e)) : n && typeof n === 'object' && n.initialise(e) } }, p.prototype.toJSON = function toJSON$1() { return toJSON(this) }, p.prototype.toString = function toString() { return this.program.magicString.original.slice(this.start, this.end) }, p.prototype.transpile = function transpile(e, t) { for (let r = 0, n = this.keys; r < n.length; r += 1) { const i = this[n[r]]; Array.isArray(i) ? i.forEach(r => r && r.transpile(e, t)) : i && typeof i === 'object' && i.transpile(e, t) } }; var f = {
      Identifier: function Identifier(e, t) { e.push(t) }, ObjectPattern: function ObjectPattern(e, t) { for (let r = 0, n = t.properties; r < n.length; r += 1) { const i = n[r]; f[i.type](e, i) } }, Property: function Property(e, t) { f[t.value.type](e, t.value) }, ArrayPattern: function ArrayPattern(e, t) { for (let r = 0, n = t.elements; r < n.length; r += 1) { const i = n[r]; i && f[i.type](e, i) } }, RestElement: function RestElement(e, t) { f[t.argument.type](e, t.argument) }, AssignmentPattern: function AssignmentPattern(e, t) { f[t.left.type](e, t.left) },
    }; const d = Object.create(null); function Scope(e) { e = e || {}, this.parent = e.parent, this.isBlockScope = !!e.block, this.createDeclarationCallback = e.declare; for (var t = this; t.isBlockScope;)t = t.parent; this.functionScope = t, this.identifiers = [], this.declarations = Object.create(null), this.references = Object.create(null), this.blockScopedDeclarations = this.isBlockScope ? null : Object.create(null), this.aliases = Object.create(null) } function locate(e, t) { let r; const n = e.split('\n'); const i = n.length; let a = 0; for (r = 0; r < i; r += 1) { const o = a + n[r].length + 1; if (o > t) return { line: r + 1, column: t - a, char: r }; a = o } throw new Error('Could not determine location of character') } function repeat(e, t) { for (var r = ''; t--;)r += e; return r } function getSnippet(e, t, r) { void 0 === r && (r = 1); const n = Math.max(t.line - 5, 0); const i = t.line; const a = String(i).length; const o = e.split('\n').slice(n, i); const s = o[o.length - 1].slice(0, t.column).replace(/\t/g, '  ').length; let u = o.map((e, t) => `${(function pad(e, t) { const r = String(e); return r + repeat(' ', t - r.length) }(t + n + 1, a))} : ${e.replace(/\t/g, '  ')}`).join('\n'); return u += `\n${repeat(' ', a + 3 + s)}${repeat('^', r)}` }'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split(' ').forEach(e => d[e] = !0), Scope.prototype = {
      addDeclaration: function addDeclaration(e, t) {
        for (let r = 0, n = extractNames(e); r < n.length; r += 1) {
          const i = n[r]; const a = i.name; const o = {
            name: a, node: i, kind: t, instances: [],
          }; this.declarations[a] = o, this.isBlockScope && (this.functionScope.blockScopedDeclarations[a] || (this.functionScope.blockScopedDeclarations[a] = []), this.functionScope.blockScopedDeclarations[a].push(o));
        }
      },
      addReference: function addReference(e) { this.consolidated ? this.consolidateReference(e) : this.identifiers.push(e) },
      consolidate: function consolidate() { for (let e = 0; e < this.identifiers.length; e += 1) { const t = this.identifiers[e]; this.consolidateReference(t) } this.consolidated = !0 },
      consolidateReference: function consolidateReference(e) { const t = this.declarations[e.name]; t ? t.instances.push(e) : (this.references[e.name] = !0, this.parent && this.parent.addReference(e)) },
      contains: function contains(e) { return this.declarations[e] || !!this.parent && this.parent.contains(e) },
      createIdentifier: function createIdentifier(e) { typeof e === 'number' && (e = e.toString()); for (var t = e = e.replace(/\s/g, '').replace(/\[([^\]]+)\]/g, '_$1').replace(/[^a-zA-Z0-9_$]/g, '_').replace(/_{2,}/, '_'), r = 1; this.declarations[t] || this.references[t] || this.aliases[t] || t in d;)t = `${e}$${r++}`; return this.aliases[t] = !0, t },
      createDeclaration: function createDeclaration(e) { const t = this.createIdentifier(e); return this.createDeclarationCallback(t), t },
      findDeclaration: function findDeclaration(e) { return this.declarations[e] || this.parent && this.parent.findDeclaration(e) },
      resolveName: function resolveName(e) { const t = this.findDeclaration(e); return t ? t.name : e },
    }; const h = (function (e) { function CompileError(t, r) { if (e.call(this, t), this.name = 'CompileError', r) { const n = r.program.magicString.original; const i = locate(n, r.start); this.message = `${t} (${i.line}:${i.column})`, this.stack = (new e()).stack.replace(new RegExp(`.+new ${this.name}.+\\n`, 'm'), ''), this.loc = i, this.snippet = getSnippet(n, i, r.end - r.start) } } return e && (CompileError.__proto__ = e), CompileError.prototype = Object.create(e && e.prototype), CompileError.prototype.constructor = CompileError, CompileError.prototype.toString = function toString() { return `${this.name}: ${this.message}\n${this.snippet}` }, CompileError }(Error)); function findIndex(e, t) { for (let r = 0; r < e.length; r += 1) if (t(e[r], r)) return r; return -1 } const m = {
      Identifier: destructureIdentifier, AssignmentPattern: function destructureAssignmentPattern(e, t, r, n, i, a, o) { const s = n.left.type === 'Identifier'; const u = s ? n.left.name : i; a || o.push((t, r, i) => { e.prependRight(n.left.end, `${r}if ( ${u} === void 0 ) ${u}`), e.move(n.left.end, n.right.end, t), e.appendLeft(n.right.end, i) }); s || destructure(e, t, r, n.left, i, a, o) }, ArrayPattern: function destructureArrayPattern(e, t, r, n, i, a, o) { let s = n.start; n.elements.forEach((n, u) => { n && (n.type === 'RestElement' ? handleProperty(e, t, r, s, n.argument, `${i}.slice(${u})`, a, o) : handleProperty(e, t, r, s, n, `${i}[${u}]`, a, o), s = n.end) }), e.remove(s, n.end) }, ObjectPattern: destructureObjectPattern,
    }; function destructure(e, t, r, n, i, a, o) { m[n.type](e, t, r, n, i, a, o) } function destructureIdentifier(e, t, r, n, i, a, o) { o.push((t, o, s) => { e.overwrite(n.start, n.end, `${(a ? o : `${o}var `) + r(n)} = ${i}${s}`), e.move(n.start, n.end, t) }) } function destructureObjectPattern(e, t, r, n, i, a, o) { const s = this; let u = n.start; const l = []; n.properties.forEach((n) => { let c; let p; if (n.type === 'Property') { const f = n.computed || n.key.type !== 'Identifier'; const d = f ? e.slice(n.key.start, n.key.end) : n.key.name; c = f ? `${i}[${d}]` : `${i}.${d}`, p = n.value, l.push(f ? d : `"${d}"`) } else { if (n.type !== 'RestElement') throw new h(s, `Unexpected node of type ${n.type} in object pattern`); p = n.argument, c = t('rest'), o.push((t, r, o) => { const s = n.program.getObjectWithoutPropertiesHelper(e); e.overwrite(n.start, u = n.argument.start, `${(a ? r : `${r}var `) + c} = ${s}( ${i}, [${l.join(', ')}] )${o}`), e.move(n.start, u, t) }) }handleProperty(e, t, r, u, p, c, a, o), u = n.end }), e.remove(u, n.end) } function handleProperty(e, t, r, n, i, a, o, s) { switch (i.type) { case 'Identifier': e.remove(n, i.start), destructureIdentifier(e, 0, r, i, a, o, s); break; case 'MemberExpression': e.remove(n, i.start), (function destructureMemberExpression(e, t, r, n, i, a, o) { o.push((t, r, o) => { e.prependRight(n.start, a ? r : `${r}var `), e.appendLeft(n.end, ` = ${i}${o}`), e.move(n.start, n.end, t) }) }(e, 0, 0, i, a, !0, s)); break; case 'AssignmentPattern': var u; var l = i.left.type === 'Identifier'; u = l ? r(i.left) : t(a), s.push((t, r, n) => { o ? (e.prependRight(i.right.start, `${u} = ${a}, ${u} = ${u} === void 0 ? `), e.appendLeft(i.right.end, ` : ${u}${n}`)) : (e.prependRight(i.right.start, `${r}var ${u} = ${a}; if ( ${u} === void 0 ) ${u} = `), e.appendLeft(i.right.end, n)), e.move(i.right.start, i.right.end, t) }), l ? e.remove(n, i.right.start) : (e.remove(n, i.left.start), e.remove(i.left.end, i.right.start), handleProperty(e, t, r, n, i.left, u, o, s)); break; case 'ObjectPattern': e.remove(n, n = i.start); var c = a; i.properties.length > 1 && (c = t(a), s.push((t, r, s) => { e.prependRight(i.start, `${(o ? '' : `${r}var `) + c} = `), e.overwrite(i.start, n = i.start + 1, a), e.appendLeft(n, s), e.overwrite(i.start, n = i.start + 1, `${(o ? '' : `${r}var `) + c} = ${a}${s}`), e.move(i.start, n, t) })), destructureObjectPattern(e, t, r, i, c, o, s); break; case 'ArrayPattern': if (e.remove(n, n = i.start), i.elements.filter(Boolean).length > 1) { const p = t(a); s.push((t, r, s) => { e.prependRight(i.start, `${(o ? '' : `${r}var `) + p} = `), e.overwrite(i.start, n = i.start + 1, a, { contentOnly: !0 }), e.appendLeft(n, s), e.move(i.start, n, t) }), i.elements.forEach((i, a) => { i && (i.type === 'RestElement' ? handleProperty(e, t, r, n, i.argument, `${p}.slice(${a})`, o, s) : handleProperty(e, t, r, n, i, `${p}[${a}]`, o, s), n = i.end) }) } else { const f = findIndex(i.elements, Boolean); const d = i.elements[f]; d.type === 'RestElement' ? handleProperty(e, t, r, n, d.argument, `${a}.slice(${f})`, o, s) : handleProperty(e, t, r, n, d, `${a}[${f}]`, o, s), n = d.end }e.remove(n, i.end); break; default: throw new Error(`Unexpected node type in destructuring (${i.type})`); } } const g = (function (e) { function BlockStatement() { e.apply(this, arguments) } return e && (BlockStatement.__proto__ = e), BlockStatement.prototype = Object.create(e && e.prototype), BlockStatement.prototype.constructor = BlockStatement, BlockStatement.prototype.createScope = function createScope() { const e = this; this.parentIsFunction = /Function/.test(this.parent.type), this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root', this.scope = new Scope({ block: !this.isFunctionBlock, parent: this.parent.findScope(!1), declare(t) { return e.createdDeclarations.push(t) } }), this.parentIsFunction && this.parent.params.forEach((t) => { e.scope.addDeclaration(t, 'param') }) }, BlockStatement.prototype.initialise = function initialise(e) { this.thisAlias = null, this.argumentsAlias = null, this.defaultParameters = [], this.createdDeclarations = [], this.scope || this.createScope(), this.body.forEach(t => t.initialise(e)), this.scope.consolidate() }, BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary() { return this.type === 'Program' ? this : /^Function/.test(this.parent.type) ? this : this.parent.findLexicalBoundary() }, BlockStatement.prototype.findScope = function findScope(e) { return e && !this.isFunctionBlock ? this.parent.findScope(e) : this.scope }, BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias() { return this.argumentsAlias || (this.argumentsAlias = this.scope.createIdentifier('arguments')), this.argumentsAlias }, BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias() { return this.argumentsArrayAlias || (this.argumentsArrayAlias = this.scope.createIdentifier('argsArray')), this.argumentsArrayAlias }, BlockStatement.prototype.getThisAlias = function getThisAlias() { return this.thisAlias || (this.thisAlias = this.scope.createIdentifier('this')), this.thisAlias }, BlockStatement.prototype.getIndentation = function getIndentation() { if (void 0 === this.indentation) { for (var e = this.program.magicString.original, t = this.synthetic || !this.body.length, r = t ? this.start : this.body[0].start; r && e[r] !== '\n';)r -= 1; for (this.indentation = ''; ;) { const n = e[r += 1]; if (n !== ' ' && n !== '\t') break; this.indentation += n } for (var i = this.program.magicString.getIndentString(), a = this.parent; a;)a.kind !== 'constructor' || a.parent.parent.superClass || (this.indentation = this.indentation.replace(i, '')), a = a.parent; t && (this.indentation += i) } return this.indentation }, BlockStatement.prototype.transpile = function transpile(t, r) { let n; const i = this; const a = this.getIndentation(); const o = []; if (this.argumentsAlias && o.push((e, r, n) => { const a = `${r}var ${i.argumentsAlias} = arguments${n}`; t.appendLeft(e, a) }), this.thisAlias && o.push((e, r, n) => { const a = `${r}var ${i.thisAlias} = this${n}`; t.appendLeft(e, a) }), this.argumentsArrayAlias && o.push((e, r, n) => { const o = i.scope.createIdentifier('i'); const s = `${r}var ${o} = arguments.length, ${i.argumentsArrayAlias} = Array(${o});\n${a}while ( ${o}-- ) ${i.argumentsArrayAlias}[${o}] = arguments[${o}]${n}`; t.appendLeft(e, s) }), /Function/.test(this.parent.type) ? this.transpileParameters(this.parent.params, t, r, a, o) : this.parent.type === 'CatchClause' && this.transpileParameters([this.parent.param], t, r, a, o), r.letConst && this.isFunctionBlock && this.transpileBlockScopedIdentifiers(t), e.prototype.transpile.call(this, t, r), this.createdDeclarations.length && o.push((e, r, n) => { const a = `${r}var ${i.createdDeclarations.join(', ')}${n}`; t.appendLeft(e, a) }), this.synthetic) if (this.parent.type === 'ArrowFunctionExpression') { const s = this.body[0]; o.length ? (t.appendLeft(this.start, '{').prependRight(this.end, `${this.parent.getIndentation()}}`), t.prependRight(s.start, `\n${a}return `), t.appendLeft(s.end, ';\n')) : r.arrow && (t.prependRight(s.start, '{ return '), t.appendLeft(s.end, '; }')) } else o.length && t.prependRight(this.start, '{').appendLeft(this.end, '}'); n = (function isUseStrict(e) { return !!e && e.type === 'ExpressionStatement' && e.expression.type === 'Literal' && e.expression.value === 'use strict' }(this.body[0])) ? this.body[0].end : this.synthetic || this.parent.type === 'Root' ? this.start : this.start + 1; const u = `\n${a}`; let l = ';'; o.forEach((e, t) => { t === o.length - 1 && (l = ';\n'), e(n, u, l) }) }, BlockStatement.prototype.transpileParameters = function transpileParameters(e, t, r, n, i) { const a = this; e.forEach((o) => { if (o.type === 'AssignmentPattern' && o.left.type === 'Identifier')r.defaultParameter && i.push((e, r, n) => { const i = `${r}if ( ${o.left.name} === void 0 ) ${o.left.name}`; t.prependRight(o.left.end, i).move(o.left.end, o.right.end, e).appendLeft(o.right.end, n) }); else if (o.type === 'RestElement')r.spreadRest && i.push((r, i, s) => { const u = e[e.length - 2]; if (u)t.remove(u ? u.end : o.start, o.end); else { for (var l = o.start, c = o.end; /\s/.test(t.original[l - 1]);)l -= 1; for (;/\s/.test(t.original[c]);)c += 1; t.remove(l, c) } const p = o.argument.name; const f = a.scope.createIdentifier('len'); const d = e.length - 1; d ? t.prependRight(r, `${i}var ${p} = [], ${f} = arguments.length - ${d};\n${n}while ( ${f}-- > 0 ) ${p}[ ${f} ] = arguments[ ${f} + ${d} ]${s}`) : t.prependRight(r, `${i}var ${p} = [], ${f} = arguments.length;\n${n}while ( ${f}-- ) ${p}[ ${f} ] = arguments[ ${f} ]${s}`) }); else if (o.type !== 'Identifier' && r.parameterDestructuring) { const s = a.scope.createIdentifier('ref'); destructure(t, e => a.scope.createIdentifier(e), (e) => { const t = e.name; return a.scope.resolveName(t) }, o, s, !1, i), t.prependRight(o.start, s) } }) }, BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers(e) { const t = this; Object.keys(this.scope.blockScopedDeclarations).forEach((r) => { for (let n = 0, i = t.scope.blockScopedDeclarations[r]; n < i.length; n += 1) { const a = i[n]; let o = !1; if (a.kind === 'for.let') { const s = a.node.findNearest('ForStatement'); if (s.shouldRewriteAsFunction) { const u = t.scope.createIdentifier(r); const l = s.reassigned[r] ? t.scope.createIdentifier(r) : r; a.name = u, e.overwrite(a.node.start, a.node.end, u, { storeName: !0 }), s.aliases[r] = { outer: u, inner: l }; for (let c = 0, p = a.instances; c < p.length; c += 1) { const f = p[c]; const d = s.body.contains(f) ? l : u; r !== d && e.overwrite(f.start, f.end, d, { storeName: !0 }) }o = !0 } } if (!o) { const h = t.scope.createIdentifier(r); if (r !== h) { a.name = h, e.overwrite(a.node.start, a.node.end, h, { storeName: !0 }); for (let m = 0, g = a.instances; m < g.length; m += 1) { const v = g[m]; v.rewritten = !0, e.overwrite(v.start, v.end, h, { storeName: !0 }) } } } } }) }, BlockStatement }(p)); function isArguments(e) { return e.type === 'Identifier' && e.name === 'arguments' } function spread(e, t, r, n, i) { for (var a = t.length, o = -1; a--;) { const s = t[a]; s && s.type === 'SpreadElement' && (isArguments(s.argument) && e.overwrite(s.argument.start, s.argument.end, n), o = a) } if (o === -1) return !1; if (i) { for (a = 0; a < t.length; a += 1) { const u = t[a]; u.type === 'SpreadElement' ? e.remove(u.start, u.argument.start) : (e.prependRight(u.start, '['), e.prependRight(u.end, ']')) } return !0 } let l = t[o]; const c = t[o - 1]; for (c ? e.overwrite(c.end, l.start, ' ].concat( ') : (e.remove(r, l.start), e.overwrite(l.end, t[1].start, '.concat( ')), a = o; a < t.length; a += 1)(l = t[a]) && (l.type === 'SpreadElement' ? e.remove(l.start, l.argument.start) : (e.appendLeft(l.start, '['), e.appendLeft(l.end, ']'))); return !0 } const v = (function (e) { function ArrayExpression() { e.apply(this, arguments) } return e && (ArrayExpression.__proto__ = e), ArrayExpression.prototype = Object.create(e && e.prototype), ArrayExpression.prototype.constructor = ArrayExpression, ArrayExpression.prototype.initialise = function initialise(t) { if (t.spreadRest && this.elements.length) for (let r = this.findLexicalBoundary(), n = this.elements.length; n--;) { const i = this.elements[n]; i && i.type === 'SpreadElement' && isArguments(i.argument) && (this.argumentsArrayAlias = r.getArgumentsArrayAlias()) }e.prototype.initialise.call(this, t) }, ArrayExpression.prototype.transpile = function transpile(t, r) { if (e.prototype.transpile.call(this, t, r), r.spreadRest) { if (this.elements.length) { const n = this.elements[this.elements.length - 1]; n && /\s*,/.test(t.original.slice(n.end, this.end)) && t.overwrite(n.end, this.end - 1, ' ') } if (this.elements.length === 1) { const i = this.elements[0]; i && i.type === 'SpreadElement' && (isArguments(i.argument) ? t.overwrite(this.start, this.end, `[].concat( ${this.argumentsArrayAlias} )`) : (t.overwrite(this.start, i.argument.start, '[].concat( '), t.overwrite(i.end, this.end, ' )'))) } else { spread(t, this.elements, this.start, this.argumentsArrayAlias) && t.overwrite(this.end - 1, this.end, ')') } } }, ArrayExpression }(p)); function removeTrailingComma(e, t) { for (;e.original[t] !== ')';) { if (e.original[t] === ',') return void e.remove(t, t + 1); e.original[t] === '/' && (t = e.original.indexOf(e.original[t + 1] === '/' ? '\n' : '*/', t) + 1), t += 1 } } const y = (function (e) { function ArrowFunctionExpression() { e.apply(this, arguments) } return e && (ArrowFunctionExpression.__proto__ = e), ArrowFunctionExpression.prototype = Object.create(e && e.prototype), ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression, ArrowFunctionExpression.prototype.initialise = function initialise(t) { this.body.createScope(), e.prototype.initialise.call(this, t) }, ArrowFunctionExpression.prototype.transpile = function transpile(t, r) { const n = this.params.length === 1 && this.start === this.params[0].start; if (r.arrow || this.needsArguments(r)) { for (var i = this.body.start; t.original[i] !== '=';)i -= 1; t.remove(i, this.body.start), e.prototype.transpile.call(this, t, r), n && (t.prependRight(this.params[0].start, '('), t.appendLeft(this.params[0].end, ')')), this.parent && this.parent.type === 'ExpressionStatement' ? t.prependRight(this.start, '!function') : t.prependRight(this.start, 'function ') } else e.prototype.transpile.call(this, t, r); r.trailingFunctionCommas && this.params.length && !n && removeTrailingComma(t, this.params[this.params.length - 1].end) }, ArrowFunctionExpression.prototype.needsArguments = function needsArguments(e) { return e.spreadRest && this.params.filter(e => e.type === 'RestElement').length > 0 }, ArrowFunctionExpression }(p)); function checkConst(e, t) { const r = t.findDeclaration(e.name); if (r && r.kind === 'const') throw new h(`${e.name} is read-only`, e); } const b = (function (e) { function AssignmentExpression() { e.apply(this, arguments) } return e && (AssignmentExpression.__proto__ = e), AssignmentExpression.prototype = Object.create(e && e.prototype), AssignmentExpression.prototype.constructor = AssignmentExpression, AssignmentExpression.prototype.initialise = function initialise(t) { if (this.left.type === 'Identifier') { const r = this.findScope(!1).findDeclaration(this.left.name); const n = r && r.node.ancestor(3); n && n.type === 'ForStatement' && n.body.contains(this) && (n.reassigned[this.left.name] = !0) }e.prototype.initialise.call(this, t) }, AssignmentExpression.prototype.transpile = function transpile(t, r) { this.left.type === 'Identifier' && checkConst(this.left, this.findScope(!1)), this.operator === '**=' && r.exponentiation ? this.transpileExponentiation(t, r) : /Pattern/.test(this.left.type) && r.destructuring && this.transpileDestructuring(t, r), e.prototype.transpile.call(this, t, r) }, AssignmentExpression.prototype.transpileDestructuring = function transpileDestructuring(e) { const t = this; const r = this.findScope(!0); const n = this.findScope(!1); const i = r.createDeclaration('assign'); e.appendRight(this.left.end, `(${i}`), e.appendLeft(this.right.end, ', '); const a = []; destructure(e, e => r.createDeclaration(e), (e) => { const t = n.resolveName(e.name); return checkConst(e, n), t }, this.left, i, !0, a); let o = ', '; a.forEach((e, r) => { r === a.length - 1 && (o = ''), e(t.end, '', o) }), this.unparenthesizedParent().type === 'ExpressionStatement' ? e.appendRight(this.end, ')') : e.appendRight(this.end, `, ${i})`) }, AssignmentExpression.prototype.transpileExponentiation = function transpileExponentiation(e) { for (var t, r = this.findScope(!1), n = this.left.end; e.original[n] !== '*';)n += 1; e.remove(n, n + 2); const i = this.left.unparenthesize(); if (i.type === 'Identifier')t = r.resolveName(i.name); else if (i.type === 'MemberExpression') { let a; let o; let s = !1; let u = !1; const l = this.findNearest(/(?:Statement|Declaration)$/); const c = l.getIndentation(); i.property.type === 'Identifier' ? o = i.computed ? r.resolveName(i.property.name) : i.property.name : (o = r.createDeclaration('property'), u = !0), i.object.type === 'Identifier' ? a = r.resolveName(i.object.name) : (a = r.createDeclaration('object'), s = !0), i.start === l.start ? s && u ? (e.prependRight(l.start, `${a} = `), e.overwrite(i.object.end, i.property.start, `;\n${c}${o} = `), e.overwrite(i.property.end, i.end, `;\n${c}${a}[${o}]`)) : s ? (e.prependRight(l.start, `${a} = `), e.appendLeft(i.object.end, `;\n${c}`), e.appendLeft(i.object.end, a)) : u && (e.prependRight(i.property.start, `${o} = `), e.appendLeft(i.property.end, `;\n${c}`), e.move(i.property.start, i.property.end, this.start), e.appendLeft(i.object.end, `[${o}]`), e.remove(i.object.end, i.property.start), e.remove(i.property.end, i.end)) : (s && u ? (e.prependRight(i.start, `( ${a} = `), e.overwrite(i.object.end, i.property.start, `, ${o} = `), e.overwrite(i.property.end, i.end, `, ${a}[${o}]`)) : s ? (e.prependRight(i.start, `( ${a} = `), e.appendLeft(i.object.end, `, ${a}`)) : u && (e.prependRight(i.property.start, `( ${o} = `), e.appendLeft(i.property.end, ', '), e.move(i.property.start, i.property.end, i.start), e.overwrite(i.object.end, i.property.start, `[${o}]`), e.remove(i.property.end, i.end)), u && e.appendLeft(this.end, ' )')), t = a + (i.computed || u ? `[${o}]` : `.${o}`) }e.prependRight(this.right.start, `Math.pow( ${t}, `), e.appendLeft(this.right.end, ' )') }, AssignmentExpression }(p)); const x = (function (e) { function BinaryExpression() { e.apply(this, arguments) } return e && (BinaryExpression.__proto__ = e), BinaryExpression.prototype = Object.create(e && e.prototype), BinaryExpression.prototype.constructor = BinaryExpression, BinaryExpression.prototype.transpile = function transpile(t, r) { this.operator === '**' && r.exponentiation && (t.prependRight(this.start, 'Math.pow( '), t.overwrite(this.left.end, this.right.start, ', '), t.appendLeft(this.end, ' )')), e.prototype.transpile.call(this, t, r) }, BinaryExpression }(p)); const D = /(?:For(?:In|Of)?|While)Statement/; const _ = (function (e) { function BreakStatement() { e.apply(this, arguments) } return e && (BreakStatement.__proto__ = e), BreakStatement.prototype = Object.create(e && e.prototype), BreakStatement.prototype.constructor = BreakStatement, BreakStatement.prototype.initialise = function initialise() { const e = this.findNearest(D); const t = this.findNearest('SwitchCase'); e && (!t || e.depth > t.depth) && (e.canBreak = !0, this.loop = e) }, BreakStatement.prototype.transpile = function transpile(e) { if (this.loop && this.loop.shouldRewriteAsFunction) { if (this.label) throw new h('Labels are not currently supported in a loop with locally-scoped variables', this); e.overwrite(this.start, this.start + 5, "return 'break'") } }, BreakStatement }(p)); const C = (function (e) { function CallExpression() { e.apply(this, arguments) } return e && (CallExpression.__proto__ = e), CallExpression.prototype = Object.create(e && e.prototype), CallExpression.prototype.constructor = CallExpression, CallExpression.prototype.initialise = function initialise(t) { if (t.spreadRest && this.arguments.length > 1) for (let r = this.findLexicalBoundary(), n = this.arguments.length; n--;) { const i = this.arguments[n]; i.type === 'SpreadElement' && isArguments(i.argument) && (this.argumentsArrayAlias = r.getArgumentsArrayAlias()) }e.prototype.initialise.call(this, t) }, CallExpression.prototype.transpile = function transpile(t, r) { if (r.spreadRest && this.arguments.length) { let n; let i = !1; const a = this.arguments[0]; if (this.arguments.length === 1 ? a.type === 'SpreadElement' && (t.remove(a.start, a.argument.start), i = !0) : i = spread(t, this.arguments, a.start, this.argumentsArrayAlias), i) { let o = null; if (this.callee.type === 'Super' ? o = this.callee : this.callee.type === 'MemberExpression' && this.callee.object.type === 'Super' && (o = this.callee.object), o || this.callee.type !== 'MemberExpression')n = 'void 0'; else if (this.callee.object.type === 'Identifier')n = this.callee.object.name; else { n = this.findScope(!0).createDeclaration('ref'); const s = this.callee.object; t.prependRight(s.start, `(${n} = `), t.appendLeft(s.end, ')') }t.appendLeft(this.callee.end, '.apply'), o ? (o.noCall = !0, this.arguments.length > 1 && (a.type !== 'SpreadElement' && t.prependRight(a.start, '[ '), t.appendLeft(this.arguments[this.arguments.length - 1].end, ' )'))) : this.arguments.length === 1 ? t.prependRight(a.start, `${n}, `) : (a.type === 'SpreadElement' ? t.appendLeft(a.start, `${n}, `) : t.appendLeft(a.start, `${n}, [ `), t.appendLeft(this.arguments[this.arguments.length - 1].end, ' )')) } }r.trailingFunctionCommas && this.arguments.length && removeTrailingComma(t, this.arguments[this.arguments.length - 1].end), e.prototype.transpile.call(this, t, r) }, CallExpression }(p)); const w = (function (e) {
      function ClassBody() { e.apply(this, arguments) } return e && (ClassBody.__proto__ = e), ClassBody.prototype = Object.create(e && e.prototype), ClassBody.prototype.constructor = ClassBody, ClassBody.prototype.transpile = function transpile(t, r, n, i) {
        const a = this; if (r.classes) {
          const o = this.parent.name; const s = t.getIndentString(); const u = this.getIndentation() + (n ? s : ''); const l = u + s; const c = findIndex(this.body, e => e.kind === 'constructor'); const p = this.body[c]; let f = ''; let h = ''; if (this.body.length ? (t.remove(this.start, this.body[0].start), t.remove(this.body[this.body.length - 1].end, this.end)) : t.remove(this.start, this.end), p) { p.value.body.isConstructorBody = !0; const m = this.body[c - 1]; const g = this.body[c + 1]; c > 0 && (t.remove(m.end, p.start), t.move(p.start, g ? g.start : this.end - 1, this.body[0].start)), n || t.appendLeft(p.end, ';') } const v = !1 !== this.program.options.namedFunctionExpressions; const y = v || this.parent.superClass || this.parent.type !== 'ClassDeclaration'; if (this.parent.superClass) { let b = `if ( ${i} ) ${o}.__proto__ = ${i};\n${u}${o}.prototype = Object.create( ${i} && ${i}.prototype );\n${u}${o}.prototype.constructor = ${o};`; if (p)f += `\n\n${u}${b}`; else f += `${b = `function ${o} () {${i ? `\n${l}${i}.apply(this, arguments);\n${u}}` : '}'}${n ? '' : ';'}${this.body.length ? `\n\n${u}` : ''}${b}`}\n\n${u}`; } else if (!p) { let x = `function ${y ? `${o} ` : ''}() {}`; this.parent.type === 'ClassDeclaration' && (x += ';'), this.body.length && (x += `\n\n${u}`), f += x } let D; let _; const C = this.findScope(!1); const w = []; const E = []; if (this.body.forEach((e, r) => {
            if (e.kind !== 'constructor') {
              if (e.static) { const n = t.original[e.start + 6] == ' ' ? 7 : 6; t.remove(e.start, e.start + n) } let i; const s = e.kind !== 'method'; let l = e.key.name; (d[l] || e.value.body.scope.references[l]) && (l = C.createIdentifier(l)); let p = !1; if (e.computed || e.key.type !== 'Literal' || (p = !0, e.computed = !0), s) { if (e.computed) throw new Error('Computed accessor properties are not currently supported'); t.remove(e.start, e.key.start), e.static ? (~E.indexOf(e.key.name) || E.push(e.key.name), _ || (_ = C.createIdentifier('staticAccessors')), i = `${_}`) : (~w.indexOf(e.key.name) || w.push(e.key.name), D || (D = C.createIdentifier('prototypeAccessors')), i = `${D}`) } else i = e.static ? `${o}` : `${o}.prototype`; e.computed || (i += '.'), (c > 0 && r === c + 1 || r === 0 && c === a.body.length - 1) && (i = `\n\n${u}${i}`); let f = e.key.end; if (e.computed) if (p)t.prependRight(e.key.start, '['), t.appendLeft(e.key.end, ']'); else { for (;t.original[f] !== ']';)f += 1; f += 1 } const h = e.computed || s || !v ? '' : `${l} `; const
                m = `${s ? `.${e.kind}` : ''} = function${e.value.generator ? '* ' : ' '}${h}`; t.remove(f, e.value.start), t.prependRight(e.value.start, m), t.appendLeft(e.end, ';'), e.value.generator && t.remove(e.start, e.key.start), t.prependRight(e.start, i);
            } else { const g = y ? ` ${o}` : ''; t.overwrite(e.key.start, e.key.end, `function${g}`) }
          }), w.length || E.length) { const S = []; const k = []; w.length && (S.push(`var ${D} = { ${w.map(e => `${e}: { configurable: true }`).join(',')} };`), k.push(`Object.defineProperties( ${o}.prototype, ${D} );`)), E.length && (S.push(`var ${_} = { ${E.map(e => `${e}: { configurable: true }`).join(',')} };`), k.push(`Object.defineProperties( ${o}, ${_} );`)), p && (f += `\n\n${u}`), f += S.join(`\n${u}`), p || (f += `\n\n${u}`), h += `\n\n${u}${k.join(`\n${u}`)}` }p ? t.appendLeft(p.end, f) : t.prependRight(this.start, f), t.appendLeft(this.end, h);
        }e.prototype.transpile.call(this, t, r);
      }, ClassBody;
    }(p)); const E = (function (e) { function ClassDeclaration() { e.apply(this, arguments) } return e && (ClassDeclaration.__proto__ = e), ClassDeclaration.prototype = Object.create(e && e.prototype), ClassDeclaration.prototype.constructor = ClassDeclaration, ClassDeclaration.prototype.initialise = function initialise(t) { this.id ? (this.name = this.id.name, this.findScope(!0).addDeclaration(this.id, 'class')) : this.name = this.findScope(!0).createIdentifier('defaultExport'), e.prototype.initialise.call(this, t) }, ClassDeclaration.prototype.transpile = function transpile(e, t) { if (t.classes) { this.superClass || (function deindent(e, t) { const r = e.start; const n = e.end; const i = t.getIndentString(); const a = i.length; const o = r - a; e.program.indentExclusions[o] || t.original.slice(o, r) !== i || t.remove(o, r); for (var s, u = new RegExp(`${i}\\S`, 'g'), l = t.original.slice(r, n); s = u.exec(l);) { const c = r + s.index; e.program.indentExclusions[c] || t.remove(c, c + a) } }(this.body, e)); const r = this.superClass && (this.superClass.name || 'superclass'); const n = this.getIndentation(); const i = n + e.getIndentString(); const a = this.parent.type === 'ExportDefaultDeclaration'; a && e.remove(this.parent.start, this.start); let o = this.start; this.id ? (e.overwrite(o, this.id.start, 'var '), o = this.id.end) : e.prependLeft(o, `var ${this.name}`), this.superClass ? this.superClass.end === this.body.start ? (e.remove(o, this.superClass.start), e.appendLeft(o, ` = (function (${r}) {\n${i}`)) : (e.overwrite(o, this.superClass.start, ' = '), e.overwrite(this.superClass.end, this.body.start, `(function (${r}) {\n${i}`)) : o === this.body.start ? e.appendLeft(o, ' = ') : e.overwrite(o, this.body.start, ' = '), this.body.transpile(e, t, !!this.superClass, r); const s = a ? `\n\n${n}export default ${this.name};` : ''; this.superClass ? (e.appendLeft(this.end, `\n\n${i}return ${this.name};\n${n}}(`), e.move(this.superClass.start, this.superClass.end, this.end), e.prependRight(this.end, `));${s}`)) : s && e.prependRight(this.end, s) } else this.body.transpile(e, t, !1, null); }, ClassDeclaration }(p)); const S = (function (e) { function ClassExpression() { e.apply(this, arguments) } return e && (ClassExpression.__proto__ = e), ClassExpression.prototype = Object.create(e && e.prototype), ClassExpression.prototype.constructor = ClassExpression, ClassExpression.prototype.initialise = function initialise(t) { this.name = (this.id ? this.id.name : this.parent.type === 'VariableDeclarator' ? this.parent.id.name : this.parent.type !== 'AssignmentExpression' ? null : this.parent.left.type === 'Identifier' ? this.parent.left.name : this.parent.left.type === 'MemberExpression' ? this.parent.left.property.name : null) || this.findScope(!0).createIdentifier('anonymous'), e.prototype.initialise.call(this, t) }, ClassExpression.prototype.transpile = function transpile(e, t) { if (t.classes) { const r = this.superClass && (this.superClass.name || 'superclass'); const n = this.getIndentation(); const i = n + e.getIndentString(); this.superClass ? (e.remove(this.start, this.superClass.start), e.remove(this.superClass.end, this.body.start), e.appendLeft(this.start, `(function (${r}) {\n${i}`)) : e.overwrite(this.start, this.body.start, `(function () {\n${i}`), this.body.transpile(e, t, !0, r); const a = `\n\n${i}return ${this.name};\n${n}}(`; this.superClass ? (e.appendLeft(this.end, a), e.move(this.superClass.start, this.superClass.end, this.end), e.prependRight(this.end, '))')) : e.appendLeft(this.end, `\n\n${i}return ${this.name};\n${n}}())`) } else this.body.transpile(e, t, !1); }, ClassExpression }(p)); const k = (function (e) { function ContinueStatement() { e.apply(this, arguments) } return e && (ContinueStatement.__proto__ = e), ContinueStatement.prototype = Object.create(e && e.prototype), ContinueStatement.prototype.constructor = ContinueStatement, ContinueStatement.prototype.transpile = function transpile(e) { if (this.findNearest(D).shouldRewriteAsFunction) { if (this.label) throw new h('Labels are not currently supported in a loop with locally-scoped variables', this); e.overwrite(this.start, this.start + 8, 'return') } }, ContinueStatement }(p)); const A = (function (e) { function ExportDefaultDeclaration() { e.apply(this, arguments) } return e && (ExportDefaultDeclaration.__proto__ = e), ExportDefaultDeclaration.prototype = Object.create(e && e.prototype), ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration, ExportDefaultDeclaration.prototype.initialise = function initialise(t) { if (t.moduleExport) throw new h('export is not supported', this); e.prototype.initialise.call(this, t) }, ExportDefaultDeclaration }(p)); const T = (function (e) { function ExportNamedDeclaration() { e.apply(this, arguments) } return e && (ExportNamedDeclaration.__proto__ = e), ExportNamedDeclaration.prototype = Object.create(e && e.prototype), ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration, ExportNamedDeclaration.prototype.initialise = function initialise(t) { if (t.moduleExport) throw new h('export is not supported', this); e.prototype.initialise.call(this, t) }, ExportNamedDeclaration }(p)); const P = (function (e) { function LoopStatement() { e.apply(this, arguments) } return e && (LoopStatement.__proto__ = e), LoopStatement.prototype = Object.create(e && e.prototype), LoopStatement.prototype.constructor = LoopStatement, LoopStatement.prototype.findScope = function findScope(e) { return e || !this.createdScope ? this.parent.findScope(e) : this.body.scope }, LoopStatement.prototype.initialise = function initialise(t) { if (this.body.createScope(), this.createdScope = !0, this.reassigned = Object.create(null), this.aliases = Object.create(null), e.prototype.initialise.call(this, t), t.letConst) for (let r = Object.keys(this.body.scope.declarations), n = r.length; n--;) { for (let i = r[n], a = this.body.scope.declarations[i], o = a.instances.length; o--;) { const s = a.instances[o].findNearest(/Function/); if (s && s.depth > this.depth) { this.shouldRewriteAsFunction = !0; break } } if (this.shouldRewriteAsFunction) break; } }, LoopStatement.prototype.transpile = function transpile(t, r) { const n = this.type != 'ForOfStatement' && (this.body.type !== 'BlockStatement' || this.body.type === 'BlockStatement' && this.body.synthetic); if (this.shouldRewriteAsFunction) { const i = this.getIndentation(); const a = i + t.getIndentString(); const o = this.args ? ` ${this.args.join(', ')} ` : ''; const s = this.params ? ` ${this.params.join(', ')} ` : ''; const u = this.findScope(!0); const l = u.createIdentifier('loop'); const c = `var ${l} = function (${s}) ${this.body.synthetic ? `{\n${i}${t.getIndentString()}` : ''}`; const p = `${this.body.synthetic ? `\n${i}}` : ''};\n\n${i}`; if (t.prependRight(this.body.start, c), t.appendLeft(this.body.end, p), t.move(this.start, this.body.start, this.body.end), this.canBreak || this.canReturn) { const f = u.createIdentifier('returned'); let d = `{\n${a}var ${f} = ${l}(${o});\n`; this.canBreak && (d += `\n${a}if ( ${f} === 'break' ) break;`), this.canReturn && (d += `\n${a}if ( ${f} ) return ${f}.v;`), d += `\n${i}}`, t.prependRight(this.body.end, d) } else { const h = `${l}(${o});`; this.type === 'DoWhileStatement' ? t.overwrite(this.start, this.body.start, `do {\n${a}${h}\n${i}}`) : t.prependRight(this.body.end, h) } } else n && (t.appendLeft(this.body.start, '{ '), t.prependRight(this.body.end, ' }')); e.prototype.transpile.call(this, t, r) }, LoopStatement }(p)); const R = (function (e) { function ForStatement() { e.apply(this, arguments) } return e && (ForStatement.__proto__ = e), ForStatement.prototype = Object.create(e && e.prototype), ForStatement.prototype.constructor = ForStatement, ForStatement.prototype.findScope = function findScope(e) { return e || !this.createdScope ? this.parent.findScope(e) : this.body.scope }, ForStatement.prototype.transpile = function transpile(t, r) { const n = this; const i = this.getIndentation() + t.getIndentString(); if (this.shouldRewriteAsFunction) { const a = this.init.type === 'VariableDeclaration' ? [].concat.apply([], this.init.declarations.map(e => extractNames(e.id))) : []; const o = this.aliases; this.args = a.map(e => (e in n.aliases ? n.aliases[e].outer : e)), this.params = a.map(e => (e in n.aliases ? n.aliases[e].inner : e)); const s = Object.keys(this.reassigned).map(e => `${o[e].outer} = ${o[e].inner};`); if (s.length) if (this.body.synthetic)t.appendLeft(this.body.body[0].end, `; ${s.join(' ')}`); else { const u = this.body.body[this.body.body.length - 1]; t.appendLeft(u.end, `\n\n${i}${s.join(`\n${i}`)}`) } }e.prototype.transpile.call(this, t, r) }, ForStatement }(P)); const O = (function (e) { function ForInStatement() { e.apply(this, arguments) } return e && (ForInStatement.__proto__ = e), ForInStatement.prototype = Object.create(e && e.prototype), ForInStatement.prototype.constructor = ForInStatement, ForInStatement.prototype.findScope = function findScope(e) { return e || !this.createdScope ? this.parent.findScope(e) : this.body.scope }, ForInStatement.prototype.transpile = function transpile(t, r) { const n = this; const i = this.left.type === 'VariableDeclaration'; if (this.shouldRewriteAsFunction) { const a = i ? [].concat.apply([], this.left.declarations.map(e => extractNames(e.id))) : []; this.args = a.map(e => (e in n.aliases ? n.aliases[e].outer : e)), this.params = a.map(e => (e in n.aliases ? n.aliases[e].inner : e)) }e.prototype.transpile.call(this, t, r); const o = i ? this.left.declarations[0].id : this.left; o.type !== 'Identifier' && this.destructurePattern(t, o, i) }, ForInStatement.prototype.destructurePattern = function destructurePattern(e, t, r) { const n = this.findScope(!0); const i = this.getIndentation() + e.getIndentString(); const a = n.createIdentifier('ref'); const o = this.body.body.length ? this.body.body[0].start : this.body.start + 1; e.move(t.start, t.end, o), e.prependRight(t.end, r ? a : `var ${a}`); const s = []; destructure(e, e => n.createIdentifier(e), (e) => { const t = e.name; return n.resolveName(t) }, t, a, !1, s); let u = `;\n${i}`; s.forEach((e, t) => { t === s.length - 1 && (u = `;\n\n${i}`), e(o, '', u) }) }, ForInStatement }(P)); const F = (function (e) { function ForOfStatement() { e.apply(this, arguments) } return e && (ForOfStatement.__proto__ = e), ForOfStatement.prototype = Object.create(e && e.prototype), ForOfStatement.prototype.constructor = ForOfStatement, ForOfStatement.prototype.initialise = function initialise(t) { if (t.forOf && !t.dangerousForOf) throw new h("for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you're doing", this); e.prototype.initialise.call(this, t) }, ForOfStatement.prototype.transpile = function transpile(t, r) { if (e.prototype.transpile.call(this, t, r), r.dangerousForOf) if (this.body.body[0]) { const n = this.findScope(!0); const i = this.getIndentation(); const a = i + t.getIndentString(); const o = n.createIdentifier('i'); const s = n.createIdentifier('list'); this.body.synthetic && (t.prependRight(this.left.start, `{\n${a}`), t.appendLeft(this.body.body[0].end, `\n${i}}`)); const u = this.body.body[0].start; t.remove(this.left.end, this.right.start), t.move(this.left.start, this.left.end, u), t.prependRight(this.right.start, `var ${o} = 0, ${s} = `), t.appendLeft(this.right.end, `; ${o} < ${s}.length; ${o} += 1`); const l = this.left.type === 'VariableDeclaration'; const c = l ? this.left.declarations[0].id : this.left; if (c.type !== 'Identifier') { const p = []; const f = n.createIdentifier('ref'); destructure(t, e => n.createIdentifier(e), (e) => { const t = e.name; return n.resolveName(t) }, c, f, !l, p); let d = `;\n${a}`; p.forEach((e, t) => { t === p.length - 1 && (d = `;\n\n${a}`), e(u, '', d) }), l ? (t.appendLeft(this.left.start + this.left.kind.length + 1, f), t.appendLeft(this.left.end, ` = ${s}[${o}];\n${a}`)) : t.appendLeft(this.left.end, `var ${f} = ${s}[${o}];\n${a}`) } else t.appendLeft(this.left.end, ` = ${s}[${o}];\n\n${a}`); } else this.left.type === 'VariableDeclaration' && this.left.kind === 'var' ? (t.remove(this.start, this.left.start), t.appendLeft(this.left.end, ';'), t.remove(this.left.end, this.end)) : t.remove(this.start, this.end); }, ForOfStatement }(P)); const L = (function (e) { function FunctionDeclaration() { e.apply(this, arguments) } return e && (FunctionDeclaration.__proto__ = e), FunctionDeclaration.prototype = Object.create(e && e.prototype), FunctionDeclaration.prototype.constructor = FunctionDeclaration, FunctionDeclaration.prototype.initialise = function initialise(t) { if (this.generator && t.generator) throw new h('Generators are not supported', this); this.body.createScope(), this.id && this.findScope(!0).addDeclaration(this.id, 'function'), e.prototype.initialise.call(this, t) }, FunctionDeclaration.prototype.transpile = function transpile(t, r) { e.prototype.transpile.call(this, t, r), r.trailingFunctionCommas && this.params.length && removeTrailingComma(t, this.params[this.params.length - 1].end) }, FunctionDeclaration }(p)); const M = (function (e) { function FunctionExpression() { e.apply(this, arguments) } return e && (FunctionExpression.__proto__ = e), FunctionExpression.prototype = Object.create(e && e.prototype), FunctionExpression.prototype.constructor = FunctionExpression, FunctionExpression.prototype.initialise = function initialise(t) { if (this.generator && t.generator) throw new h('Generators are not supported', this); this.body.createScope(), this.id && this.body.scope.addDeclaration(this.id, 'function'), e.prototype.initialise.call(this, t); let r; const n = this.parent; if (t.conciseMethodProperty && n.type === 'Property' && n.kind === 'init' && n.method && n.key.type === 'Identifier' ? r = n.key.name : t.classes && n.type === 'MethodDefinition' && n.kind === 'method' && n.key.type === 'Identifier' ? r = n.key.name : this.id && this.id.type === 'Identifier' && (r = this.id.alias || this.id.name), r) for (let i = 0, a = this.params; i < a.length; i += 1) { const o = a[i]; if (o.type === 'Identifier' && r === o.name) { const s = this.body.scope; const u = s.declarations[r]; const l = s.createIdentifier(r); o.alias = l; for (let c = 0, p = u.instances; c < p.length; c += 1) { p[c].alias = l } break } } }, FunctionExpression.prototype.transpile = function transpile(t, r) { e.prototype.transpile.call(this, t, r), r.trailingFunctionCommas && this.params.length && removeTrailingComma(t, this.params[this.params.length - 1].end) }, FunctionExpression }(p)); const j = (function (e) { function Identifier() { e.apply(this, arguments) } return e && (Identifier.__proto__ = e), Identifier.prototype = Object.create(e && e.prototype), Identifier.prototype.constructor = Identifier, Identifier.prototype.findScope = function findScope(e) { return this.parent.params && ~this.parent.params.indexOf(this) ? this.parent.body.scope : this.parent.type === 'FunctionExpression' && this === this.parent.id ? this.parent.body.scope : this.parent.findScope(e) }, Identifier.prototype.initialise = function initialise(e) { if (function isReference(e, t) { return e.type === 'MemberExpression' ? !e.computed && isReference(e.object, e) : e.type === 'Identifier' ? !t || !/(Function|Class)Expression/.test(t.type) && (t.type === 'VariableDeclarator' ? e === t.init : t.type === 'MemberExpression' || t.type === 'MethodDefinition' ? t.computed || e === t.object : t.type !== 'ArrayPattern' && (t.type === 'Property' ? t.parent.type !== 'ObjectPattern' && (t.computed || e === t.value) : t.type !== 'MethodDefinition' && (t.type !== 'ExportSpecifier' || e === t.local))) : void 0 }(this, this.parent)) { if (e.arrow && this.name === 'arguments' && !this.findScope(!1).contains(this.name)) { const t = this.findLexicalBoundary(); const r = this.findNearest('ArrowFunctionExpression'); const n = this.findNearest(D); r && r.depth > t.depth && (this.alias = t.getArgumentsAlias()), n && n.body.contains(this) && n.depth > t.depth && (this.alias = t.getArgumentsAlias()) } this.findScope(!1).addReference(this) } }, Identifier.prototype.transpile = function transpile(e) { this.alias && e.overwrite(this.start, this.end, this.alias, { storeName: !0, contentOnly: !0 }) }, Identifier }(p)); const N = (function (e) { function IfStatement() { e.apply(this, arguments) } return e && (IfStatement.__proto__ = e), IfStatement.prototype = Object.create(e && e.prototype), IfStatement.prototype.constructor = IfStatement, IfStatement.prototype.initialise = function initialise(t) { e.prototype.initialise.call(this, t) }, IfStatement.prototype.transpile = function transpile(t, r) { (this.consequent.type !== 'BlockStatement' || this.consequent.type === 'BlockStatement' && this.consequent.synthetic) && (t.appendLeft(this.consequent.start, '{ '), t.prependRight(this.consequent.end, ' }')), this.alternate && this.alternate.type !== 'IfStatement' && (this.alternate.type !== 'BlockStatement' || this.alternate.type === 'BlockStatement' && this.alternate.synthetic) && (t.appendLeft(this.alternate.start, '{ '), t.prependRight(this.alternate.end, ' }')), e.prototype.transpile.call(this, t, r) }, IfStatement }(p)); const I = (function (e) { function ImportDeclaration() { e.apply(this, arguments) } return e && (ImportDeclaration.__proto__ = e), ImportDeclaration.prototype = Object.create(e && e.prototype), ImportDeclaration.prototype.constructor = ImportDeclaration, ImportDeclaration.prototype.initialise = function initialise(t) { if (t.moduleImport) throw new h('import is not supported', this); e.prototype.initialise.call(this, t) }, ImportDeclaration }(p)); const B = (function (e) { function ImportDefaultSpecifier() { e.apply(this, arguments) } return e && (ImportDefaultSpecifier.__proto__ = e), ImportDefaultSpecifier.prototype = Object.create(e && e.prototype), ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier, ImportDefaultSpecifier.prototype.initialise = function initialise(t) { this.findScope(!0).addDeclaration(this.local, 'import'), e.prototype.initialise.call(this, t) }, ImportDefaultSpecifier }(p)); const q = (function (e) { function ImportSpecifier() { e.apply(this, arguments) } return e && (ImportSpecifier.__proto__ = e), ImportSpecifier.prototype = Object.create(e && e.prototype), ImportSpecifier.prototype.constructor = ImportSpecifier, ImportSpecifier.prototype.initialise = function initialise(t) { this.findScope(!0).addDeclaration(this.local, 'import'), e.prototype.initialise.call(this, t) }, ImportSpecifier }(p)); const U = (function (e) { function JSXAttribute() { e.apply(this, arguments) } return e && (JSXAttribute.__proto__ = e), JSXAttribute.prototype = Object.create(e && e.prototype), JSXAttribute.prototype.constructor = JSXAttribute, JSXAttribute.prototype.transpile = function transpile(t, r) { let n; const i = this.name; const a = i.start; const o = i.name; const s = this.value ? this.value.start : this.name.end; t.overwrite(a, s, `${/-/.test(n = o) ? `'${n}'` : n}: ${this.value ? '' : 'true'}`), e.prototype.transpile.call(this, t, r) }, JSXAttribute }(p)); const z = (function (e) { function JSXClosingElement() { e.apply(this, arguments) } return e && (JSXClosingElement.__proto__ = e), JSXClosingElement.prototype = Object.create(e && e.prototype), JSXClosingElement.prototype.constructor = JSXClosingElement, JSXClosingElement.prototype.transpile = function transpile(e) { let t = !0; const r = this.parent.children[this.parent.children.length - 1]; (r && (function containsNewLine(e) { return e.type === 'JSXText' && !/\S/.test(e.value) && /\n/.test(e.value) }(r)) || this.parent.openingElement.attributes.length) && (t = !1), e.overwrite(this.start, this.end, t ? ' )' : ')') }, JSXClosingElement }(p)); const V = (function (e) { function JSXClosingFragment() { e.apply(this, arguments) } return e && (JSXClosingFragment.__proto__ = e), JSXClosingFragment.prototype = Object.create(e && e.prototype), JSXClosingFragment.prototype.constructor = JSXClosingFragment, JSXClosingFragment.prototype.transpile = function transpile(e) { let t = !0; const r = this.parent.children[this.parent.children.length - 1]; r && (function containsNewLine$1(e) { return e.type === 'JSXText' && !/\S/.test(e.value) && /\n/.test(e.value) }(r)) && (t = !1), e.overwrite(this.start, this.end, t ? ' )' : ')') }, JSXClosingFragment }(p)); function normalise(e, t) { return e = e.replace(/\u00a0/g, '&nbsp;'), t && /\n/.test(e) && (e = e.replace(/\s+$/, '')), e = e.replace(/^\n\r?\s+/, '').replace(/\s*\n\r?\s*/gm, ' '), JSON.stringify(e) } const H = (function (e) { function JSXElement() { e.apply(this, arguments) } return e && (JSXElement.__proto__ = e), JSXElement.prototype = Object.create(e && e.prototype), JSXElement.prototype.constructor = JSXElement, JSXElement.prototype.transpile = function transpile(t, r) { e.prototype.transpile.call(this, t, r); const n = this.children.filter(e => e.type !== 'JSXText' || (/\S/.test(e.raw) || !/\n/.test(e.raw))); if (n.length) { let i; let a = this.openingElement.end; for (i = 0; i < n.length; i += 1) { const o = n[i]; if (o.type === 'JSXExpressionContainer' && o.expression.type === 'JSXEmptyExpression');else { const s = t.original[a] === '\n' && o.type !== 'JSXText' ? '' : ' '; t.appendLeft(a, `,${s}`) } if (o.type === 'JSXText') { const u = normalise(o.value, i === n.length - 1); t.overwrite(o.start, o.end, u) }a = o.end } } }, JSXElement }(p)); const $ = (function (e) { function JSXExpressionContainer() { e.apply(this, arguments) } return e && (JSXExpressionContainer.__proto__ = e), JSXExpressionContainer.prototype = Object.create(e && e.prototype), JSXExpressionContainer.prototype.constructor = JSXExpressionContainer, JSXExpressionContainer.prototype.transpile = function transpile(t, r) { t.remove(this.start, this.expression.start), t.remove(this.expression.end, this.end), e.prototype.transpile.call(this, t, r) }, JSXExpressionContainer }(p)); const G = (function (e) { function JSXFragment() { e.apply(this, arguments) } return e && (JSXFragment.__proto__ = e), JSXFragment.prototype = Object.create(e && e.prototype), JSXFragment.prototype.constructor = JSXFragment, JSXFragment }(H)); const J = (function (e) { function JSXOpeningElement() { e.apply(this, arguments) } return e && (JSXOpeningElement.__proto__ = e), JSXOpeningElement.prototype = Object.create(e && e.prototype), JSXOpeningElement.prototype.constructor = JSXOpeningElement, JSXOpeningElement.prototype.transpile = function transpile(t, r) { e.prototype.transpile.call(this, t, r), t.overwrite(this.start, this.name.start, `${this.program.jsx}( `); const n = this.name.type === 'JSXIdentifier' && this.name.name[0] === this.name.name[0].toLowerCase(); n && t.prependRight(this.name.start, "'"); const i = this.attributes.length; let a = this.name.end; if (i) { let o; let s; let u; let l = !1; for (o = 0; o < i; o += 1) if (this.attributes[o].type === 'JSXSpreadAttribute') { l = !0; break } for (a = this.attributes[0].end, o = 0; o < i; o += 1) { const c = this.attributes[o]; if (o > 0 && (c.start === a ? t.prependRight(a, ', ') : t.overwrite(a, c.start, ', ')), l && c.type !== 'JSXSpreadAttribute') { const p = this.attributes[o - 1]; const f = this.attributes[o + 1]; p && p.type !== 'JSXSpreadAttribute' || t.prependRight(c.start, '{ '), f && f.type !== 'JSXSpreadAttribute' || t.appendLeft(c.end, ' }') }a = c.end } if (l) if (i === 1)u = n ? "'," : ','; else { if (!this.program.options.objectAssign) throw new h("Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper.", this); u = n ? `', ${this.program.options.objectAssign}({},` : `, ${this.program.options.objectAssign}({},`, s = ')' } else u = n ? "', {" : ', {', s = ' }'; t.prependRight(this.name.end, u), s && t.appendLeft(this.attributes[i - 1].end, s) } else t.appendLeft(this.name.end, n ? "', null" : ', null'), a = this.name.end; this.selfClosing ? t.overwrite(a, this.end, this.attributes.length ? ')' : ' )') : t.remove(a, this.end) }, JSXOpeningElement }(p)); const W = (function (e) { function JSXOpeningFragment() { e.apply(this, arguments) } return e && (JSXOpeningFragment.__proto__ = e), JSXOpeningFragment.prototype = Object.create(e && e.prototype), JSXOpeningFragment.prototype.constructor = JSXOpeningFragment, JSXOpeningFragment.prototype.transpile = function transpile(e, t) { e.overwrite(this.start, this.end, `${this.program.jsx}( React.Fragment, null`) }, JSXOpeningFragment }(p)); const K = (function (e) { function JSXSpreadAttribute() { e.apply(this, arguments) } return e && (JSXSpreadAttribute.__proto__ = e), JSXSpreadAttribute.prototype = Object.create(e && e.prototype), JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute, JSXSpreadAttribute.prototype.transpile = function transpile(t, r) { t.remove(this.start, this.argument.start), t.remove(this.argument.end, this.end), e.prototype.transpile.call(this, t, r) }, JSXSpreadAttribute }(p)); const X = createCommonjsModule((e, t) => {
      /*!
 * regjsgen 0.3.0
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Available under MIT license <https://github.com/demoneaux/regjsgen/blob/master/LICENSE>
 */
      (function () {
        const r = { function: !0, object: !0 }; let n = r[typeof window] && window || this; const i = r.object && t; const a = r.object && e && !e.nodeType && e; const o = i && a && typeof u === 'object' && u; !o || o.global !== o && o.window !== o && o.self !== o || (n = o); const s = Object.prototype.hasOwnProperty; const l = String.fromCharCode; const c = Math.floor; function fromCodePoint() { let e; let t; const r = []; let n = -1; const i = arguments.length; if (!i) return ''; for (var a = ''; ++n < i;) { let o = Number(arguments[n]); if (!isFinite(o) || o < 0 || o > 1114111 || c(o) != o) throw RangeError(`Invalid code point: ${o}`); o <= 65535 ? r.push(o) : (e = 55296 + ((o -= 65536) >> 10), t = o % 1024 + 56320, r.push(e, t)), (n + 1 == i || r.length > 16384) && (a += l(...r), r.length = 0) } return a } const p = {}; function assertType(e, t) { if (t.indexOf('|') == -1) { if (e == t) return; throw Error(`Invalid node type: ${e}; expected type: ${t}`) } if (!(t = s.call(p, t) ? p[t] : p[t] = RegExp(`^(?:${t})$`)).test(e)) throw Error(`Invalid node type: ${e}; expected types: ${t}`); } function generate(e) { const t = e.type; if (s.call(f, t)) return f[t](e); throw Error(`Invalid node type: ${t}`) } function generateClassAtom(e) { return assertType(e.type, 'anchor|characterClassEscape|characterClassRange|dot|value'), generate(e) } function generateTerm(e) { return assertType(e.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value'), generate(e) } var f = {
          alternative: function generateAlternative(e) { assertType(e.type, 'alternative'); for (var t = e.body, r = -1, n = t.length, i = ''; ++r < n;)i += generateTerm(t[r]); return i }, anchor: function generateAnchor(e) { switch (assertType(e.type, 'anchor'), e.kind) { case 'start': return '^'; case 'end': return '$'; case 'boundary': return '\\b'; case 'not-boundary': return '\\B'; default: throw Error('Invalid assertion'); } }, characterClass: function generateCharacterClass(e) { assertType(e.type, 'characterClass'); const t = e.body; let r = -1; const n = t.length; let i = ''; for (e.negative && (i += '^'); ++r < n;)i += generateClassAtom(t[r]); return `[${i}]` }, characterClassEscape: function generateCharacterClassEscape(e) { return assertType(e.type, 'characterClassEscape'), `\\${e.value}` }, characterClassRange: function generateCharacterClassRange(e) { assertType(e.type, 'characterClassRange'); const t = e.min; const r = e.max; if (t.type == 'characterClassRange' || r.type == 'characterClassRange') throw Error('Invalid character class range'); return `${generateClassAtom(t)}-${generateClassAtom(r)}` }, unicodePropertyEscape: function generateUnicodePropertyEscape(e) { return assertType(e.type, 'unicodePropertyEscape'), `\\${e.negative ? 'P' : 'p'}{${e.value}}` }, disjunction: function generateDisjunction(e) { assertType(e.type, 'disjunction'); for (var t = e.body, r = -1, n = t.length, i = ''; ++r < n;)r != 0 && (i += '|'), i += generate(t[r]); return i }, dot: function generateDot(e) { return assertType(e.type, 'dot'), '.' }, group: function generateGroup(e) { assertType(e.type, 'group'); let t = ''; switch (e.behavior) { case 'normal': break; case 'ignore': t += '?:'; break; case 'lookahead': t += '?='; break; case 'negativeLookahead': t += '?!'; break; default: throw Error(`Invalid behaviour: ${e.behaviour}`); } for (let r = e.body, n = -1, i = r.length; ++n < i;)t += generate(r[n]); return `(${t})` }, quantifier: function generateQuantifier(e) { assertType(e.type, 'quantifier'); let t = ''; const r = e.min; const n = e.max; return t = n == null ? r == 0 ? '*' : r == 1 ? '+' : `{${r},}` : r == n ? `{${r}}` : r == 0 && n == 1 ? '?' : `{${r},${n}}`, e.greedy || (t += '?'), (function generateAtom(e) { return assertType(e.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value'), generate(e) }(e.body[0])) + t }, reference: function generateReference(e) { return assertType(e.type, 'reference'), `\\${e.matchIndex}` }, value: function generateValue(e) { assertType(e.type, 'value'); const t = e.kind; const r = e.codePoint; switch (t) { case 'controlLetter': return `\\c${fromCodePoint(r + 64)}`; case 'hexadecimalEscape': return `\\x${(`00${r.toString(16).toUpperCase()}`).slice(-2)}`; case 'identifier': return `\\${fromCodePoint(r)}`; case 'null': return `\\${r}`; case 'octal': return `\\${r.toString(8)}`; case 'singleEscape': switch (r) { case 8: return '\\b'; case 9: return '\\t'; case 10: return '\\n'; case 11: return '\\v'; case 12: return '\\f'; case 13: return '\\r'; default: throw Error(`Invalid codepoint: ${r}`); } case 'symbol': return fromCodePoint(r); case 'unicodeEscape': return `\\u${(`0000${r.toString(16).toUpperCase()}`).slice(-4)}`; case 'unicodeCodePointEscape': return `\\u{${r.toString(16).toUpperCase()}}`; default: throw Error(`Unsupported node kind: ${t}`); } },
        }; i && a ? i.generate = generate : n.regjsgen = { generate };
      }).call(u);
    }); const Y = createCommonjsModule((e) => {
      !(function () {
        const t = {
          parse: function parse(e, t, r) {
            function addRaw(t) { return t.raw = e.substring(t.range[0], t.range[1]), t } function updateRawStart(e, t) { return e.range[0] = t, addRaw(e) } function createAnchor(e, t) { return addRaw({ type: 'anchor', kind: e, range: [s - t, s] }) } function createValue(e, t, r, n) {
              return addRaw({
                type: 'value', kind: e, codePoint: t, range: [r, n],
              });
            } function createEscaped(e, t, r, n) { return n = n || 0, createValue(e, t, s - (r.length + n), s) } function createCharacter(e) { let t; const r = e[0]; const n = r.charCodeAt(0); return o && r.length === 1 && n >= 55296 && n <= 56319 && (t = lookahead().charCodeAt(0)) >= 56320 && t <= 57343 ? createValue('symbol', 1024 * (n - 55296) + t - 56320 + 65536, ++s - 2, s) : createValue('symbol', n, s - 1, s) } function createQuantifier(e, t, r, n) {
              return n == null && (r = s - 1, n = s), addRaw({
                type: 'quantifier', min: e, max: t, greedy: !0, body: null, range: [r, n],
              });
            } function createCharacterClass(e, t, r, n) {
              return addRaw({
                type: 'characterClass', body: e, negative: t, range: [r, n],
              });
            } function createClassRange(e, t, r, n) {
              return e.codePoint > t.codePoint && bail('invalid range in character class', `${e.raw}-${t.raw}`, r, n), addRaw({
                type: 'characterClassRange', min: e, max: t, range: [r, n],
              });
            } function flattenBody(e) { return e.type === 'alternative' ? e.body : [e] } function incr(t) { t = t || 1; const r = e.substring(s, s + t); return s += t || 1, r } function skip(e) { match(e) || bail('character', e) } function match(t) { if (e.indexOf(t, s) === s) return incr(t.length); } function lookahead() { return e[s] } function current(t) { return e.indexOf(t, s) === s } function next(t) { return e[s + 1] === t } function matchReg(t) { const r = e.substring(s).match(t); return r && (r.range = [], r.range[0] = s, incr(r[0].length), r.range[1] = s), r } function parseDisjunction() { const e = []; const t = s; for (e.push(parseAlternative()); match('|');)e.push(parseAlternative()); return e.length === 1 ? e[0] : (function createDisjunction(e, t, r) { return addRaw({ type: 'disjunction', body: e, range: [t, r] }) }(e, t, s)) } function parseAlternative() { for (var e, t = [], r = s; e = parseTerm();)t.push(e); return t.length === 1 ? t[0] : (function createAlternative(e, t, r) { return addRaw({ type: 'alternative', body: e, range: [t, r] }) }(t, r, s)) } function parseTerm() { if (s >= e.length || current('|') || current(')')) return null; const t = (function parseAnchor() { return match('^') ? createAnchor('start', 1) : match('$') ? createAnchor('end', 1) : match('\\b') ? createAnchor('boundary', 2) : match('\\B') ? createAnchor('not-boundary', 2) : parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead') }()); if (t) return t; const r = (function parseAtom() { let e; return (e = matchReg(/^[^^$\\.*+?(){[|]/)) ? createCharacter(e) : match('.') ? (function createDot() { return addRaw({ type: 'dot', range: [s - 1, s] }) }()) : match('\\') ? ((e = parseAtomEscape()) || bail('atomEscape'), e) : (e = (function parseCharacterClass() { let e; const t = s; return (e = matchReg(/^\[\^/)) ? (e = parseClassRanges(), skip(']'), createCharacterClass(e, !0, t, s)) : match('[') ? (e = parseClassRanges(), skip(']'), createCharacterClass(e, !1, t, s)) : null }())) ? e : parseGroup('(?:', 'ignore', '(', 'normal') }()); r || bail('Expected atom'); const n = (function parseQuantifier() { let e; let t; let r; let n; const i = s; return match('*') ? t = createQuantifier(0) : match('+') ? t = createQuantifier(1) : match('?') ? t = createQuantifier(0, 1) : (e = matchReg(/^\{([0-9]+)\}/)) ? (r = parseInt(e[1], 10), t = createQuantifier(r, r, e.range[0], e.range[1])) : (e = matchReg(/^\{([0-9]+),\}/)) ? (r = parseInt(e[1], 10), t = createQuantifier(r, void 0, e.range[0], e.range[1])) : (e = matchReg(/^\{([0-9]+),([0-9]+)\}/)) && (r = parseInt(e[1], 10), n = parseInt(e[2], 10), r > n && bail('numbers out of order in {} quantifier', '', i, s), t = createQuantifier(r, n, e.range[0], e.range[1])), t && match('?') && (t.greedy = !1, t.range[1] += 1), t }()) || !1; return n ? (n.body = flattenBody(r), updateRawStart(n, r.range[0]), n) : r } function parseGroup(e, t, r, n) {
              let o = null; const u = s; if (match(e))o = t; else { if (!match(r)) return !1; o = n } const l = parseDisjunction(); l || bail('Expected disjunction'), skip(')'); const c = (function createGroup(e, t, r, n) {
                return addRaw({
                  type: 'group', behavior: e, body: t, range: [r, n],
                });
              }(o, flattenBody(l), u, s)); return o == 'normal' && a && i++, c;
            } function parseUnicodeSurrogatePairEscape(e) { let t; let r; if (o && e.kind == 'unicodeEscape' && (t = e.codePoint) >= 55296 && t <= 56319 && current('\\') && next('u')) { const n = s; s++; const i = parseClassEscape(); i.kind == 'unicodeEscape' && (r = i.codePoint) >= 56320 && r <= 57343 ? (e.range[1] = i.range[1], e.codePoint = 1024 * (t - 55296) + r - 56320 + 65536, e.type = 'value', e.kind = 'unicodeCodePointEscape', addRaw(e)) : s = n } return e } function parseClassEscape() { return parseAtomEscape(!0) } function parseAtomEscape(e) {
              let t; const a = s; if (t = (function parseDecimalEscape() { let e; let t; if (e = matchReg(/^(?!0)\d+/)) { t = e[0]; const r = parseInt(e[0], 10); return r <= i ? (function createReference(e) { return addRaw({ type: 'reference', matchIndex: parseInt(e, 10), range: [s - 1 - e.length, s] }) }(e[0])) : (n.push(r), incr(-e[0].length), (e = matchReg(/^[0-7]{1,3}/)) ? createEscaped('octal', parseInt(e[0], 8), e[0], 1) : updateRawStart(e = createCharacter(matchReg(/^[89]/)), e.range[0] - 1)) } return (e = matchReg(/^[0-7]{1,3}/)) ? (t = e[0], /^0{1,3}$/.test(t) ? createEscaped('null', 0, '0', t.length + 1) : createEscaped('octal', parseInt(t, 8), t, 1)) : !!(e = matchReg(/^[dDsSwW]/)) && (function createCharacterClassEscape(e) { return addRaw({ type: 'characterClassEscape', value: e, range: [s - 2, s] }) }(e[0])) }())) return t; if (e) { if (match('b')) return createEscaped('singleEscape', 8, '\\b'); match('B') && bail('\\B not possible inside of CharacterClass', '', a) } return t = (function parseCharacterEscape() {
                let e; if (e = matchReg(/^[fnrtv]/)) { let t = 0; switch (e[0]) { case 't': t = 9; break; case 'n': t = 10; break; case 'v': t = 11; break; case 'f': t = 12; break; case 'r': t = 13; } return createEscaped('singleEscape', t, `\\${e[0]}`) } return (e = matchReg(/^c([a-zA-Z])/)) ? createEscaped('controlLetter', e[1].charCodeAt(0) % 32, e[1], 2) : (e = matchReg(/^x([0-9a-fA-F]{2})/)) ? createEscaped('hexadecimalEscape', parseInt(e[1], 16), e[1], 2) : (e = matchReg(/^u([0-9a-fA-F]{4})/)) ? parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(e[1], 16), e[1], 2)) : o && (e = matchReg(/^u\{([0-9a-fA-F]+)\}/)) ? createEscaped('unicodeCodePointEscape', parseInt(e[1], 16), e[1], 4) : r.unicodePropertyEscape && o && (e = matchReg(/^([pP])\{([^\}]+)\}/)) ? addRaw({
                  type: 'unicodePropertyEscape', negative: e[1] === 'P', value: e[2], range: [e.range[0] - 1, e.range[1]], raw: e[0],
                }) : (function parseIdentityEscape() { let e; return (function isIdentifierPart(e) { const t = new RegExp('[--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]'); return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && t.test(String.fromCharCode(e)) }(lookahead())) ? match('') ? createEscaped('identifier', 8204, '') : match('') ? createEscaped('identifier', 8205, '') : null : createEscaped('identifier', (e = incr()).charCodeAt(0), e, 1) }());
              }());
            } function parseClassRanges() { let e; return current(']') ? [] : ((e = (function parseNonemptyClassRanges() { const e = parseClassAtom(); return e || bail('classAtom'), current(']') ? [e] : parseHelperClassRanges(e) }())) || bail('nonEmptyClassRanges'), e) } function parseHelperClassRanges(e) { let t; let r; let n; if (current('-') && !next(']')) { skip('-'), (n = parseClassAtom()) || bail('classAtom'), r = s; const i = parseClassRanges(); return i || bail('classRanges'), t = e.range[0], i.type === 'empty' ? [createClassRange(e, n, t, r)] : [createClassRange(e, n, t, r)].concat(i) } return (n = (function parseNonemptyClassRangesNoDash() { const e = parseClassAtom(); return e || bail('classAtom'), current(']') ? e : parseHelperClassRanges(e) }())) || bail('nonEmptyClassRangesNoDash'), [e].concat(n) } function parseClassAtom() { return match('-') ? createCharacter('-') : (function parseClassAtomNoDash() { let e; return (e = matchReg(/^[^\\\]-]/)) ? createCharacter(e[0]) : match('\\') ? ((e = parseClassEscape()) || bail('classEscape'), parseUnicodeSurrogatePairEscape(e)) : void 0 }()) } function bail(t, r, n, i) { n = n == null ? s : n, i = i == null ? n : i; const a = Math.max(0, n - 10); const o = Math.min(i + 10, e.length); const u = `    ${e.substring(a, o)}`; const l = `    ${new Array(n - a + 1).join(' ')}^`; throw SyntaxError(`${t} at position ${n}${r ? `: ${r}` : ''}\n${u}\n${l}`) }r || (r = {}); var n = []; var i = 0; var a = !0; var o = (t || '').indexOf('u') !== -1; var s = 0; (e = String(e)) === '' && (e = '(?:)'); const u = parseDisjunction(); u.range[1] !== e.length && bail('Could not parse entire input - got stuck', '', u.range[1]); for (let l = 0; l < n.length; l++) if (n[l] <= i) return s = 0, a = !1, parseDisjunction(); return u;
          },
        }; e.exports ? e.exports = t : window.regjsparser = t;
      }());
    }); const Q = createCommonjsModule((e, t) => {
      /*! https://mths.be/regenerate v1.3.3 by @mathias | MIT license */
      !(function (r) {
        const n = t; const i = e && e.exports == n && e; const a = typeof u === 'object' && u; a.global !== a && a.window !== a || (r = a); const o = 'A ranges `stop` value must be greater than or equal to the `start` value.'; const s = 'Invalid code point value. Code points range from U+000000 to U+10FFFF.'; const l = /\\x00([^0123456789]|$)/g; const c = {}; const p = c.hasOwnProperty; const f = function (e, t) { for (let r = -1, n = e.length; ++r < n;)t(e[r], r); }; const d = c.toString; const h = function (e) { return d.call(e) == '[object Array]' }; const m = function (e) { return typeof e === 'number' || d.call(e) == '[object Number]' }; const g = function (e, t) { const r = String(e); return r.length < t ? (`0000${r}`).slice(-t) : r }; const v = function (e) { return Number(e).toString(16).toUpperCase() }; const y = [].slice; const b = function (e, t) { for (var r, n, i = 0, a = e.length; i < a;) { if (r = e[i], n = e[i + 1], t >= r && t < n) return t == r ? n == r + 1 ? (e.splice(i, 2), e) : (e[i] = t + 1, e) : t == n - 1 ? (e[i + 1] = t, e) : (e.splice(i, 2, r, t, t + 1, n), e); i += 2 } return e }; const x = function (e, t, r) { if (r < t) throw Error(o); for (var n, i, a = 0; a < e.length;) { if (n = e[a], i = e[a + 1] - 1, n > r) return e; if (t <= n && r >= i)e.splice(a, 2); else { if (t >= n && r < i) return t == n ? (e[a] = r + 1, e[a + 1] = i + 1, e) : (e.splice(a, 2, n, t, r + 1, i + 1), e); if (t >= n && t <= i)e[a + 1] = t; else if (r >= n && r <= i) return e[a] = r + 1, e; a += 2 } } return e }; const D = function (e, t) { let r; let n; let i = 0; let a = null; const o = e.length; if (t < 0 || t > 1114111) throw RangeError(s); for (;i < o;) { if (r = e[i], n = e[i + 1], t >= r && t < n) return e; if (t == r - 1) return e[i] = t, e; if (r > t) return e.splice(a != null ? a + 2 : 0, 0, t, t + 1), e; if (t == n) return t + 1 == e[i + 2] ? (e.splice(i, 4, r, e[i + 3]), e) : (e[i + 1] = t + 1, e); a = i, i += 2 } return e.push(t, t + 1), e }; const _ = function (e, t) { for (var r, n, i = 0, a = e.slice(), o = t.length; i < o;)a = (r = t[i]) == (n = t[i + 1] - 1) ? D(a, r) : C(a, r, n), i += 2; return a }; var C = function (e, t, r) { if (r < t) throw Error(o); if (t < 0 || t > 1114111 || r < 0 || r > 1114111) throw RangeError(s); for (var n, i, a = 0, u = !1, l = e.length; a < l;) { if (n = e[a], i = e[a + 1], u) { if (n == r + 1) return e.splice(a - 1, 2), e; if (n > r) return e; n >= t && n <= r && (i > t && i - 1 <= r ? (e.splice(a, 2), a -= 2) : (e.splice(a - 1, 2), a -= 2)) } else { if (n == r + 1) return e[a] = t, e; if (n > r) return e.splice(a, 0, t, r + 1), e; if (t >= n && t < i && r + 1 <= i) return e; t >= n && t < i || i == t ? (e[a + 1] = r + 1, u = !0) : t <= n && r + 1 >= i && (e[a] = t, e[a + 1] = r + 1, u = !0) }a += 2 } return u || e.push(t, r + 1), e }; const w = function (e, t) { let r = 0; const n = e.length; let i = e[r]; let a = e[n - 1]; if (n >= 2 && (t < i || t > a)) return !1; for (;r < n;) { if (i = e[r], a = e[r + 1], t >= i && t < a) return !0; r += 2 } return !1 }; const E = function (e) { return !e.length }; const S = function (e) { return e.length == 2 && e[0] + 1 == e[1] }; const k = function (e) { for (var t, r, n = 0, i = [], a = e.length; n < a;) { for (t = e[n], r = e[n + 1]; t < r;)i.push(t), ++t; n += 2 } return i }; const A = Math.floor; const T = function (e) { return parseInt(A((e - 65536) / 1024) + 55296, 10) }; const P = function (e) { return parseInt((e - 65536) % 1024 + 56320, 10) }; const R = String.fromCharCode; const O = function (e) { return e == 9 ? '\\t' : e == 10 ? '\\n' : e == 12 ? '\\f' : e == 13 ? '\\r' : e == 92 ? '\\\\' : e == 36 || e >= 40 && e <= 43 || e >= 45 && e <= 47 || e == 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125 ? `\\${R(e)}` : e >= 32 && e <= 126 ? R(e) : e <= 255 ? `\\x${g(v(e), 2)}` : `\\u${g(v(e), 4)}` }; const F = function (e) { return e <= 65535 ? O(e) : `\\u{${e.toString(16).toUpperCase()}}` }; const L = function (e) { const t = e.length; const r = e.charCodeAt(0); return r >= 55296 && r <= 56319 && t > 1 ? 1024 * (r - 55296) + e.charCodeAt(1) - 56320 + 65536 : r }; const M = function (e) { let t; let r; let n = ''; let i = 0; const a = e.length; if (S(e)) return O(e[0]); for (;i < a;)n += (t = e[i]) == (r = e[i + 1] - 1) ? O(t) : t + 1 == r ? O(t) + O(r) : `${O(t)}-${O(r)}`, i += 2; return `[${n}]` }; const j = function (e) { if (e.length == 1) return e; for (let t = -1, r = -1; ++t < e.length;) { const n = e[t]; const i = n[1]; const a = i[0]; const o = i[1]; for (r = t; ++r < e.length;) { const s = e[r]; const u = s[1]; const l = u[0]; const c = u[1]; a == l && o == c && (S(s[0]) ? n[0] = D(n[0], s[0][0]) : n[0] = C(n[0], s[0][0], s[0][1] - 1), e.splice(r, 1), --r) } } return e }; const N = function (e) { if (!e.length) return []; for (var t, r, n, i, a, o, s = 0, u = [], l = e.length; s < l;) { t = e[s], r = e[s + 1] - 1, n = T(t), i = P(t), a = T(r); const c = (o = P(r)) == 57343; let p = !1; n == a || i == 56320 && c ? (u.push([[n, a + 1], [i, o + 1]]), p = !0) : u.push([[n, n + 1], [i, 57344]]), !p && n + 1 < a && (c ? (u.push([[n + 1, a + 1], [56320, o + 1]]), p = !0) : u.push([[n + 1, a], [56320, 57344]])), p || u.push([[a, a + 1], [56320, o + 1]]), s += 2 } return (function (e) { for (var t, r, n, i, a, o, s = [], u = [], l = !1, c = -1, p = e.length; ++c < p;) if (t = e[c], r = e[c + 1]) { for (n = t[0], i = t[1], a = r[0], o = r[1], u = i; a && n[0] == a[0] && n[1] == a[1];)u = S(o) ? D(u, o[0]) : C(u, o[0], o[1] - 1), n = (t = e[++c])[0], i = t[1], a = (r = e[c + 1]) && r[0], o = r && r[1], l = !0; s.push([n, l ? u : i]), l = !1 } else s.push(t); return j(s) }(u)) }; const I = function (e, t, r) {
          if (r) return (function (e) { let t; let r; let n = ''; let i = 0; const a = e.length; if (S(e)) return F(e[0]); for (;i < a;)n += (t = e[i]) == (r = e[i + 1] - 1) ? F(t) : t + 1 == r ? F(t) + F(r) : `${F(t)}-${F(r)}`, i += 2; return `[${n }]` }(e)); const n = []; const i = (function (e) {
            for (var t, r, n = [], i = [], a = [], o = [], s = 0, u = e.length; s < u;)t = e[s], r = e[s + 1] - 1, t < 55296 ? (r < 55296 && a.push(t, r + 1), r >= 55296 && r <= 56319 && (a.push(t, 55296), n.push(55296, r + 1)), r >= 56320 && r <= 57343 && (a.push(t, 55296), n.push(55296, 56320), i.push(56320, r + 1)), r > 57343 && (a.push(t, 55296), n.push(55296, 56320), i.push(56320, 57344), r <= 65535 ? a.push(57344, r + 1) : (a.push(57344, 65536), o.push(65536, r + 1)))) : t >= 55296 && t <= 56319 ? (r >= 55296 && r <= 56319 && n.push(t, r + 1), r >= 56320 && r <= 57343 && (n.push(t, 56320), i.push(56320, r + 1)), r > 57343 && (n.push(t, 56320), i.push(56320, 57344), r <= 65535 ? a.push(57344, r + 1) : (a.push(57344, 65536), o.push(65536, r + 1)))) : t >= 56320 && t <= 57343 ? (r >= 56320 && r <= 57343 && i.push(t, r + 1), r > 57343 && (i.push(t, 57344), r <= 65535 ? a.push(57344, r + 1) : (a.push(57344, 65536), o.push(65536, r + 1)))) : t > 57343 && t <= 65535 ? r <= 65535 ? a.push(t, r + 1) : (a.push(t, 65536), o.push(65536, r + 1)) : o.push(t, r + 1), s += 2; return {
              loneHighSurrogates: n, loneLowSurrogates: i, bmp: a, astral: o, 
            };
          }(e)); const a = i.loneHighSurrogates; const o = i.loneLowSurrogates; let s = i.bmp; const u = i.astral; let l = !E(a); let c = !E(o); const p = N(u); return t && (s = _(s, a), l = !1, s = _(s, o), c = !1), E(s) || n.push(M(s)), p.length && n.push(function (e) { const t = []; return f(e, (e) => { const r = e[0]; const n = e[1]; t.push(M(r) + M(n)) }), t.join('|') }(p)), l && n.push(`${M(a)}(?![\\uDC00-\\uDFFF])`), c && n.push(`(?:[^\\uD800-\\uDBFF]|^)${M(o)}`), n.join('|');
        }; var B = function (e) { return arguments.length > 1 && (e = y.call(arguments)), this instanceof B ? (this.data = [], e ? this.add(e) : this) : (new B()).add(e) }; B.version = '1.3.3'; const q = B.prototype; !(function (e, t) { let r; for (r in t)p.call(t, r) && (e[r] = t[r]); }(q, {
          add(e) { const t = this; return e == null ? t : e instanceof B ? (t.data = _(t.data, e.data), t) : (arguments.length > 1 && (e = y.call(arguments)), h(e) ? (f(e, (e) => { t.add(e) }), t) : (t.data = D(t.data, m(e) ? e : L(e)), t)) }, remove(e) { const t = this; return e == null ? t : e instanceof B ? (t.data = (function (e, t) { for (var r, n, i = 0, a = e.slice(), o = t.length; i < o;)a = (r = t[i]) == (n = t[i + 1] - 1) ? b(a, r) : x(a, r, n), i += 2; return a }(t.data, e.data)), t) : (arguments.length > 1 && (e = y.call(arguments)), h(e) ? (f(e, (e) => { t.remove(e) }), t) : (t.data = b(t.data, m(e) ? e : L(e)), t)) }, addRange(e, t) { return this.data = C(this.data, m(e) ? e : L(e), m(t) ? t : L(t)), this }, removeRange(e, t) { const r = m(e) ? e : L(e); const n = m(t) ? t : L(t); return this.data = x(this.data, r, n), this }, intersection(e) { const t = e instanceof B ? k(e.data) : e; return this.data = (function (e, t) { for (var r, n = 0, i = t.length, a = []; n < i;)r = t[n], w(e, r) && a.push(r), ++n; return (function (e) { for (var t, r = -1, n = e.length, i = n - 1, a = [], o = !0, s = 0; ++r < n;) if (t = e[r], o)a.push(t), s = t, o = !1; else if (t == s + 1) { if (r != i) { s = t; continue }o = !0, a.push(t + 1) } else a.push(s + 1, t), s = t; return o || a.push(t + 1), a }(a)) }(this.data, t)), this }, contains(e) { return w(this.data, m(e) ? e : L(e)) }, clone() { const e = new B(); return e.data = this.data.slice(0), e }, toString(e) { const t = I(this.data, !!e && e.bmpOnly, !!e && e.hasUnicodeFlag); return t ? t.replace(l, '\\0$1') : '[]' }, toRegExp(e) { const t = this.toString(e && e.indexOf('u') != -1 ? { hasUnicodeFlag: !0 } : null); return RegExp(t, e || '') }, valueOf() { return k(this.data) },
        })), q.toArray = q.valueOf, n && !n.nodeType ? i ? i.exports = B : n.regenerate = B : r.regenerate = B;
      }(u));
    }); const Z = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']); const ee = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['Ext', 'Extender'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]); const te = function (e) { if (Z.has(e)) return e; if (ee.has(e)) return ee.get(e); throw new Error(`Unknown property: ${e}`) }; const re = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]); const ne = function (e, t) { const r = re.get(e); if (!r) throw new Error(`Unknown property \`${e}\`.`); const n = r.get(t); if (n) return n; throw new Error(`Unknown value \`${t}\` for property \`${e}\`.`) }; const ie = new Map([[75, 8490], [83, 383], [107, 8490], [115, 383], [181, 924], [197, 8491], [223, 7838], [229, 8491], [383, 83], [452, 453], [453, 452], [455, 456], [456, 455], [458, 459], [459, 458], [497, 498], [498, 497], [618, 42926], [669, 42930], [837, 8126], [914, 976], [917, 1013], [920, 1012], [921, 8126], [922, 1008], [924, 181], [928, 982], [929, 1009], [931, 962], [934, 981], [937, 8486], [952, 1012], [962, 931], [969, 8486], [976, 914], [977, 1012], [981, 934], [982, 928], [1008, 922], [1009, 929], [1012, [920, 977, 952]], [1013, 917], [1042, 7296], [1044, 7297], [1054, 7298], [1057, 7299], [1058, 7301], [1066, 7302], [1074, 7296], [1076, 7297], [1086, 7298], [1089, 7299], [1090, [7300, 7301]], [1098, 7302], [1122, 7303], [1123, 7303], [5024, 43888], [5025, 43889], [5026, 43890], [5027, 43891], [5028, 43892], [5029, 43893], [5030, 43894], [5031, 43895], [5032, 43896], [5033, 43897], [5034, 43898], [5035, 43899], [5036, 43900], [5037, 43901], [5038, 43902], [5039, 43903], [5040, 43904], [5041, 43905], [5042, 43906], [5043, 43907], [5044, 43908], [5045, 43909], [5046, 43910], [5047, 43911], [5048, 43912], [5049, 43913], [5050, 43914], [5051, 43915], [5052, 43916], [5053, 43917], [5054, 43918], [5055, 43919], [5056, 43920], [5057, 43921], [5058, 43922], [5059, 43923], [5060, 43924], [5061, 43925], [5062, 43926], [5063, 43927], [5064, 43928], [5065, 43929], [5066, 43930], [5067, 43931], [5068, 43932], [5069, 43933], [5070, 43934], [5071, 43935], [5072, 43936], [5073, 43937], [5074, 43938], [5075, 43939], [5076, 43940], [5077, 43941], [5078, 43942], [5079, 43943], [5080, 43944], [5081, 43945], [5082, 43946], [5083, 43947], [5084, 43948], [5085, 43949], [5086, 43950], [5087, 43951], [5088, 43952], [5089, 43953], [5090, 43954], [5091, 43955], [5092, 43956], [5093, 43957], [5094, 43958], [5095, 43959], [5096, 43960], [5097, 43961], [5098, 43962], [5099, 43963], [5100, 43964], [5101, 43965], [5102, 43966], [5103, 43967], [5104, 5112], [5105, 5113], [5106, 5114], [5107, 5115], [5108, 5116], [5109, 5117], [5112, 5104], [5113, 5105], [5114, 5106], [5115, 5107], [5116, 5108], [5117, 5109], [7296, [1042, 1074]], [7297, [1044, 1076]], [7298, [1054, 1086]], [7299, [1057, 1089]], [7300, [7301, 1090]], [7301, [1058, 7300, 1090]], [7302, [1066, 1098]], [7303, [1122, 1123]], [7304, [42570, 42571]], [7776, 7835], [7835, 7776], [7838, 223], [8064, 8072], [8065, 8073], [8066, 8074], [8067, 8075], [8068, 8076], [8069, 8077], [8070, 8078], [8071, 8079], [8072, 8064], [8073, 8065], [8074, 8066], [8075, 8067], [8076, 8068], [8077, 8069], [8078, 8070], [8079, 8071], [8080, 8088], [8081, 8089], [8082, 8090], [8083, 8091], [8084, 8092], [8085, 8093], [8086, 8094], [8087, 8095], [8088, 8080], [8089, 8081], [8090, 8082], [8091, 8083], [8092, 8084], [8093, 8085], [8094, 8086], [8095, 8087], [8096, 8104], [8097, 8105], [8098, 8106], [8099, 8107], [8100, 8108], [8101, 8109], [8102, 8110], [8103, 8111], [8104, 8096], [8105, 8097], [8106, 8098], [8107, 8099], [8108, 8100], [8109, 8101], [8110, 8102], [8111, 8103], [8115, 8124], [8124, 8115], [8126, [837, 921]], [8131, 8140], [8140, 8131], [8179, 8188], [8188, 8179], [8486, [937, 969]], [8490, 75], [8491, [197, 229]], [42570, 7304], [42571, 7304], [42926, 618], [42930, 669], [42931, 43859], [42932, 42933], [42933, 42932], [42934, 42935], [42935, 42934], [43859, 42931], [43888, 5024], [43889, 5025], [43890, 5026], [43891, 5027], [43892, 5028], [43893, 5029], [43894, 5030], [43895, 5031], [43896, 5032], [43897, 5033], [43898, 5034], [43899, 5035], [43900, 5036], [43901, 5037], [43902, 5038], [43903, 5039], [43904, 5040], [43905, 5041], [43906, 5042], [43907, 5043], [43908, 5044], [43909, 5045], [43910, 5046], [43911, 5047], [43912, 5048], [43913, 5049], [43914, 5050], [43915, 5051], [43916, 5052], [43917, 5053], [43918, 5054], [43919, 5055], [43920, 5056], [43921, 5057], [43922, 5058], [43923, 5059], [43924, 5060], [43925, 5061], [43926, 5062], [43927, 5063], [43928, 5064], [43929, 5065], [43930, 5066], [43931, 5067], [43932, 5068], [43933, 5069], [43934, 5070], [43935, 5071], [43936, 5072], [43937, 5073], [43938, 5074], [43939, 5075], [43940, 5076], [43941, 5077], [43942, 5078], [43943, 5079], [43944, 5080], [43945, 5081], [43946, 5082], [43947, 5083], [43948, 5084], [43949, 5085], [43950, 5086], [43951, 5087], [43952, 5088], [43953, 5089], [43954, 5090], [43955, 5091], [43956, 5092], [43957, 5093], [43958, 5094], [43959, 5095], [43960, 5096], [43961, 5097], [43962, 5098], [43963, 5099], [43964, 5100], [43965, 5101], [43966, 5102], [43967, 5103], [66560, 66600], [66561, 66601], [66562, 66602], [66563, 66603], [66564, 66604], [66565, 66605], [66566, 66606], [66567, 66607], [66568, 66608], [66569, 66609], [66570, 66610], [66571, 66611], [66572, 66612], [66573, 66613], [66574, 66614], [66575, 66615], [66576, 66616], [66577, 66617], [66578, 66618], [66579, 66619], [66580, 66620], [66581, 66621], [66582, 66622], [66583, 66623], [66584, 66624], [66585, 66625], [66586, 66626], [66587, 66627], [66588, 66628], [66589, 66629], [66590, 66630], [66591, 66631], [66592, 66632], [66593, 66633], [66594, 66634], [66595, 66635], [66596, 66636], [66597, 66637], [66598, 66638], [66599, 66639], [66600, 66560], [66601, 66561], [66602, 66562], [66603, 66563], [66604, 66564], [66605, 66565], [66606, 66566], [66607, 66567], [66608, 66568], [66609, 66569], [66610, 66570], [66611, 66571], [66612, 66572], [66613, 66573], [66614, 66574], [66615, 66575], [66616, 66576], [66617, 66577], [66618, 66578], [66619, 66579], [66620, 66580], [66621, 66581], [66622, 66582], [66623, 66583], [66624, 66584], [66625, 66585], [66626, 66586], [66627, 66587], [66628, 66588], [66629, 66589], [66630, 66590], [66631, 66591], [66632, 66592], [66633, 66593], [66634, 66594], [66635, 66595], [66636, 66596], [66637, 66597], [66638, 66598], [66639, 66599], [66736, 66776], [66737, 66777], [66738, 66778], [66739, 66779], [66740, 66780], [66741, 66781], [66742, 66782], [66743, 66783], [66744, 66784], [66745, 66785], [66746, 66786], [66747, 66787], [66748, 66788], [66749, 66789], [66750, 66790], [66751, 66791], [66752, 66792], [66753, 66793], [66754, 66794], [66755, 66795], [66756, 66796], [66757, 66797], [66758, 66798], [66759, 66799], [66760, 66800], [66761, 66801], [66762, 66802], [66763, 66803], [66764, 66804], [66765, 66805], [66766, 66806], [66767, 66807], [66768, 66808], [66769, 66809], [66770, 66810], [66771, 66811], [66776, 66736], [66777, 66737], [66778, 66738], [66779, 66739], [66780, 66740], [66781, 66741], [66782, 66742], [66783, 66743], [66784, 66744], [66785, 66745], [66786, 66746], [66787, 66747], [66788, 66748], [66789, 66749], [66790, 66750], [66791, 66751], [66792, 66752], [66793, 66753], [66794, 66754], [66795, 66755], [66796, 66756], [66797, 66757], [66798, 66758], [66799, 66759], [66800, 66760], [66801, 66761], [66802, 66762], [66803, 66763], [66804, 66764], [66805, 66765], [66806, 66766], [66807, 66767], [66808, 66768], [66809, 66769], [66810, 66770], [66811, 66771], [68736, 68800], [68737, 68801], [68738, 68802], [68739, 68803], [68740, 68804], [68741, 68805], [68742, 68806], [68743, 68807], [68744, 68808], [68745, 68809], [68746, 68810], [68747, 68811], [68748, 68812], [68749, 68813], [68750, 68814], [68751, 68815], [68752, 68816], [68753, 68817], [68754, 68818], [68755, 68819], [68756, 68820], [68757, 68821], [68758, 68822], [68759, 68823], [68760, 68824], [68761, 68825], [68762, 68826], [68763, 68827], [68764, 68828], [68765, 68829], [68766, 68830], [68767, 68831], [68768, 68832], [68769, 68833], [68770, 68834], [68771, 68835], [68772, 68836], [68773, 68837], [68774, 68838], [68775, 68839], [68776, 68840], [68777, 68841], [68778, 68842], [68779, 68843], [68780, 68844], [68781, 68845], [68782, 68846], [68783, 68847], [68784, 68848], [68785, 68849], [68786, 68850], [68800, 68736], [68801, 68737], [68802, 68738], [68803, 68739], [68804, 68740], [68805, 68741], [68806, 68742], [68807, 68743], [68808, 68744], [68809, 68745], [68810, 68746], [68811, 68747], [68812, 68748], [68813, 68749], [68814, 68750], [68815, 68751], [68816, 68752], [68817, 68753], [68818, 68754], [68819, 68755], [68820, 68756], [68821, 68757], [68822, 68758], [68823, 68759], [68824, 68760], [68825, 68761], [68826, 68762], [68827, 68763], [68828, 68764], [68829, 68765], [68830, 68766], [68831, 68767], [68832, 68768], [68833, 68769], [68834, 68770], [68835, 68771], [68836, 68772], [68837, 68773], [68838, 68774], [68839, 68775], [68840, 68776], [68841, 68777], [68842, 68778], [68843, 68779], [68844, 68780], [68845, 68781], [68846, 68782], [68847, 68783], [68848, 68784], [68849, 68785], [68850, 68786], [71840, 71872], [71841, 71873], [71842, 71874], [71843, 71875], [71844, 71876], [71845, 71877], [71846, 71878], [71847, 71879], [71848, 71880], [71849, 71881], [71850, 71882], [71851, 71883], [71852, 71884], [71853, 71885], [71854, 71886], [71855, 71887], [71856, 71888], [71857, 71889], [71858, 71890], [71859, 71891], [71860, 71892], [71861, 71893], [71862, 71894], [71863, 71895], [71864, 71896], [71865, 71897], [71866, 71898], [71867, 71899], [71868, 71900], [71869, 71901], [71870, 71902], [71871, 71903], [71872, 71840], [71873, 71841], [71874, 71842], [71875, 71843], [71876, 71844], [71877, 71845], [71878, 71846], [71879, 71847], [71880, 71848], [71881, 71849], [71882, 71850], [71883, 71851], [71884, 71852], [71885, 71853], [71886, 71854], [71887, 71855], [71888, 71856], [71889, 71857], [71890, 71858], [71891, 71859], [71892, 71860], [71893, 71861], [71894, 71862], [71895, 71863], [71896, 71864], [71897, 71865], [71898, 71866], [71899, 71867], [71900, 71868], [71901, 71869], [71902, 71870], [71903, 71871], [125184, 125218], [125185, 125219], [125186, 125220], [125187, 125221], [125188, 125222], [125189, 125223], [125190, 125224], [125191, 125225], [125192, 125226], [125193, 125227], [125194, 125228], [125195, 125229], [125196, 125230], [125197, 125231], [125198, 125232], [125199, 125233], [125200, 125234], [125201, 125235], [125202, 125236], [125203, 125237], [125204, 125238], [125205, 125239], [125206, 125240], [125207, 125241], [125208, 125242], [125209, 125243], [125210, 125244], [125211, 125245], [125212, 125246], [125213, 125247], [125214, 125248], [125215, 125249], [125216, 125250], [125217, 125251], [125218, 125184], [125219, 125185], [125220, 125186], [125221, 125187], [125222, 125188], [125223, 125189], [125224, 125190], [125225, 125191], [125226, 125192], [125227, 125193], [125228, 125194], [125229, 125195], [125230, 125196], [125231, 125197], [125232, 125198], [125233, 125199], [125234, 125200], [125235, 125201], [125236, 125202], [125237, 125203], [125238, 125204], [125239, 125205], [125240, 125206], [125241, 125207], [125242, 125208], [125243, 125209], [125244, 125210], [125245, 125211], [125246, 125212], [125247, 125213], [125248, 125214], [125249, 125215], [125250, 125216], [125251, 125217]]); const ae = {
      REGULAR: new Map([['d', Q().addRange(48, 57)], ['D', Q().addRange(0, 47).addRange(58, 65535)], ['s', Q(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)], ['S', Q().addRange(0, 8).addRange(14, 31).addRange(33, 159)
        .addRange(161, 5759)
        .addRange(5761, 8191)
        .addRange(8203, 8231)
        .addRange(8234, 8238)
        .addRange(8240, 8286)
        .addRange(8288, 12287)
        .addRange(12289, 65278)
        .addRange(65280, 65535)], ['w', Q(95).addRange(48, 57).addRange(65, 90).addRange(97, 122)], ['W', Q(96).addRange(0, 47).addRange(58, 64).addRange(91, 94)
        .addRange(123, 65535)]]),
      UNICODE: new Map([['d', Q().addRange(48, 57)], ['D', Q().addRange(0, 47).addRange(58, 1114111)], ['s', Q(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)], ['S', Q().addRange(0, 8).addRange(14, 31).addRange(33, 159)
        .addRange(161, 5759)
        .addRange(5761, 8191)
        .addRange(8203, 8231)
        .addRange(8234, 8238)
        .addRange(8240, 8286)
        .addRange(8288, 12287)
        .addRange(12289, 65278)
        .addRange(65280, 1114111)], ['w', Q(95).addRange(48, 57).addRange(65, 90).addRange(97, 122)], ['W', Q(96).addRange(0, 47).addRange(58, 64).addRange(91, 94)
        .addRange(123, 1114111)]]),
      UNICODE_IGNORE_CASE: new Map([['d', Q().addRange(48, 57)], ['D', Q().addRange(0, 47).addRange(58, 1114111)], ['s', Q(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)], ['S', Q().addRange(0, 8).addRange(14, 31).addRange(33, 159)
        .addRange(161, 5759)
        .addRange(5761, 8191)
        .addRange(8203, 8231)
        .addRange(8234, 8238)
        .addRange(8240, 8286)
        .addRange(8288, 12287)
        .addRange(12289, 65278)
        .addRange(65280, 1114111)], ['w', Q(95, 383, 8490).addRange(48, 57).addRange(65, 90).addRange(97, 122)], ['W', Q(96).addRange(0, 47).addRange(58, 64).addRange(91, 94)
        .addRange(123, 382)
        .addRange(384, 8489)
        .addRange(8491, 1114111)]]),
    }; const oe = createCommonjsModule((e) => {
      const t = X.generate; const r = Y.parse; const n = Q().addRange(0, 1114111); const i = Q().addRange(0, 65535); const a = n.clone().remove(10, 13, 8232, 8233); const o = a.clone().intersection(i); const s = function (e, t, r) { return t ? r ? ae.UNICODE_IGNORE_CASE.get(e) : ae.UNICODE.get(e) : ae.REGULAR.get(e) }; const u = function (e, t) { try { return (function commonjsRequire() { throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs') }()) } catch (r) { throw new Error(`Failed to recognize value \`${t}\` for property \`${e}\`.`) } }; const l = function (e, t) { let r; const i = e.split('='); const a = i[0]; if (i.length == 1)r = (function (e) { try { const t = ne('General_Category', e); return u('General_Category', t) } catch (e) {} const r = te(e); return u(r) }(a)); else { const o = te(a); const s = ne(o, i[1]); r = u(o, s) } return t ? n.clone().remove(r) : r.clone() }; Q.prototype.iuAddRange = function (e, t) { do { const r = f(e); r && this.add(r) } while (++e <= t);return this }; const c = function (e, t) { let n = r(t, h.useUnicodeFlag ? 'u' : ''); switch (n.type) { case 'characterClass': case 'group': case 'value': break; default: n = p(n, t); }Object.assign(e, n) }; var p = function (e, t) {
        return {
          type: 'group', behavior: 'ignore', body: [e], raw: `(?:${t})`,
        };
      }; var f = function (e) { return ie.get(e) || !1 }; var d = function (e, t) { switch (e.type) { case 'dot': c(e, (m = h.unicode, g = h.dotAll, g ? m ? n : i : m ? a : o).toString(t)); break; case 'characterClass': e = (function (e, t) { for (var r = Q(), a = 0, o = e.body; a < o.length; a += 1) { const u = o[a]; switch (u.type) { case 'value': if (r.add(u.codePoint), h.ignoreCase && h.unicode && !h.useUnicodeFlag) { const p = f(u.codePoint); p && r.add(p) } break; case 'characterClassRange': var d = u.min.codePoint; var m = u.max.codePoint; r.addRange(d, m), h.ignoreCase && h.unicode && !h.useUnicodeFlag && r.iuAddRange(d, m); break; case 'characterClassEscape': r.add(s(u.value, h.unicode, h.ignoreCase)); break; case 'unicodePropertyEscape': r.add(l(u.value, u.negative)); break; default: throw new Error(`Unknown term type: ${u.type}`); } } return e.negative && (r = (h.unicode ? n : i).clone().remove(r)), c(e, r.toString(t)), e }(e, t)); break; case 'unicodePropertyEscape': c(e, l(e.value, e.negative).toString(t)); break; case 'characterClassEscape': c(e, s(e.value, h.unicode, h.ignoreCase).toString(t)); break; case 'alternative': case 'disjunction': case 'group': case 'quantifier': e.body = e.body.map(e => d(e, t)); break; case 'value': var r = e.codePoint; var u = Q(r); if (h.ignoreCase && h.unicode && !h.useUnicodeFlag) { const p = f(r); p && u.add(p) }c(e, u.toString(t)); break; case 'anchor': case 'empty': case 'group': case 'reference': break; default: throw new Error(`Unknown term type: ${e.type}`); } let m; let g; return e }; var h = {
        ignoreCase: !1, unicode: !1, dotAll: !1, useUnicodeFlag: !1,
      }; e.exports = function (e, n, i) { const a = { unicodePropertyEscape: i && i.unicodePropertyEscape }; h.ignoreCase = n && n.includes('i'), h.unicode = n && n.includes('u'); const o = i && i.dotAllFlag; h.dotAll = o && n && n.includes('s'), h.useUnicodeFlag = i && i.useUnicodeFlag; const s = { hasUnicodeFlag: h.useUnicodeFlag, bmpOnly: !h.unicode }; const u = r(e, n, a); return d(u, s), t(u) };
    }); const se = {
      ArrayExpression: v,
      ArrowFunctionExpression: y,
      AssignmentExpression: b,
      BinaryExpression: x,
      BreakStatement: _,
      CallExpression: C,
      ClassBody: w,
      ClassDeclaration: E,
      ClassExpression: S,
      ContinueStatement: k,
      DoWhileStatement: P,
      ExportNamedDeclaration: T,
      ExportDefaultDeclaration: A,
      ForStatement: R,
      ForInStatement: O,
      ForOfStatement: F,
      FunctionDeclaration: L,
      FunctionExpression: M,
      Identifier: j,
      IfStatement: N,
      ImportDeclaration: I,
      ImportDefaultSpecifier: B,
      ImportSpecifier: q,
      JSXAttribute: U,
      JSXClosingElement: z,
      JSXClosingFragment: V,
      JSXElement: H,
      JSXExpressionContainer: $,
      JSXFragment: G,
      JSXOpeningElement: J,
      JSXOpeningFragment: W,
      JSXSpreadAttribute: K,
      Literal: (function (e) { function Literal() { e.apply(this, arguments) } return e && (Literal.__proto__ = e), Literal.prototype = Object.create(e && e.prototype), Literal.prototype.constructor = Literal, Literal.prototype.initialise = function initialise() { typeof this.value === 'string' && this.program.indentExclusionElements.push(this) }, Literal.prototype.transpile = function transpile(e, t) { if (t.numericLiteral) { const r = this.raw.slice(0, 2); r !== '0b' && r !== '0o' || e.overwrite(this.start, this.end, String(this.value), { storeName: !0, contentOnly: !0 }) } if (this.regex) { const n = this.regex; const i = n.pattern; const a = n.flags; if (t.stickyRegExp && /y/.test(a)) throw new h('Regular expression sticky flag is not supported', this); t.unicodeRegExp && /u/.test(a) && e.overwrite(this.start, this.end, `/${oe(i, a)}/${a.replace('u', '')}`, { contentOnly: !0 }) } }, Literal }(p)),
      MemberExpression: (function (e) { function MemberExpression() { e.apply(this, arguments) } return e && (MemberExpression.__proto__ = e), MemberExpression.prototype = Object.create(e && e.prototype), MemberExpression.prototype.constructor = MemberExpression, MemberExpression.prototype.transpile = function transpile(t, r) { r.reservedProperties && d[this.property.name] && (t.overwrite(this.object.end, this.property.start, "['"), t.appendLeft(this.property.end, "']")), e.prototype.transpile.call(this, t, r) }, MemberExpression }(p)),
      NewExpression: (function (e) { function NewExpression() { e.apply(this, arguments) } return e && (NewExpression.__proto__ = e), NewExpression.prototype = Object.create(e && e.prototype), NewExpression.prototype.constructor = NewExpression, NewExpression.prototype.initialise = function initialise(t) { if (t.spreadRest && this.arguments.length) for (let r = this.findLexicalBoundary(), n = this.arguments.length; n--;) { const i = this.arguments[n]; if (i.type === 'SpreadElement' && isArguments(i.argument)) { this.argumentsArrayAlias = r.getArgumentsArrayAlias(); break } }e.prototype.initialise.call(this, t) }, NewExpression.prototype.transpile = function transpile(t, r) { if (e.prototype.transpile.call(this, t, r), r.spreadRest && this.arguments.length) { const n = this.arguments[0]; spread(t, this.arguments, n.start, this.argumentsArrayAlias, !0) && (t.prependRight(this.start + 'new'.length, ' (Function.prototype.bind.apply('), t.overwrite(this.callee.end, n.start, ', [ null ].concat( '), t.appendLeft(this.end, ' ))')) } this.arguments.length && removeTrailingComma(t, this.arguments[this.arguments.length - 1].end) }, NewExpression }(p)),
      ObjectExpression: (function (e) { function ObjectExpression() { e.apply(this, arguments) } return e && (ObjectExpression.__proto__ = e), ObjectExpression.prototype = Object.create(e && e.prototype), ObjectExpression.prototype.constructor = ObjectExpression, ObjectExpression.prototype.transpile = function transpile(t, r) { e.prototype.transpile.call(this, t, r); for (var n = this.start + 1, i = 0, a = 0, o = 0, s = null, u = null, l = 0; l < this.properties.length; ++l) { const c = this.properties[l]; c.type === 'SpreadElement' ? (a += 1, s === null && (s = l)) : c.computed ? (o += 1, u === null && (u = l)) : c.type === 'Property' && (i += 1) } if (a) { if (!this.program.options.objectAssign) throw new h("Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper.", this); let p = this.properties.length; if (i && !o) for (;p--;) { const f = this.properties[p]; if (f.type === 'Property' && !f.computed) { const d = this.properties[p - 1]; const m = this.properties[p + 1]; d && d.type === 'Property' && !d.computed || t.prependRight(f.start, '{'), m && m.type === 'Property' && !m.computed || t.appendLeft(f.end, '}') } }n = this.properties[0].start, o ? this.properties[0].type === 'SpreadElement' ? (t.overwrite(this.start, n, `${this.program.options.objectAssign}({}, `), t.remove(this.end - 1, this.end), t.appendRight(this.end, ')')) : (t.prependLeft(this.start, `${this.program.options.objectAssign}(`), t.appendRight(this.end, ')')) : (t.overwrite(this.start, n, `${this.program.options.objectAssign}({}, `), t.overwrite(this.properties[this.properties.length - 1].end, this.end, ')')) } if (o && r.computedProperty) { let g; let v; const y = this.getIndentation(); this.parent.type === 'VariableDeclarator' && this.parent.parent.declarations.length === 1 && this.parent.id.type === 'Identifier' ? (g = !0, v = this.parent.id.alias || this.parent.id.name) : this.parent.type === 'AssignmentExpression' && this.parent.parent.type === 'ExpressionStatement' && this.parent.left.type === 'Identifier' ? (g = !0, v = this.parent.left.alias || this.parent.left.name) : this.parent.type === 'AssignmentPattern' && this.parent.left.type === 'Identifier' && (g = !0, v = this.parent.left.alias || this.parent.left.name), a && (g = !1), v = this.findScope(!1).resolveName(v); const b = n; const x = this.end; g || (s === null || u < s ? (v = this.findScope(!0).createDeclaration('obj'), t.prependRight(this.start, `( ${v} = `)) : v = null); for (var D, _ = this.properties.length, C = !1, w = !0, E = 0; E < _; E += 1) { const S = this.properties[E]; let k = E > 0 ? this.properties[E - 1].end : b; if (S.type === 'Property' && (S.computed || D && !a)) { if (E === 0 && (k = this.start + 1), D = S, v) { const A = (g ? `;\n${y}${v}` : `, ${v}`) + (S.key.type === 'Literal' || S.computed ? '' : '.'); k < S.start ? t.overwrite(k, S.start, A) : t.prependRight(S.start, A) } else { const T = (v = this.findScope(!0).createDeclaration('obj')) + (S.computed ? '' : '.'); t.appendRight(S.start, `( ${v} = {}, ${T}`) } let P = S.key.end; if (S.computed) { for (;t.original[P] !== ']';)P += 1; P += 1 }S.key.type !== 'Literal' || S.computed ? S.shorthand || S.method && !S.computed && r.conciseMethodProperty ? t.overwrite(S.key.start, S.key.end, t.slice(S.key.start, S.key.end).replace(/:/, ' =')) : (S.value.start > P && t.remove(P, S.value.start), t.prependLeft(P, ' = ')) : t.overwrite(S.start, S.key.end + 1, `[${t.slice(S.start, S.key.end)}] = `), !S.method || !S.computed && r.conciseMethodProperty || (S.value.generator && t.remove(S.start, S.key.start), t.prependRight(S.value.start, `function${S.value.generator ? '*' : ''} `)) } else S.type === 'SpreadElement' ? v && E > 0 && (D || (D = this.properties[E - 1]), t.appendLeft(D.end, `, ${v} )`), D = null, v = null) : (!w && a && (t.prependRight(S.start, '{'), t.appendLeft(S.end, '}')), C = !0); if (w && (S.type === 'SpreadElement' || S.computed)) { let R = C ? this.properties[this.properties.length - 1].end : this.end - 1; t.original[R] == ',' && ++R; const O = t.slice(R, x); t.prependLeft(k, O), t.remove(R, x), w = !1 } let F = S.end; if (E < _ - 1 && !C) for (;t.original[F] !== ',';)F += 1; else E == _ - 1 && (F = this.end); t.remove(S.end, F) }o === _ && t.remove(this.properties[_ - 1].end, this.end - 1), !g && v && t.appendLeft(D.end, `, ${v} )`) } }, ObjectExpression }(p)),
      Property: (function (e) { function Property() { e.apply(this, arguments) } return e && (Property.__proto__ = e), Property.prototype = Object.create(e && e.prototype), Property.prototype.constructor = Property, Property.prototype.transpile = function transpile(t, r) { if (e.prototype.transpile.call(this, t, r), r.conciseMethodProperty && !this.computed && this.parent.type !== 'ObjectPattern') if (this.shorthand)t.prependRight(this.start, `${this.key.name}: `); else if (this.method) { let n = ''; !1 !== this.program.options.namedFunctionExpressions && (n = ` ${n = this.key.type === 'Literal' && typeof this.key.value === 'number' ? '' : this.key.type === 'Identifier' ? d[this.key.name] || !/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) || this.value.body.scope.references[this.key.name] ? this.findScope(!0).createIdentifier(this.key.name) : this.key.name : this.findScope(!0).createIdentifier(this.key.value)}`), this.value.generator && t.remove(this.start, this.key.start), t.appendLeft(this.key.end, `: function${this.value.generator ? '*' : ''}${n}`) }r.reservedProperties && d[this.key.name] && (t.prependRight(this.key.start, "'"), t.appendLeft(this.key.end, "'")) }, Property }(p)),
      ReturnStatement: (function (e) { function ReturnStatement() { e.apply(this, arguments) } return e && (ReturnStatement.__proto__ = e), ReturnStatement.prototype = Object.create(e && e.prototype), ReturnStatement.prototype.constructor = ReturnStatement, ReturnStatement.prototype.initialise = function initialise(e) { this.loop = this.findNearest(D), this.nearestFunction = this.findNearest(/Function/), this.loop && (!this.nearestFunction || this.loop.depth > this.nearestFunction.depth) && (this.loop.canReturn = !0, this.shouldWrap = !0), this.argument && this.argument.initialise(e) }, ReturnStatement.prototype.transpile = function transpile(e, t) { const r = this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction; this.argument ? (r && e.prependRight(this.argument.start, '{ v: '), this.argument.transpile(e, t), r && e.appendLeft(this.argument.end, ' }')) : r && e.appendLeft(this.start + 6, ' {}') }, ReturnStatement }(p)),
      SpreadElement: (function (e) { function SpreadElement() { e.apply(this, arguments) } return e && (SpreadElement.__proto__ = e), SpreadElement.prototype = Object.create(e && e.prototype), SpreadElement.prototype.constructor = SpreadElement, SpreadElement.prototype.transpile = function transpile(t, r) { this.parent.type == 'ObjectExpression' && (t.remove(this.start, this.argument.start), t.remove(this.argument.end, this.end)), e.prototype.transpile.call(this, t, r) }, SpreadElement }(p)),
      Super: (function (e) { function Super() { e.apply(this, arguments) } return e && (Super.__proto__ = e), Super.prototype = Object.create(e && e.prototype), Super.prototype.constructor = Super, Super.prototype.initialise = function initialise(e) { if (e.classes) { if (this.method = this.findNearest('MethodDefinition'), !this.method) throw new h('use of super outside class method', this); const t = this.findNearest('ClassBody').parent; if (this.superClassName = t.superClass && (t.superClass.name || 'superclass'), !this.superClassName) throw new h('super used in base class', this); if (this.isCalled = this.parent.type === 'CallExpression' && this === this.parent.callee, this.method.kind !== 'constructor' && this.isCalled) throw new h('super() not allowed outside class constructor', this); if (this.isMember = this.parent.type === 'MemberExpression', !this.isCalled && !this.isMember) throw new h('Unexpected use of `super` (expected `super(...)` or `super.*`)', this); } if (e.arrow) { const r = this.findLexicalBoundary(); const n = this.findNearest('ArrowFunctionExpression'); const i = this.findNearest(D); n && n.depth > r.depth && (this.thisAlias = r.getThisAlias()), i && i.body.contains(this) && i.depth > r.depth && (this.thisAlias = r.getThisAlias()) } }, Super.prototype.transpile = function transpile(e, t) { if (t.classes) { const r = this.isCalled || this.method.static ? this.superClassName : `${this.superClassName}.prototype`; e.overwrite(this.start, this.end, r, { storeName: !0, contentOnly: !0 }); const n = this.isCalled ? this.parent : this.parent.parent; if (n && n.type === 'CallExpression') { this.noCall || e.appendLeft(n.callee.end, '.call'); const i = this.thisAlias || 'this'; n.arguments.length ? e.appendLeft(n.arguments[0].start, `${i}, `) : e.appendLeft(n.end - 1, `${i}`) } } }, Super }(p)),
      TaggedTemplateExpression: (function (e) { function TaggedTemplateExpression() { e.apply(this, arguments) } return e && (TaggedTemplateExpression.__proto__ = e), TaggedTemplateExpression.prototype = Object.create(e && e.prototype), TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression, TaggedTemplateExpression.prototype.initialise = function initialise(t) { if (t.templateString && !t.dangerousTaggedTemplateString) throw new h("Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you're doing", this); e.prototype.initialise.call(this, t) }, TaggedTemplateExpression.prototype.transpile = function transpile(t, r) { if (r.templateString && r.dangerousTaggedTemplateString) { const n = this.quasi.expressions.concat(this.quasi.quasis).sort((e, t) => e.start - t.start); const i = this.program.body.scope; const a = this.quasi.quasis.map(e => JSON.stringify(e.value.cooked)).join(', '); let o = this.program.templateLiteralQuasis[a]; o || (o = i.createIdentifier('templateObject'), t.prependRight(this.program.prependAt, `var ${o} = Object.freeze([${a}]);\n`), this.program.templateLiteralQuasis[a] = o), t.overwrite(this.tag.end, n[0].start, `(${o}`); let s = n[0].start; n.forEach((e) => { e.type === 'TemplateElement' ? t.remove(s, e.end) : t.overwrite(s, e.start, ', '), s = e.end }), t.overwrite(s, this.end, ')') }e.prototype.transpile.call(this, t, r) }, TaggedTemplateExpression }(p)),
      TemplateElement: (function (e) { function TemplateElement() { e.apply(this, arguments) } return e && (TemplateElement.__proto__ = e), TemplateElement.prototype = Object.create(e && e.prototype), TemplateElement.prototype.constructor = TemplateElement, TemplateElement.prototype.initialise = function initialise() { this.program.indentExclusionElements.push(this) }, TemplateElement }(p)),
      TemplateLiteral: (function (e) { function TemplateLiteral() { e.apply(this, arguments) } return e && (TemplateLiteral.__proto__ = e), TemplateLiteral.prototype = Object.create(e && e.prototype), TemplateLiteral.prototype.constructor = TemplateLiteral, TemplateLiteral.prototype.transpile = function transpile(t, r) { if (e.prototype.transpile.call(this, t, r), r.templateString && this.parent.type !== 'TaggedTemplateExpression') { const n = this.expressions.concat(this.quasis).sort((e, t) => e.start - t.start || e.end - t.end).filter((e, t) => e.type !== 'TemplateElement' || (!!e.value.raw || !t)); if (n.length >= 3) { const i = n[0]; const a = n[2]; i.type === 'TemplateElement' && i.value.raw === '' && a.type === 'TemplateElement' && n.shift() } const o = !(this.quasis.length === 1 && this.expressions.length === 0 || this.parent.type === 'TemplateLiteral' || this.parent.type === 'AssignmentExpression' || this.parent.type === 'AssignmentPattern' || this.parent.type === 'VariableDeclarator' || this.parent.type === 'BinaryExpression' && this.parent.operator === '+'); o && t.appendRight(this.start, '('); let s = this.start; n.forEach((e, r) => { let n = r === 0 ? o ? '(' : '' : ' + '; if (e.type === 'TemplateElement')t.overwrite(s, e.end, n + JSON.stringify(e.value.cooked)); else { const i = e.type !== 'Identifier'; i && (n += '('), t.remove(s, e.start), n && t.prependRight(e.start, n), i && t.appendLeft(e.end, ')') }s = e.end }), o && t.appendLeft(s, ')'), t.overwrite(s, this.end, '', { contentOnly: !0 }) } }, TemplateLiteral }(p)),
      ThisExpression: (function (e) { function ThisExpression() { e.apply(this, arguments) } return e && (ThisExpression.__proto__ = e), ThisExpression.prototype = Object.create(e && e.prototype), ThisExpression.prototype.constructor = ThisExpression, ThisExpression.prototype.initialise = function initialise(e) { if (e.arrow) { const t = this.findLexicalBoundary(); const r = this.findNearest('ArrowFunctionExpression'); const n = this.findNearest(D); (r && r.depth > t.depth || n && n.body.contains(this) && n.depth > t.depth || n && n.right && n.right.contains(this)) && (this.alias = t.getThisAlias()) } }, ThisExpression.prototype.transpile = function transpile(e) { this.alias && e.overwrite(this.start, this.end, this.alias, { storeName: !0, contentOnly: !0 }) }, ThisExpression }(p)),
      UpdateExpression: (function (e) { function UpdateExpression() { e.apply(this, arguments) } return e && (UpdateExpression.__proto__ = e), UpdateExpression.prototype = Object.create(e && e.prototype), UpdateExpression.prototype.constructor = UpdateExpression, UpdateExpression.prototype.initialise = function initialise(t) { if (this.argument.type === 'Identifier') { const r = this.findScope(!1).findDeclaration(this.argument.name); const n = r && r.node.ancestor(3); n && n.type === 'ForStatement' && n.body.contains(this) && (n.reassigned[this.argument.name] = !0) }e.prototype.initialise.call(this, t) }, UpdateExpression.prototype.transpile = function transpile(t, r) { this.argument.type === 'Identifier' && checkConst(this.argument, this.findScope(!1)), e.prototype.transpile.call(this, t, r) }, UpdateExpression }(p)),
      VariableDeclaration: (function (e) {
        function VariableDeclaration() { e.apply(this, arguments) } return e && (VariableDeclaration.__proto__ = e), VariableDeclaration.prototype = Object.create(e && e.prototype), VariableDeclaration.prototype.constructor = VariableDeclaration, VariableDeclaration.prototype.initialise = function initialise(e) { this.scope = this.findScope(this.kind === 'var'), this.declarations.forEach(t => t.initialise(e)) }, VariableDeclaration.prototype.transpile = function transpile(e, t) {
          const r = this; const n = this.getIndentation(); let i = this.kind; if (t.letConst && i !== 'var' && (i = 'var', e.overwrite(this.start, this.start + this.kind.length, i, { storeName: !0 })), t.destructuring && this.parent.type !== 'ForOfStatement' && this.parent.type !== 'ForInStatement') {
            let a; let o = this.start; this.declarations.forEach((i, s) => {
              if (i.transpile(e, t), i.id.type === 'Identifier')s > 0 && r.declarations[s - 1].id.type !== 'Identifier' && e.overwrite(o, i.id.start, 'var '); else {
                const u = D.test(r.parent.type); s === 0 ? e.remove(o, i.id.start) : e.overwrite(o, i.id.start, `;\n${n}`); const l = i.init.type === 'Identifier' && !i.init.rewritten; const c = l ? i.init.alias || i.init.name : i.findScope(!0).createIdentifier('ref'); o = i.start; const p = []; l ? e.remove(i.id.end, i.end) : p.push((t, r, n) => { e.prependRight(i.id.end, `var ${c}`), e.appendLeft(i.init.end, `${n}`), e.move(i.id.end, i.end, t) }); const f = i.findScope(!1); destructure(e, e => f.createIdentifier(e), (e) => { const t = e.name; return f.resolveName(t) }, i.id, c, u, p); const d = u ? 'var ' : ''; let
                  h = u ? ', ' : `;\n${n}`; p.forEach((e, t) => { s === r.declarations.length - 1 && t === p.length - 1 && (h = u ? '' : ';'), e(i.start, t === 0 ? d : '', h) });
              }o = i.end, a = i.id.type !== 'Identifier';
            }), a && this.end > o && e.overwrite(o, this.end, '', { contentOnly: !0 });
          } else this.declarations.forEach((r) => { r.transpile(e, t) });
        }, VariableDeclaration;
      }(p)),
      VariableDeclarator: (function (e) { function VariableDeclarator() { e.apply(this, arguments) } return e && (VariableDeclarator.__proto__ = e), VariableDeclarator.prototype = Object.create(e && e.prototype), VariableDeclarator.prototype.constructor = VariableDeclarator, VariableDeclarator.prototype.initialise = function initialise(t) { let r = this.parent.kind; r === 'let' && this.parent.parent.type === 'ForStatement' && (r = 'for.let'), this.parent.scope.addDeclaration(this.id, r), e.prototype.initialise.call(this, t) }, VariableDeclarator.prototype.transpile = function transpile(e, t) { if (!this.init && t.letConst && this.parent.kind !== 'var') { const r = this.findNearest(/Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/); !r || /Function/.test(r.type) || this.isLeftDeclaratorOfLoop() || e.appendLeft(this.id.end, ' = (void 0)') } this.id && this.id.transpile(e, t), this.init && this.init.transpile(e, t) }, VariableDeclarator.prototype.isLeftDeclaratorOfLoop = function isLeftDeclaratorOfLoop() { return this.parent && this.parent.type === 'VariableDeclaration' && this.parent.parent && (this.parent.parent.type === 'ForInStatement' || this.parent.parent.type === 'ForOfStatement') && this.parent.parent.left && this.parent.parent.left.declarations[0] === this }, VariableDeclarator }(p)),
      WhileStatement: P,
    }; const ue = { Program: ['body'], Literal: [] }; const le = {
      IfStatement: 'consequent', ForStatement: 'body', ForInStatement: 'body', ForOfStatement: 'body', WhileStatement: 'body', DoWhileStatement: 'body', ArrowFunctionExpression: 'body',
    }; function Program(e, t, r, i) {
      this.type = 'Root', this.jsx = i.jsx || 'React.createElement', this.options = i, this.source = e, this.magicString = new n.a(e), this.ast = t, this.depth = 0, (function wrap(e, t) {
        if (e) {
          if ('length' in e) for (let r = e.length; r--;)wrap(e[r], t); else if (!e.__wrapped) {
            e.__wrapped = !0, ue[e.type] || (ue[e.type] = Object.keys(e).filter(t => typeof e[t] === 'object')); const n = le[e.type]; if (n && e[n].type !== 'BlockStatement') {
              const i = e[n]; e[n] = {
                start: i.start, end: i.end, type: 'BlockStatement', body: [i], synthetic: !0,
              };
            }e.parent = t, e.program = t.program || t, e.depth = t.depth + 1, e.keys = ue[e.type], e.indentation = void 0; for (let a = 0, o = ue[e.type]; a < o.length; a += 1) { const s = o[a]; wrap(e[s], e) }e.program.magicString.addSourcemapLocation(e.start), e.program.magicString.addSourcemapLocation(e.end); const u = (e.type === 'BlockStatement' ? g : se[e.type]) || p; e.__proto__ = u.prototype;
          }
        }
      }(this.body = t, this)), this.body.__proto__ = g.prototype, this.templateLiteralQuasis = Object.create(null); for (let a = 0; a < this.body.body.length; ++a) if (!this.body.body[a].directive) { this.prependAt = this.body.body[a].start; break } this.objectWithoutPropertiesHelper = null, this.indentExclusionElements = [], this.body.initialise(r), this.indentExclusions = Object.create(null); for (let o = 0, s = this.indentExclusionElements; o < s.length; o += 1) for (let u = s[o], l = u.start; l < u.end; l += 1) this.indentExclusions[l] = !0; this.body.transpile(this.magicString, r);
    }Program.prototype = {
      export: function export$1(e) { return void 0 === e && (e = {}), { code: this.magicString.toString(), map: this.magicString.generateMap({ file: e.file, source: e.source, includeContent: !1 !== e.includeContent }) } }, findNearest: function findNearest() { return null }, findScope: function findScope() { return null }, getObjectWithoutPropertiesHelper: function getObjectWithoutPropertiesHelper(e) { return this.objectWithoutPropertiesHelper || (this.objectWithoutPropertiesHelper = this.body.scope.createIdentifier('objectWithoutProperties'), e.prependLeft(this.prependAt, `function ${this.objectWithoutPropertiesHelper} (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n`)), this.objectWithoutPropertiesHelper },
    }; const ce = {
      chrome: {
        48: 305357, 49: 326143, 50: 391679, 51: 391679, 52: 522751, 53: 522751, 54: 522751, 55: 522751, 56: 522751, 57: 522751, 58: 1047039, 59: 1047039, 60: 1047039, 61: 1047039, 62: 1047039, 63: 1047039,
      },
      firefox: {
        43: 325853, 44: 326109, 45: 326111, 46: 391647, 47: 391679, 48: 391679, 49: 387583, 50: 387583, 51: 387583, 52: 1047039, 53: 1047039, 54: 1047039, 55: 1047039, 56: 1047039, 57: 1047039, 58: 1047039,
      },
      safari: {
        8: 262148, 9: 301166, 10: 915967, 10.1: 1047039, 11: 1047039,
      },
      ie: {
        8: 0, 9: 262144, 10: 262144, 11: 262400,
      },
      edge: {
        12: 305485, 13: 387535, 14: 1042943, 15: 1042943, 16: 1042943,
      },
      node: {
        '0.10': 262144, 0.12: 262208, 4: 297167, 5: 297167, 6: 391679, 8: 1047039, 8.3: 1047039, 8.7: 1047039,
      },
    }; const pe = ['arrow', 'classes', 'computedProperty', 'conciseMethodProperty', 'defaultParameter', 'destructuring', 'forOf', 'generator', 'letConst', 'moduleExport', 'moduleImport', 'numericLiteral', 'parameterDestructuring', 'spreadRest', 'stickyRegExp', 'templateString', 'unicodeRegExp', 'exponentiation', 'reservedProperties', 'trailingFunctionCommas']; var fe = '0.19.3'; const de = [function (e) { const t = e.tokTypes; const r = e.tokContexts; r.j_oTag = new e.TokContext('<tag', !1), r.j_cTag = new e.TokContext('</tag', !1), r.j_expr = new e.TokContext('<tag>...</tag>', !0, !0), t.jsxName = new e.TokenType('jsxName'), t.jsxText = new e.TokenType('jsxText', { beforeExpr: !0 }), t.jsxTagStart = new e.TokenType('jsxTagStart'), t.jsxTagEnd = new e.TokenType('jsxTagEnd'), t.jsxTagStart.updateContext = function () { this.context.push(r.j_expr), this.context.push(r.j_oTag), this.exprAllowed = !1 }, t.jsxTagEnd.updateContext = function (e) { const n = this.context.pop(); n === r.j_oTag && e === t.slash || n === r.j_cTag ? (this.context.pop(), this.exprAllowed = this.curContext() === r.j_expr) : this.exprAllowed = !0 }; const n = e.Parser.prototype; function getQualifiedJSXName(e) { return e ? e.type === 'JSXIdentifier' ? e.name : e.type === 'JSXNamespacedName' ? `${e.namespace.name}:${e.name.name}` : e.type === 'JSXMemberExpression' ? `${getQualifiedJSXName(e.object)}.${getQualifiedJSXName(e.property)}` : void 0 : e } return n.jsx_readToken = function () { for (let r = '', n = this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, 'Unterminated JSX contents'); const i = this.input.charCodeAt(this.pos); switch (i) { case 60: case 123: return this.pos === this.start ? i === 60 && this.exprAllowed ? (++this.pos, this.finishToken(t.jsxTagStart)) : this.getTokenFromCode(i) : (r += this.input.slice(n, this.pos), this.finishToken(t.jsxText, r)); case 38: r += this.input.slice(n, this.pos), r += this.jsx_readEntity(), n = this.pos; break; default: e.isNewLine(i) ? (r += this.input.slice(n, this.pos), r += this.jsx_readNewLine(!0), n = this.pos) : ++this.pos; } } }, n.jsx_readNewLine = function (e) { let t; const r = this.input.charCodeAt(this.pos); return ++this.pos, r === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, t = e ? '\n' : '\r\n') : t = String.fromCharCode(r), this.options.locations && (++this.curLine, this.lineStart = this.pos), t }, n.jsx_readString = function (r) { for (var n = '', i = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, 'Unterminated string constant'); const a = this.input.charCodeAt(this.pos); if (a === r) break; a === 38 ? (n += this.input.slice(i, this.pos), n += this.jsx_readEntity(), i = this.pos) : e.isNewLine(a) ? (n += this.input.slice(i, this.pos), n += this.jsx_readNewLine(!1), i = this.pos) : ++this.pos } return n += this.input.slice(i, this.pos++), this.finishToken(t.string, n) }, n.jsx_readEntity = function () { let e; let t = ''; let r = 0; let n = this.input[this.pos]; n !== '&' && this.raise(this.pos, 'Entity must start with an ampersand'); for (var i = ++this.pos; this.pos < this.input.length && r++ < 10;) { if ((n = this.input[this.pos++]) === ';') { t[0] === '#' ? t[1] === 'x' ? (t = t.substr(2), o.test(t) && (e = String.fromCharCode(parseInt(t, 16)))) : (t = t.substr(1), s.test(t) && (e = String.fromCharCode(parseInt(t, 10)))) : e = a[t]; break }t += n } return e || (this.pos = i, '&') }, n.jsx_readWord = function () { let r; const n = this.pos; do { r = this.input.charCodeAt(++this.pos) } while (e.isIdentifierChar(r) || r === 45);return this.finishToken(t.jsxName, this.input.slice(n, this.pos)) }, n.jsx_parseIdentifier = function () { const e = this.startNode(); return this.type === t.jsxName ? e.name = this.value : this.type.keyword ? e.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(e, 'JSXIdentifier') }, n.jsx_parseNamespacedName = function () { const e = this.start; const r = this.startLoc; const n = this.jsx_parseIdentifier(); if (!this.options.plugins.jsx.allowNamespaces || !this.eat(t.colon)) return n; const i = this.startNodeAt(e, r); return i.namespace = n, i.name = this.jsx_parseIdentifier(), this.finishNode(i, 'JSXNamespacedName') }, n.jsx_parseElementName = function () { if (this.type === t.jsxTagEnd) return ''; const e = this.start; const r = this.startLoc; let n = this.jsx_parseNamespacedName(); for (this.type !== t.dot || n.type !== 'JSXNamespacedName' || this.options.plugins.jsx.allowNamespacedObjects || this.unexpected(); this.eat(t.dot);) { const i = this.startNodeAt(e, r); i.object = n, i.property = this.jsx_parseIdentifier(), n = this.finishNode(i, 'JSXMemberExpression') } return n }, n.jsx_parseAttributeValue = function () { switch (this.type) { case t.braceL: var e = this.jsx_parseExpressionContainer(); return e.expression.type === 'JSXEmptyExpression' && this.raise(e.start, 'JSX attributes must only be assigned a non-empty expression'), e; case t.jsxTagStart: case t.string: return this.parseExprAtom(); default: this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text'); } }, n.jsx_parseEmptyExpression = function () { const e = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc); return this.finishNodeAt(e, 'JSXEmptyExpression', this.start, this.startLoc) }, n.jsx_parseExpressionContainer = function () { const e = this.startNode(); return this.next(), e.expression = this.type === t.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(t.braceR), this.finishNode(e, 'JSXExpressionContainer') }, n.jsx_parseAttribute = function () { const e = this.startNode(); return this.eat(t.braceL) ? (this.expect(t.ellipsis), e.argument = this.parseMaybeAssign(), this.expect(t.braceR), this.finishNode(e, 'JSXSpreadAttribute')) : (e.name = this.jsx_parseNamespacedName(), e.value = this.eat(t.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(e, 'JSXAttribute')) }, n.jsx_parseOpeningElementAt = function (e, r) { const n = this.startNodeAt(e, r); n.attributes = []; const i = this.jsx_parseElementName(); for (i && (n.name = i); this.type !== t.slash && this.type !== t.jsxTagEnd;)n.attributes.push(this.jsx_parseAttribute()); return n.selfClosing = this.eat(t.slash), this.expect(t.jsxTagEnd), this.finishNode(n, i ? 'JSXOpeningElement' : 'JSXOpeningFragment') }, n.jsx_parseClosingElementAt = function (e, r) { const n = this.startNodeAt(e, r); const i = this.jsx_parseElementName(); return i && (n.name = i), this.expect(t.jsxTagEnd), this.finishNode(n, i ? 'JSXClosingElement' : 'JSXClosingFragment') }, n.jsx_parseElementAt = function (e, r) { const n = this.startNodeAt(e, r); const i = []; const a = this.jsx_parseOpeningElementAt(e, r); let o = null; if (!a.selfClosing) { e:for (;;) switch (this.type) { case t.jsxTagStart: if (e = this.start, r = this.startLoc, this.next(), this.eat(t.slash)) { o = this.jsx_parseClosingElementAt(e, r); break e }i.push(this.jsx_parseElementAt(e, r)); break; case t.jsxText: i.push(this.parseExprAtom()); break; case t.braceL: i.push(this.jsx_parseExpressionContainer()); break; default: this.unexpected(); }getQualifiedJSXName(o.name) !== getQualifiedJSXName(a.name) && this.raise(o.start, `Expected corresponding JSX closing tag for <${getQualifiedJSXName(a.name)}>`) } return n.openingElement = a, n.closingElement = o, n.children = i, this.type === t.relational && this.value === '<' && this.raise(this.start, 'Adjacent JSX elements must be wrapped in an enclosing tag'), this.finishNode(n, a.name ? 'JSXElement' : 'JSXFragment') }, n.jsx_parseText = function (e) { const t = this.parseLiteral(e); return t.type = 'JSXText', t }, n.jsx_parseElement = function () { const e = this.start; const t = this.startLoc; return this.next(), this.jsx_parseElementAt(e, t) }, e.plugins.jsx = function (n, i) { i && (typeof i !== 'object' && (i = {}), n.options.plugins.jsx = { allowNamespaces: !1 !== i.allowNamespaces, allowNamespacedObjects: !!i.allowNamespacedObjects }, n.extend('parseExprAtom', e => function (r) { return this.type === t.jsxText ? this.jsx_parseText(this.value) : this.type === t.jsxTagStart ? this.jsx_parseElement() : e.call(this, r) }), n.extend('readToken', n => function (i) { const a = this.curContext(); if (a === r.j_expr) return this.jsx_readToken(); if (a === r.j_oTag || a === r.j_cTag) { if (e.isIdentifierStart(i)) return this.jsx_readWord(); if (i == 62) return ++this.pos, this.finishToken(t.jsxTagEnd); if ((i === 34 || i === 39) && a == r.j_oTag) return this.jsx_readString(i); } return i === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(t.jsxTagStart)) : n.call(this, i) }), n.extend('updateContext', e => function (n) { if (this.type == t.braceL) { const i = this.curContext(); i == r.j_oTag ? this.context.push(r.b_expr) : i == r.j_expr ? this.context.push(r.b_tmpl) : e.call(this, n), this.exprAllowed = !0 } else { if (this.type !== t.slash || n !== t.jsxTagStart) return e.call(this, n); this.context.length -= 2, this.context.push(r.j_cTag), this.exprAllowed = !1 } })) }, e }, c].reduce((e, t) => t(e), i).parse; const he = ['dangerousTaggedTemplateString', 'dangerousForOf']; function target(e) { let t = Object.keys(e).length ? 1048575 : 262144; Object.keys(e).forEach((r) => { const n = ce[r]; if (!n) throw new Error(`Unknown environment '${r}'. Please raise an issue at https://github.com/Rich-Harris/buble/issues`); const i = e[r]; if (!(i in n)) throw new Error(`Support data exists for the following versions of ${r}: ${Object.keys(n).join(', ')}. Please raise an issue at https://github.com/Rich-Harris/buble/issues`); const a = n[i]; t &= a }); const r = Object.create(null); return pe.forEach((e, n) => { r[e] = !(t & 1 << n) }), he.forEach((e) => { r[e] = !1 }), r } function transform(e, t) {
      let r; void 0 === t && (t = {}); let n = null; try {
        r = de(e, {
          ecmaVersion: 9, preserveParens: !0, sourceType: 'module', onComment(e, t) { if (!n) { const r = /@jsx\s+([^\s]+)/.exec(t); r && (n = r[1]) } }, plugins: { jsx: !0, dynamicImport: !0 },
        }), t.jsx = n || t.jsx;
      } catch (t) { throw t.snippet = getSnippet(e, t.loc), t.toString = function () { return `${t.name}: ${t.message}\n${t.snippet}` }, t } const i = target(t.target || {}); return Object.keys(t.transforms || {}).forEach((e) => { if (e === 'modules') return 'moduleImport' in t.transforms || (i.moduleImport = t.transforms.modules), void ('moduleExport' in t.transforms || (i.moduleExport = t.transforms.modules)); if (!(e in i)) throw new Error(`Unknown transform '${e}'`); i[e] = t.transforms[e] }), new Program(e, r, i, t).export(t);
    }
  }.call(t, r(14));
}, function (e, t, r) {
  (function (e, n) {
    const i = r(482); function Chunk(e, t, r) { this.start = e, this.end = t, this.original = r, this.intro = '', this.outro = '', this.content = r, this.storeName = !1, this.edited = !1, Object.defineProperties(this, { previous: { writable: !0, value: null }, next: { writable: !0, value: null } }) }Chunk.prototype = {
      appendLeft: function appendLeft(e) { this.outro += e }, appendRight: function appendRight(e) { this.intro = this.intro + e }, clone: function clone() { const e = new Chunk(this.start, this.end, this.original); return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e }, contains: function contains(e) { return this.start < e && e < this.end }, eachNext: function eachNext(e) { for (let t = this; t;)e(t), t = t.next; }, eachPrevious: function eachPrevious(e) { for (let t = this; t;)e(t), t = t.previous; }, edit: function edit(e, t, r) { return this.content = e, r || (this.intro = '', this.outro = ''), this.storeName = t, this.edited = !0, this }, prependLeft: function prependLeft(e) { this.outro = e + this.outro }, prependRight: function prependRight(e) { this.intro = e + this.intro }, split: function split(e) { const t = e - this.start; const r = this.original.slice(0, t); const n = this.original.slice(t); this.original = r; const i = new Chunk(e, this.end, n); return i.outro = this.outro, this.outro = '', this.end = e, this.edited ? (i.edit('', !1), this.content = '') : this.content = r, i.next = this.next, i.next && (i.next.previous = i), i.previous = this, this.next = i, i }, toString: function toString() { return this.intro + this.content + this.outro }, trimEnd: function trimEnd(e) { if (this.outro = this.outro.replace(e, ''), this.outro.length) return !0; const t = this.content.replace(e, ''); return t.length ? (t !== this.content && this.split(this.start + t.length).edit('', !1), !0) : (this.edit('', !1), this.intro = this.intro.replace(e, ''), !!this.intro.length || void 0) }, trimStart: function trimStart(e) { if (this.intro = this.intro.replace(e, ''), this.intro.length) return !0; const t = this.content.replace(e, ''); return t.length ? (t !== this.content && (this.split(this.end - t.length), this.edit('', !1)), !0) : (this.edit('', !1), this.outro = this.outro.replace(e, ''), !!this.outro.length || void 0) },
    }; const a = typeof window !== 'undefined' && typeof window.btoa === 'function' ? window.btoa : typeof e === 'function' ? function (t) { return new e(t).toString('base64') } : function () { throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.') }; function SourceMap(e) { this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings = e.mappings } function getRelativePath(e, t) { const r = e.split(/[\/\\]/); const n = t.split(/[\/\\]/); for (r.pop(); r[0] === n[0];)r.shift(), n.shift(); if (r.length) for (let i = r.length; i--;)r[i] = '..'; return r.concat(n).join('/') }SourceMap.prototype = { toString: function toString() { return JSON.stringify(this) }, toUrl: function toUrl() { return `data:application/json;charset=utf-8;base64,${a(this.toString())}` } }; const o = Object.prototype.toString; function isObject(e) { return o.call(e) === '[object Object]' } function getLocator(e) { let t = 0; const r = e.split('\n').map((e, r) => { const n = t + e.length + 1; const i = { start: t, end: n, line: r }; return t = n, i }); let n = 0; function rangeContains(e, t) { return e.start <= t && t < e.end } function getLocation(e, t) { return { line: e.line, column: t - e.start } } return function locate(e) { for (let t = r[n], i = e >= t.end ? 1 : -1; t;) { if (rangeContains(t, e)) return getLocation(t, e); t = r[n += i] } } } function Mappings(e) {
      const t = this; const r = {
        generatedCodeColumn: 0, sourceIndex: 0, sourceCodeLine: 0, sourceCodeColumn: 0, sourceCodeName: 0,
      }; let n = 0; let a = 0; this.raw = []; let o = this.raw[n] = []; let s = null; this.addEdit = function (e, r, n, i, u) { r.length ? o.push([a, e, i.line, i.column, u]) : s && o.push(s), t.advance(r), s = null }, this.addUneditedChunk = function (r, i, u, l, c) { for (let p = i.start, f = !0; p < i.end;)(e || f || c[p]) && o.push([a, r, l.line, l.column, -1]), u[p] === '\n' ? (l.line += 1, l.column = 0, n += 1, t.raw[n] = o = [], a = 0) : (l.column += 1, a += 1), p += 1, f = !1; s = [a, r, l.line, l.column, -1] }, this.advance = function (e) { if (e) { const r = e.split('\n'); const i = r.pop(); r.length ? (n += r.length, t.raw[n] = o = [], a = i.length) : a += i.length } }, this.encode = function () { return t.raw.map((e) => { let t = 0; return e.map((e) => { const n = [e[0] - t, e[1] - r.sourceIndex, e[2] - r.sourceCodeLine, e[3] - r.sourceCodeColumn]; return t = e[0], r.sourceIndex = e[1], r.sourceCodeLine = e[2], r.sourceCodeColumn = e[3], ~e[4] && (n.push(e[4] - r.sourceCodeName), r.sourceCodeName = e[4]), Object(i.a)(n) }).join(',') }).join(';') };
    } const s = function Stats() { Object.defineProperties(this, { startTimes: { value: {} } }) }; s.prototype.time = function time(e) { this.startTimes[e] = n.hrtime() }, s.prototype.timeEnd = function timeEnd(e) { const t = n.hrtime(this.startTimes[e]); this[e] || (this[e] = 0), this[e] += 1e3 * t[0] + 1e-6 * t[1] }; const u = { insertLeft: !1, insertRight: !1, storeName: !1 }; function MagicString$1(e, t) {
      void 0 === t && (t = {}); const r = new Chunk(0, e.length, e); Object.defineProperties(this, {
        original: { writable: !0, value: e }, outro: { writable: !0, value: '' }, intro: { writable: !0, value: '' }, firstChunk: { writable: !0, value: r }, lastChunk: { writable: !0, value: r }, lastSearchedChunk: { writable: !0, value: r }, byStart: { writable: !0, value: {} }, byEnd: { writable: !0, value: {} }, filename: { writable: !0, value: t.filename }, indentExclusionRanges: { writable: !0, value: t.indentExclusionRanges }, sourcemapLocations: { writable: !0, value: {} }, storedNames: { writable: !0, value: {} }, indentStr: { writable: !0, value: (function guessIndent(e) { const t = e.split('\n'); const r = t.filter(e => /^\t+/.test(e)); const n = t.filter(e => /^ {2,}/.test(e)); if (r.length === 0 && n.length === 0) return null; if (r.length >= n.length) return '\t'; const i = n.reduce((e, t) => { const r = /^ +/.exec(t)[0].length; return Math.min(r, e) }, 1 / 0); return new Array(i + 1).join(' ') }(e)) },
      }), this.byStart[0] = r, this.byEnd[e.length] = r;
    }MagicString$1.prototype = {
      addSourcemapLocation: function addSourcemapLocation(e) { this.sourcemapLocations[e] = !0 },
      append: function append(e) { if (typeof e !== 'string') throw new TypeError('outro content must be a string'); return this.outro += e, this },
      appendLeft: function appendLeft(e, t) { if (typeof t !== 'string') throw new TypeError('inserted content must be a string'); this._split(e); const r = this.byEnd[e]; return r ? r.appendLeft(t) : this.intro += t, this },
      appendRight: function appendRight(e, t) { if (typeof t !== 'string') throw new TypeError('inserted content must be a string'); this._split(e); const r = this.byStart[e]; return r ? r.appendRight(t) : this.outro += t, this },
      clone: function clone() { for (var e = new MagicString$1(this.original, { filename: this.filename }), t = this.firstChunk, r = e.firstChunk = e.lastSearchedChunk = t.clone(); t;) { e.byStart[r.start] = r, e.byEnd[r.end] = r; const n = t.next; const i = n && n.clone(); i && (r.next = i, i.previous = r, r = i), t = n } return e.lastChunk = r, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), Object.keys(this.sourcemapLocations).forEach((t) => { e.sourcemapLocations[t] = !0 }), e },
      generateMap: function generateMap(e) {
        const t = this; e = e || {}; const r = Object.keys(this.storedNames); const n = new Mappings(e.hires); const i = getLocator(this.original); return this.intro && n.advance(this.intro), this.firstChunk.eachNext((e) => { const a = i(e.start); e.intro.length && n.advance(e.intro), e.edited ? n.addEdit(0, e.content, e.original, a, e.storeName ? r.indexOf(e.original) : -1) : n.addUneditedChunk(0, e, t.original, a, t.sourcemapLocations), e.outro.length && n.advance(e.outro) }), new SourceMap({
          file: e.file ? e.file.split(/[\/\\]/).pop() : null, sources: [e.source ? getRelativePath(e.file || '', e.source) : null], sourcesContent: e.includeContent ? [this.original] : [null], names: r, mappings: n.encode(),
        });
      },
      getIndentString: function getIndentString() { return this.indentStr === null ? '\t' : this.indentStr },
      indent: function indent(e, t) { const r = /^[^\r\n]/gm; if (isObject(e) && (t = e, e = void 0), (e = void 0 !== e ? e : this.indentStr || '\t') === '') return this; const n = {}; (t = t || {}).exclude && (typeof t.exclude[0] === 'number' ? [t.exclude] : t.exclude).forEach((e) => { for (let t = e[0]; t < e[1]; t += 1)n[t] = !0; }); let i = !1 !== t.indentStart; const a = function (t) { return i ? `${e}${t}` : (i = !0, t) }; this.intro = this.intro.replace(r, a); for (let o = 0, s = this.firstChunk; s;) { const u = s.end; if (s.edited)n[o] || (s.content = s.content.replace(r, a), s.content.length && (i = s.content[s.content.length - 1] === '\n')); else for (o = s.start; o < u;) { if (!n[o]) { const l = this.original[o]; l === '\n' ? i = !0 : l !== '\r' && i && (i = !1, o === s.start ? s.prependRight(e) : (this._splitChunk(s, o), (s = s.next).prependRight(e))) }o += 1 }o = s.end, s = s.next } return this.outro = this.outro.replace(r, a), this },
      insert: function insert() { throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)') },
      insertLeft: function insertLeft(e, t) { return u.insertLeft || (console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'), u.insertLeft = !0), this.appendLeft(e, t) },
      insertRight: function insertRight(e, t) { return u.insertRight || (console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'), u.insertRight = !0), this.prependRight(e, t) },
      move: function move(e, t, r) { if (r >= e && r <= t) throw new Error('Cannot move a selection inside itself'); this._split(e), this._split(t), this._split(r); const n = this.byStart[e]; const i = this.byEnd[t]; const a = n.previous; const o = i.next; const s = this.byStart[r]; if (!s && i === this.lastChunk) return this; const u = s ? s.previous : this.lastChunk; return a && (a.next = o), o && (o.previous = a), u && (u.next = n), s && (s.previous = i), n.previous || (this.firstChunk = i.next), i.next || (this.lastChunk = n.previous, this.lastChunk.next = null), n.previous = u, i.next = s || null, u || (this.firstChunk = n), s || (this.lastChunk = i), this },
      overwrite: function overwrite(e, t, r, n) { if (typeof r !== 'string') throw new TypeError('replacement content must be a string'); for (;e < 0;)e += this.original.length; for (;t < 0;)t += this.original.length; if (t > this.original.length) throw new Error('end is out of bounds'); if (e === t) throw new Error('Cannot overwrite a zero-length range  use appendLeft or prependRight instead'); this._split(e), this._split(t), !0 === n && (u.storeName || (console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'), u.storeName = !0), n = { storeName: !0 }); const i = void 0 !== n && n.storeName; const a = void 0 !== n && n.contentOnly; if (i) { const o = this.original.slice(e, t); this.storedNames[o] = !0 } const s = this.byStart[e]; const l = this.byEnd[t]; if (s) { if (t > s.end && s.next !== this.byStart[s.end]) throw new Error('Cannot overwrite across a split point'); if (s.edit(r, i, a), s !== l) { for (var c = s.next; c !== l;)c.edit('', !1), c = c.next; c.edit('', !1) } } else { const p = new Chunk(e, t, '').edit(r, i); l.next = p, p.previous = l } return this },
      prepend: function prepend(e) { if (typeof e !== 'string') throw new TypeError('outro content must be a string'); return this.intro = e + this.intro, this },
      prependLeft: function prependLeft(e, t) { if (typeof t !== 'string') throw new TypeError('inserted content must be a string'); this._split(e); const r = this.byEnd[e]; return r ? r.prependLeft(t) : this.intro = t + this.intro, this },
      prependRight: function prependRight(e, t) { if (typeof t !== 'string') throw new TypeError('inserted content must be a string'); this._split(e); const r = this.byStart[e]; return r ? r.prependRight(t) : this.outro = t + this.outro, this },
      remove: function remove(e, t) { for (;e < 0;)e += this.original.length; for (;t < 0;)t += this.original.length; if (e === t) return this; if (e < 0 || t > this.original.length) throw new Error('Character is out of bounds'); if (e > t) throw new Error('end must be greater than start'); this._split(e), this._split(t); for (let r = this.byStart[e]; r;)r.intro = '', r.outro = '', r.edit(''), r = t > r.end ? this.byStart[r.end] : null; return this },
      slice: function slice(e, t) { for (void 0 === e && (e = 0), void 0 === t && (t = this.original.length); e < 0;)e += this.original.length; for (;t < 0;)t += this.original.length; for (var r = '', n = this.firstChunk; n && (n.start > e || n.end <= e);) { if (n.start < t && n.end >= t) return r; n = n.next } if (n && n.edited && n.start !== e) throw new Error(`Cannot use replaced character ${e} as slice start anchor.`); for (let i = n; n;) { !n.intro || i === n && n.start !== e || (r += n.intro); const a = n.start < t && n.end >= t; if (a && n.edited && n.end !== t) throw new Error(`Cannot use replaced character ${t} as slice end anchor.`); const o = i === n ? e - n.start : 0; const s = a ? n.content.length + t - n.end : n.content.length; if (r += n.content.slice(o, s), !n.outro || a && n.end !== t || (r += n.outro), a) break; n = n.next } return r },
      snip: function snip(e, t) { const r = this.clone(); return r.remove(0, e), r.remove(t, r.original.length), r },
      _split: function _split(e) { if (!this.byStart[e] && !this.byEnd[e]) for (let t = this.lastSearchedChunk, r = e > t.end; ;) { if (t.contains(e)) return this._splitChunk(t, e); t = r ? this.byStart[t.end] : this.byEnd[t.start] } },
      _splitChunk: function _splitChunk(e, t) { if (e.edited && e.content.length) { const r = getLocator(this.original)(t); throw new Error(`Cannot split a chunk that has already been edited (${r.line}:${r.column}  "${e.original}")`) } const n = e.split(t); return this.byEnd[t] = e, this.byStart[t] = n, this.byEnd[n.end] = n, e === this.lastChunk && (this.lastChunk = n), this.lastSearchedChunk = e, !0 },
      toString: function toString() { for (var e = this.intro, t = this.firstChunk; t;)e += t.toString(), t = t.next; return e + this.outro },
      trimLines: function trimLines() { return this.trim('[\\r\\n]') },
      trim: function trim(e) { return this.trimStart(e).trimEnd(e) },
      trimEnd: function trimEnd(e) { const t = new RegExp(`${e || '\\s'}+$`); if (this.outro = this.outro.replace(t, ''), this.outro.length) return this; let r = this.lastChunk; do { const n = r.end; const i = r.trimEnd(t); if (r.end !== n && (this.lastChunk === r && (this.lastChunk = r.next), this.byEnd[r.end] = r, this.byStart[r.next.start] = r.next, this.byEnd[r.next.end] = r.next), i) return this; r = r.previous } while (r);return this },
      trimStart: function trimStart(e) { const t = new RegExp(`^${e || '\\s'}+`); if (this.intro = this.intro.replace(t, ''), this.intro.length) return this; let r = this.firstChunk; do { const n = r.end; const i = r.trimStart(t); if (r.end !== n && (r === this.lastChunk && (this.lastChunk = r.next), this.byEnd[r.end] = r, this.byStart[r.next.start] = r.next, this.byEnd[r.next.end] = r.next), i) return this; r = r.next } while (r);return this },
    }; const l = Object.prototype.hasOwnProperty; function Bundle(e) { void 0 === e && (e = {}), this.intro = e.intro || '', this.separator = void 0 !== e.separator ? e.separator : '\n', this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {} }Bundle.prototype = {
      addSource: function addSource(e) { if (e instanceof MagicString$1) return this.addSource({ content: e, filename: e.filename, separator: this.separator }); if (!isObject(e) || !e.content) throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'); if (['filename', 'indentExclusionRanges', 'separator'].forEach((t) => { l.call(e, t) || (e[t] = e.content[t]) }), void 0 === e.separator && (e.separator = this.separator), e.filename) if (l.call(this.uniqueSourceIndexByFilename, e.filename)) { const t = this.uniqueSources[this.uniqueSourceIndexByFilename[e.filename]]; if (e.content.original !== t.content) throw new Error(`Illegal source: same filename (${e.filename}), different contents`); } else this.uniqueSourceIndexByFilename[e.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e.filename, content: e.content.original }); return this.sources.push(e), this },
      append: function append(e, t) { return this.addSource({ content: new MagicString$1(e), separator: t && t.separator || '' }), this },
      clone: function clone() { const e = new Bundle({ intro: this.intro, separator: this.separator }); return this.sources.forEach((t) => { e.addSource({ filename: t.filename, content: t.content.clone(), separator: t.separator }) }), e },
      generateMap: function generateMap(e) {
        const t = this; void 0 === e && (e = {}); const r = []; this.sources.forEach((e) => { Object.keys(e.content.storedNames).forEach((e) => { ~r.indexOf(e) || r.push(e) }) }); const n = new Mappings(e.hires); return this.intro && n.advance(this.intro), this.sources.forEach((e, i) => { i > 0 && n.advance(t.separator); const a = e.filename ? t.uniqueSourceIndexByFilename[e.filename] : -1; const o = e.content; const s = getLocator(o.original); o.intro && n.advance(o.intro), o.firstChunk.eachNext((t) => { const i = s(t.start); t.intro.length && n.advance(t.intro), e.filename ? t.edited ? n.addEdit(a, t.content, t.original, i, t.storeName ? r.indexOf(t.original) : -1) : n.addUneditedChunk(a, t, o.original, i, o.sourcemapLocations) : n.advance(t.content), t.outro.length && n.advance(t.outro) }), o.outro && n.advance(o.outro) }), new SourceMap({
          file: e.file ? e.file.split(/[\/\\]/).pop() : null, sources: this.uniqueSources.map(t => (e.file ? getRelativePath(e.file, t.filename) : t.filename)), sourcesContent: this.uniqueSources.map(t => (e.includeContent ? t.content : null)), names: r, mappings: n.encode(),
        });
      },
      getIndentString: function getIndentString() { const e = {}; return this.sources.forEach((t) => { const r = t.content.indentStr; r !== null && (e[r] || (e[r] = 0), e[r] += 1) }), Object.keys(e).sort((t, r) => e[t] - e[r])[0] || '\t' },
      indent: function indent(e) { const t = this; if (arguments.length || (e = this.getIndentString()), e === '') return this; let r = !this.intro || this.intro.slice(-1) === '\n'; return this.sources.forEach((n, i) => { const a = void 0 !== n.separator ? n.separator : t.separator; const o = r || i > 0 && /\r?\n$/.test(a); n.content.indent(e, { exclude: n.indentExclusionRanges, indentStart: o }), r = n.content.toString().slice(0, -1) === '\n' }), this.intro && (this.intro = e + this.intro.replace(/^[^\n]/gm, (t, r) => (r > 0 ? e + t : t))), this },
      prepend: function prepend(e) { return this.intro = e + this.intro, this },
      toString: function toString() { const e = this; const t = this.sources.map((t, r) => { const n = void 0 !== t.separator ? t.separator : e.separator; return (r > 0 ? n : '') + t.content.toString() }).join(''); return this.intro + t },
      trimLines: function trimLines() { return this.trim('[\\r\\n]') },
      trim: function trim(e) { return this.trimStart(e).trimEnd(e) },
      trimStart: function trimStart(e) { const t = new RegExp(`^${e || '\\s'}+`); if (this.intro = this.intro.replace(t, ''), !this.intro) { let r; let n = 0; do { if (!(r = this.sources[n])) break; r.content.trimStart(e), n += 1 } while (r.content.toString() === '') } return this },
      trimEnd: function trimEnd(e) { let t; const r = new RegExp(`${e || '\\s'}+$`); let n = this.sources.length - 1; do { if (!(t = this.sources[n])) { this.intro = this.intro.replace(r, ''); break }t.content.trimEnd(e), n -= 1 } while (t.content.toString() === '');return this },
    }, t.a = MagicString$1;
  }).call(t, r(137).Buffer, r(45));
}, function (e, t, r) {
  t.a = function encode(e) { let t; if (typeof e === 'number')t = encodeInteger(e); else { t = ''; for (let r = 0; r < e.length; r += 1)t += encodeInteger(e[r]); } return t }; const n = {}; const i = {}; function encodeInteger(e) { let t = ''; e < 0 ? e = -e << 1 | 1 : e <<= 1; do { let r = 31 & e; (e >>= 5) > 0 && (r |= 32), t += i[r] } while (e > 0);return t }'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach((e, t) => { n[e] = t, i[t] = e });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), r.d(t, 'version', () => ne), r.d(t, 'parse', () => parse), r.d(t, 'parseExpressionAt', () => parseExpressionAt), r.d(t, 'tokenizer', () => tokenizer), r.d(t, 'parse_dammit', () => ee), r.d(t, 'LooseParser', () => te), r.d(t, 'pluginsLoose', () => re), r.d(t, 'addLooseExports', () => addLooseExports), r.d(t, 'Parser', () => P), r.d(t, 'plugins', () => T), r.d(t, 'defaultOptions', () => A), r.d(t, 'Position', () => S), r.d(t, 'SourceLocation', () => k), r.d(t, 'getLineInfo', () => getLineInfo), r.d(t, 'Node', () => V), r.d(t, 'TokenType', () => d), r.d(t, 'tokTypes', () => v), r.d(t, 'keywordTypes', () => g), r.d(t, 'TokContext', () => $), r.d(t, 'tokContexts', () => G), r.d(t, 'isIdentifierChar', () => isIdentifierChar), r.d(t, 'isIdentifierStart', () => isIdentifierStart), r.d(t, 'Token', () => Y), r.d(t, 'isNewLine', () => isNewLine), r.d(t, 'lineBreak', () => y), r.d(t, 'lineBreakG', () => b), r.d(t, 'nonASCIIwhitespace', () => x); const n = {
    3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile', 5: 'class enum extends super const export import', 6: 'enum', strict: 'implements interface let package private protected public static yield', strictBind: 'eval arguments',
  }; const i = 'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this'; const a = { 5: i, 6: `${i} const class extends export import super` }; const o = /^in(stanceof)?$/; let s = '--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'; let u = '---------------------------------------------------------------------------------------------------------------------------------------------------'; const l = new RegExp(`[${s}]`); const c = new RegExp(`[${s}${u}]`); s = u = null; const p = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 55, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 698, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 1, 31, 6124, 20, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; const f = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 19719, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; function isInAstralSet(e, t) { for (let r = 65536, n = 0; n < t.length; n += 2) { if ((r += t[n]) > e) return !1; if ((r += t[n + 1]) >= e) return !0; } } function isIdentifierStart(e, t) { return e < 65 ? e === 36 : e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && l.test(String.fromCharCode(e)) : !1 !== t && isInAstralSet(e, p))) } function isIdentifierChar(e, t) { return e < 48 ? e === 36 : e < 58 || !(e < 65) && (e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && c.test(String.fromCharCode(e)) : !1 !== t && (isInAstralSet(e, p) || isInAstralSet(e, f))))) } var d = function TokenType(e, t) { void 0 === t && (t = {}), this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null }; function binop(e, t) { return new d(e, { beforeExpr: !0, binop: t }) } const h = { beforeExpr: !0 }; const m = { startsExpr: !0 }; var g = {}; function kw(e, t) { return void 0 === t && (t = {}), t.keyword = e, g[e] = new d(e, t) } var v = {
    num: new d('num', m),
    regexp: new d('regexp', m),
    string: new d('string', m),
    name: new d('name', m),
    eof: new d('eof'),
    bracketL: new d('[', { beforeExpr: !0, startsExpr: !0 }),
    bracketR: new d(']'),
    braceL: new d('{', { beforeExpr: !0, startsExpr: !0 }),
    braceR: new d('}'),
    parenL: new d('(', { beforeExpr: !0, startsExpr: !0 }),
    parenR: new d(')'),
    comma: new d(',', h),
    semi: new d(';', h),
    colon: new d(':', h),
    dot: new d('.'),
    question: new d('?', h),
    arrow: new d('=>', h),
    template: new d('template'),
    invalidTemplate: new d('invalidTemplate'),
    ellipsis: new d('...', h),
    backQuote: new d('`', m),
    dollarBraceL: new d('${', { beforeExpr: !0, startsExpr: !0 }),
    eq: new d('=', { beforeExpr: !0, isAssign: !0 }),
    assign: new d('_=', { beforeExpr: !0, isAssign: !0 }),
    incDec: new d('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
    prefix: new d('!/~', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    logicalOR: binop('||', 1),
    logicalAND: binop('&&', 2),
    bitwiseOR: binop('|', 3),
    bitwiseXOR: binop('^', 4),
    bitwiseAND: binop('&', 5),
    equality: binop('==/!=/===/!==', 6),
    relational: binop('</>/<=/>=', 7),
    bitShift: binop('<</>>/>>>', 8),
    plusMin: new d('+/-', {
      beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0,
    }),
    modulo: binop('%', 10),
    star: binop('*', 10),
    slash: binop('/', 10),
    starstar: new d('**', { beforeExpr: !0 }),
    _break: kw('break'),
    _case: kw('case', h),
    _catch: kw('catch'),
    _continue: kw('continue'),
    _debugger: kw('debugger'),
    _default: kw('default', h),
    _do: kw('do', { isLoop: !0, beforeExpr: !0 }),
    _else: kw('else', h),
    _finally: kw('finally'),
    _for: kw('for', { isLoop: !0 }),
    _function: kw('function', m),
    _if: kw('if'),
    _return: kw('return', h),
    _switch: kw('switch'),
    _throw: kw('throw', h),
    _try: kw('try'),
    _var: kw('var'),
    _const: kw('const'),
    _while: kw('while', { isLoop: !0 }),
    _with: kw('with'),
    _new: kw('new', { beforeExpr: !0, startsExpr: !0 }),
    _this: kw('this', m),
    _super: kw('super', m),
    _class: kw('class', m),
    _extends: kw('extends', h),
    _export: kw('export'),
    _import: kw('import'),
    _null: kw('null', m),
    _true: kw('true', m),
    _false: kw('false', m),
    _in: kw('in', { beforeExpr: !0, binop: 7 }),
    _instanceof: kw('instanceof', { beforeExpr: !0, binop: 7 }),
    _typeof: kw('typeof', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _void: kw('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _delete: kw('delete', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  }; var y = /\r\n?|\n|\u2028|\u2029/; var b = new RegExp(y.source, 'g'); function isNewLine(e) { return e === 10 || e === 13 || e === 8232 || e === 8233 } var x = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; const D = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g; const _ = Object.prototype; const C = _.hasOwnProperty; const w = _.toString; function has(e, t) { return C.call(e, t) } const E = Array.isArray || function (e) { return w.call(e) === '[object Array]' }; var S = function Position(e, t) { this.line = e, this.column = t }; S.prototype.offset = function offset(e) { return new S(this.line, this.column + e) }; var k = function SourceLocation(e, t, r) { this.start = t, this.end = r, e.sourceFile !== null && (this.source = e.sourceFile) }; function getLineInfo(e, t) { for (let r = 1, n = 0; ;) { b.lastIndex = n; const i = b.exec(e); if (!(i && i.index < t)) return new S(r, t - n); ++r, n = i.index + i[0].length } } var A = {
    ecmaVersion: 7, sourceType: 'script', onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1, plugins: {},
  }; function getOptions(e) {
    const t = {}; for (const r in A)t[r] = e && has(e, r) ? e[r] : A[r]; if (t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), E(t.onToken)) { const n = t.onToken; t.onToken = function (e) { return n.push(e) } } return E(t.onComment) && (t.onComment = (function pushComment(e, t) {
      return function (r, n, i, a, o, s) {
        const u = {
          type: r ? 'Block' : 'Line', value: n, start: i, end: a,
        }; e.locations && (u.loc = new k(this, o, s)), e.ranges && (u.range = [i, a]), t.push(u);
      };
    }(t, t.onComment))), t;
  } var T = {}; function keywordRegexp(e) { return new RegExp(`^(?:${e.replace(/ /g, '|')})$`) } var P = function Parser(e, t, r) { this.options = e = getOptions(e), this.sourceFile = e.sourceFile, this.keywords = keywordRegexp(a[e.ecmaVersion >= 6 ? 6 : 5]); let i = ''; if (!e.allowReserved) { for (let o = e.ecmaVersion; !(i = n[o]); o--);e.sourceType == 'module' && (i += ' await') } this.reservedWords = keywordRegexp(i); const s = (i ? `${i} ` : '') + n.strict; this.reservedWordsStrict = keywordRegexp(s), this.reservedWordsStrictBind = keywordRegexp(`${s} ${n.strictBind}`), this.input = String(t), this.containsEsc = !1, this.loadPlugins(e.plugins), r ? (this.pos = r, this.lineStart = this.input.lastIndexOf('\n', r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(y).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = v.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = e.sourceType === 'module', this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.inFunction = this.inGenerator = this.inAsync = !1, this.yieldPos = this.awaitPos = 0, this.labels = [], this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === '#!' && this.skipLineComment(2), this.scopeStack = [], this.enterFunctionScope(), this.regexpState = null }; P.prototype.isKeyword = function isKeyword(e) { return this.keywords.test(e) }, P.prototype.isReservedWord = function isReservedWord(e) { return this.reservedWords.test(e) }, P.prototype.extend = function extend(e, t) { this[e] = t(this[e]) }, P.prototype.loadPlugins = function loadPlugins(e) { for (const t in e) { const r = T[t]; if (!r) throw new Error(`Plugin '${t}' not found`); r(this, e[t]) } }, P.prototype.parse = function parse() { const e = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(e) }; const R = P.prototype; const O = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/; function DestructuringErrors() { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 }R.strictDirective = function (e) { for (;;) { D.lastIndex = e, e += D.exec(this.input)[0].length; const t = O.exec(this.input.slice(e)); if (!t) return !1; if ((t[1] || t[2]) == 'use strict') return !0; e += t[0].length } }, R.eat = function (e) { return this.type === e && (this.next(), !0) }, R.isContextual = function (e) { return this.type === v.name && this.value === e && !this.containsEsc }, R.eatContextual = function (e) { return !!this.isContextual(e) && (this.next(), !0) }, R.expectContextual = function (e) { this.eatContextual(e) || this.unexpected() }, R.canInsertSemicolon = function () { return this.type === v.eof || this.type === v.braceR || y.test(this.input.slice(this.lastTokEnd, this.start)) }, R.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0; }, R.semicolon = function () { this.eat(v.semi) || this.insertSemicolon() || this.unexpected() }, R.afterTrailingComma = function (e, t) { if (this.type == e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0; }, R.expect = function (e) { this.eat(e) || this.unexpected() }, R.unexpected = function (e) { this.raise(e != null ? e : this.start, 'Unexpected token') }, R.checkPatternErrors = function (e, t) { if (e) { e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, 'Comma is not permitted after the rest element'); const r = t ? e.parenthesizedAssign : e.parenthesizedBind; r > -1 && this.raiseRecoverable(r, 'Parenthesized pattern') } }, R.checkExpressionErrors = function (e, t) { if (!e) return !1; const r = e.shorthandAssign; const n = e.doubleProto; if (!t) return r >= 0 || n >= 0; r >= 0 && this.raise(r, 'Shorthand property assignments are valid only in destructuring patterns'), n >= 0 && this.raiseRecoverable(n, 'Redefinition of __proto__ property') }, R.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, 'Yield expression cannot be a default value'), this.awaitPos && this.raise(this.awaitPos, 'Await expression cannot be a default value') }, R.isSimpleAssignTarget = function (e) { return e.type === 'ParenthesizedExpression' ? this.isSimpleAssignTarget(e.expression) : e.type === 'Identifier' || e.type === 'MemberExpression' }; const F = P.prototype; F.parseTopLevel = function (e) { const t = {}; for (e.body || (e.body = []); this.type !== v.eof;) { const r = this.parseStatement(!0, !0, t); e.body.push(r) } return this.adaptDirectivePrologue(e.body), this.next(), this.options.ecmaVersion >= 6 && (e.sourceType = this.options.sourceType), this.finishNode(e, 'Program') }; const L = { kind: 'loop' }; const M = { kind: 'switch' }; F.isLet = function () { if (this.options.ecmaVersion < 6 || !this.isContextual('let')) return !1; D.lastIndex = this.pos; const e = D.exec(this.input); const t = this.pos + e[0].length; const r = this.input.charCodeAt(t); if (r === 91 || r == 123) return !0; if (isIdentifierStart(r, !0)) { for (var n = t + 1; isIdentifierChar(this.input.charCodeAt(n), !0);)++n; const i = this.input.slice(t, n); if (!o.test(i)) return !0; } return !1 }, F.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual('async')) return !1; D.lastIndex = this.pos; const e = D.exec(this.input); const t = this.pos + e[0].length; return !(y.test(this.input.slice(this.pos, t)) || this.input.slice(t, t + 8) !== 'function' || t + 8 != this.input.length && isIdentifierChar(this.input.charAt(t + 8))) }, F.parseStatement = function (e, t, r) { let n; let i = this.type; const a = this.startNode(); switch (this.isLet() && (i = v._var, n = 'let'), i) { case v._break: case v._continue: return this.parseBreakContinueStatement(a, i.keyword); case v._debugger: return this.parseDebuggerStatement(a); case v._do: return this.parseDoStatement(a); case v._for: return this.parseForStatement(a); case v._function: return !e && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(a, !1); case v._class: return e || this.unexpected(), this.parseClass(a, !0); case v._if: return this.parseIfStatement(a); case v._return: return this.parseReturnStatement(a); case v._switch: return this.parseSwitchStatement(a); case v._throw: return this.parseThrowStatement(a); case v._try: return this.parseTryStatement(a); case v._const: case v._var: return n = n || this.value, e || n == 'var' || this.unexpected(), this.parseVarStatement(a, n); case v._while: return this.parseWhileStatement(a); case v._with: return this.parseWithStatement(a); case v.braceL: return this.parseBlock(); case v.semi: return this.parseEmptyStatement(a); case v._export: case v._import: return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === v._import ? this.parseImport(a) : this.parseExport(a, r); default: if (this.isAsyncFunction()) return e || this.unexpected(), this.next(), this.parseFunctionStatement(a, !0); var o = this.value; var s = this.parseExpression(); return i === v.name && s.type === 'Identifier' && this.eat(v.colon) ? this.parseLabeledStatement(a, o, s) : this.parseExpressionStatement(a, s); } }, F.parseBreakContinueStatement = function (e, t) { const r = t == 'break'; this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.label = null : this.type !== v.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon()); for (var n = 0; n < this.labels.length; ++n) { const i = this.labels[n]; if (e.label == null || i.name === e.label.name) { if (i.kind != null && (r || i.kind === 'loop')) break; if (e.label && r) break; } } return n === this.labels.length && this.raise(e.start, `Unsyntactic ${t}`), this.finishNode(e, r ? 'BreakStatement' : 'ContinueStatement') }, F.parseDebuggerStatement = function (e) { return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement') }, F.parseDoStatement = function (e) { return this.next(), this.labels.push(L), e.body = this.parseStatement(!1), this.labels.pop(), this.expect(v._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(v.semi) : this.semicolon(), this.finishNode(e, 'DoWhileStatement') }, F.parseForStatement = function (e) {
    this.next(); const t = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual('await') ? this.lastTokStart : -1; if (this.labels.push(L), this.enterLexicalScope(), this.expect(v.parenL), this.type === v.semi) return t > -1 && this.unexpected(t), this.parseFor(e, null); const r = this.isLet(); if (this.type === v._var || this.type === v._const || r) { const n = this.startNode(); const i = r ? 'let' : this.value; return this.next(), this.parseVar(n, !0, i), this.finishNode(n, 'VariableDeclaration'), !(this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual('of')) || n.declarations.length !== 1 || i !== 'var' && n.declarations[0].init ? (t > -1 && this.unexpected(t), this.parseFor(e, n)) : (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, n)) } const a = new DestructuringErrors(); const
      o = this.parseExpression(!0, a); return this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual('of') ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.toAssignable(o, !1, a), this.checkLVal(o), this.parseForIn(e, o)) : (this.checkExpressionErrors(a, !0), t > -1 && this.unexpected(t), this.parseFor(e, o));
  }, F.parseFunctionStatement = function (e, t) { return this.next(), this.parseFunction(e, !0, !1, t) }, F.parseIfStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement(!this.strict && this.type == v._function), e.alternate = this.eat(v._else) ? this.parseStatement(!this.strict && this.type == v._function) : null, this.finishNode(e, 'IfStatement') }, F.parseReturnStatement = function (e) { return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, 'ReturnStatement') }, F.parseSwitchStatement = function (e) { let t; this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(v.braceL), this.labels.push(M), this.enterLexicalScope(); for (let r = !1; this.type != v.braceR;) if (this.type === v._case || this.type === v._default) { const n = this.type === v._case; t && this.finishNode(t, 'SwitchCase'), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), n ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, 'Multiple default clauses'), r = !0, t.test = null), this.expect(v.colon) } else t || this.unexpected(), t.consequent.push(this.parseStatement(!0)); return this.exitLexicalScope(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.labels.pop(), this.finishNode(e, 'SwitchStatement') }, F.parseThrowStatement = function (e) { return this.next(), y.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, 'Illegal newline after throw'), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, 'ThrowStatement') }; const j = []; F.parseTryStatement = function (e) { if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === v._catch) { const t = this.startNode(); this.next(), this.expect(v.parenL), t.param = this.parseBindingAtom(), this.enterLexicalScope(), this.checkLVal(t.param, 'let'), this.expect(v.parenR), t.body = this.parseBlock(!1), this.exitLexicalScope(), e.handler = this.finishNode(t, 'CatchClause') } return e.finalizer = this.eat(v._finally) ? this.parseBlock() : null, e.handler || e.finalizer || this.raise(e.start, 'Missing catch or finally clause'), this.finishNode(e, 'TryStatement') }, F.parseVarStatement = function (e, t) { return this.next(), this.parseVar(e, !1, t), this.semicolon(), this.finishNode(e, 'VariableDeclaration') }, F.parseWhileStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), this.labels.push(L), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'WhileStatement') }, F.parseWithStatement = function (e) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement(!1), this.finishNode(e, 'WithStatement') }, F.parseEmptyStatement = function (e) { return this.next(), this.finishNode(e, 'EmptyStatement') }, F.parseLabeledStatement = function (e, t, r) { for (let n = 0, i = this.labels; n < i.length; n += 1) { i[n].name === t && this.raise(r.start, `Label '${t}' is already declared`) } for (var a = this.type.isLoop ? 'loop' : this.type === v._switch ? 'switch' : null, o = this.labels.length - 1; o >= 0; o--) { const s = this.labels[o]; if (s.statementStart != e.start) break; s.statementStart = this.start, s.kind = a } return this.labels.push({ name: t, kind: a, statementStart: this.start }), e.body = this.parseStatement(!0), (e.body.type == 'ClassDeclaration' || e.body.type == 'VariableDeclaration' && e.body.kind != 'var' || e.body.type == 'FunctionDeclaration' && (this.strict || e.body.generator)) && this.raiseRecoverable(e.body.start, 'Invalid labeled declaration'), this.labels.pop(), e.label = r, this.finishNode(e, 'LabeledStatement') }, F.parseExpressionStatement = function (e, t) { return e.expression = t, this.semicolon(), this.finishNode(e, 'ExpressionStatement') }, F.parseBlock = function (e) { void 0 === e && (e = !0); const t = this.startNode(); for (t.body = [], this.expect(v.braceL), e && this.enterLexicalScope(); !this.eat(v.braceR);) { const r = this.parseStatement(!0); t.body.push(r) } return e && this.exitLexicalScope(), this.finishNode(t, 'BlockStatement') }, F.parseFor = function (e, t) { return e.init = t, this.expect(v.semi), e.test = this.type === v.semi ? null : this.parseExpression(), this.expect(v.semi), e.update = this.type === v.parenR ? null : this.parseExpression(), this.expect(v.parenR), this.exitLexicalScope(), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'ForStatement') }, F.parseForIn = function (e, t) { const r = this.type === v._in ? 'ForInStatement' : 'ForOfStatement'; return this.next(), r == 'ForInStatement' && (t.type === 'AssignmentPattern' || t.type === 'VariableDeclaration' && t.declarations[0].init != null && (this.strict || t.declarations[0].id.type !== 'Identifier')) && this.raise(t.start, 'Invalid assignment in for-in loop head'), e.left = t, e.right = r == 'ForInStatement' ? this.parseExpression() : this.parseMaybeAssign(), this.expect(v.parenR), this.exitLexicalScope(), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, r) }, F.parseVar = function (e, t, r) { for (e.declarations = [], e.kind = r; ;) { const n = this.startNode(); if (this.parseVarId(n, r), this.eat(v.eq) ? n.init = this.parseMaybeAssign(t) : r !== 'const' || this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual('of') ? n.id.type == 'Identifier' || t && (this.type === v._in || this.isContextual('of')) ? n.init = null : this.raise(this.lastTokEnd, 'Complex binding patterns require an initialization value') : this.unexpected(), e.declarations.push(this.finishNode(n, 'VariableDeclarator')), !this.eat(v.comma)) break; } return e }, F.parseVarId = function (e, t) { e.id = this.parseBindingAtom(t), this.checkLVal(e.id, t, !1) }, F.parseFunction = function (e, t, r, n) { this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !n) && (e.generator = this.eat(v.star)), this.options.ecmaVersion >= 8 && (e.async = !!n), t && (e.id = t === 'nullableID' && this.type != v.name ? null : this.parseIdent(), e.id && this.checkLVal(e.id, 'var')); const i = this.inGenerator; const a = this.inAsync; const o = this.yieldPos; const s = this.awaitPos; const u = this.inFunction; return this.inGenerator = e.generator, this.inAsync = e.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), t || (e.id = this.type == v.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r), this.inGenerator = i, this.inAsync = a, this.yieldPos = o, this.awaitPos = s, this.inFunction = u, this.finishNode(e, t ? 'FunctionDeclaration' : 'FunctionExpression') }, F.parseFunctionParams = function (e) { this.expect(v.parenL), e.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, F.parseClass = function (e, t) { this.next(), this.parseClassId(e, t), this.parseClassSuper(e); const r = this.startNode(); let n = !1; for (r.body = [], this.expect(v.braceL); !this.eat(v.braceR);) { const i = this.parseClassMember(r); i && i.type === 'MethodDefinition' && i.kind === 'constructor' && (n && this.raise(i.start, 'Duplicate constructor in the same class'), n = !0) } return e.body = this.finishNode(r, 'ClassBody'), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression') }, F.parseClassMember = function (e) { const t = this; if (this.eat(v.semi)) return null; const r = this.startNode(); const n = function (e, n) { void 0 === n && (n = !1); const i = t.start; const a = t.startLoc; return !!t.eatContextual(e) && (!(t.type === v.parenL || n && t.canInsertSemicolon()) || (r.key && t.unexpected(), r.computed = !1, r.key = t.startNodeAt(i, a), r.key.name = e, t.finishNode(r.key, 'Identifier'), !1)) }; r.kind = 'method', r.static = n('static'); let i = this.eat(v.star); let a = !1; i || (this.options.ecmaVersion >= 8 && n('async', !0) ? (a = !0, i = this.options.ecmaVersion >= 9 && this.eat(v.star)) : n('get') ? r.kind = 'get' : n('set') && (r.kind = 'set')), r.key || this.parsePropertyName(r); const o = r.key; return r.computed || r.static || !(o.type === 'Identifier' && o.name === 'constructor' || o.type === 'Literal' && o.value === 'constructor') ? r.static && o.type === 'Identifier' && o.name === 'prototype' && this.raise(o.start, 'Classes may not have a static property named prototype') : (r.kind !== 'method' && this.raise(o.start, "Constructor can't have get/set modifier"), i && this.raise(o.start, "Constructor can't be a generator"), a && this.raise(o.start, "Constructor can't be an async method"), r.kind = 'constructor'), this.parseClassMethod(e, r, i, a), r.kind === 'get' && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, 'getter should have no params'), r.kind === 'set' && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, 'setter should have exactly one param'), r.kind === 'set' && r.value.params[0].type === 'RestElement' && this.raiseRecoverable(r.value.params[0].start, 'Setter cannot use rest params'), r }, F.parseClassMethod = function (e, t, r, n) { t.value = this.parseMethod(r, n), e.body.push(this.finishNode(t, 'MethodDefinition')) }, F.parseClassId = function (e, t) { e.id = this.type === v.name ? this.parseIdent() : !0 === t ? this.unexpected() : null }, F.parseClassSuper = function (e) { e.superClass = this.eat(v._extends) ? this.parseExprSubscripts() : null }, F.parseExport = function (e, t) { if (this.next(), this.eat(v.star)) return this.expectContextual('from'), this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, 'ExportAllDeclaration'); if (this.eat(v._default)) { let r; if (this.checkExport(t, 'default', this.lastTokStart), this.type === v._function || (r = this.isAsyncFunction())) { const n = this.startNode(); this.next(), r && this.next(), e.declaration = this.parseFunction(n, 'nullableID', !1, r) } else if (this.type === v._class) { const i = this.startNode(); e.declaration = this.parseClass(i, 'nullableID') } else e.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(e, 'ExportDefaultDeclaration') } if (this.shouldParseExportStatement())e.declaration = this.parseStatement(!0), e.declaration.type === 'VariableDeclaration' ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id.name, e.declaration.id.start), e.specifiers = [], e.source = null; else { if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual('from')) this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom(); else { for (let a = 0, o = e.specifiers; a < o.length; a += 1) { const s = o[a]; this.checkUnreserved(s.local) }e.source = null } this.semicolon() } return this.finishNode(e, 'ExportNamedDeclaration') }, F.checkExport = function (e, t, r) { e && (has(e, t) && this.raiseRecoverable(r, `Duplicate export '${t}'`), e[t] = !0) }, F.checkPatternExport = function (e, t) { const r = t.type; if (r == 'Identifier') this.checkExport(e, t.name, t.start); else if (r == 'ObjectPattern') for (let n = 0, i = t.properties; n < i.length; n += 1) { const a = i[n]; this.checkPatternExport(e, a) } else if (r == 'ArrayPattern') for (let o = 0, s = t.elements; o < s.length; o += 1) { const u = s[o]; u && this.checkPatternExport(e, u) } else r == 'Property' ? this.checkPatternExport(e, t.value) : r == 'AssignmentPattern' ? this.checkPatternExport(e, t.left) : r == 'RestElement' ? this.checkPatternExport(e, t.argument) : r == 'ParenthesizedExpression' && this.checkPatternExport(e, t.expression); }, F.checkVariableExport = function (e, t) { if (e) for (let r = 0, n = t; r < n.length; r += 1) { const i = n[r]; this.checkPatternExport(e, i.id) } }, F.shouldParseExportStatement = function () { return this.type.keyword === 'var' || this.type.keyword === 'const' || this.type.keyword === 'class' || this.type.keyword === 'function' || this.isLet() || this.isAsyncFunction() }, F.parseExportSpecifiers = function (e) { const t = []; let r = !0; for (this.expect(v.braceL); !this.eat(v.braceR);) { if (r)r = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; const n = this.startNode(); n.local = this.parseIdent(!0), n.exported = this.eatContextual('as') ? this.parseIdent(!0) : n.local, this.checkExport(e, n.exported.name, n.exported.start), t.push(this.finishNode(n, 'ExportSpecifier')) } return t }, F.parseImport = function (e) { return this.next(), this.type === v.string ? (e.specifiers = j, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual('from'), e.source = this.type === v.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, 'ImportDeclaration') }, F.parseImportSpecifiers = function () { const e = []; let t = !0; if (this.type === v.name) { const r = this.startNode(); if (r.local = this.parseIdent(), this.checkLVal(r.local, 'let'), e.push(this.finishNode(r, 'ImportDefaultSpecifier')), !this.eat(v.comma)) return e; } if (this.type === v.star) { const n = this.startNode(); return this.next(), this.expectContextual('as'), n.local = this.parseIdent(), this.checkLVal(n.local, 'let'), e.push(this.finishNode(n, 'ImportNamespaceSpecifier')), e } for (this.expect(v.braceL); !this.eat(v.braceR);) { if (t)t = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; const i = this.startNode(); i.imported = this.parseIdent(!0), this.eatContextual('as') ? i.local = this.parseIdent() : (this.checkUnreserved(i.imported), i.local = i.imported), this.checkLVal(i.local, 'let'), e.push(this.finishNode(i, 'ImportSpecifier')) } return e }, F.adaptDirectivePrologue = function (e) { for (let t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)e[t].directive = e[t].expression.raw.slice(1, -1); }, F.isDirectiveCandidate = function (e) { return e.type === 'ExpressionStatement' && e.expression.type === 'Literal' && typeof e.expression.value === 'string' && (this.input[e.start] === '"' || this.input[e.start] === "'") }; const N = P.prototype; N.toAssignable = function (e, t, r) { if (this.options.ecmaVersion >= 6 && e) switch (e.type) { case 'Identifier': this.inAsync && e.name === 'await' && this.raise(e.start, "Can not use 'await' as identifier inside an async function"); break; case 'ObjectPattern': case 'ArrayPattern': case 'RestElement': break; case 'ObjectExpression': e.type = 'ObjectPattern', r && this.checkPatternErrors(r, !0); for (let n = 0, i = e.properties; n < i.length; n += 1) { const a = i[n]; this.toAssignable(a, t), a.type !== 'RestElement' || a.argument.type !== 'ArrayPattern' && a.argument.type !== 'ObjectPattern' || this.raise(a.argument.start, 'Unexpected token') } break; case 'Property': e.kind !== 'init' && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t); break; case 'ArrayExpression': e.type = 'ArrayPattern', r && this.checkPatternErrors(r, !0), this.toAssignableList(e.elements, t); break; case 'SpreadElement': e.type = 'RestElement', this.toAssignable(e.argument, t), e.argument.type === 'AssignmentPattern' && this.raise(e.argument.start, 'Rest elements cannot have a default value'); break; case 'AssignmentExpression': e.operator !== '=' && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = 'AssignmentPattern', delete e.operator, this.toAssignable(e.left, t); case 'AssignmentPattern': break; case 'ParenthesizedExpression': this.toAssignable(e.expression, t); break; case 'MemberExpression': if (!t) break; default: this.raise(e.start, 'Assigning to rvalue'); } else r && this.checkPatternErrors(r, !0); return e }, N.toAssignableList = function (e, t) { for (var r = e.length, n = 0; n < r; n++) { const i = e[n]; i && this.toAssignable(i, t) } if (r) { const a = e[r - 1]; this.options.ecmaVersion === 6 && t && a && a.type === 'RestElement' && a.argument.type !== 'Identifier' && this.unexpected(a.argument.start) } return e }, N.parseSpread = function (e) { const t = this.startNode(); return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, 'SpreadElement') }, N.parseRestBinding = function () { const e = this.startNode(); return this.next(), this.options.ecmaVersion === 6 && this.type !== v.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, 'RestElement') }, N.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case v.bracketL: var e = this.startNode(); return this.next(), e.elements = this.parseBindingList(v.bracketR, !0, !0), this.finishNode(e, 'ArrayPattern'); case v.braceL: return this.parseObj(!0); } return this.parseIdent() }, N.parseBindingList = function (e, t, r) { for (var n = [], i = !0; !this.eat(e);) if (i ? i = !1 : this.expect(v.comma), t && this.type === v.comma)n.push(null); else { if (r && this.afterTrailingComma(e)) break; if (this.type === v.ellipsis) { const a = this.parseRestBinding(); this.parseBindingListItem(a), n.push(a), this.type === v.comma && this.raise(this.start, 'Comma is not permitted after the rest element'), this.expect(e); break } const o = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(o), n.push(o) } return n }, N.parseBindingListItem = function (e) { return e }, N.parseMaybeDefault = function (e, t, r) { if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(v.eq)) return r; const n = this.startNodeAt(e, t); return n.left = r, n.right = this.parseMaybeAssign(), this.finishNode(n, 'AssignmentPattern') }, N.checkLVal = function (e, t, r) { switch (e.type) { case 'Identifier': this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, `${(t ? 'Binding ' : 'Assigning to ') + e.name} in strict mode`), r && (has(r, e.name) && this.raiseRecoverable(e.start, 'Argument name clash'), r[e.name] = !0), t && t !== 'none' && ((t === 'var' && !this.canDeclareVarName(e.name) || t !== 'var' && !this.canDeclareLexicalName(e.name)) && this.raiseRecoverable(e.start, `Identifier '${e.name}' has already been declared`), t === 'var' ? this.declareVarName(e.name) : this.declareLexicalName(e.name)); break; case 'MemberExpression': t && this.raiseRecoverable(e.start, 'Binding member expression'); break; case 'ObjectPattern': for (let n = 0, i = e.properties; n < i.length; n += 1) { const a = i[n]; this.checkLVal(a, t, r) } break; case 'Property': this.checkLVal(e.value, t, r); break; case 'ArrayPattern': for (let o = 0, s = e.elements; o < s.length; o += 1) { const u = s[o]; u && this.checkLVal(u, t, r) } break; case 'AssignmentPattern': this.checkLVal(e.left, t, r); break; case 'RestElement': this.checkLVal(e.argument, t, r); break; case 'ParenthesizedExpression': this.checkLVal(e.expression, t, r); break; default: this.raise(e.start, `${t ? 'Binding' : 'Assigning to'} rvalue`); } }; const I = P.prototype; I.checkPropClash = function (e, t, r) { if (!(this.options.ecmaVersion >= 9 && e.type === 'SpreadElement' || this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) { let n; const i = e.key; switch (i.type) { case 'Identifier': n = i.name; break; case 'Literal': n = String(i.value); break; default: return; } const a = e.kind; if (this.options.ecmaVersion >= 6)n === '__proto__' && a === 'init' && (t.proto && (r && r.doubleProto < 0 ? r.doubleProto = i.start : this.raiseRecoverable(i.start, 'Redefinition of __proto__ property')), t.proto = !0); else { let o = t[n = `$${n}`]; if (o)(a === 'init' ? this.strict && o.init || o.get || o.set : o.init || o[a]) && this.raiseRecoverable(i.start, 'Redefinition of property'); else o = t[n] = { init: !1, get: !1, set: !1 }; o[a] = !0 } } }, I.parseExpression = function (e, t) { const r = this.start; const n = this.startLoc; const i = this.parseMaybeAssign(e, t); if (this.type === v.comma) { const a = this.startNodeAt(r, n); for (a.expressions = [i]; this.eat(v.comma);)a.expressions.push(this.parseMaybeAssign(e, t)); return this.finishNode(a, 'SequenceExpression') } return i }, I.parseMaybeAssign = function (e, t, r) { if (this.inGenerator && this.isContextual('yield')) return this.parseYield(); let n = !1; let i = -1; let a = -1; t ? (i = t.parenthesizedAssign, a = t.trailingComma, t.parenthesizedAssign = t.trailingComma = -1) : (t = new DestructuringErrors(), n = !0); const o = this.start; const s = this.startLoc; this.type != v.parenL && this.type != v.name || (this.potentialArrowAt = this.start); let u = this.parseMaybeConditional(e, t); if (r && (u = r.call(this, u, o, s)), this.type.isAssign) { const l = this.startNodeAt(o, s); return l.operator = this.value, l.left = this.type === v.eq ? this.toAssignable(u, !1, t) : u, n || DestructuringErrors.call(t), t.shorthandAssign = -1, this.checkLVal(u), this.next(), l.right = this.parseMaybeAssign(e), this.finishNode(l, 'AssignmentExpression') } return n && this.checkExpressionErrors(t, !0), i > -1 && (t.parenthesizedAssign = i), a > -1 && (t.trailingComma = a), u }, I.parseMaybeConditional = function (e, t) { const r = this.start; const n = this.startLoc; const i = this.parseExprOps(e, t); if (this.checkExpressionErrors(t)) return i; if (this.eat(v.question)) { const a = this.startNodeAt(r, n); return a.test = i, a.consequent = this.parseMaybeAssign(), this.expect(v.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(a, 'ConditionalExpression') } return i }, I.parseExprOps = function (e, t) { const r = this.start; const n = this.startLoc; const i = this.parseMaybeUnary(t, !1); return this.checkExpressionErrors(t) ? i : i.start == r && i.type === 'ArrowFunctionExpression' ? i : this.parseExprOp(i, r, n, -1, e) }, I.parseExprOp = function (e, t, r, n, i) { const a = this.type.binop; if (a != null && (!i || this.type !== v._in) && a > n) { const o = this.type === v.logicalOR || this.type === v.logicalAND; const s = this.value; this.next(); const u = this.start; const l = this.startLoc; const c = this.parseExprOp(this.parseMaybeUnary(null, !1), u, l, a, i); const p = this.buildBinary(t, r, e, c, s, o); return this.parseExprOp(p, t, r, n, i) } return e }, I.buildBinary = function (e, t, r, n, i, a) { const o = this.startNodeAt(e, t); return o.left = r, o.operator = i, o.right = n, this.finishNode(o, a ? 'LogicalExpression' : 'BinaryExpression') }, I.parseMaybeUnary = function (e, t) { let r; const n = this.start; const i = this.startLoc; if (this.inAsync && this.isContextual('await'))r = this.parseAwait(), t = !0; else if (this.type.prefix) { const a = this.startNode(); const o = this.type === v.incDec; a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), o ? this.checkLVal(a.argument) : this.strict && a.operator === 'delete' && a.argument.type === 'Identifier' ? this.raiseRecoverable(a.start, 'Deleting local variable in strict mode') : t = !0, r = this.finishNode(a, o ? 'UpdateExpression' : 'UnaryExpression') } else { if (r = this.parseExprSubscripts(e), this.checkExpressionErrors(e)) return r; for (;this.type.postfix && !this.canInsertSemicolon();) { const s = this.startNodeAt(n, i); s.operator = this.value, s.prefix = !1, s.argument = r, this.checkLVal(r), this.next(), r = this.finishNode(s, 'UpdateExpression') } } return !t && this.eat(v.starstar) ? this.buildBinary(n, i, r, this.parseMaybeUnary(null, !1), '**', !1) : r }, I.parseExprSubscripts = function (e) { const t = this.start; const r = this.startLoc; const n = this.parseExprAtom(e); const i = n.type === 'ArrowFunctionExpression' && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')'; if (this.checkExpressionErrors(e) || i) return n; const a = this.parseSubscripts(n, t, r); return e && a.type === 'MemberExpression' && (e.parenthesizedAssign >= a.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= a.start && (e.parenthesizedBind = -1)), a }, I.parseSubscripts = function (e, t, r, n) {
    for (let i = this.options.ecmaVersion >= 8 && e.type === 'Identifier' && e.name === 'async' && this.lastTokEnd == e.end && !this.canInsertSemicolon() && this.input.slice(e.start, e.end) === 'async', a = void 0; ;) {
      if ((a = this.eat(v.bracketL)) || this.eat(v.dot)) { const o = this.startNodeAt(t, r); o.object = e, o.property = a ? this.parseExpression() : this.parseIdent(!0), o.computed = !!a, a && this.expect(v.bracketR), e = this.finishNode(o, 'MemberExpression') } else if (!n && this.eat(v.parenL)) {
        const s = new DestructuringErrors();


        const u = this.yieldPos; const
          l = this.awaitPos; this.yieldPos = 0, this.awaitPos = 0; const c = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1, s); if (i && !this.canInsertSemicolon() && this.eat(v.arrow)) return this.checkPatternErrors(s, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = u, this.awaitPos = l, this.parseArrowExpression(this.startNodeAt(t, r), c, !0); this.checkExpressionErrors(s, !0), this.yieldPos = u || this.yieldPos, this.awaitPos = l || this.awaitPos; const p = this.startNodeAt(t, r); p.callee = e, p.arguments = c, e = this.finishNode(p, 'CallExpression');
      } else { if (this.type !== v.backQuote) return e; const f = this.startNodeAt(t, r); f.tag = e, f.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(f, 'TaggedTemplateExpression') }
    }
  }, I.parseExprAtom = function (e) { let t; const r = this.potentialArrowAt == this.start; switch (this.type) { case v._super: return this.inFunction || this.raise(this.start, "'super' outside of function or class"), t = this.startNode(), this.next(), this.type !== v.dot && this.type !== v.bracketL && this.type !== v.parenL && this.unexpected(), this.finishNode(t, 'Super'); case v._this: return t = this.startNode(), this.next(), this.finishNode(t, 'ThisExpression'); case v.name: var n = this.start; var i = this.startLoc; var a = this.containsEsc; var o = this.parseIdent(this.type !== v.name); if (this.options.ecmaVersion >= 8 && !a && o.name === 'async' && !this.canInsertSemicolon() && this.eat(v._function)) return this.parseFunction(this.startNodeAt(n, i), !1, !1, !0); if (r && !this.canInsertSemicolon()) { if (this.eat(v.arrow)) return this.parseArrowExpression(this.startNodeAt(n, i), [o], !1); if (this.options.ecmaVersion >= 8 && o.name === 'async' && this.type === v.name && !a) return o = this.parseIdent(), !this.canInsertSemicolon() && this.eat(v.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n, i), [o], !0); } return o; case v.regexp: var s = this.value; return (t = this.parseLiteral(s.value)).regex = { pattern: s.pattern, flags: s.flags }, t; case v.num: case v.string: return this.parseLiteral(this.value); case v._null: case v._true: case v._false: return (t = this.startNode()).value = this.type === v._null ? null : this.type === v._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, 'Literal'); case v.parenL: var u = this.start; var l = this.parseParenAndDistinguishExpression(r); return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(l) && (e.parenthesizedAssign = u), e.parenthesizedBind < 0 && (e.parenthesizedBind = u)), l; case v.bracketL: return t = this.startNode(), this.next(), t.elements = this.parseExprList(v.bracketR, !0, !0, e), this.finishNode(t, 'ArrayExpression'); case v.braceL: return this.parseObj(!1, e); case v._function: return t = this.startNode(), this.next(), this.parseFunction(t, !1); case v._class: return this.parseClass(this.startNode(), !1); case v._new: return this.parseNew(); case v.backQuote: return this.parseTemplate(); default: this.unexpected(); } }, I.parseLiteral = function (e) { const t = this.startNode(); return t.value = e, t.raw = this.input.slice(this.start, this.end), this.next(), this.finishNode(t, 'Literal') }, I.parseParenExpression = function () { this.expect(v.parenL); const e = this.parseExpression(); return this.expect(v.parenR), e }, I.parseParenAndDistinguishExpression = function (e) { let t; const r = this.start; const n = this.startLoc; const i = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); let a; const o = this.start; const s = this.startLoc; const u = []; let l = !0; let c = !1; const p = new DestructuringErrors(); const f = this.yieldPos; const d = this.awaitPos; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== v.parenR;) { if (l ? l = !1 : this.expect(v.comma), i && this.afterTrailingComma(v.parenR, !0)) { c = !0; break } if (this.type === v.ellipsis) { a = this.start, u.push(this.parseParenItem(this.parseRestBinding())), this.type === v.comma && this.raise(this.start, 'Comma is not permitted after the rest element'); break }u.push(this.parseMaybeAssign(!1, p, this.parseParenItem)) } const h = this.start; const m = this.startLoc; if (this.expect(v.parenR), e && !this.canInsertSemicolon() && this.eat(v.arrow)) return this.checkPatternErrors(p, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = d, this.parseParenArrowList(r, n, u); u.length && !c || this.unexpected(this.lastTokStart), a && this.unexpected(a), this.checkExpressionErrors(p, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = d || this.awaitPos, u.length > 1 ? ((t = this.startNodeAt(o, s)).expressions = u, this.finishNodeAt(t, 'SequenceExpression', h, m)) : t = u[0] } else t = this.parseParenExpression(); if (this.options.preserveParens) { const g = this.startNodeAt(r, n); return g.expression = t, this.finishNode(g, 'ParenthesizedExpression') } return t }, I.parseParenItem = function (e) { return e }, I.parseParenArrowList = function (e, t, r) { return this.parseArrowExpression(this.startNodeAt(e, t), r) }; const B = []; I.parseNew = function () { const e = this.startNode(); const t = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(v.dot)) { e.meta = t; const r = this.containsEsc; return e.property = this.parseIdent(!0), (e.property.name !== 'target' || r) && this.raiseRecoverable(e.property.start, 'The only valid meta property for new is new.target'), this.inFunction || this.raiseRecoverable(e.start, 'new.target can only be used in functions'), this.finishNode(e, 'MetaProperty') } const n = this.start; const i = this.startLoc; return e.callee = this.parseSubscripts(this.parseExprAtom(), n, i, !0), this.eat(v.parenL) ? e.arguments = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = B, this.finishNode(e, 'NewExpression') }, I.parseTemplateElement = function (e) { const t = e.isTagged; const r = this.startNode(); return this.type === v.invalidTemplate ? (t || this.raiseRecoverable(this.start, 'Bad escape sequence in untagged template literal'), r.value = { raw: this.value, cooked: null }) : r.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'), cooked: this.value }, this.next(), r.tail = this.type === v.backQuote, this.finishNode(r, 'TemplateElement') }, I.parseTemplate = function (e) { void 0 === e && (e = {}); let t = e.isTagged; void 0 === t && (t = !1); const r = this.startNode(); this.next(), r.expressions = []; let n = this.parseTemplateElement({ isTagged: t }); for (r.quasis = [n]; !n.tail;) this.expect(v.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(v.braceR), r.quasis.push(n = this.parseTemplateElement({ isTagged: t })); return this.next(), this.finishNode(r, 'TemplateLiteral') }, I.isAsyncProp = function (e) { return !e.computed && e.key.type === 'Identifier' && e.key.name === 'async' && (this.type === v.name || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === v.star) && !y.test(this.input.slice(this.lastTokEnd, this.start)) }, I.parseObj = function (e, t) { const r = this.startNode(); let n = !0; const i = {}; for (r.properties = [], this.next(); !this.eat(v.braceR);) { if (n)n = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; const a = this.parseProperty(e, t); e || this.checkPropClash(a, i, t), r.properties.push(a) } return this.finishNode(r, e ? 'ObjectPattern' : 'ObjectExpression') }, I.parseProperty = function (e, t) { let r; let n; let i; let a; const o = this.startNode(); if (this.options.ecmaVersion >= 9 && this.eat(v.ellipsis)) return e ? (o.argument = this.parseIdent(!1), this.type === v.comma && this.raise(this.start, 'Comma is not permitted after the rest element'), this.finishNode(o, 'RestElement')) : (this.type === v.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), o.argument = this.parseMaybeAssign(!1, t), this.type === v.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(o, 'SpreadElement')); this.options.ecmaVersion >= 6 && (o.method = !1, o.shorthand = !1, (e || t) && (i = this.start, a = this.startLoc), e || (r = this.eat(v.star))); const s = this.containsEsc; return this.parsePropertyName(o), !e && !s && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(o) ? (n = !0, r = this.options.ecmaVersion >= 9 && this.eat(v.star), this.parsePropertyName(o, t)) : n = !1, this.parsePropertyValue(o, e, r, n, i, a, t, s), this.finishNode(o, 'Property') }, I.parsePropertyValue = function (e, t, r, n, i, a, o, s) { if ((r || n) && this.type === v.colon && this.unexpected(), this.eat(v.colon))e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o), e.kind = 'init'; else if (this.options.ecmaVersion >= 6 && this.type === v.parenL)t && this.unexpected(), e.kind = 'init', e.method = !0, e.value = this.parseMethod(r, n); else if (t || s || !(this.options.ecmaVersion >= 5) || e.computed || e.key.type !== 'Identifier' || e.key.name !== 'get' && e.key.name !== 'set' || this.type == v.comma || this.type == v.braceR) this.options.ecmaVersion >= 6 && !e.computed && e.key.type === 'Identifier' ? (this.checkUnreserved(e.key), e.kind = 'init', t ? e.value = this.parseMaybeDefault(i, a, e.key) : this.type === v.eq && o ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), e.value = this.parseMaybeDefault(i, a, e.key)) : e.value = e.key, e.shorthand = !0) : this.unexpected(); else { (r || n) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1); const u = e.kind === 'get' ? 0 : 1; if (e.value.params.length !== u) { const l = e.value.start; e.kind === 'get' ? this.raiseRecoverable(l, 'getter should have no params') : this.raiseRecoverable(l, 'setter should have exactly one param') } else e.kind === 'set' && e.value.params[0].type === 'RestElement' && this.raiseRecoverable(e.value.params[0].start, 'Setter cannot use rest params'); } }, I.parsePropertyName = function (e) { if (this.options.ecmaVersion >= 6) { if (this.eat(v.bracketL)) return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(v.bracketR), e.key; e.computed = !1 } return e.key = this.type === v.num || this.type === v.string ? this.parseExprAtom() : this.parseIdent(!0) }, I.initFunction = function (e) { e.id = null, this.options.ecmaVersion >= 6 && (e.generator = !1, e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1) }, I.parseMethod = function (e, t) { const r = this.startNode(); const n = this.inGenerator; const i = this.inAsync; const a = this.yieldPos; const o = this.awaitPos; const s = this.inFunction; return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.inGenerator = r.generator, this.inAsync = r.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), this.expect(v.parenL), r.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1), this.inGenerator = n, this.inAsync = i, this.yieldPos = a, this.awaitPos = o, this.inFunction = s, this.finishNode(r, 'FunctionExpression') }, I.parseArrowExpression = function (e, t, r) { const n = this.inGenerator; const i = this.inAsync; const a = this.yieldPos; const o = this.awaitPos; const s = this.inFunction; return this.enterFunctionScope(), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.inGenerator = !1, this.inAsync = e.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0), this.inGenerator = n, this.inAsync = i, this.yieldPos = a, this.awaitPos = o, this.inFunction = s, this.finishNode(e, 'ArrowFunctionExpression') }, I.parseFunctionBody = function (e, t) { const r = t && this.type !== v.braceL; const n = this.strict; let i = !1; if (r)e.body = this.parseMaybeAssign(), e.expression = !0, this.checkParams(e, !1); else { const a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params); n && !a || (i = this.strictDirective(this.end)) && a && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"); const o = this.labels; this.labels = [], i && (this.strict = !0), this.checkParams(e, !n && !i && !t && this.isSimpleParamList(e.params)), e.body = this.parseBlock(!1), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = o } this.exitFunctionScope(), this.strict && e.id && this.checkLVal(e.id, 'none'), this.strict = n }, I.isSimpleParamList = function (e) { for (let t = 0, r = e; t < r.length; t += 1) { if (r[t].type !== 'Identifier') return !1; } return !0 }, I.checkParams = function (e, t) { for (let r = {}, n = 0, i = e.params; n < i.length; n += 1) { const a = i[n]; this.checkLVal(a, 'var', t ? null : r) } }, I.parseExprList = function (e, t, r, n) { for (var i = [], a = !0; !this.eat(e);) { if (a)a = !1; else if (this.expect(v.comma), t && this.afterTrailingComma(e)) break; let o = void 0; r && this.type === v.comma ? o = null : this.type === v.ellipsis ? (o = this.parseSpread(n), n && this.type === v.comma && n.trailingComma < 0 && (n.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, n), i.push(o) } return i }, I.checkUnreserved = function (e) { const t = e.start; const r = e.end; const n = e.name; (this.inGenerator && n === 'yield' && this.raiseRecoverable(t, "Can not use 'yield' as identifier inside a generator"), this.inAsync && n === 'await' && this.raiseRecoverable(t, "Can not use 'await' as identifier inside an async function"), this.isKeyword(n) && this.raise(t, `Unexpected keyword '${n}'`), this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf('\\') != -1) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(n) && (this.inAsync || n !== 'await' || this.raiseRecoverable(t, "Can not use keyword 'await' outside an async function"), this.raiseRecoverable(t, `The keyword '${n}' is reserved`)) }, I.parseIdent = function (e, t) { const r = this.startNode(); return e && this.options.allowReserved == 'never' && (e = !1), this.type === v.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, r.name !== 'class' && r.name !== 'function' || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop()) : this.unexpected(), this.next(), this.finishNode(r, 'Identifier'), e || this.checkUnreserved(r), r }, I.parseYield = function () { this.yieldPos || (this.yieldPos = this.start); const e = this.startNode(); return this.next(), this.type == v.semi || this.canInsertSemicolon() || this.type != v.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(v.star), e.argument = this.parseMaybeAssign()), this.finishNode(e, 'YieldExpression') }, I.parseAwait = function () { this.awaitPos || (this.awaitPos = this.start); const e = this.startNode(); return this.next(), e.argument = this.parseMaybeUnary(null, !0), this.finishNode(e, 'AwaitExpression') }; const q = P.prototype; q.raise = function (e, t) { const r = getLineInfo(this.input, e); t += ` (${r.line}:${r.column})`; const n = new SyntaxError(t); throw n.pos = e, n.loc = r, n.raisedAt = this.pos, n }, q.raiseRecoverable = q.raise, q.curPosition = function () { if (this.options.locations) return new S(this.curLine, this.pos - this.lineStart); }; const U = P.prototype; const z = Object.assign || function (e) { for (var t = [], r = arguments.length - 1; r-- > 0;)t[r] = arguments[r + 1]; for (let n = 0, i = t; n < i.length; n += 1) { const a = i[n]; for (const o in a)has(a, o) && (e[o] = a[o]); } return e }; U.enterFunctionScope = function () {
    this.scopeStack.push({
      var: {}, lexical: {}, childVar: {}, parentLexical: {},
    });
  }, U.exitFunctionScope = function () { this.scopeStack.pop() }, U.enterLexicalScope = function () {
    const e = this.scopeStack[this.scopeStack.length - 1]; const t = {
      var: {}, lexical: {}, childVar: {}, parentLexical: {},
    }; this.scopeStack.push(t), z(t.parentLexical, e.lexical, e.parentLexical);
  }, U.exitLexicalScope = function () { const e = this.scopeStack.pop(); const t = this.scopeStack[this.scopeStack.length - 1]; z(t.childVar, e.var, e.childVar) }, U.canDeclareVarName = function (e) { const t = this.scopeStack[this.scopeStack.length - 1]; return !has(t.lexical, e) && !has(t.parentLexical, e) }, U.canDeclareLexicalName = function (e) { const t = this.scopeStack[this.scopeStack.length - 1]; return !has(t.lexical, e) && !has(t.var, e) && !has(t.childVar, e) }, U.declareVarName = function (e) { this.scopeStack[this.scopeStack.length - 1].var[e] = !0 }, U.declareLexicalName = function (e) { this.scopeStack[this.scopeStack.length - 1].lexical[e] = !0 }; var V = function Node(e, t, r) { this.type = '', this.start = t, this.end = 0, e.options.locations && (this.loc = new k(e, r)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [t, 0]) }; const H = P.prototype; function finishNodeAt(e, t, r, n) { return e.type = t, e.end = r, this.options.locations && (e.loc.end = n), this.options.ranges && (e.range[1] = r), e }H.startNode = function () { return new V(this, this.start, this.startLoc) }, H.startNodeAt = function (e, t) { return new V(this, e, t) }, H.finishNode = function (e, t) { return finishNodeAt.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc) }, H.finishNodeAt = function (e, t, r, n) { return finishNodeAt.call(this, e, t, r, n) }; var $ = function TokContext(e, t, r, n, i) { this.token = e, this.isExpr = !!t, this.preserveSpace = !!r, this.override = n, this.generator = !!i }; var G = {
    b_stat: new $('{', !1), b_expr: new $('{', !0), b_tmpl: new $('${', !1), p_stat: new $('(', !1), p_expr: new $('(', !0), q_tmpl: new $('`', !0, !0, (e => e.tryReadTemplateToken())), f_stat: new $('function', !1), f_expr: new $('function', !0), f_expr_gen: new $('function', !0, !1, null, !0), f_gen: new $('function', !1, !1, null, !0),
  }; const J = P.prototype; J.initialContext = function () { return [G.b_stat] }, J.braceIsBlock = function (e) { const t = this.curContext(); return t === G.f_expr || t === G.f_stat || (e !== v.colon || t !== G.b_stat && t !== G.b_expr ? e === v._return || e == v.name && this.exprAllowed ? y.test(this.input.slice(this.lastTokEnd, this.start)) : e === v._else || e === v.semi || e === v.eof || e === v.parenR || e == v.arrow || (e == v.braceL ? t === G.b_stat : e != v._var && e != v.name && !this.exprAllowed) : !t.isExpr) }, J.inGeneratorContext = function () { for (let e = this.context.length - 1; e >= 1; e--) { const t = this.context[e]; if (t.token === 'function') return t.generator; } return !1 }, J.updateContext = function (e) { let t; const r = this.type; r.keyword && e == v.dot ? this.exprAllowed = !1 : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr }, v.parenR.updateContext = v.braceR.updateContext = function () { if (this.context.length != 1) { let e = this.context.pop(); e === G.b_stat && this.curContext().token === 'function' && (e = this.context.pop()), this.exprAllowed = !e.isExpr } else this.exprAllowed = !0; }, v.braceL.updateContext = function (e) { this.context.push(this.braceIsBlock(e) ? G.b_stat : G.b_expr), this.exprAllowed = !0 }, v.dollarBraceL.updateContext = function () { this.context.push(G.b_tmpl), this.exprAllowed = !0 }, v.parenL.updateContext = function (e) { const t = e === v._if || e === v._for || e === v._with || e === v._while; this.context.push(t ? G.p_stat : G.p_expr), this.exprAllowed = !0 }, v.incDec.updateContext = function () {}, v._function.updateContext = v._class.updateContext = function (e) { e.beforeExpr && e !== v.semi && e !== v._else && (e !== v.colon && e !== v.braceL || this.curContext() !== G.b_stat) ? this.context.push(G.f_expr) : this.context.push(G.f_stat), this.exprAllowed = !1 }, v.backQuote.updateContext = function () { this.curContext() === G.q_tmpl ? this.context.pop() : this.context.push(G.q_tmpl), this.exprAllowed = !1 }, v.star.updateContext = function (e) { if (e == v._function) { const t = this.context.length - 1; this.context[t] === G.f_expr ? this.context[t] = G.f_expr_gen : this.context[t] = G.f_gen } this.exprAllowed = !0 }, v.name.updateContext = function (e) { let t = !1; this.options.ecmaVersion >= 6 && (this.value == 'of' && !this.exprAllowed || this.value == 'yield' && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t }; const W = { $LONE: ['ASCII', 'ASCII_Hex_Digit', 'AHex', 'Alphabetic', 'Alpha', 'Any', 'Assigned', 'Bidi_Control', 'Bidi_C', 'Bidi_Mirrored', 'Bidi_M', 'Case_Ignorable', 'CI', 'Cased', 'Changes_When_Casefolded', 'CWCF', 'Changes_When_Casemapped', 'CWCM', 'Changes_When_Lowercased', 'CWL', 'Changes_When_NFKC_Casefolded', 'CWKCF', 'Changes_When_Titlecased', 'CWT', 'Changes_When_Uppercased', 'CWU', 'Dash', 'Default_Ignorable_Code_Point', 'DI', 'Deprecated', 'Dep', 'Diacritic', 'Dia', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extender', 'Ext', 'Grapheme_Base', 'Gr_Base', 'Grapheme_Extend', 'Gr_Ext', 'Hex_Digit', 'Hex', 'IDS_Binary_Operator', 'IDSB', 'IDS_Trinary_Operator', 'IDST', 'ID_Continue', 'IDC', 'ID_Start', 'IDS', 'Ideographic', 'Ideo', 'Join_Control', 'Join_C', 'Logical_Order_Exception', 'LOE', 'Lowercase', 'Lower', 'Math', 'Noncharacter_Code_Point', 'NChar', 'Pattern_Syntax', 'Pat_Syn', 'Pattern_White_Space', 'Pat_WS', 'Quotation_Mark', 'QMark', 'Radical', 'Regional_Indicator', 'RI', 'Sentence_Terminal', 'STerm', 'Soft_Dotted', 'SD', 'Terminal_Punctuation', 'Term', 'Unified_Ideograph', 'UIdeo', 'Uppercase', 'Upper', 'Variation_Selector', 'VS', 'White_Space', 'space', 'XID_Continue', 'XIDC', 'XID_Start', 'XIDS'], General_Category: ['Cased_Letter', 'LC', 'Close_Punctuation', 'Pe', 'Connector_Punctuation', 'Pc', 'Control', 'Cc', 'cntrl', 'Currency_Symbol', 'Sc', 'Dash_Punctuation', 'Pd', 'Decimal_Number', 'Nd', 'digit', 'Enclosing_Mark', 'Me', 'Final_Punctuation', 'Pf', 'Format', 'Cf', 'Initial_Punctuation', 'Pi', 'Letter', 'L', 'Letter_Number', 'Nl', 'Line_Separator', 'Zl', 'Lowercase_Letter', 'Ll', 'Mark', 'M', 'Combining_Mark', 'Math_Symbol', 'Sm', 'Modifier_Letter', 'Lm', 'Modifier_Symbol', 'Sk', 'Nonspacing_Mark', 'Mn', 'Number', 'N', 'Open_Punctuation', 'Ps', 'Other', 'C', 'Other_Letter', 'Lo', 'Other_Number', 'No', 'Other_Punctuation', 'Po', 'Other_Symbol', 'So', 'Paragraph_Separator', 'Zp', 'Private_Use', 'Co', 'Punctuation', 'P', 'punct', 'Separator', 'Z', 'Space_Separator', 'Zs', 'Spacing_Mark', 'Mc', 'Surrogate', 'Cs', 'Symbol', 'S', 'Titlecase_Letter', 'Lt', 'Unassigned', 'Cn', 'Uppercase_Letter', 'Lu'], Script: ['Adlam', 'Adlm', 'Ahom', 'Anatolian_Hieroglyphs', 'Hluw', 'Arabic', 'Arab', 'Armenian', 'Armn', 'Avestan', 'Avst', 'Balinese', 'Bali', 'Bamum', 'Bamu', 'Bassa_Vah', 'Bass', 'Batak', 'Batk', 'Bengali', 'Beng', 'Bhaiksuki', 'Bhks', 'Bopomofo', 'Bopo', 'Brahmi', 'Brah', 'Braille', 'Brai', 'Buginese', 'Bugi', 'Buhid', 'Buhd', 'Canadian_Aboriginal', 'Cans', 'Carian', 'Cari', 'Caucasian_Albanian', 'Aghb', 'Chakma', 'Cakm', 'Cham', 'Cherokee', 'Cher', 'Common', 'Zyyy', 'Coptic', 'Copt', 'Qaac', 'Cuneiform', 'Xsux', 'Cypriot', 'Cprt', 'Cyrillic', 'Cyrl', 'Deseret', 'Dsrt', 'Devanagari', 'Deva', 'Duployan', 'Dupl', 'Egyptian_Hieroglyphs', 'Egyp', 'Elbasan', 'Elba', 'Ethiopic', 'Ethi', 'Georgian', 'Geor', 'Glagolitic', 'Glag', 'Gothic', 'Goth', 'Grantha', 'Gran', 'Greek', 'Grek', 'Gujarati', 'Gujr', 'Gurmukhi', 'Guru', 'Han', 'Hani', 'Hangul', 'Hang', 'Hanunoo', 'Hano', 'Hatran', 'Hatr', 'Hebrew', 'Hebr', 'Hiragana', 'Hira', 'Imperial_Aramaic', 'Armi', 'Inherited', 'Zinh', 'Qaai', 'Inscriptional_Pahlavi', 'Phli', 'Inscriptional_Parthian', 'Prti', 'Javanese', 'Java', 'Kaithi', 'Kthi', 'Kannada', 'Knda', 'Katakana', 'Kana', 'Kayah_Li', 'Kali', 'Kharoshthi', 'Khar', 'Khmer', 'Khmr', 'Khojki', 'Khoj', 'Khudawadi', 'Sind', 'Lao', 'Laoo', 'Latin', 'Latn', 'Lepcha', 'Lepc', 'Limbu', 'Limb', 'Linear_A', 'Lina', 'Linear_B', 'Linb', 'Lisu', 'Lycian', 'Lyci', 'Lydian', 'Lydi', 'Mahajani', 'Mahj', 'Malayalam', 'Mlym', 'Mandaic', 'Mand', 'Manichaean', 'Mani', 'Marchen', 'Marc', 'Masaram_Gondi', 'Gonm', 'Meetei_Mayek', 'Mtei', 'Mende_Kikakui', 'Mend', 'Meroitic_Cursive', 'Merc', 'Meroitic_Hieroglyphs', 'Mero', 'Miao', 'Plrd', 'Modi', 'Mongolian', 'Mong', 'Mro', 'Mroo', 'Multani', 'Mult', 'Myanmar', 'Mymr', 'Nabataean', 'Nbat', 'New_Tai_Lue', 'Talu', 'Newa', 'Nko', 'Nkoo', 'Nushu', 'Nshu', 'Ogham', 'Ogam', 'Ol_Chiki', 'Olck', 'Old_Hungarian', 'Hung', 'Old_Italic', 'Ital', 'Old_North_Arabian', 'Narb', 'Old_Permic', 'Perm', 'Old_Persian', 'Xpeo', 'Old_South_Arabian', 'Sarb', 'Old_Turkic', 'Orkh', 'Oriya', 'Orya', 'Osage', 'Osge', 'Osmanya', 'Osma', 'Pahawh_Hmong', 'Hmng', 'Palmyrene', 'Palm', 'Pau_Cin_Hau', 'Pauc', 'Phags_Pa', 'Phag', 'Phoenician', 'Phnx', 'Psalter_Pahlavi', 'Phlp', 'Rejang', 'Rjng', 'Runic', 'Runr', 'Samaritan', 'Samr', 'Saurashtra', 'Saur', 'Sharada', 'Shrd', 'Shavian', 'Shaw', 'Siddham', 'Sidd', 'SignWriting', 'Sgnw', 'Sinhala', 'Sinh', 'Sora_Sompeng', 'Sora', 'Soyombo', 'Soyo', 'Sundanese', 'Sund', 'Syloti_Nagri', 'Sylo', 'Syriac', 'Syrc', 'Tagalog', 'Tglg', 'Tagbanwa', 'Tagb', 'Tai_Le', 'Tale', 'Tai_Tham', 'Lana', 'Tai_Viet', 'Tavt', 'Takri', 'Takr', 'Tamil', 'Taml', 'Tangut', 'Tang', 'Telugu', 'Telu', 'Thaana', 'Thaa', 'Thai', 'Tibetan', 'Tibt', 'Tifinagh', 'Tfng', 'Tirhuta', 'Tirh', 'Ugaritic', 'Ugar', 'Vai', 'Vaii', 'Warang_Citi', 'Wara', 'Yi', 'Yiii', 'Zanabazar_Square', 'Zanb'] }; Array.prototype.push.apply(W.$LONE, W.General_Category), W.gc = W.General_Category, W.sc = W.Script_Extensions = W.scx = W.Script; const K = P.prototype; const X = function RegExpValidationState(e) { this.parser = e, this.validFlags = `gim${e.options.ecmaVersion >= 6 ? 'uy' : ''}${e.options.ecmaVersion >= 9 ? 's' : ''}`, this.source = '', this.flags = '', this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = '', this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [] }; function codePointToString$1(e) { return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e))) } function isSyntaxCharacter(e) { return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125 } function isControlLetter(e) { return e >= 65 && e <= 90 || e >= 97 && e <= 122 } function isUnicodePropertyNameCharacter(e) { return isControlLetter(e) || e === 95 } function isUnicodePropertyValueCharacter(e) { return isUnicodePropertyNameCharacter(e) || isDecimalDigit(e) } function isDecimalDigit(e) { return e >= 48 && e <= 57 } function isHexDigit(e) { return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102 } function hexToInt(e) { return e >= 65 && e <= 70 ? e - 65 + 10 : e >= 97 && e <= 102 ? e - 97 + 10 : e - 48 } function isOctalDigit(e) { return e >= 48 && e <= 55 }X.prototype.reset = function reset(e, t, r) { const n = r.indexOf('u') !== -1; this.start = 0 | e, this.source = `${t}`, this.flags = r, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9 }, X.prototype.raise = function raise(e) { this.parser.raiseRecoverable(this.start, `Invalid regular expression: /${this.source}/: ${e}`) }, X.prototype.at = function at(e) { const t = this.source; const r = t.length; if (e >= r) return -1; const n = t.charCodeAt(e); return !this.switchU || n <= 55295 || n >= 57344 || e + 1 >= r ? n : (n << 10) + t.charCodeAt(e + 1) - 56613888 }, X.prototype.nextIndex = function nextIndex(e) { const t = this.source; const r = t.length; if (e >= r) return r; const n = t.charCodeAt(e); return !this.switchU || n <= 55295 || n >= 57344 || e + 1 >= r ? e + 1 : e + 2 }, X.prototype.current = function current() { return this.at(this.pos) }, X.prototype.lookahead = function lookahead() { return this.at(this.nextIndex(this.pos)) }, X.prototype.advance = function advance() { this.pos = this.nextIndex(this.pos) }, X.prototype.eat = function eat(e) { return this.current() === e && (this.advance(), !0) }, K.validateRegExpFlags = function (e) { for (let t = e.validFlags, r = e.flags, n = 0; n < r.length; n++) { const i = r.charAt(n); t.indexOf(i) == -1 && this.raise(e.start, 'Invalid regular expression flag'), r.indexOf(i, n + 1) > -1 && this.raise(e.start, 'Duplicate regular expression flag') } }, K.validateRegExpPattern = function (e) { this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = !0, this.regexp_pattern(e)) }, K.regexp_pattern = function (e) { e.pos = 0, e.lastIntValue = 0, e.lastStringValue = '', e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise('Lone quantifier brackets')), e.maxBackReference > e.numCapturingParens && e.raise('Invalid escape'); for (let t = 0, r = e.backReferenceNames; t < r.length; t += 1) { const n = r[t]; e.groupNames.indexOf(n) === -1 && e.raise('Invalid named capture referenced') } }, K.regexp_disjunction = function (e) { for (this.regexp_alternative(e); e.eat(124);) this.regexp_alternative(e); this.regexp_eatQuantifier(e, !0) && e.raise('Nothing to repeat'), e.eat(123) && e.raise('Lone quantifier brackets') }, K.regexp_alternative = function (e) { for (;e.pos < e.source.length && this.regexp_eatTerm(e);); }, K.regexp_eatTerm = function (e) { return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise('Invalid quantifier'), !0) : !(e.switchU ? !this.regexp_eatAtom(e) : !this.regexp_eatExtendedAtom(e)) && (this.regexp_eatQuantifier(e), !0) }, K.regexp_eatAssertion = function (e) { const t = e.pos; if (e.lastAssertionIsQuantifiable = !1, e.eat(94) || e.eat(36)) return !0; if (e.eat(92)) { if (e.eat(66) || e.eat(98)) return !0; e.pos = t } if (e.eat(40) && e.eat(63)) { let r = !1; if (this.options.ecmaVersion >= 9 && (r = e.eat(60)), e.eat(61) || e.eat(33)) return this.regexp_disjunction(e), e.eat(41) || e.raise('Unterminated group'), e.lastAssertionIsQuantifiable = !r, !0; } return e.pos = t, !1 }, K.regexp_eatQuantifier = function (e, t) { return void 0 === t && (t = !1), !!this.regexp_eatQuantifierPrefix(e, t) && (e.eat(63), !0) }, K.regexp_eatQuantifierPrefix = function (e, t) { return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t) }, K.regexp_eatBracedQuantifier = function (e, t) { const r = e.pos; if (e.eat(123)) { let n = 0; let i = -1; if (this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue), e.eat(125))) return i !== -1 && i < n && !t && e.raise('numbers out of order in {} quantifier'), !0; e.switchU && !t && e.raise('Incomplete quantifier'), e.pos = r } return !1 }, K.regexp_eatAtom = function (e) { return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) }, K.regexp_eatReverseSolidusAtomEscape = function (e) { const t = e.pos; if (e.eat(92)) { if (this.regexp_eatAtomEscape(e)) return !0; e.pos = t } return !1 }, K.regexp_eatUncapturingGroup = function (e) { const t = e.pos; if (e.eat(40)) { if (e.eat(63) && e.eat(58)) { if (this.regexp_disjunction(e), e.eat(41)) return !0; e.raise('Unterminated group') }e.pos = t } return !1 }, K.regexp_eatCapturingGroup = function (e) { if (e.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise('Invalid group'), this.regexp_disjunction(e), e.eat(41)) return e.numCapturingParens += 1, !0; e.raise('Unterminated group') } return !1 }, K.regexp_eatExtendedAtom = function (e) { return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e) }, K.regexp_eatInvalidBracedQuantifier = function (e) { return this.regexp_eatBracedQuantifier(e, !0) && e.raise('Nothing to repeat'), !1 }, K.regexp_eatSyntaxCharacter = function (e) { const t = e.current(); return !!isSyntaxCharacter(t) && (e.lastIntValue = t, e.advance(), !0) }, K.regexp_eatPatternCharacters = function (e) { for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !isSyntaxCharacter(r);)e.advance(); return e.pos !== t }, K.regexp_eatExtendedPatternCharacter = function (e) { const t = e.current(); return !(t === -1 || t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t === 91 || t === 94 || t === 124) && (e.advance(), !0) }, K.regexp_groupSpecifier = function (e) { if (e.eat(63)) { if (this.regexp_eatGroupName(e)) return e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise('Duplicate capture group name'), void e.groupNames.push(e.lastStringValue); e.raise('Invalid group') } }, K.regexp_eatGroupName = function (e) { if (e.lastStringValue = '', e.eat(60)) { if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0; e.raise('Invalid capture group name') } return !1 }, K.regexp_eatRegExpIdentifierName = function (e) { if (e.lastStringValue = '', this.regexp_eatRegExpIdentifierStart(e)) { for (e.lastStringValue += codePointToString$1(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e);)e.lastStringValue += codePointToString$1(e.lastIntValue); return !0 } return !1 }, K.regexp_eatRegExpIdentifierStart = function (e) { const t = e.pos; let r = e.current(); return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), (function isRegExpIdentifierStart(e) { return isIdentifierStart(e, !0) || e === 36 || e === 95 }(r)) ? (e.lastIntValue = r, !0) : (e.pos = t, !1) }, K.regexp_eatRegExpIdentifierPart = function (e) { const t = e.pos; let r = e.current(); return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), (function isRegExpIdentifierPart(e) { return isIdentifierChar(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205 }(r)) ? (e.lastIntValue = r, !0) : (e.pos = t, !1) }, K.regexp_eatAtomEscape = function (e) { return !!(this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e)) || (e.switchU && (e.current() === 99 && e.raise('Invalid unicode escape'), e.raise('Invalid escape')), !1) }, K.regexp_eatBackReference = function (e) { const t = e.pos; if (this.regexp_eatDecimalEscape(e)) { const r = e.lastIntValue; if (e.switchU) return r > e.maxBackReference && (e.maxBackReference = r), !0; if (r <= e.numCapturingParens) return !0; e.pos = t } return !1 }, K.regexp_eatKGroupName = function (e) { if (e.eat(107)) { if (this.regexp_eatGroupName(e)) return e.backReferenceNames.push(e.lastStringValue), !0; e.raise('Invalid named reference') } return !1 }, K.regexp_eatCharacterEscape = function (e) { return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e) }, K.regexp_eatCControlLetter = function (e) { const t = e.pos; if (e.eat(99)) { if (this.regexp_eatControlLetter(e)) return !0; e.pos = t } return !1 }, K.regexp_eatZero = function (e) { return e.current() === 48 && !isDecimalDigit(e.lookahead()) && (e.lastIntValue = 0, e.advance(), !0) }, K.regexp_eatControlEscape = function (e) { const t = e.current(); return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 && (e.lastIntValue = 13, e.advance(), !0) }, K.regexp_eatControlLetter = function (e) { const t = e.current(); return !!isControlLetter(t) && (e.lastIntValue = t % 32, e.advance(), !0) }, K.regexp_eatRegExpUnicodeEscapeSequence = function (e) { const t = e.pos; if (e.eat(117)) { if (this.regexp_eatFixedHexDigits(e, 4)) { const r = e.lastIntValue; if (e.switchU && r >= 55296 && r <= 56319) { const n = e.pos; if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) { const i = e.lastIntValue; if (i >= 56320 && i <= 57343) return e.lastIntValue = 1024 * (r - 55296) + (i - 56320) + 65536, !0; }e.pos = n, e.lastIntValue = r } return !0 } if (e.switchU && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && (function isValidUnicode(e) { return e >= 0 && e <= 1114111 }(e.lastIntValue))) return !0; e.switchU && e.raise('Invalid unicode escape'), e.pos = t } return !1 }, K.regexp_eatIdentityEscape = function (e) { if (e.switchU) return !!this.regexp_eatSyntaxCharacter(e) || !!e.eat(47) && (e.lastIntValue = 47, !0); const t = e.current(); return !(t === 99 || e.switchN && t === 107) && (e.lastIntValue = t, e.advance(), !0) }, K.regexp_eatDecimalEscape = function (e) { e.lastIntValue = 0; let t = e.current(); if (t >= 49 && t <= 57) { do { e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance() } while ((t = e.current()) >= 48 && t <= 57);return !0 } return !1 }, K.regexp_eatCharacterClassEscape = function (e) { const t = e.current(); if (function isCharacterClassEscape(e) { return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87 }(t)) return e.lastIntValue = -1, e.advance(), !0; if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) { if (e.lastIntValue = -1, e.advance(), e.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(125)) return !0; e.raise('Invalid property name') } return !1 }, K.regexp_eatUnicodePropertyValueExpression = function (e) { const t = e.pos; if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) { const r = e.lastStringValue; if (this.regexp_eatUnicodePropertyValue(e)) { const n = e.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(e, r, n), !0 } } if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) { const i = e.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(e, i), !0 } return !1 }, K.regexp_validateUnicodePropertyNameAndValue = function (e, t, r) { W.hasOwnProperty(t) && W[t].indexOf(r) !== -1 || e.raise('Invalid property name') }, K.regexp_validateUnicodePropertyNameOrValue = function (e, t) { W.$LONE.indexOf(t) === -1 && e.raise('Invalid property name') }, K.regexp_eatUnicodePropertyName = function (e) { let t = 0; for (e.lastStringValue = ''; isUnicodePropertyNameCharacter(t = e.current());)e.lastStringValue += codePointToString$1(t), e.advance(); return e.lastStringValue !== '' }, K.regexp_eatUnicodePropertyValue = function (e) { let t = 0; for (e.lastStringValue = ''; isUnicodePropertyValueCharacter(t = e.current());)e.lastStringValue += codePointToString$1(t), e.advance(); return e.lastStringValue !== '' }, K.regexp_eatLoneUnicodePropertyNameOrValue = function (e) { return this.regexp_eatUnicodePropertyValue(e) }, K.regexp_eatCharacterClass = function (e) { if (e.eat(91)) { if (e.eat(94), this.regexp_classRanges(e), e.eat(93)) return !0; e.raise('Unterminated character class') } return !1 }, K.regexp_classRanges = function (e) { for (;this.regexp_eatClassAtom(e);) { const t = e.lastIntValue; if (e.eat(45) && this.regexp_eatClassAtom(e)) { const r = e.lastIntValue; !e.switchU || t !== -1 && r !== -1 || e.raise('Invalid character class'), t !== -1 && r !== -1 && t > r && e.raise('Range out of order in character class') } } }, K.regexp_eatClassAtom = function (e) { const t = e.pos; if (e.eat(92)) { if (this.regexp_eatClassEscape(e)) return !0; if (e.switchU) { const r = e.current(); (r === 99 || isOctalDigit(r)) && e.raise('Invalid class escape'), e.raise('Invalid escape') }e.pos = t } const n = e.current(); return n !== 93 && (e.lastIntValue = n, e.advance(), !0) }, K.regexp_eatClassEscape = function (e) { const t = e.pos; if (e.eat(98)) return e.lastIntValue = 8, !0; if (e.switchU && e.eat(45)) return e.lastIntValue = 45, !0; if (!e.switchU && e.eat(99)) { if (this.regexp_eatClassControlLetter(e)) return !0; e.pos = t } return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) }, K.regexp_eatClassControlLetter = function (e) { const t = e.current(); return !(!isDecimalDigit(t) && t !== 95) && (e.lastIntValue = t % 32, e.advance(), !0) }, K.regexp_eatHexEscapeSequence = function (e) { const t = e.pos; if (e.eat(120)) { if (this.regexp_eatFixedHexDigits(e, 2)) return !0; e.switchU && e.raise('Invalid escape'), e.pos = t } return !1 }, K.regexp_eatDecimalDigits = function (e) { const t = e.pos; let r = 0; for (e.lastIntValue = 0; isDecimalDigit(r = e.current());)e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance(); return e.pos !== t }, K.regexp_eatHexDigits = function (e) { const t = e.pos; let r = 0; for (e.lastIntValue = 0; isHexDigit(r = e.current());)e.lastIntValue = 16 * e.lastIntValue + hexToInt(r), e.advance(); return e.pos !== t }, K.regexp_eatLegacyOctalEscapeSequence = function (e) { if (this.regexp_eatOctalDigit(e)) { const t = e.lastIntValue; if (this.regexp_eatOctalDigit(e)) { const r = e.lastIntValue; t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = 64 * t + 8 * r + e.lastIntValue : e.lastIntValue = 8 * t + r } else e.lastIntValue = t; return !0 } return !1 }, K.regexp_eatOctalDigit = function (e) { const t = e.current(); return isOctalDigit(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1) }, K.regexp_eatFixedHexDigits = function (e, t) { const r = e.pos; e.lastIntValue = 0; for (let n = 0; n < t; ++n) { const i = e.current(); if (!isHexDigit(i)) return e.pos = r, !1; e.lastIntValue = 16 * e.lastIntValue + hexToInt(i), e.advance() } return !0 }; var Y = function Token(e) { this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new k(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]) }; const Q = P.prototype; function codePointToString(e) { return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e))) }Q.next = function () { this.options.onToken && this.options.onToken(new Y(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, Q.getToken = function () { return this.next(), new Y(this) }, typeof Symbol !== 'undefined' && (Q[Symbol.iterator] = function () { const e = this; return { next() { const t = e.getToken(); return { done: t.type === v.eof, value: t } } } }), Q.curContext = function () { return this.context[this.context.length - 1] }, Q.nextToken = function () { const e = this.curContext(); return e && e.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(v.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos()) }, Q.readToken = function (e) { return isIdentifierStart(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e) }, Q.fullCharCodeAtPos = function () { const e = this.input.charCodeAt(this.pos); return e <= 55295 || e >= 57344 ? e : (e << 10) + this.input.charCodeAt(this.pos + 1) - 56613888 }, Q.skipBlockComment = function () { let e; const t = this.options.onComment && this.curPosition(); const r = this.pos; const n = this.input.indexOf('*/', this.pos += 2); if (n === -1 && this.raise(this.pos - 2, 'Unterminated comment'), this.pos = n + 2, this.options.locations) for (b.lastIndex = r; (e = b.exec(this.input)) && e.index < this.pos;)++this.curLine, this.lineStart = e.index + e[0].length; this.options.onComment && this.options.onComment(!0, this.input.slice(r + 2, n), r, this.pos, t, this.curPosition()) }, Q.skipLineComment = function (e) { for (var t = this.pos, r = this.options.onComment && this.curPosition(), n = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !isNewLine(n);)n = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(t + e, this.pos), t, this.pos, r, this.curPosition()) }, Q.skipSpace = function () { e:for (;this.pos < this.input.length;) { const e = this.input.charCodeAt(this.pos); switch (e) { case 32: case 160: ++this.pos; break; case 13: this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break e; } break; default: if (!(e > 8 && e < 14 || e >= 5760 && x.test(String.fromCharCode(e)))) break e; ++this.pos; } } }, Q.finishToken = function (e, t) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); const r = this.type; this.type = e, this.value = t, this.updateContext(r) }, Q.readToken_dot = function () { const e = this.input.charCodeAt(this.pos + 1); if (e >= 48 && e <= 57) return this.readNumber(!0); const t = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(v.ellipsis)) : (++this.pos, this.finishToken(v.dot)) }, Q.readToken_slash = function () { const e = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.slash, 1) }, Q.readToken_mult_modulo_exp = function (e) { let t = this.input.charCodeAt(this.pos + 1); let r = 1; let n = e === 42 ? v.star : v.modulo; return this.options.ecmaVersion >= 7 && e == 42 && t === 42 && (++r, n = v.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(v.assign, r + 1) : this.finishOp(n, r) }, Q.readToken_pipe_amp = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? this.finishOp(e === 124 ? v.logicalOR : v.logicalAND, 2) : t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(e === 124 ? v.bitwiseOR : v.bitwiseAND, 1) }, Q.readToken_caret = function () { return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.bitwiseXOR, 1) }, Q.readToken_plus_min = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? t != 45 || this.inModule || this.input.charCodeAt(this.pos + 2) != 62 || this.lastTokEnd !== 0 && !y.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(v.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.plusMin, 1) }, Q.readToken_lt_gt = function (e) { const t = this.input.charCodeAt(this.pos + 1); let r = 1; return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(v.assign, r + 1) : this.finishOp(v.bitShift, r)) : t != 33 || e != 60 || this.inModule || this.input.charCodeAt(this.pos + 2) != 45 || this.input.charCodeAt(this.pos + 3) != 45 ? (t === 61 && (r = 2), this.finishOp(v.relational, r)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken()) }, Q.readToken_eq_excl = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === 61 ? this.finishOp(v.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(v.arrow)) : this.finishOp(e === 61 ? v.eq : v.prefix, 1) }, Q.getTokenFromCode = function (e) { switch (e) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(v.parenL); case 41: return ++this.pos, this.finishToken(v.parenR); case 59: return ++this.pos, this.finishToken(v.semi); case 44: return ++this.pos, this.finishToken(v.comma); case 91: return ++this.pos, this.finishToken(v.bracketL); case 93: return ++this.pos, this.finishToken(v.bracketR); case 123: return ++this.pos, this.finishToken(v.braceL); case 125: return ++this.pos, this.finishToken(v.braceR); case 58: return ++this.pos, this.finishToken(v.colon); case 63: return ++this.pos, this.finishToken(v.question); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(v.backQuote); case 48: var t = this.input.charCodeAt(this.pos + 1); if (t === 120 || t === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (t === 111 || t === 79) return this.readRadixNumber(8); if (t === 98 || t === 66) return this.readRadixNumber(2); } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(e); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(e); case 124: case 38: return this.readToken_pipe_amp(e); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(e); case 60: case 62: return this.readToken_lt_gt(e); case 61: case 33: return this.readToken_eq_excl(e); case 126: return this.finishOp(v.prefix, 1); } this.raise(this.pos, `Unexpected character '${codePointToString(e)}'`) }, Q.finishOp = function (e, t) { const r = this.input.slice(this.pos, this.pos + t); return this.pos += t, this.finishToken(e, r) }, Q.readRegexp = function () { for (var e, t, r = this.pos; ;) { this.pos >= this.input.length && this.raise(r, 'Unterminated regular expression'); const n = this.input.charAt(this.pos); if (y.test(n) && this.raise(r, 'Unterminated regular expression'), e)e = !1; else { if (n === '[')t = !0; else if (n === ']' && t)t = !1; else if (n === '/' && !t) break; e = n === '\\' }++this.pos } const i = this.input.slice(r, this.pos); ++this.pos; const a = this.pos; const o = this.readWord1(); this.containsEsc && this.unexpected(a); const s = this.regexpState || (this.regexpState = new X(this)); s.reset(r, i, o), this.validateRegExpFlags(s), this.validateRegExpPattern(s); let u = null; try { u = new RegExp(i, o) } catch (e) {} return this.finishToken(v.regexp, { pattern: i, flags: o, value: u }) }, Q.readInt = function (e, t) { for (var r = this.pos, n = 0, i = 0, a = t == null ? 1 / 0 : t; i < a; ++i) { const o = this.input.charCodeAt(this.pos); let s = void 0; if ((s = o >= 97 ? o - 97 + 10 : o >= 65 ? o - 65 + 10 : o >= 48 && o <= 57 ? o - 48 : 1 / 0) >= e) break; ++this.pos, n = n * e + s } return this.pos === r || t != null && this.pos - r !== t ? null : n }, Q.readRadixNumber = function (e) { this.pos += 2; const t = this.readInt(e); return t == null && this.raise(this.start + 2, `Expected number in radix ${e}`), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'), this.finishToken(v.num, t) }, Q.readNumber = function (e) { const t = this.pos; e || this.readInt(10) !== null || this.raise(t, 'Invalid number'); let r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48; r && this.strict && this.raise(t, 'Invalid number'), r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1); let n = this.input.charCodeAt(this.pos); n !== 46 || r || (++this.pos, this.readInt(10), n = this.input.charCodeAt(this.pos)), n !== 69 && n !== 101 || r || ((n = this.input.charCodeAt(++this.pos)) !== 43 && n !== 45 || ++this.pos, this.readInt(10) === null && this.raise(t, 'Invalid number')), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'); const i = this.input.slice(t, this.pos); const a = r ? parseInt(i, 8) : parseFloat(i); return this.finishToken(v.num, a) }, Q.readCodePoint = function () { let e; if (this.input.charCodeAt(this.pos) === 123) { this.options.ecmaVersion < 6 && this.unexpected(); const t = ++this.pos; e = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(t, 'Code point out of bounds') } else e = this.readHexChar(4); return e }, Q.readString = function (e) { for (var t = '', r = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, 'Unterminated string constant'); const n = this.input.charCodeAt(this.pos); if (n === e) break; n === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(!1), r = this.pos) : (isNewLine(n) && this.raise(this.start, 'Unterminated string constant'), ++this.pos) } return t += this.input.slice(r, this.pos++), this.finishToken(v.string, t) }; const Z = {}; Q.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (e) { if (e !== Z) throw e; this.readInvalidTemplateToken() } this.inTemplateElement = !1 }, Q.invalidStringToken = function (e, t) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Z; this.raise(e, t) }, Q.readTmplToken = function () { for (let e = '', t = this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, 'Unterminated template'); const r = this.input.charCodeAt(this.pos); if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos !== this.start || this.type !== v.template && this.type !== v.invalidTemplate ? (e += this.input.slice(t, this.pos), this.finishToken(v.template, e)) : r === 36 ? (this.pos += 2, this.finishToken(v.dollarBraceL)) : (++this.pos, this.finishToken(v.backQuote)); if (r === 92)e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos; else if (isNewLine(r)) { switch (e += this.input.slice(t, this.pos), ++this.pos, r) { case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: e += '\n'; break; default: e += String.fromCharCode(r); } this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos } else ++this.pos; } }, Q.readInvalidTemplateToken = function () { for (;this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) { case '\\': ++this.pos; break; case '$': if (this.input[this.pos + 1] !== '{') break; case '`': return this.finishToken(v.invalidTemplate, this.input.slice(this.start, this.pos)); } this.raise(this.start, 'Unterminated template') }, Q.readEscapedChar = function (e) { let t = this.input.charCodeAt(++this.pos); switch (++this.pos, t) { case 110: return '\n'; case 114: return '\r'; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return codePointToString(this.readCodePoint()); case 116: return '\t'; case 98: return '\b'; case 118: return '\v'; case 102: return '\f'; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ''; default: if (t >= 48 && t <= 55) { let r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]; let n = parseInt(r, 8); return n > 255 && (r = r.slice(0, -1), n = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), r === '0' && t != 56 && t != 57 || !this.strict && !e || this.invalidStringToken(this.pos - 1 - r.length, e ? 'Octal literal in template string' : 'Octal literal in strict mode'), String.fromCharCode(n) } return String.fromCharCode(t); } }, Q.readHexChar = function (e) { const t = this.pos; const r = this.readInt(16, e); return r === null && this.invalidStringToken(t, 'Bad character escape sequence'), r }, Q.readWord1 = function () { this.containsEsc = !1; for (var e = '', t = !0, r = this.pos, n = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { const i = this.fullCharCodeAtPos(); if (isIdentifierChar(i, n)) this.pos += i <= 65535 ? 1 : 2; else { if (i !== 92) break; this.containsEsc = !0, e += this.input.slice(r, this.pos); const a = this.pos; this.input.charCodeAt(++this.pos) != 117 && this.invalidStringToken(this.pos, 'Expecting Unicode escape sequence \\uXXXX'), ++this.pos; const o = this.readCodePoint(); (t ? isIdentifierStart : isIdentifierChar)(o, n) || this.invalidStringToken(a, 'Invalid Unicode escape'), e += codePointToString(o), r = this.pos }t = !1 } return e + this.input.slice(r, this.pos) }, Q.readWord = function () { const e = this.readWord1(); let t = v.name; return this.keywords.test(e) && (this.containsEsc && this.raiseRecoverable(this.start, `Escape sequence in keyword ${e}`), t = g[e]), this.finishToken(t, e) }; let ee; let te; let re; var ne = '5.5.3'; function parse(e, t) { return new P(t, e).parse() } function parseExpressionAt(e, t, r) { const n = new P(r, e, t); return n.nextToken(), n.parseExpression() } function tokenizer(e, t) { return new P(t, e) } function addLooseExports(e, t, r) { ee = e, te = t, re = r }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(485); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.PlaygroundErrorRenderer = PlaygroundErrorRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function PlaygroundErrorRenderer(e) { const t = e.classes; const r = e.message; return n.default.createElement('pre', { className: t.root }, r) }PlaygroundErrorRenderer.propTypes = { classes: i.default.object.isRequired, message: i.default.string.isRequired }, t.default = (0, a.default)((e) => {
    const t = e.fontFamily; const r = e.fontSize; const n = e.color; return {
      root: {
        margin: 0, lineHeight: 1.2, fontSize: r.small, fontFamily: t.monospace, color: n.error, whiteSpace: 'pre',
      },
    };
  })(PlaygroundErrorRenderer);
}, function (e, t, r) {
  !(function webpackUniversalModuleDefinition(t, r) { e.exports = r() }(0, () => (function (e) { const t = {}; function __webpack_require__(r) { if (t[r]) return t[r].exports; const n = t[r] = { exports: {}, id: r, loaded: !1 }; return e[r].call(n.exports, n, n.exports, __webpack_require__), n.loaded = !0, n.exports } return __webpack_require__.m = e, __webpack_require__.c = t, __webpack_require__.p = '', __webpack_require__(0) }([function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(1); const i = r(3); const a = r(8); const o = r(15); function parse(e, t, r) { let o = null; const s = function (e, t) { r && r(e, t), o && o.visit(e, t) }; let u = typeof r === 'function' ? s : null; let l = !1; if (t) { l = typeof t.comment === 'boolean' && t.comment; const c = typeof t.attachComment === 'boolean' && t.attachComment; (l || c) && ((o = new n.CommentHandler()).attach = c, t.comment = !0, u = s) } let p; let f = !1; t && typeof t.sourceType === 'string' && (f = t.sourceType === 'module'), p = t && typeof t.jsx === 'boolean' && t.jsx ? new i.JSXParser(e, t, u) : new a.Parser(e, t, u); const d = f ? p.parseModule() : p.parseScript(); return l && o && (d.comments = o.comments), p.config.tokens && (d.tokens = p.tokens), p.config.tolerant && (d.errors = p.errorHandler.errors), d }t.parse = parse, t.parseModule = function parseModule(e, t, r) { const n = t || {}; return n.sourceType = 'module', parse(e, n, r) }, t.parseScript = function parseScript(e, t, r) { const n = t || {}; return n.sourceType = 'script', parse(e, n, r) }, t.tokenize = function tokenize(e, t, r) { let n; const i = new o.Tokenizer(e, t); n = []; try { for (;;) { let a = i.getNextToken(); if (!a) break; r && (a = r(a)), n.push(a) } } catch (e) { i.errorHandler.tolerate(e) } return i.errorHandler.tolerant && (n.errors = i.errors()), n }; const s = r(2); t.Syntax = s.Syntax, t.version = '4.0.0';
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(2); const i = (function () {
      function CommentHandler() { this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [] } return CommentHandler.prototype.insertInnerComments = function (e, t) { if (e.type === n.Syntax.BlockStatement && e.body.length === 0) { for (var r = [], i = this.leading.length - 1; i >= 0; --i) { const a = this.leading[i]; t.end.offset >= a.start && (r.unshift(a.comment), this.leading.splice(i, 1), this.trailing.splice(i, 1)) }r.length && (e.innerComments = r) } }, CommentHandler.prototype.findTrailingComments = function (e) { let t = []; if (this.trailing.length > 0) { for (let r = this.trailing.length - 1; r >= 0; --r) { const n = this.trailing[r]; n.start >= e.end.offset && t.unshift(n.comment) } return this.trailing.length = 0, t } const i = this.stack[this.stack.length - 1]; if (i && i.node.trailingComments) { const a = i.node.trailingComments[0]; a && a.range[0] >= e.end.offset && (t = i.node.trailingComments, delete i.node.trailingComments) } return t }, CommentHandler.prototype.findLeadingComments = function (e) { for (var t, r = []; this.stack.length > 0;) { if (!((a = this.stack[this.stack.length - 1]) && a.start >= e.start.offset)) break; t = a.node, this.stack.pop() } if (t) { for (var n = (t.leadingComments ? t.leadingComments.length : 0) - 1; n >= 0; --n) { const i = t.leadingComments[n]; i.range[1] <= e.start.offset && (r.unshift(i), t.leadingComments.splice(n, 1)) } return t.leadingComments && t.leadingComments.length === 0 && delete t.leadingComments, r } for (n = this.leading.length - 1; n >= 0; --n) { var a; (a = this.leading[n]).start <= e.start.offset && (r.unshift(a.comment), this.leading.splice(n, 1)) } return r }, CommentHandler.prototype.visitNode = function (e, t) { if (!(e.type === n.Syntax.Program && e.body.length > 0)) { this.insertInnerComments(e, t); const r = this.findTrailingComments(t); const i = this.findLeadingComments(t); i.length > 0 && (e.leadingComments = i), r.length > 0 && (e.trailingComments = r), this.stack.push({ node: e, start: t.start.offset }) } }, CommentHandler.prototype.visitComment = function (e, t) {
        const r = e.type[0] === 'L' ? 'Line' : 'Block';


        let n = { type: r, value: e.value }; if (e.range && (n.range = e.range), e.loc && (n.loc = e.loc), this.comments.push(n), this.attach) { const i = { comment: { type: r, value: e.value, range: [t.start.offset, t.end.offset] }, start: t.start.offset }; e.loc && (i.comment.loc = e.loc), e.type = r, this.leading.push(i), this.trailing.push(i) }
      }, CommentHandler.prototype.visit = function (e, t) { e.type === 'LineComment' ? this.visitComment(e, t) : e.type === 'BlockComment' ? this.visitComment(e, t) : this.attach && this.visitNode(e, t) }, CommentHandler;
    }()); t.CommentHandler = i;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.Syntax = {
      AssignmentExpression: 'AssignmentExpression', AssignmentPattern: 'AssignmentPattern', ArrayExpression: 'ArrayExpression', ArrayPattern: 'ArrayPattern', ArrowFunctionExpression: 'ArrowFunctionExpression', AwaitExpression: 'AwaitExpression', BlockStatement: 'BlockStatement', BinaryExpression: 'BinaryExpression', BreakStatement: 'BreakStatement', CallExpression: 'CallExpression', CatchClause: 'CatchClause', ClassBody: 'ClassBody', ClassDeclaration: 'ClassDeclaration', ClassExpression: 'ClassExpression', ConditionalExpression: 'ConditionalExpression', ContinueStatement: 'ContinueStatement', DoWhileStatement: 'DoWhileStatement', DebuggerStatement: 'DebuggerStatement', EmptyStatement: 'EmptyStatement', ExportAllDeclaration: 'ExportAllDeclaration', ExportDefaultDeclaration: 'ExportDefaultDeclaration', ExportNamedDeclaration: 'ExportNamedDeclaration', ExportSpecifier: 'ExportSpecifier', ExpressionStatement: 'ExpressionStatement', ForStatement: 'ForStatement', ForOfStatement: 'ForOfStatement', ForInStatement: 'ForInStatement', FunctionDeclaration: 'FunctionDeclaration', FunctionExpression: 'FunctionExpression', Identifier: 'Identifier', IfStatement: 'IfStatement', ImportDeclaration: 'ImportDeclaration', ImportDefaultSpecifier: 'ImportDefaultSpecifier', ImportNamespaceSpecifier: 'ImportNamespaceSpecifier', ImportSpecifier: 'ImportSpecifier', Literal: 'Literal', LabeledStatement: 'LabeledStatement', LogicalExpression: 'LogicalExpression', MemberExpression: 'MemberExpression', MetaProperty: 'MetaProperty', MethodDefinition: 'MethodDefinition', NewExpression: 'NewExpression', ObjectExpression: 'ObjectExpression', ObjectPattern: 'ObjectPattern', Program: 'Program', Property: 'Property', RestElement: 'RestElement', ReturnStatement: 'ReturnStatement', SequenceExpression: 'SequenceExpression', SpreadElement: 'SpreadElement', Super: 'Super', SwitchCase: 'SwitchCase', SwitchStatement: 'SwitchStatement', TaggedTemplateExpression: 'TaggedTemplateExpression', TemplateElement: 'TemplateElement', TemplateLiteral: 'TemplateLiteral', ThisExpression: 'ThisExpression', ThrowStatement: 'ThrowStatement', TryStatement: 'TryStatement', UnaryExpression: 'UnaryExpression', UpdateExpression: 'UpdateExpression', VariableDeclaration: 'VariableDeclaration', VariableDeclarator: 'VariableDeclarator', WhileStatement: 'WhileStatement', WithStatement: 'WithStatement', YieldExpression: 'YieldExpression',
    };
  }, function (e, t, r) {
    let n; const i = this && this.__extends || (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (const r in t)t.hasOwnProperty(r) && (e[r] = t[r]); }, function (e, t) { function __() { this.constructor = e }n(e, t), e.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __()) }); Object.defineProperty(t, '__esModule', { value: !0 }); const a = r(4); const o = r(5); const s = r(6); const u = r(7); const l = r(8); const c = r(13); const p = r(14); function getQualifiedElementName(e) { let t; switch (e.type) { case s.JSXSyntax.JSXIdentifier: t = e.name; break; case s.JSXSyntax.JSXNamespacedName: var r = e; t = `${getQualifiedElementName(r.namespace)}:${getQualifiedElementName(r.name)}`; break; case s.JSXSyntax.JSXMemberExpression: var n = e; t = `${getQualifiedElementName(n.object)}.${getQualifiedElementName(n.property)}`; } return t }c.TokenName[100] = 'JSXIdentifier', c.TokenName[101] = 'JSXText'; const f = (function (e) {
      function JSXParser(t, r, n) { return e.call(this, t, r, n) || this } return i(JSXParser, e), JSXParser.prototype.parsePrimaryExpression = function () { return this.match('<') ? this.parseJSXRoot() : e.prototype.parsePrimaryExpression.call(this) }, JSXParser.prototype.startJSX = function () { this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column }, JSXParser.prototype.finishJSX = function () { this.nextToken() }, JSXParser.prototype.reenterJSX = function () { this.startJSX(), this.expectJSX('}'), this.config.tokens && this.tokens.pop() }, JSXParser.prototype.createJSXNode = function () { return this.collectComments(), { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }, JSXParser.prototype.createJSXChildNode = function () { return { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }, JSXParser.prototype.scanXHTMLEntity = function (e) { for (var t = '&', r = !0, n = !1, i = !1, o = !1; !this.scanner.eof() && r && !n;) { const s = this.scanner.source[this.scanner.index]; if (s === e) break; if (n = s === ';', t += s, ++this.scanner.index, !n) switch (t.length) { case 2: i = s === '#'; break; case 3: i && (r = (o = s === 'x') || a.Character.isDecimalDigit(s.charCodeAt(0)), i = i && !o); break; default: r = (r = r && !(i && !a.Character.isDecimalDigit(s.charCodeAt(0)))) && !(o && !a.Character.isHexDigit(s.charCodeAt(0))); } } if (r && n && t.length > 2) { const u = t.substr(1, t.length - 2); i && u.length > 1 ? t = String.fromCharCode(parseInt(u.substr(1), 10)) : o && u.length > 2 ? t = String.fromCharCode(parseInt(`0${u.substr(1)}`, 16)) : i || o || !p.XHTMLEntities[u] || (t = p.XHTMLEntities[u]) } return t }, JSXParser.prototype.lexJSX = function () {
        const e = this.scanner.source.charCodeAt(this.scanner.index); if (e === 60 || e === 62 || e === 47 || e === 58 || e === 61 || e === 123 || e === 125) {
 return {
          type: 7, value: s = this.scanner.source[this.scanner.index++], lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index, 
        };
        } if (e === 34 || e === 39) {
          for (var t = this.scanner.index, r = this.scanner.source[this.scanner.index++], n = ''; !this.scanner.eof();) { if ((u = this.scanner.source[this.scanner.index++]) === r) break; n += u === '&' ? this.scanXHTMLEntity(r) : u } return {
            type: 8, value: n, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t, end: this.scanner.index,
          };
        } if (e === 46) {
          const i = this.scanner.source.charCodeAt(this.scanner.index + 1); const o = this.scanner.source.charCodeAt(this.scanner.index + 2); var s = i === 46 && o === 46 ? '...' : '.'; t = this.scanner.index; return this.scanner.index += s.length, {
            type: 7, value: s, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t, end: this.scanner.index,
          };
        } if (e === 96) {
 return {
          type: 10, value: '', lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index, end: this.scanner.index,
        };
        } if (a.Character.isIdentifierStart(e) && e !== 92) {
          t = this.scanner.index; for (++this.scanner.index; !this.scanner.eof();) { var u = this.scanner.source.charCodeAt(this.scanner.index); if (a.Character.isIdentifierPart(u) && u !== 92)++this.scanner.index; else { if (u !== 45) break; ++this.scanner.index } } return {
            type: 100, value: this.scanner.source.slice(t, this.scanner.index), lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t, end: this.scanner.index,
          };
        } return this.scanner.lex();
      }, JSXParser.prototype.nextJSXToken = function () { this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart; const e = this.lexJSX(); return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(e)), e }, JSXParser.prototype.nextJSXText = function () {
        this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart; for (var e = this.scanner.index, t = ''; !this.scanner.eof();) { const r = this.scanner.source[this.scanner.index]; if (r === '{' || r === '<') break; ++this.scanner.index, t += r, a.Character.isLineTerminator(r.charCodeAt(0)) && (++this.scanner.lineNumber, r === '\r' && this.scanner.source[this.scanner.index] === '\n' && ++this.scanner.index, this.scanner.lineStart = this.scanner.index) } this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart; const n = {
          type: 101, value: t, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: e, end: this.scanner.index,
        }; return t.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(n)), n;
      }, JSXParser.prototype.peekJSXToken = function () { const e = this.scanner.saveState(); this.scanner.scanComments(); const t = this.lexJSX(); return this.scanner.restoreState(e), t }, JSXParser.prototype.expectJSX = function (e) { const t = this.nextJSXToken(); t.type === 7 && t.value === e || this.throwUnexpectedToken(t) }, JSXParser.prototype.matchJSX = function (e) { const t = this.peekJSXToken(); return t.type === 7 && t.value === e }, JSXParser.prototype.parseJSXIdentifier = function () { const e = this.createJSXNode(); const t = this.nextJSXToken(); return t.type !== 100 && this.throwUnexpectedToken(t), this.finalize(e, new o.JSXIdentifier(t.value)) }, JSXParser.prototype.parseJSXElementName = function () { const e = this.createJSXNode(); let t = this.parseJSXIdentifier(); if (this.matchJSX(':')) { const r = t; this.expectJSX(':'); const n = this.parseJSXIdentifier(); t = this.finalize(e, new o.JSXNamespacedName(r, n)) } else if (this.matchJSX('.')) for (;this.matchJSX('.');) { const i = t; this.expectJSX('.'); const a = this.parseJSXIdentifier(); t = this.finalize(e, new o.JSXMemberExpression(i, a)) } return t }, JSXParser.prototype.parseJSXAttributeName = function () { let e; const t = this.createJSXNode(); const r = this.parseJSXIdentifier(); if (this.matchJSX(':')) { const n = r; this.expectJSX(':'); const i = this.parseJSXIdentifier(); e = this.finalize(t, new o.JSXNamespacedName(n, i)) } else e = r; return e }, JSXParser.prototype.parseJSXStringLiteralAttribute = function () { const e = this.createJSXNode(); const t = this.nextJSXToken(); t.type !== 8 && this.throwUnexpectedToken(t); const r = this.getTokenRaw(t); return this.finalize(e, new u.Literal(t.value, r)) }, JSXParser.prototype.parseJSXExpressionAttribute = function () { const e = this.createJSXNode(); this.expectJSX('{'), this.finishJSX(), this.match('}') && this.tolerateError('JSX attributes must only be assigned a non-empty expression'); const t = this.parseAssignmentExpression(); return this.reenterJSX(), this.finalize(e, new o.JSXExpressionContainer(t)) }, JSXParser.prototype.parseJSXAttributeValue = function () { return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute() }, JSXParser.prototype.parseJSXNameValueAttribute = function () { const e = this.createJSXNode(); const t = this.parseJSXAttributeName(); let r = null; return this.matchJSX('=') && (this.expectJSX('='), r = this.parseJSXAttributeValue()), this.finalize(e, new o.JSXAttribute(t, r)) }, JSXParser.prototype.parseJSXSpreadAttribute = function () { const e = this.createJSXNode(); this.expectJSX('{'), this.expectJSX('...'), this.finishJSX(); const t = this.parseAssignmentExpression(); return this.reenterJSX(), this.finalize(e, new o.JSXSpreadAttribute(t)) }, JSXParser.prototype.parseJSXAttributes = function () { for (var e = []; !this.matchJSX('/') && !this.matchJSX('>');) { const t = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute(); e.push(t) } return e }, JSXParser.prototype.parseJSXOpeningElement = function () { const e = this.createJSXNode(); this.expectJSX('<'); const t = this.parseJSXElementName(); const r = this.parseJSXAttributes(); const n = this.matchJSX('/'); return n && this.expectJSX('/'), this.expectJSX('>'), this.finalize(e, new o.JSXOpeningElement(t, n, r)) }, JSXParser.prototype.parseJSXBoundaryElement = function () { const e = this.createJSXNode(); if (this.expectJSX('<'), this.matchJSX('/')) { this.expectJSX('/'); const t = this.parseJSXElementName(); return this.expectJSX('>'), this.finalize(e, new o.JSXClosingElement(t)) } const r = this.parseJSXElementName(); const n = this.parseJSXAttributes(); const i = this.matchJSX('/'); return i && this.expectJSX('/'), this.expectJSX('>'), this.finalize(e, new o.JSXOpeningElement(r, i, n)) }, JSXParser.prototype.parseJSXEmptyExpression = function () { const e = this.createJSXChildNode(); return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(e, new o.JSXEmptyExpression()) }, JSXParser.prototype.parseJSXExpressionContainer = function () { let e; const t = this.createJSXNode(); return this.expectJSX('{'), this.matchJSX('}') ? (e = this.parseJSXEmptyExpression(), this.expectJSX('}')) : (this.finishJSX(), e = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(t, new o.JSXExpressionContainer(e)) }, JSXParser.prototype.parseJSXChildren = function () { for (var e = []; !this.scanner.eof();) { const t = this.createJSXChildNode(); const r = this.nextJSXText(); if (r.start < r.end) { const n = this.getTokenRaw(r); const i = this.finalize(t, new o.JSXText(r.value, n)); e.push(i) } if (this.scanner.source[this.scanner.index] !== '{') break; const a = this.parseJSXExpressionContainer(); e.push(a) } return e }, JSXParser.prototype.parseComplexJSXElement = function (e) {
        for (let t = []; !this.scanner.eof();) {
          e.children = e.children.concat(this.parseJSXChildren()); const r = this.createJSXChildNode(); const n = this.parseJSXBoundaryElement(); if (n.type === s.JSXSyntax.JSXOpeningElement) {
            const i = n; if (i.selfClosing) { var a = this.finalize(r, new o.JSXElement(i, [], null)); e.children.push(a) } else {
              t.push(e), e = {
                node: r, opening: i, closing: null, children: [],
              }; 
}
          } if (n.type === s.JSXSyntax.JSXClosingElement) { e.closing = n; const u = getQualifiedElementName(e.opening.name); if (u !== getQualifiedElementName(e.closing.name) && this.tolerateError('Expected corresponding JSX closing tag for %0', u), !(t.length > 0)) break; a = this.finalize(e.node, new o.JSXElement(e.opening, e.children, e.closing)); (e = t[t.length - 1]).children.push(a), t.pop() }
        } return e;
      }, JSXParser.prototype.parseJSXElement = function () {
        const e = this.createJSXNode(); const t = this.parseJSXOpeningElement(); let r = []; let n = null; if (!t.selfClosing) {
          const i = this.parseComplexJSXElement({
            node: e, opening: t, closing: n, children: r,
          }); r = i.children, n = i.closing;
        } return this.finalize(e, new o.JSXElement(t, r, n));
      }, JSXParser.prototype.parseJSXRoot = function () { this.config.tokens && this.tokens.pop(), this.startJSX(); const e = this.parseJSXElement(); return this.finishJSX(), e }, JSXParser.prototype.isStartOfExpression = function () { return e.prototype.isStartOfExpression.call(this) || this.match('<') }, JSXParser;
    }(l.Parser)); t.JSXParser = f;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const r = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }; t.Character = {
      fromCodePoint(e) { return e < 65536 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10)) + String.fromCharCode(56320 + (e - 65536 & 1023)) }, isWhiteSpace(e) { return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0 }, isLineTerminator(e) { return e === 10 || e === 13 || e === 8232 || e === 8233 }, isIdentifierStart(e) { return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && r.NonAsciiIdentifierStart.test(t.Character.fromCodePoint(e)) }, isIdentifierPart(e) { return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && r.NonAsciiIdentifierPart.test(t.Character.fromCodePoint(e)) }, isDecimalDigit(e) { return e >= 48 && e <= 57 }, isHexDigit(e) { return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102 }, isOctalDigit(e) { return e >= 48 && e <= 55 },
    };
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(6); const i = (function () { return function JSXClosingElement(e) { this.type = n.JSXSyntax.JSXClosingElement, this.name = e } }()); t.JSXClosingElement = i; const a = (function () { return function JSXElement(e, t, r) { this.type = n.JSXSyntax.JSXElement, this.openingElement = e, this.children = t, this.closingElement = r } }()); t.JSXElement = a; const o = (function () { return function JSXEmptyExpression() { this.type = n.JSXSyntax.JSXEmptyExpression } }()); t.JSXEmptyExpression = o; const s = (function () { return function JSXExpressionContainer(e) { this.type = n.JSXSyntax.JSXExpressionContainer, this.expression = e } }()); t.JSXExpressionContainer = s; const u = (function () { return function JSXIdentifier(e) { this.type = n.JSXSyntax.JSXIdentifier, this.name = e } }()); t.JSXIdentifier = u; const l = (function () { return function JSXMemberExpression(e, t) { this.type = n.JSXSyntax.JSXMemberExpression, this.object = e, this.property = t } }()); t.JSXMemberExpression = l; const c = (function () { return function JSXAttribute(e, t) { this.type = n.JSXSyntax.JSXAttribute, this.name = e, this.value = t } }()); t.JSXAttribute = c; const p = (function () { return function JSXNamespacedName(e, t) { this.type = n.JSXSyntax.JSXNamespacedName, this.namespace = e, this.name = t } }()); t.JSXNamespacedName = p; const f = (function () { return function JSXOpeningElement(e, t, r) { this.type = n.JSXSyntax.JSXOpeningElement, this.name = e, this.selfClosing = t, this.attributes = r } }()); t.JSXOpeningElement = f; const d = (function () { return function JSXSpreadAttribute(e) { this.type = n.JSXSyntax.JSXSpreadAttribute, this.argument = e } }()); t.JSXSpreadAttribute = d; const h = (function () { return function JSXText(e, t) { this.type = n.JSXSyntax.JSXText, this.value = e, this.raw = t } }()); t.JSXText = h;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.JSXSyntax = {
      JSXAttribute: 'JSXAttribute', JSXClosingElement: 'JSXClosingElement', JSXElement: 'JSXElement', JSXEmptyExpression: 'JSXEmptyExpression', JSXExpressionContainer: 'JSXExpressionContainer', JSXIdentifier: 'JSXIdentifier', JSXMemberExpression: 'JSXMemberExpression', JSXNamespacedName: 'JSXNamespacedName', JSXOpeningElement: 'JSXOpeningElement', JSXSpreadAttribute: 'JSXSpreadAttribute', JSXText: 'JSXText',
    };
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(2); const i = (function () { return function ArrayExpression(e) { this.type = n.Syntax.ArrayExpression, this.elements = e } }()); t.ArrayExpression = i; const a = (function () { return function ArrayPattern(e) { this.type = n.Syntax.ArrayPattern, this.elements = e } }()); t.ArrayPattern = a; const o = (function () { return function ArrowFunctionExpression(e, t, r) { this.type = n.Syntax.ArrowFunctionExpression, this.id = null, this.params = e, this.body = t, this.generator = !1, this.expression = r, this.async = !1 } }()); t.ArrowFunctionExpression = o; const s = (function () { return function AssignmentExpression(e, t, r) { this.type = n.Syntax.AssignmentExpression, this.operator = e, this.left = t, this.right = r } }()); t.AssignmentExpression = s; const u = (function () { return function AssignmentPattern(e, t) { this.type = n.Syntax.AssignmentPattern, this.left = e, this.right = t } }()); t.AssignmentPattern = u; const l = (function () { return function AsyncArrowFunctionExpression(e, t, r) { this.type = n.Syntax.ArrowFunctionExpression, this.id = null, this.params = e, this.body = t, this.generator = !1, this.expression = r, this.async = !0 } }()); t.AsyncArrowFunctionExpression = l; const c = (function () { return function AsyncFunctionDeclaration(e, t, r) { this.type = n.Syntax.FunctionDeclaration, this.id = e, this.params = t, this.body = r, this.generator = !1, this.expression = !1, this.async = !0 } }()); t.AsyncFunctionDeclaration = c; const p = (function () { return function AsyncFunctionExpression(e, t, r) { this.type = n.Syntax.FunctionExpression, this.id = e, this.params = t, this.body = r, this.generator = !1, this.expression = !1, this.async = !0 } }()); t.AsyncFunctionExpression = p; const f = (function () { return function AwaitExpression(e) { this.type = n.Syntax.AwaitExpression, this.argument = e } }()); t.AwaitExpression = f; const d = (function () { return function BinaryExpression(e, t, r) { const i = e === '||' || e === '&&'; this.type = i ? n.Syntax.LogicalExpression : n.Syntax.BinaryExpression, this.operator = e, this.left = t, this.right = r } }()); t.BinaryExpression = d; const h = (function () { return function BlockStatement(e) { this.type = n.Syntax.BlockStatement, this.body = e } }()); t.BlockStatement = h; const m = (function () { return function BreakStatement(e) { this.type = n.Syntax.BreakStatement, this.label = e } }()); t.BreakStatement = m; const g = (function () { return function CallExpression(e, t) { this.type = n.Syntax.CallExpression, this.callee = e, this.arguments = t } }()); t.CallExpression = g; const v = (function () { return function CatchClause(e, t) { this.type = n.Syntax.CatchClause, this.param = e, this.body = t } }()); t.CatchClause = v; const y = (function () { return function ClassBody(e) { this.type = n.Syntax.ClassBody, this.body = e } }()); t.ClassBody = y; const b = (function () { return function ClassDeclaration(e, t, r) { this.type = n.Syntax.ClassDeclaration, this.id = e, this.superClass = t, this.body = r } }()); t.ClassDeclaration = b; const x = (function () { return function ClassExpression(e, t, r) { this.type = n.Syntax.ClassExpression, this.id = e, this.superClass = t, this.body = r } }()); t.ClassExpression = x; const D = (function () { return function ComputedMemberExpression(e, t) { this.type = n.Syntax.MemberExpression, this.computed = !0, this.object = e, this.property = t } }()); t.ComputedMemberExpression = D; const _ = (function () { return function ConditionalExpression(e, t, r) { this.type = n.Syntax.ConditionalExpression, this.test = e, this.consequent = t, this.alternate = r } }()); t.ConditionalExpression = _; const C = (function () { return function ContinueStatement(e) { this.type = n.Syntax.ContinueStatement, this.label = e } }()); t.ContinueStatement = C; const w = (function () { return function DebuggerStatement() { this.type = n.Syntax.DebuggerStatement } }()); t.DebuggerStatement = w; const E = (function () { return function Directive(e, t) { this.type = n.Syntax.ExpressionStatement, this.expression = e, this.directive = t } }()); t.Directive = E; const S = (function () { return function DoWhileStatement(e, t) { this.type = n.Syntax.DoWhileStatement, this.body = e, this.test = t } }()); t.DoWhileStatement = S; const k = (function () { return function EmptyStatement() { this.type = n.Syntax.EmptyStatement } }()); t.EmptyStatement = k; const A = (function () { return function ExportAllDeclaration(e) { this.type = n.Syntax.ExportAllDeclaration, this.source = e } }()); t.ExportAllDeclaration = A; const T = (function () { return function ExportDefaultDeclaration(e) { this.type = n.Syntax.ExportDefaultDeclaration, this.declaration = e } }()); t.ExportDefaultDeclaration = T; const P = (function () { return function ExportNamedDeclaration(e, t, r) { this.type = n.Syntax.ExportNamedDeclaration, this.declaration = e, this.specifiers = t, this.source = r } }()); t.ExportNamedDeclaration = P; const R = (function () { return function ExportSpecifier(e, t) { this.type = n.Syntax.ExportSpecifier, this.exported = t, this.local = e } }()); t.ExportSpecifier = R; const O = (function () { return function ExpressionStatement(e) { this.type = n.Syntax.ExpressionStatement, this.expression = e } }()); t.ExpressionStatement = O; const F = (function () { return function ForInStatement(e, t, r) { this.type = n.Syntax.ForInStatement, this.left = e, this.right = t, this.body = r, this.each = !1 } }()); t.ForInStatement = F; const L = (function () { return function ForOfStatement(e, t, r) { this.type = n.Syntax.ForOfStatement, this.left = e, this.right = t, this.body = r } }()); t.ForOfStatement = L; const M = (function () { return function ForStatement(e, t, r, i) { this.type = n.Syntax.ForStatement, this.init = e, this.test = t, this.update = r, this.body = i } }()); t.ForStatement = M; const j = (function () { return function FunctionDeclaration(e, t, r, i) { this.type = n.Syntax.FunctionDeclaration, this.id = e, this.params = t, this.body = r, this.generator = i, this.expression = !1, this.async = !1 } }()); t.FunctionDeclaration = j; const N = (function () { return function FunctionExpression(e, t, r, i) { this.type = n.Syntax.FunctionExpression, this.id = e, this.params = t, this.body = r, this.generator = i, this.expression = !1, this.async = !1 } }()); t.FunctionExpression = N; const I = (function () { return function Identifier(e) { this.type = n.Syntax.Identifier, this.name = e } }()); t.Identifier = I; const B = (function () { return function IfStatement(e, t, r) { this.type = n.Syntax.IfStatement, this.test = e, this.consequent = t, this.alternate = r } }()); t.IfStatement = B; const q = (function () { return function ImportDeclaration(e, t) { this.type = n.Syntax.ImportDeclaration, this.specifiers = e, this.source = t } }()); t.ImportDeclaration = q; const U = (function () { return function ImportDefaultSpecifier(e) { this.type = n.Syntax.ImportDefaultSpecifier, this.local = e } }()); t.ImportDefaultSpecifier = U; const z = (function () { return function ImportNamespaceSpecifier(e) { this.type = n.Syntax.ImportNamespaceSpecifier, this.local = e } }()); t.ImportNamespaceSpecifier = z; const V = (function () { return function ImportSpecifier(e, t) { this.type = n.Syntax.ImportSpecifier, this.local = e, this.imported = t } }()); t.ImportSpecifier = V; const H = (function () { return function LabeledStatement(e, t) { this.type = n.Syntax.LabeledStatement, this.label = e, this.body = t } }()); t.LabeledStatement = H; const $ = (function () { return function Literal(e, t) { this.type = n.Syntax.Literal, this.value = e, this.raw = t } }()); t.Literal = $; const G = (function () { return function MetaProperty(e, t) { this.type = n.Syntax.MetaProperty, this.meta = e, this.property = t } }()); t.MetaProperty = G; const J = (function () { return function MethodDefinition(e, t, r, i, a) { this.type = n.Syntax.MethodDefinition, this.key = e, this.computed = t, this.value = r, this.kind = i, this.static = a } }()); t.MethodDefinition = J; const W = (function () { return function Module(e) { this.type = n.Syntax.Program, this.body = e, this.sourceType = 'module' } }()); t.Module = W; const K = (function () { return function NewExpression(e, t) { this.type = n.Syntax.NewExpression, this.callee = e, this.arguments = t } }()); t.NewExpression = K; const X = (function () { return function ObjectExpression(e) { this.type = n.Syntax.ObjectExpression, this.properties = e } }()); t.ObjectExpression = X; const Y = (function () { return function ObjectPattern(e) { this.type = n.Syntax.ObjectPattern, this.properties = e } }()); t.ObjectPattern = Y; const Q = (function () { return function Property(e, t, r, i, a, o) { this.type = n.Syntax.Property, this.key = t, this.computed = r, this.value = i, this.kind = e, this.method = a, this.shorthand = o } }()); t.Property = Q; const Z = (function () { return function RegexLiteral(e, t, r, i) { this.type = n.Syntax.Literal, this.value = e, this.raw = t, this.regex = { pattern: r, flags: i } } }()); t.RegexLiteral = Z; const ee = (function () { return function RestElement(e) { this.type = n.Syntax.RestElement, this.argument = e } }()); t.RestElement = ee; const te = (function () { return function ReturnStatement(e) { this.type = n.Syntax.ReturnStatement, this.argument = e } }()); t.ReturnStatement = te; const re = (function () { return function Script(e) { this.type = n.Syntax.Program, this.body = e, this.sourceType = 'script' } }()); t.Script = re; const ne = (function () { return function SequenceExpression(e) { this.type = n.Syntax.SequenceExpression, this.expressions = e } }()); t.SequenceExpression = ne; const ie = (function () { return function SpreadElement(e) { this.type = n.Syntax.SpreadElement, this.argument = e } }()); t.SpreadElement = ie; const ae = (function () { return function StaticMemberExpression(e, t) { this.type = n.Syntax.MemberExpression, this.computed = !1, this.object = e, this.property = t } }()); t.StaticMemberExpression = ae; const oe = (function () { return function Super() { this.type = n.Syntax.Super } }()); t.Super = oe; const se = (function () { return function SwitchCase(e, t) { this.type = n.Syntax.SwitchCase, this.test = e, this.consequent = t } }()); t.SwitchCase = se; const ue = (function () { return function SwitchStatement(e, t) { this.type = n.Syntax.SwitchStatement, this.discriminant = e, this.cases = t } }()); t.SwitchStatement = ue; const le = (function () { return function TaggedTemplateExpression(e, t) { this.type = n.Syntax.TaggedTemplateExpression, this.tag = e, this.quasi = t } }()); t.TaggedTemplateExpression = le; const ce = (function () { return function TemplateElement(e, t) { this.type = n.Syntax.TemplateElement, this.value = e, this.tail = t } }()); t.TemplateElement = ce; const pe = (function () { return function TemplateLiteral(e, t) { this.type = n.Syntax.TemplateLiteral, this.quasis = e, this.expressions = t } }()); t.TemplateLiteral = pe; const fe = (function () { return function ThisExpression() { this.type = n.Syntax.ThisExpression } }()); t.ThisExpression = fe; const de = (function () { return function ThrowStatement(e) { this.type = n.Syntax.ThrowStatement, this.argument = e } }()); t.ThrowStatement = de; const he = (function () { return function TryStatement(e, t, r) { this.type = n.Syntax.TryStatement, this.block = e, this.handler = t, this.finalizer = r } }()); t.TryStatement = he; const me = (function () { return function UnaryExpression(e, t) { this.type = n.Syntax.UnaryExpression, this.operator = e, this.argument = t, this.prefix = !0 } }()); t.UnaryExpression = me; const ge = (function () { return function UpdateExpression(e, t, r) { this.type = n.Syntax.UpdateExpression, this.operator = e, this.argument = t, this.prefix = r } }()); t.UpdateExpression = ge; const ve = (function () { return function VariableDeclaration(e, t) { this.type = n.Syntax.VariableDeclaration, this.declarations = e, this.kind = t } }()); t.VariableDeclaration = ve; const ye = (function () { return function VariableDeclarator(e, t) { this.type = n.Syntax.VariableDeclarator, this.id = e, this.init = t } }()); t.VariableDeclarator = ye; const be = (function () { return function WhileStatement(e, t) { this.type = n.Syntax.WhileStatement, this.test = e, this.body = t } }()); t.WhileStatement = be; const xe = (function () { return function WithStatement(e, t) { this.type = n.Syntax.WithStatement, this.object = e, this.body = t } }()); t.WithStatement = xe; const De = (function () { return function YieldExpression(e, t) { this.type = n.Syntax.YieldExpression, this.argument = e, this.delegate = t } }()); t.YieldExpression = De;
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(9); const i = r(10); const a = r(11); const o = r(7); const s = r(12); const u = r(2); const l = r(13); const c = (function () {
      function Parser(e, t, r) {
        void 0 === t && (t = {}), this.config = {
          range: typeof t.range === 'boolean' && t.range, loc: typeof t.loc === 'boolean' && t.loc, source: null, tokens: typeof t.tokens === 'boolean' && t.tokens, comment: typeof t.comment === 'boolean' && t.comment, tolerant: typeof t.tolerant === 'boolean' && t.tolerant,
        }, this.config.loc && t.source && t.source !== null && (this.config.source = String(t.source)), this.delegate = r, this.errorHandler = new i.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new s.Scanner(e, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = {
          ')': 0, ';': 0, ',': 0, '=': 0, ']': 0, '||': 1, '&&': 2, '|': 3, '^': 4, '&': 5, '==': 6, '!=': 6, '===': 6, '!==': 6, '<': 7, '>': 7, '<=': 7, '>=': 7, '<<': 8, '>>': 8, '>>>': 8, '+': 9, '-': 9, '*': 11, '/': 11, '%': 11,
        }, this.lookahead = {
          type: 2, value: '', lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0,
        }, this.hasLineTerminator = !1, this.context = {
          isModule: !1, await: !1, allowIn: !0, allowStrictDirective: !0, allowYield: !0, firstCoverInitializedNameError: null, isAssignmentTarget: !1, isBindingElement: !1, inFunctionBody: !1, inIteration: !1, inSwitch: !1, labelSet: {}, strict: !1,
        }, this.tokens = [], this.startMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.lastMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.nextToken(), this.lastMarker = { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
      } return Parser.prototype.throwError = function (e) { for (let t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; const i = Array.prototype.slice.call(arguments, 1); const a = e.replace(/%(\d)/g, (e, t) => n.assert(t < i.length, "Message reference must be in range"), i[t]); const o = this.lastMarker.index; const s = this.lastMarker.line; const u = this.lastMarker.column + 1; throw this.errorHandler.createError(o, s, u, a) }, Parser.prototype.tolerateError = function (e) { for (let t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; const i = Array.prototype.slice.call(arguments, 1); const a = e.replace(/%(\d)/g, (e, t) => n.assert(t < i.length, "Message reference must be in range"), i[t]); const o = this.lastMarker.index; const s = this.scanner.lineNumber; const u = this.lastMarker.column + 1; this.errorHandler.tolerateError(o, s, u, a) }, Parser.prototype.unexpectedTokenError = function (e, t) { let r; let n = t || a.Messages.UnexpectedToken; if (e ? (t || (n = e.type === 2 ? a.Messages.UnexpectedEOS : e.type === 3 ? a.Messages.UnexpectedIdentifier : e.type === 6 ? a.Messages.UnexpectedNumber : e.type === 8 ? a.Messages.UnexpectedString : e.type === 10 ? a.Messages.UnexpectedTemplate : a.Messages.UnexpectedToken, e.type === 4 && (this.scanner.isFutureReservedWord(e.value) ? n = a.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(e.value) && (n = a.Messages.StrictReservedWord))), r = e.value) : r = 'ILLEGAL', n = n.replace('%0', r), e && typeof e.lineNumber === 'number') { var i = e.start; var o = e.lineNumber; const s = this.lastMarker.index - this.lastMarker.column; var u = e.start - s + 1; return this.errorHandler.createError(i, o, u, n) }i = this.lastMarker.index, o = this.lastMarker.line, u = this.lastMarker.column + 1; return this.errorHandler.createError(i, o, u, n) }, Parser.prototype.throwUnexpectedToken = function (e, t) { throw this.unexpectedTokenError(e, t) }, Parser.prototype.tolerateUnexpectedToken = function (e, t) { this.errorHandler.tolerate(this.unexpectedTokenError(e, t)) }, Parser.prototype.collectComments = function () { if (this.config.comment) { const e = this.scanner.scanComments(); if (e.length > 0 && this.delegate) for (let t = 0; t < e.length; ++t) { const r = e[t]; let n = void 0; n = { type: r.multiLine ? 'BlockComment' : 'LineComment', value: this.scanner.source.slice(r.slice[0], r.slice[1]) }, this.config.range && (n.range = r.range), this.config.loc && (n.loc = r.loc); const i = { start: { line: r.loc.start.line, column: r.loc.start.column, offset: r.range[0] }, end: { line: r.loc.end.line, column: r.loc.end.column, offset: r.range[1] } }; this.delegate(n, i) } } else this.scanner.scanComments(); }, Parser.prototype.getTokenRaw = function (e) { return this.scanner.source.slice(e.start, e.end) }, Parser.prototype.convertToken = function (e) { const t = { type: l.TokenName[e.type], value: this.getTokenRaw(e) }; if (this.config.range && (t.range = [e.start, e.end]), this.config.loc && (t.loc = { start: { line: this.startMarker.line, column: this.startMarker.column }, end: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }), e.type === 9) { const r = e.pattern; const n = e.flags; t.regex = { pattern: r, flags: n } } return t }, Parser.prototype.nextToken = function () { const e = this.lookahead; this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart); const t = this.scanner.lex(); return this.hasLineTerminator = e.lineNumber !== t.lineNumber, t && this.context.strict && t.type === 3 && this.scanner.isStrictModeReservedWord(t.value) && (t.type = 4), this.lookahead = t, this.config.tokens && t.type !== 2 && this.tokens.push(this.convertToken(t)), e }, Parser.prototype.nextRegexToken = function () { this.collectComments(); const e = this.scanner.scanRegExp(); return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(e))), this.lookahead = e, this.nextToken(), e }, Parser.prototype.createNode = function () { return { index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column } }, Parser.prototype.startNode = function (e) { return { index: e.start, line: e.lineNumber, column: e.start - e.lineStart } }, Parser.prototype.finalize = function (e, t) { if (this.config.range && (t.range = [e.index, this.lastMarker.index]), this.config.loc && (t.loc = { start: { line: e.line, column: e.column }, end: { line: this.lastMarker.line, column: this.lastMarker.column } }, this.config.source && (t.loc.source = this.config.source)), this.delegate) { const r = { start: { line: e.line, column: e.column, offset: e.index }, end: { line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index } }; this.delegate(t, r) } return t }, Parser.prototype.expect = function (e) { const t = this.nextToken(); t.type === 7 && t.value === e || this.throwUnexpectedToken(t) }, Parser.prototype.expectCommaSeparator = function () { if (this.config.tolerant) { const e = this.lookahead; e.type === 7 && e.value === ',' ? this.nextToken() : e.type === 7 && e.value === ';' ? (this.nextToken(), this.tolerateUnexpectedToken(e)) : this.tolerateUnexpectedToken(e, a.Messages.UnexpectedToken) } else this.expect(','); }, Parser.prototype.expectKeyword = function (e) { const t = this.nextToken(); t.type === 4 && t.value === e || this.throwUnexpectedToken(t) }, Parser.prototype.match = function (e) { return this.lookahead.type === 7 && this.lookahead.value === e }, Parser.prototype.matchKeyword = function (e) { return this.lookahead.type === 4 && this.lookahead.value === e }, Parser.prototype.matchContextualKeyword = function (e) { return this.lookahead.type === 3 && this.lookahead.value === e }, Parser.prototype.matchAssign = function () { if (this.lookahead.type !== 7) return !1; const e = this.lookahead.value; return e === '=' || e === '*=' || e === '**=' || e === '/=' || e === '%=' || e === '+=' || e === '-=' || e === '<<=' || e === '>>=' || e === '>>>=' || e === '&=' || e === '^=' || e === '|=' }, Parser.prototype.isolateCoverGrammar = function (e) { const t = this.context.isBindingElement; const r = this.context.isAssignmentTarget; const n = this.context.firstCoverInitializedNameError; this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null; const i = e.call(this); return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = t, this.context.isAssignmentTarget = r, this.context.firstCoverInitializedNameError = n, i }, Parser.prototype.inheritCoverGrammar = function (e) { const t = this.context.isBindingElement; const r = this.context.isAssignmentTarget; const n = this.context.firstCoverInitializedNameError; this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null; const i = e.call(this); return this.context.isBindingElement = this.context.isBindingElement && t, this.context.isAssignmentTarget = this.context.isAssignmentTarget && r, this.context.firstCoverInitializedNameError = n || this.context.firstCoverInitializedNameError, i }, Parser.prototype.consumeSemicolon = function () { this.match(';') ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type === 2 || this.match('}') || this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column) }, Parser.prototype.parsePrimaryExpression = function () { let e; let t; let r; const n = this.createNode(); switch (this.lookahead.type) { case 3: (this.context.isModule || this.context.await) && this.lookahead.value === 'await' && this.tolerateUnexpectedToken(this.lookahead), e = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(n, new o.Identifier(this.nextToken().value)); break; case 6: case 8: this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, a.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, t = this.nextToken(), r = this.getTokenRaw(t), e = this.finalize(n, new o.Literal(t.value, r)); break; case 1: this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, t = this.nextToken(), r = this.getTokenRaw(t), e = this.finalize(n, new o.Literal(t.value === 'true', r)); break; case 5: this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, t = this.nextToken(), r = this.getTokenRaw(t), e = this.finalize(n, new o.Literal(null, r)); break; case 10: e = this.parseTemplateLiteral(); break; case 7: switch (this.lookahead.value) { case '(': this.context.isBindingElement = !1, e = this.inheritCoverGrammar(this.parseGroupExpression); break; case '[': e = this.inheritCoverGrammar(this.parseArrayInitializer); break; case '{': e = this.inheritCoverGrammar(this.parseObjectInitializer); break; case '/': case '/=': this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, t = this.nextRegexToken(), r = this.getTokenRaw(t), e = this.finalize(n, new o.RegexLiteral(t.regex, r, t.pattern, t.flags)); break; default: e = this.throwUnexpectedToken(this.nextToken()); } break; case 4: !this.context.strict && this.context.allowYield && this.matchKeyword('yield') ? e = this.parseIdentifierName() : !this.context.strict && this.matchKeyword('let') ? e = this.finalize(n, new o.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword('function') ? e = this.parseFunctionExpression() : this.matchKeyword('this') ? (this.nextToken(), e = this.finalize(n, new o.ThisExpression())) : e = this.matchKeyword('class') ? this.parseClassExpression() : this.throwUnexpectedToken(this.nextToken())); break; default: e = this.throwUnexpectedToken(this.nextToken()); } return e }, Parser.prototype.parseSpreadElement = function () { const e = this.createNode(); this.expect('...'); const t = this.inheritCoverGrammar(this.parseAssignmentExpression); return this.finalize(e, new o.SpreadElement(t)) }, Parser.prototype.parseArrayInitializer = function () { const e = this.createNode(); const t = []; for (this.expect('['); !this.match(']');) if (this.match(',')) this.nextToken(), t.push(null); else if (this.match('...')) { const r = this.parseSpreadElement(); this.match(']') || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(',')), t.push(r) } else t.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match(']') || this.expect(','); return this.expect(']'), this.finalize(e, new o.ArrayExpression(t)) }, Parser.prototype.parsePropertyMethod = function (e) { this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; const t = this.context.strict; const r = this.context.allowStrictDirective; this.context.allowStrictDirective = e.simple; const n = this.isolateCoverGrammar(this.parseFunctionSourceElements); return this.context.strict && e.firstRestricted && this.tolerateUnexpectedToken(e.firstRestricted, e.message), this.context.strict && e.stricted && this.tolerateUnexpectedToken(e.stricted, e.message), this.context.strict = t, this.context.allowStrictDirective = r, n }, Parser.prototype.parsePropertyMethodFunction = function () { const e = this.createNode(); const t = this.context.allowYield; this.context.allowYield = !1; const r = this.parseFormalParameters(); const n = this.parsePropertyMethod(r); return this.context.allowYield = t, this.finalize(e, new o.FunctionExpression(null, r.params, n, !1)) }, Parser.prototype.parsePropertyMethodAsyncFunction = function () { const e = this.createNode(); const t = this.context.allowYield; const r = this.context.await; this.context.allowYield = !1, this.context.await = !0; const n = this.parseFormalParameters(); const i = this.parsePropertyMethod(n); return this.context.allowYield = t, this.context.await = r, this.finalize(e, new o.AsyncFunctionExpression(null, n.params, i)) }, Parser.prototype.parseObjectPropertyKey = function () { let e; const t = this.createNode(); const r = this.nextToken(); switch (r.type) { case 8: case 6: this.context.strict && r.octal && this.tolerateUnexpectedToken(r, a.Messages.StrictOctalLiteral); var n = this.getTokenRaw(r); e = this.finalize(t, new o.Literal(r.value, n)); break; case 3: case 1: case 5: case 4: e = this.finalize(t, new o.Identifier(r.value)); break; case 7: r.value === '[' ? (e = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect(']')) : e = this.throwUnexpectedToken(r); break; default: e = this.throwUnexpectedToken(r); } return e }, Parser.prototype.isPropertyKey = function (e, t) { return e.type === u.Syntax.Identifier && e.name === t || e.type === u.Syntax.Literal && e.value === t }, Parser.prototype.parseObjectProperty = function (e) { let t; const r = this.createNode(); const n = this.lookahead; let i = null; let s = null; let u = !1; let l = !1; let c = !1; let p = !1; if (n.type === 3) { var f = n.value; this.nextToken(), u = this.match('['), i = (p = !(this.hasLineTerminator || f !== 'async' || this.match(':') || this.match('(') || this.match('*'))) ? this.parseObjectPropertyKey() : this.finalize(r, new o.Identifier(f)) } else this.match('*') ? this.nextToken() : (u = this.match('['), i = this.parseObjectPropertyKey()); const d = this.qualifiedPropertyName(this.lookahead); if (n.type === 3 && !p && n.value === 'get' && d)t = 'get', u = this.match('['), i = this.parseObjectPropertyKey(), this.context.allowYield = !1, s = this.parseGetterMethod(); else if (n.type === 3 && !p && n.value === 'set' && d)t = 'set', u = this.match('['), i = this.parseObjectPropertyKey(), s = this.parseSetterMethod(); else if (n.type === 7 && n.value === '*' && d)t = 'init', u = this.match('['), i = this.parseObjectPropertyKey(), s = this.parseGeneratorMethod(), l = !0; else if (i || this.throwUnexpectedToken(this.lookahead), t = 'init', this.match(':') && !p)!u && this.isPropertyKey(i, '__proto__') && (e.value && this.tolerateError(a.Messages.DuplicateProtoProperty), e.value = !0), this.nextToken(), s = this.inheritCoverGrammar(this.parseAssignmentExpression); else if (this.match('('))s = p ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l = !0; else if (n.type === 3) { f = this.finalize(r, new o.Identifier(n.value)); if (this.match('=')) { this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), c = !0; const h = this.isolateCoverGrammar(this.parseAssignmentExpression); s = this.finalize(r, new o.AssignmentPattern(f, h)) } else c = !0, s = f; } else this.throwUnexpectedToken(this.nextToken()); return this.finalize(r, new o.Property(t, i, u, s, l, c)) }, Parser.prototype.parseObjectInitializer = function () { const e = this.createNode(); this.expect('{'); for (var t = [], r = { value: !1 }; !this.match('}');)t.push(this.parseObjectProperty(r)), this.match('}') || this.expectCommaSeparator(); return this.expect('}'), this.finalize(e, new o.ObjectExpression(t)) }, Parser.prototype.parseTemplateHead = function () { n.assert(this.lookahead.head, 'Template literal must start with a template head'); const e = this.createNode(); const t = this.nextToken(); const r = t.value; const i = t.cooked; return this.finalize(e, new o.TemplateElement({ raw: r, cooked: i }, t.tail)) }, Parser.prototype.parseTemplateElement = function () { this.lookahead.type !== 10 && this.throwUnexpectedToken(); const e = this.createNode(); const t = this.nextToken(); const r = t.value; const n = t.cooked; return this.finalize(e, new o.TemplateElement({ raw: r, cooked: n }, t.tail)) }, Parser.prototype.parseTemplateLiteral = function () { const e = this.createNode(); const t = []; const r = []; let n = this.parseTemplateHead(); for (r.push(n); !n.tail;)t.push(this.parseExpression()), n = this.parseTemplateElement(), r.push(n); return this.finalize(e, new o.TemplateLiteral(r, t)) }, Parser.prototype.reinterpretExpressionAsPattern = function (e) { switch (e.type) { case u.Syntax.Identifier: case u.Syntax.MemberExpression: case u.Syntax.RestElement: case u.Syntax.AssignmentPattern: break; case u.Syntax.SpreadElement: e.type = u.Syntax.RestElement, this.reinterpretExpressionAsPattern(e.argument); break; case u.Syntax.ArrayExpression: e.type = u.Syntax.ArrayPattern; for (var t = 0; t < e.elements.length; t++)e.elements[t] !== null && this.reinterpretExpressionAsPattern(e.elements[t]); break; case u.Syntax.ObjectExpression: e.type = u.Syntax.ObjectPattern; for (t = 0; t < e.properties.length; t++) this.reinterpretExpressionAsPattern(e.properties[t].value); break; case u.Syntax.AssignmentExpression: e.type = u.Syntax.AssignmentPattern, delete e.operator, this.reinterpretExpressionAsPattern(e.left); } }, Parser.prototype.parseGroupExpression = function () { let e; if (this.expect('('), this.match(')')) this.nextToken(), this.match('=>') || this.expect('=>'), e = { type: 'ArrowParameterPlaceHolder', params: [], async: !1 }; else { const t = this.lookahead; const r = []; if (this.match('...'))e = this.parseRestElement(r), this.expect(')'), this.match('=>') || this.expect('=>'), e = { type: 'ArrowParameterPlaceHolder', params: [e], async: !1 }; else { let n = !1; if (this.context.isBindingElement = !0, e = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(',')) { const i = []; for (this.context.isAssignmentTarget = !1, i.push(e); this.lookahead.type !== 2 && this.match(',');) { if (this.nextToken(), this.match(')')) { this.nextToken(); for (var a = 0; a < i.length; a++) this.reinterpretExpressionAsPattern(i[a]); n = !0, e = { type: 'ArrowParameterPlaceHolder', params: i, async: !1 } } else if (this.match('...')) { this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), i.push(this.parseRestElement(r)), this.expect(')'), this.match('=>') || this.expect('=>'), this.context.isBindingElement = !1; for (a = 0; a < i.length; a++) this.reinterpretExpressionAsPattern(i[a]); n = !0, e = { type: 'ArrowParameterPlaceHolder', params: i, async: !1 } } else i.push(this.inheritCoverGrammar(this.parseAssignmentExpression)); if (n) break; }n || (e = this.finalize(this.startNode(t), new o.SequenceExpression(i))) } if (!n) { if (this.expect(')'), this.match('=>') && (e.type === u.Syntax.Identifier && e.name === 'yield' && (n = !0, e = { type: 'ArrowParameterPlaceHolder', params: [e], async: !1 }), !n)) { if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), e.type === u.Syntax.SequenceExpression) for (a = 0; a < e.expressions.length; a++) this.reinterpretExpressionAsPattern(e.expressions[a]); else this.reinterpretExpressionAsPattern(e); e = { type: 'ArrowParameterPlaceHolder', params: e.type === u.Syntax.SequenceExpression ? e.expressions : [e], async: !1 } } this.context.isBindingElement = !1 } } } return e }, Parser.prototype.parseArguments = function () { this.expect('('); const e = []; if (!this.match(')')) for (;;) { const t = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression); if (e.push(t), this.match(')')) break; if (this.expectCommaSeparator(), this.match(')')) break; } return this.expect(')'), e }, Parser.prototype.isIdentifierName = function (e) { return e.type === 3 || e.type === 4 || e.type === 1 || e.type === 5 }, Parser.prototype.parseIdentifierName = function () { const e = this.createNode(); const t = this.nextToken(); return this.isIdentifierName(t) || this.throwUnexpectedToken(t), this.finalize(e, new o.Identifier(t.value)) }, Parser.prototype.parseNewExpression = function () { let e; const t = this.createNode(); const r = this.parseIdentifierName(); if (n.assert(r.name === 'new', 'New expression must start with `new`'), this.match('.')) if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === 'target') { const i = this.parseIdentifierName(); e = new o.MetaProperty(r, i) } else this.throwUnexpectedToken(this.lookahead); else { const a = this.isolateCoverGrammar(this.parseLeftHandSideExpression); const s = this.match('(') ? this.parseArguments() : []; e = new o.NewExpression(a, s), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } return this.finalize(t, e) }, Parser.prototype.parseAsyncArgument = function () { const e = this.parseAssignmentExpression(); return this.context.firstCoverInitializedNameError = null, e }, Parser.prototype.parseAsyncArguments = function () { this.expect('('); const e = []; if (!this.match(')')) for (;;) { const t = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument); if (e.push(t), this.match(')')) break; if (this.expectCommaSeparator(), this.match(')')) break; } return this.expect(')'), e }, Parser.prototype.parseLeftHandSideExpressionAllowCall = function () { let e; const t = this.lookahead; const r = this.matchContextualKeyword('async'); const n = this.context.allowIn; for (this.context.allowIn = !0, this.matchKeyword('super') && this.context.inFunctionBody ? (e = this.createNode(), this.nextToken(), e = this.finalize(e, new o.Super()), this.match('(') || this.match('.') || this.match('[') || this.throwUnexpectedToken(this.lookahead)) : e = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression); ;) if (this.match('.')) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect('.'); var i = this.parseIdentifierName(); e = this.finalize(this.startNode(t), new o.StaticMemberExpression(e, i)) } else if (this.match('(')) { const a = r && t.lineNumber === this.lookahead.lineNumber; this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1; const s = a ? this.parseAsyncArguments() : this.parseArguments(); if (e = this.finalize(this.startNode(t), new o.CallExpression(e, s)), a && this.match('=>')) { for (let u = 0; u < s.length; ++u) this.reinterpretExpressionAsPattern(s[u]); e = { type: 'ArrowParameterPlaceHolder', params: s, async: !0 } } } else if (this.match('[')) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect('['); i = this.isolateCoverGrammar(this.parseExpression); this.expect(']'), e = this.finalize(this.startNode(t), new o.ComputedMemberExpression(e, i)) } else { if (this.lookahead.type !== 10 || !this.lookahead.head) break; const l = this.parseTemplateLiteral(); e = this.finalize(this.startNode(t), new o.TaggedTemplateExpression(e, l)) } return this.context.allowIn = n, e }, Parser.prototype.parseSuper = function () { const e = this.createNode(); return this.expectKeyword('super'), this.match('[') || this.match('.') || this.throwUnexpectedToken(this.lookahead), this.finalize(e, new o.Super()) }, Parser.prototype.parseLeftHandSideExpression = function () { n.assert(this.context.allowIn, 'callee of new expression always allow in keyword.'); for (var e = this.startNode(this.lookahead), t = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression); ;) if (this.match('[')) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect('['); var r = this.isolateCoverGrammar(this.parseExpression); this.expect(']'), t = this.finalize(e, new o.ComputedMemberExpression(t, r)) } else if (this.match('.')) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect('.'); r = this.parseIdentifierName(); t = this.finalize(e, new o.StaticMemberExpression(t, r)) } else { if (this.lookahead.type !== 10 || !this.lookahead.head) break; const i = this.parseTemplateLiteral(); t = this.finalize(e, new o.TaggedTemplateExpression(t, i)) } return t }, Parser.prototype.parseUpdateExpression = function () { let e; const t = this.lookahead; if (this.match('++') || this.match('--')) { const r = this.startNode(t); const n = this.nextToken(); e = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && e.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e.name) && this.tolerateError(a.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment); var i = !0; e = this.finalize(r, new o.UpdateExpression(n.value, e, i)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } else if (e = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === 7 && (this.match('++') || this.match('--'))) { this.context.strict && e.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e.name) && this.tolerateError(a.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; const s = this.nextToken().value; i = !1; e = this.finalize(this.startNode(t), new o.UpdateExpression(s, e, i)) } return e }, Parser.prototype.parseAwaitExpression = function () { const e = this.createNode(); this.nextToken(); const t = this.parseUnaryExpression(); return this.finalize(e, new o.AwaitExpression(t)) }, Parser.prototype.parseUnaryExpression = function () { let e; if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) { const t = this.startNode(this.lookahead); const r = this.nextToken(); e = this.inheritCoverGrammar(this.parseUnaryExpression), e = this.finalize(t, new o.UnaryExpression(r.value, e)), this.context.strict && e.operator === 'delete' && e.argument.type === u.Syntax.Identifier && this.tolerateError(a.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } else e = this.context.await && this.matchContextualKeyword('await') ? this.parseAwaitExpression() : this.parseUpdateExpression(); return e }, Parser.prototype.parseExponentiationExpression = function () { const e = this.lookahead; let t = this.inheritCoverGrammar(this.parseUnaryExpression); if (t.type !== u.Syntax.UnaryExpression && this.match('**')) { this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; const r = t; const n = this.isolateCoverGrammar(this.parseExponentiationExpression); t = this.finalize(this.startNode(e), new o.BinaryExpression('**', r, n)) } return t }, Parser.prototype.binaryPrecedence = function (e) { const t = e.value; return e.type === 7 ? this.operatorPrecedence[t] || 0 : e.type === 4 && (t === 'instanceof' || this.context.allowIn && t === 'in') ? 7 : 0 }, Parser.prototype.parseBinaryExpression = function () { const e = this.lookahead; let t = this.inheritCoverGrammar(this.parseExponentiationExpression); const r = this.lookahead; let n = this.binaryPrecedence(r); if (n > 0) { this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; for (var i = [e, this.lookahead], a = t, s = this.isolateCoverGrammar(this.parseExponentiationExpression), u = [a, r.value, s], l = [n]; !((n = this.binaryPrecedence(this.lookahead)) <= 0);) { for (;u.length > 2 && n <= l[l.length - 1];) { s = u.pop(); var c = u.pop(); l.pop(), a = u.pop(), i.pop(); var p = this.startNode(i[i.length - 1]); u.push(this.finalize(p, new o.BinaryExpression(c, a, s))) }u.push(this.nextToken().value), l.push(n), i.push(this.lookahead), u.push(this.isolateCoverGrammar(this.parseExponentiationExpression)) } let f = u.length - 1; for (t = u[f], i.pop(); f > 1;) { p = this.startNode(i.pop()), c = u[f - 1]; t = this.finalize(p, new o.BinaryExpression(c, u[f - 2], t)), f -= 2 } } return t }, Parser.prototype.parseConditionalExpression = function () { const e = this.lookahead; let t = this.inheritCoverGrammar(this.parseBinaryExpression); if (this.match('?')) { this.nextToken(); const r = this.context.allowIn; this.context.allowIn = !0; const n = this.isolateCoverGrammar(this.parseAssignmentExpression); this.context.allowIn = r, this.expect(':'); const i = this.isolateCoverGrammar(this.parseAssignmentExpression); t = this.finalize(this.startNode(e), new o.ConditionalExpression(t, n, i)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } return t }, Parser.prototype.checkPatternParam = function (e, t) { switch (t.type) { case u.Syntax.Identifier: this.validateParam(e, t, t.name); break; case u.Syntax.RestElement: this.checkPatternParam(e, t.argument); break; case u.Syntax.AssignmentPattern: this.checkPatternParam(e, t.left); break; case u.Syntax.ArrayPattern: for (var r = 0; r < t.elements.length; r++)t.elements[r] !== null && this.checkPatternParam(e, t.elements[r]); break; case u.Syntax.ObjectPattern: for (r = 0; r < t.properties.length; r++) this.checkPatternParam(e, t.properties[r].value); }e.simple = e.simple && t instanceof o.Identifier }, Parser.prototype.reinterpretAsCoverFormalsList = function (e) {
        let t; let r = [e]; let n = !1; switch (e.type) { case u.Syntax.Identifier: break; case 'ArrowParameterPlaceHolder': r = e.params, n = e.async; break; default: return null; }t = { simple: !0, paramSet: {} }; for (var i = 0; i < r.length; ++i) { (o = r[i]).type === u.Syntax.AssignmentPattern ? o.right.type === u.Syntax.YieldExpression && (o.right.argument && this.throwUnexpectedToken(this.lookahead), o.right.type = u.Syntax.Identifier, o.right.name = 'yield', delete o.right.argument, delete o.right.delegate) : n && o.type === u.Syntax.Identifier && o.name === 'await' && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(t, o), r[i] = o } if (this.context.strict || !this.context.allowYield) for (i = 0; i < r.length; ++i) { var o; (o = r[i]).type === u.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead) } if (t.message === a.Messages.StrictParamDupe) { const s = this.context.strict ? t.stricted : t.firstRestricted; this.throwUnexpectedToken(s, t.message) } return {
          simple: t.simple, params: r, stricted: t.stricted, firstRestricted: t.firstRestricted, message: t.message,
        };
      }, Parser.prototype.parseAssignmentExpression = function () { let e; if (!this.context.allowYield && this.matchKeyword('yield'))e = this.parseYieldExpression(); else { const t = this.lookahead; let r = t; if (e = this.parseConditionalExpression(), r.type === 3 && r.lineNumber === this.lookahead.lineNumber && r.value === 'async' && (this.lookahead.type === 3 || this.matchKeyword('yield'))) { const n = this.parsePrimaryExpression(); this.reinterpretExpressionAsPattern(n), e = { type: 'ArrowParameterPlaceHolder', params: [n], async: !0 } } if (e.type === 'ArrowParameterPlaceHolder' || this.match('=>')) { this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; const i = e.async; const s = this.reinterpretAsCoverFormalsList(e); if (s) { this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null; const l = this.context.strict; const c = this.context.allowStrictDirective; this.context.allowStrictDirective = s.simple; const p = this.context.allowYield; const f = this.context.await; this.context.allowYield = !0, this.context.await = i; const d = this.startNode(t); this.expect('=>'); let h = void 0; if (this.match('{')) { const m = this.context.allowIn; this.context.allowIn = !0, h = this.parseFunctionSourceElements(), this.context.allowIn = m } else h = this.isolateCoverGrammar(this.parseAssignmentExpression); const g = h.type !== u.Syntax.BlockStatement; this.context.strict && s.firstRestricted && this.throwUnexpectedToken(s.firstRestricted, s.message), this.context.strict && s.stricted && this.tolerateUnexpectedToken(s.stricted, s.message), e = i ? this.finalize(d, new o.AsyncArrowFunctionExpression(s.params, h, g)) : this.finalize(d, new o.ArrowFunctionExpression(s.params, h, g)), this.context.strict = l, this.context.allowStrictDirective = c, this.context.allowYield = p, this.context.await = f } } else if (this.matchAssign()) { if (this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.strict && e.type === u.Syntax.Identifier) { const v = e; this.scanner.isRestrictedWord(v.name) && this.tolerateUnexpectedToken(r, a.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(v.name) && this.tolerateUnexpectedToken(r, a.Messages.StrictReservedWord) } this.match('=') ? this.reinterpretExpressionAsPattern(e) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1); const y = (r = this.nextToken()).value; const b = this.isolateCoverGrammar(this.parseAssignmentExpression); e = this.finalize(this.startNode(t), new o.AssignmentExpression(y, e, b)), this.context.firstCoverInitializedNameError = null } } return e }, Parser.prototype.parseExpression = function () { const e = this.lookahead; let t = this.isolateCoverGrammar(this.parseAssignmentExpression); if (this.match(',')) { const r = []; for (r.push(t); this.lookahead.type !== 2 && this.match(',');) this.nextToken(), r.push(this.isolateCoverGrammar(this.parseAssignmentExpression)); t = this.finalize(this.startNode(e), new o.SequenceExpression(r)) } return t }, Parser.prototype.parseStatementListItem = function () { let e; if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4) switch (this.lookahead.value) { case 'export': this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalExportDeclaration), e = this.parseExportDeclaration(); break; case 'import': this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalImportDeclaration), e = this.parseImportDeclaration(); break; case 'const': e = this.parseLexicalDeclaration({ inFor: !1 }); break; case 'function': e = this.parseFunctionDeclaration(); break; case 'class': e = this.parseClassDeclaration(); break; case 'let': e = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement(); break; default: e = this.parseStatement(); } else e = this.parseStatement(); return e }, Parser.prototype.parseBlock = function () { const e = this.createNode(); this.expect('{'); for (var t = []; !this.match('}');)t.push(this.parseStatementListItem()); return this.expect('}'), this.finalize(e, new o.BlockStatement(t)) }, Parser.prototype.parseLexicalBinding = function (e, t) { const r = this.createNode(); const n = this.parsePattern([], e); this.context.strict && n.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(n.name) && this.tolerateError(a.Messages.StrictVarName); let i = null; return e === 'const' ? this.matchKeyword('in') || this.matchContextualKeyword('of') || (this.match('=') ? (this.nextToken(), i = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(a.Messages.DeclarationMissingInitializer, 'const')) : (!t.inFor && n.type !== u.Syntax.Identifier || this.match('=')) && (this.expect('='), i = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(r, new o.VariableDeclarator(n, i)) }, Parser.prototype.parseBindingList = function (e, t) { for (var r = [this.parseLexicalBinding(e, t)]; this.match(',');) this.nextToken(), r.push(this.parseLexicalBinding(e, t)); return r }, Parser.prototype.isLexicalDeclaration = function () { const e = this.scanner.saveState(); this.scanner.scanComments(); const t = this.scanner.lex(); return this.scanner.restoreState(e), t.type === 3 || t.type === 7 && t.value === '[' || t.type === 7 && t.value === '{' || t.type === 4 && t.value === 'let' || t.type === 4 && t.value === 'yield' }, Parser.prototype.parseLexicalDeclaration = function (e) { const t = this.createNode(); const r = this.nextToken().value; n.assert(r === 'let' || r === 'const', 'Lexical declaration must be either let or const'); const i = this.parseBindingList(r, e); return this.consumeSemicolon(), this.finalize(t, new o.VariableDeclaration(i, r)) }, Parser.prototype.parseBindingRestElement = function (e, t) { const r = this.createNode(); this.expect('...'); const n = this.parsePattern(e, t); return this.finalize(r, new o.RestElement(n)) }, Parser.prototype.parseArrayPattern = function (e, t) { const r = this.createNode(); this.expect('['); for (var n = []; !this.match(']');) if (this.match(',')) this.nextToken(), n.push(null); else { if (this.match('...')) { n.push(this.parseBindingRestElement(e, t)); break }n.push(this.parsePatternWithDefault(e, t)), this.match(']') || this.expect(',') } return this.expect(']'), this.finalize(r, new o.ArrayPattern(n)) }, Parser.prototype.parsePropertyPattern = function (e, t) { let r; let n; const i = this.createNode(); let a = !1; let s = !1; if (this.lookahead.type === 3) { const u = this.lookahead; r = this.parseVariableIdentifier(); const l = this.finalize(i, new o.Identifier(u.value)); if (this.match('=')) { e.push(u), s = !0, this.nextToken(); const c = this.parseAssignmentExpression(); n = this.finalize(this.startNode(u), new o.AssignmentPattern(l, c)) } else this.match(':') ? (this.expect(':'), n = this.parsePatternWithDefault(e, t)) : (e.push(u), s = !0, n = l); } else a = this.match('['), r = this.parseObjectPropertyKey(), this.expect(':'), n = this.parsePatternWithDefault(e, t); return this.finalize(i, new o.Property('init', r, a, n, !1, s)) }, Parser.prototype.parseObjectPattern = function (e, t) { const r = this.createNode(); const n = []; for (this.expect('{'); !this.match('}');)n.push(this.parsePropertyPattern(e, t)), this.match('}') || this.expect(','); return this.expect('}'), this.finalize(r, new o.ObjectPattern(n)) }, Parser.prototype.parsePattern = function (e, t) { let r; return this.match('[') ? r = this.parseArrayPattern(e, t) : this.match('{') ? r = this.parseObjectPattern(e, t) : (!this.matchKeyword('let') || t !== 'const' && t !== 'let' || this.tolerateUnexpectedToken(this.lookahead, a.Messages.LetInLexicalBinding), e.push(this.lookahead), r = this.parseVariableIdentifier(t)), r }, Parser.prototype.parsePatternWithDefault = function (e, t) { const r = this.lookahead; let n = this.parsePattern(e, t); if (this.match('=')) { this.nextToken(); const i = this.context.allowYield; this.context.allowYield = !0; const a = this.isolateCoverGrammar(this.parseAssignmentExpression); this.context.allowYield = i, n = this.finalize(this.startNode(r), new o.AssignmentPattern(n, a)) } return n }, Parser.prototype.parseVariableIdentifier = function (e) { const t = this.createNode(); const r = this.nextToken(); return r.type === 4 && r.value === 'yield' ? this.context.strict ? this.tolerateUnexpectedToken(r, a.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(r) : r.type !== 3 ? this.context.strict && r.type === 4 && this.scanner.isStrictModeReservedWord(r.value) ? this.tolerateUnexpectedToken(r, a.Messages.StrictReservedWord) : (this.context.strict || r.value !== 'let' || e !== 'var') && this.throwUnexpectedToken(r) : (this.context.isModule || this.context.await) && r.type === 3 && r.value === 'await' && this.tolerateUnexpectedToken(r), this.finalize(t, new o.Identifier(r.value)) }, Parser.prototype.parseVariableDeclaration = function (e) { const t = this.createNode(); const r = this.parsePattern([], 'var'); this.context.strict && r.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r.name) && this.tolerateError(a.Messages.StrictVarName); let n = null; return this.match('=') ? (this.nextToken(), n = this.isolateCoverGrammar(this.parseAssignmentExpression)) : r.type === u.Syntax.Identifier || e.inFor || this.expect('='), this.finalize(t, new o.VariableDeclarator(r, n)) }, Parser.prototype.parseVariableDeclarationList = function (e) { const t = { inFor: e.inFor }; const r = []; for (r.push(this.parseVariableDeclaration(t)); this.match(',');) this.nextToken(), r.push(this.parseVariableDeclaration(t)); return r }, Parser.prototype.parseVariableStatement = function () { const e = this.createNode(); this.expectKeyword('var'); const t = this.parseVariableDeclarationList({ inFor: !1 }); return this.consumeSemicolon(), this.finalize(e, new o.VariableDeclaration(t, 'var')) }, Parser.prototype.parseEmptyStatement = function () { const e = this.createNode(); return this.expect(';'), this.finalize(e, new o.EmptyStatement()) }, Parser.prototype.parseExpressionStatement = function () { const e = this.createNode(); const t = this.parseExpression(); return this.consumeSemicolon(), this.finalize(e, new o.ExpressionStatement(t)) }, Parser.prototype.parseIfClause = function () { return this.context.strict && this.matchKeyword('function') && this.tolerateError(a.Messages.StrictFunction), this.parseStatement() }, Parser.prototype.parseIfStatement = function () { let e; const t = this.createNode(); let r = null; this.expectKeyword('if'), this.expect('('); const n = this.parseExpression(); return !this.match(')') && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e = this.finalize(this.createNode(), new o.EmptyStatement())) : (this.expect(')'), e = this.parseIfClause(), this.matchKeyword('else') && (this.nextToken(), r = this.parseIfClause())), this.finalize(t, new o.IfStatement(n, e, r)) }, Parser.prototype.parseDoWhileStatement = function () { const e = this.createNode(); this.expectKeyword('do'); const t = this.context.inIteration; this.context.inIteration = !0; const r = this.parseStatement(); this.context.inIteration = t, this.expectKeyword('while'), this.expect('('); const n = this.parseExpression(); return !this.match(')') && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(')'), this.match(';') && this.nextToken()), this.finalize(e, new o.DoWhileStatement(r, n)) }, Parser.prototype.parseWhileStatement = function () { let e; const t = this.createNode(); this.expectKeyword('while'), this.expect('('); const r = this.parseExpression(); if (!this.match(')') && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), e = this.finalize(this.createNode(), new o.EmptyStatement()); else { this.expect(')'); const n = this.context.inIteration; this.context.inIteration = !0, e = this.parseStatement(), this.context.inIteration = n } return this.finalize(t, new o.WhileStatement(r, e)) }, Parser.prototype.parseForStatement = function () { let e; let t; let r; let n = null; let i = null; let s = null; let l = !0; const c = this.createNode(); if (this.expectKeyword('for'), this.expect('('), this.match(';')) this.nextToken(); else if (this.matchKeyword('var')) { n = this.createNode(), this.nextToken(); var p = this.context.allowIn; this.context.allowIn = !1; var f = this.parseVariableDeclarationList({ inFor: !0 }); if (this.context.allowIn = p, f.length === 1 && this.matchKeyword('in')) { const d = f[0]; d.init && (d.id.type === u.Syntax.ArrayPattern || d.id.type === u.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(a.Messages.ForInOfLoopInitializer, 'for-in'), n = this.finalize(n, new o.VariableDeclaration(f, 'var')), this.nextToken(), e = n, t = this.parseExpression(), n = null } else f.length === 1 && f[0].init === null && this.matchContextualKeyword('of') ? (n = this.finalize(n, new o.VariableDeclaration(f, 'var')), this.nextToken(), e = n, t = this.parseAssignmentExpression(), n = null, l = !1) : (n = this.finalize(n, new o.VariableDeclaration(f, 'var')), this.expect(';')); } else if (this.matchKeyword('const') || this.matchKeyword('let')) { n = this.createNode(); const h = this.nextToken().value; if (this.context.strict || this.lookahead.value !== 'in') { p = this.context.allowIn; this.context.allowIn = !1; f = this.parseBindingList(h, { inFor: !0 }); this.context.allowIn = p, f.length === 1 && f[0].init === null && this.matchKeyword('in') ? (n = this.finalize(n, new o.VariableDeclaration(f, h)), this.nextToken(), e = n, t = this.parseExpression(), n = null) : f.length === 1 && f[0].init === null && this.matchContextualKeyword('of') ? (n = this.finalize(n, new o.VariableDeclaration(f, h)), this.nextToken(), e = n, t = this.parseAssignmentExpression(), n = null, l = !1) : (this.consumeSemicolon(), n = this.finalize(n, new o.VariableDeclaration(f, h))) } else n = this.finalize(n, new o.Identifier(h)), this.nextToken(), e = n, t = this.parseExpression(), n = null; } else { const m = this.lookahead; p = this.context.allowIn; if (this.context.allowIn = !1, n = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = p, this.matchKeyword('in')) this.context.isAssignmentTarget && n.type !== u.Syntax.AssignmentExpression || this.tolerateError(a.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(n), e = n, t = this.parseExpression(), n = null; else if (this.matchContextualKeyword('of')) this.context.isAssignmentTarget && n.type !== u.Syntax.AssignmentExpression || this.tolerateError(a.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(n), e = n, t = this.parseAssignmentExpression(), n = null, l = !1; else { if (this.match(',')) { for (var g = [n]; this.match(',');) this.nextToken(), g.push(this.isolateCoverGrammar(this.parseAssignmentExpression)); n = this.finalize(this.startNode(m), new o.SequenceExpression(g)) } this.expect(';') } } if (void 0 === e && (this.match(';') || (i = this.parseExpression()), this.expect(';'), this.match(')') || (s = this.parseExpression())), !this.match(')') && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), r = this.finalize(this.createNode(), new o.EmptyStatement()); else { this.expect(')'); const v = this.context.inIteration; this.context.inIteration = !0, r = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = v } return void 0 === e ? this.finalize(c, new o.ForStatement(n, i, s, r)) : l ? this.finalize(c, new o.ForInStatement(e, t, r)) : this.finalize(c, new o.ForOfStatement(e, t, r)) }, Parser.prototype.parseContinueStatement = function () { const e = this.createNode(); this.expectKeyword('continue'); let t = null; if (this.lookahead.type === 3 && !this.hasLineTerminator) { const r = this.parseVariableIdentifier(); t = r; const n = `$${r.name}`; Object.prototype.hasOwnProperty.call(this.context.labelSet, n) || this.throwError(a.Messages.UnknownLabel, r.name) } return this.consumeSemicolon(), t !== null || this.context.inIteration || this.throwError(a.Messages.IllegalContinue), this.finalize(e, new o.ContinueStatement(t)) }, Parser.prototype.parseBreakStatement = function () { const e = this.createNode(); this.expectKeyword('break'); let t = null; if (this.lookahead.type === 3 && !this.hasLineTerminator) { const r = this.parseVariableIdentifier(); const n = `$${r.name}`; Object.prototype.hasOwnProperty.call(this.context.labelSet, n) || this.throwError(a.Messages.UnknownLabel, r.name), t = r } return this.consumeSemicolon(), t !== null || this.context.inIteration || this.context.inSwitch || this.throwError(a.Messages.IllegalBreak), this.finalize(e, new o.BreakStatement(t)) }, Parser.prototype.parseReturnStatement = function () { this.context.inFunctionBody || this.tolerateError(a.Messages.IllegalReturn); const e = this.createNode(); this.expectKeyword('return'); const t = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== 2 ? this.parseExpression() : null; return this.consumeSemicolon(), this.finalize(e, new o.ReturnStatement(t)) }, Parser.prototype.parseWithStatement = function () { this.context.strict && this.tolerateError(a.Messages.StrictModeWith); let e; const t = this.createNode(); this.expectKeyword('with'), this.expect('('); const r = this.parseExpression(); return !this.match(')') && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e = this.finalize(this.createNode(), new o.EmptyStatement())) : (this.expect(')'), e = this.parseStatement()), this.finalize(t, new o.WithStatement(r, e)) }, Parser.prototype.parseSwitchCase = function () { let e; const t = this.createNode(); this.matchKeyword('default') ? (this.nextToken(), e = null) : (this.expectKeyword('case'), e = this.parseExpression()), this.expect(':'); for (var r = []; !(this.match('}') || this.matchKeyword('default') || this.matchKeyword('case'));)r.push(this.parseStatementListItem()); return this.finalize(t, new o.SwitchCase(e, r)) }, Parser.prototype.parseSwitchStatement = function () { const e = this.createNode(); this.expectKeyword('switch'), this.expect('('); const t = this.parseExpression(); this.expect(')'); const r = this.context.inSwitch; this.context.inSwitch = !0; const n = []; let i = !1; for (this.expect('{'); !this.match('}');) { const s = this.parseSwitchCase(); s.test === null && (i && this.throwError(a.Messages.MultipleDefaultsInSwitch), i = !0), n.push(s) } return this.expect('}'), this.context.inSwitch = r, this.finalize(e, new o.SwitchStatement(t, n)) }, Parser.prototype.parseLabelledStatement = function () { let e; const t = this.createNode(); const r = this.parseExpression(); if (r.type === u.Syntax.Identifier && this.match(':')) { this.nextToken(); const n = r; const i = `$${n.name}`; Object.prototype.hasOwnProperty.call(this.context.labelSet, i) && this.throwError(a.Messages.Redeclaration, 'Label', n.name), this.context.labelSet[i] = !0; let s = void 0; if (this.matchKeyword('class')) this.tolerateUnexpectedToken(this.lookahead), s = this.parseClassDeclaration(); else if (this.matchKeyword('function')) { const l = this.lookahead; const c = this.parseFunctionDeclaration(); this.context.strict ? this.tolerateUnexpectedToken(l, a.Messages.StrictFunction) : c.generator && this.tolerateUnexpectedToken(l, a.Messages.GeneratorInLegacyContext), s = c } else s = this.parseStatement(); delete this.context.labelSet[i], e = new o.LabeledStatement(n, s) } else this.consumeSemicolon(), e = new o.ExpressionStatement(r); return this.finalize(t, e) }, Parser.prototype.parseThrowStatement = function () { const e = this.createNode(); this.expectKeyword('throw'), this.hasLineTerminator && this.throwError(a.Messages.NewlineAfterThrow); const t = this.parseExpression(); return this.consumeSemicolon(), this.finalize(e, new o.ThrowStatement(t)) }, Parser.prototype.parseCatchClause = function () { const e = this.createNode(); this.expectKeyword('catch'), this.expect('('), this.match(')') && this.throwUnexpectedToken(this.lookahead); for (var t = [], r = this.parsePattern(t), n = {}, i = 0; i < t.length; i++) { const s = `$${t[i].value}`; Object.prototype.hasOwnProperty.call(n, s) && this.tolerateError(a.Messages.DuplicateBinding, t[i].value), n[s] = !0 } this.context.strict && r.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r.name) && this.tolerateError(a.Messages.StrictCatchVariable), this.expect(')'); const l = this.parseBlock(); return this.finalize(e, new o.CatchClause(r, l)) }, Parser.prototype.parseFinallyClause = function () { return this.expectKeyword('finally'), this.parseBlock() }, Parser.prototype.parseTryStatement = function () { const e = this.createNode(); this.expectKeyword('try'); const t = this.parseBlock(); const r = this.matchKeyword('catch') ? this.parseCatchClause() : null; const n = this.matchKeyword('finally') ? this.parseFinallyClause() : null; return r || n || this.throwError(a.Messages.NoCatchOrFinally), this.finalize(e, new o.TryStatement(t, r, n)) }, Parser.prototype.parseDebuggerStatement = function () { const e = this.createNode(); return this.expectKeyword('debugger'), this.consumeSemicolon(), this.finalize(e, new o.DebuggerStatement()) }, Parser.prototype.parseStatement = function () { let e; switch (this.lookahead.type) { case 1: case 5: case 6: case 8: case 10: case 9: e = this.parseExpressionStatement(); break; case 7: var t = this.lookahead.value; e = t === '{' ? this.parseBlock() : t === '(' ? this.parseExpressionStatement() : t === ';' ? this.parseEmptyStatement() : this.parseExpressionStatement(); break; case 3: e = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement(); break; case 4: switch (this.lookahead.value) { case 'break': e = this.parseBreakStatement(); break; case 'continue': e = this.parseContinueStatement(); break; case 'debugger': e = this.parseDebuggerStatement(); break; case 'do': e = this.parseDoWhileStatement(); break; case 'for': e = this.parseForStatement(); break; case 'function': e = this.parseFunctionDeclaration(); break; case 'if': e = this.parseIfStatement(); break; case 'return': e = this.parseReturnStatement(); break; case 'switch': e = this.parseSwitchStatement(); break; case 'throw': e = this.parseThrowStatement(); break; case 'try': e = this.parseTryStatement(); break; case 'var': e = this.parseVariableStatement(); break; case 'while': e = this.parseWhileStatement(); break; case 'with': e = this.parseWithStatement(); break; default: e = this.parseExpressionStatement(); } break; default: e = this.throwUnexpectedToken(this.lookahead); } return e }, Parser.prototype.parseFunctionSourceElements = function () { const e = this.createNode(); this.expect('{'); const t = this.parseDirectivePrologues(); const r = this.context.labelSet; const n = this.context.inIteration; const i = this.context.inSwitch; const a = this.context.inFunctionBody; for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.lookahead.type !== 2 && !this.match('}');)t.push(this.parseStatementListItem()); return this.expect('}'), this.context.labelSet = r, this.context.inIteration = n, this.context.inSwitch = i, this.context.inFunctionBody = a, this.finalize(e, new o.BlockStatement(t)) }, Parser.prototype.validateParam = function (e, t, r) {
        const n = `$${ r}`; this.context.strict ? (this.scanner.isRestrictedWord(r) && (e.stricted = t, e.message = a.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(e.paramSet, n) && (e.stricted = t, e.message = a.Messages.StrictParamDupe)) : e.firstRestricted || (this.scanner.isRestrictedWord(r) ? (e.firstRestricted = t, e.message = a.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(r) ? (e.firstRestricted = t, e.message = a.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(e.paramSet, n) && (e.stricted = t, e.message = a.Messages.StrictParamDupe)), typeof Object.defineProperty === 'function' ? Object.defineProperty(e.paramSet, n, {
          value: !0, enumerable: !0, writable: !0, configurable: !0,
        }) : e.paramSet[n] = !0;
      }, Parser.prototype.parseRestElement = function (e) { const t = this.createNode(); this.expect('...'); const r = this.parsePattern(e); return this.match('=') && this.throwError(a.Messages.DefaultRestParameter), this.match(')') || this.throwError(a.Messages.ParameterAfterRestParameter), this.finalize(t, new o.RestElement(r)) }, Parser.prototype.parseFormalParameter = function (e) { for (var t = [], r = this.match('...') ? this.parseRestElement(t) : this.parsePatternWithDefault(t), n = 0; n < t.length; n++) this.validateParam(e, t[n], t[n].value); e.simple = e.simple && r instanceof o.Identifier, e.params.push(r) }, Parser.prototype.parseFormalParameters = function (e) {
        let t; if (t = { simple: !0, params: [], firstRestricted: e }, this.expect('('), !this.match(')')) for (t.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(t), !this.match(')')) && (this.expect(','), !this.match(')')););return this.expect(')'), {
          simple: t.simple, params: t.params, stricted: t.stricted, firstRestricted: t.firstRestricted, message: t.message,
        };
      }, Parser.prototype.matchAsyncFunction = function () { let e = this.matchContextualKeyword('async'); if (e) { const t = this.scanner.saveState(); this.scanner.scanComments(); const r = this.scanner.lex(); this.scanner.restoreState(t), e = t.lineNumber === r.lineNumber && r.type === 4 && r.value === 'function' } return e }, Parser.prototype.parseFunctionDeclaration = function (e) { const t = this.createNode(); const r = this.matchContextualKeyword('async'); r && this.nextToken(), this.expectKeyword('function'); let n; const i = !r && this.match('*'); i && this.nextToken(); let s = null; let u = null; if (!e || !this.match('(')) { const l = this.lookahead; s = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(l.value) && this.tolerateUnexpectedToken(l, a.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(l.value) ? (u = l, n = a.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(l.value) && (u = l, n = a.Messages.StrictReservedWord) } const c = this.context.await; const p = this.context.allowYield; this.context.await = r, this.context.allowYield = !i; const f = this.parseFormalParameters(u); const d = f.params; const h = f.stricted; u = f.firstRestricted, f.message && (n = f.message); const m = this.context.strict; const g = this.context.allowStrictDirective; this.context.allowStrictDirective = f.simple; const v = this.parseFunctionSourceElements(); return this.context.strict && u && this.throwUnexpectedToken(u, n), this.context.strict && h && this.tolerateUnexpectedToken(h, n), this.context.strict = m, this.context.allowStrictDirective = g, this.context.await = c, this.context.allowYield = p, r ? this.finalize(t, new o.AsyncFunctionDeclaration(s, d, v)) : this.finalize(t, new o.FunctionDeclaration(s, d, v, i)) }, Parser.prototype.parseFunctionExpression = function () { const e = this.createNode(); const t = this.matchContextualKeyword('async'); t && this.nextToken(), this.expectKeyword('function'); let r; const n = !t && this.match('*'); n && this.nextToken(); let i; let s = null; const u = this.context.await; const l = this.context.allowYield; if (this.context.await = t, this.context.allowYield = !n, !this.match('(')) { const c = this.lookahead; s = this.context.strict || n || !this.matchKeyword('yield') ? this.parseVariableIdentifier() : this.parseIdentifierName(), this.context.strict ? this.scanner.isRestrictedWord(c.value) && this.tolerateUnexpectedToken(c, a.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(c.value) ? (i = c, r = a.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(c.value) && (i = c, r = a.Messages.StrictReservedWord) } const p = this.parseFormalParameters(i); const f = p.params; const d = p.stricted; i = p.firstRestricted, p.message && (r = p.message); const h = this.context.strict; const m = this.context.allowStrictDirective; this.context.allowStrictDirective = p.simple; const g = this.parseFunctionSourceElements(); return this.context.strict && i && this.throwUnexpectedToken(i, r), this.context.strict && d && this.tolerateUnexpectedToken(d, r), this.context.strict = h, this.context.allowStrictDirective = m, this.context.await = u, this.context.allowYield = l, t ? this.finalize(e, new o.AsyncFunctionExpression(s, f, g)) : this.finalize(e, new o.FunctionExpression(s, f, g, n)) }, Parser.prototype.parseDirective = function () { const e = this.lookahead; const t = this.createNode(); const r = this.parseExpression(); const n = r.type === u.Syntax.Literal ? this.getTokenRaw(e).slice(1, -1) : null; return this.consumeSemicolon(), this.finalize(t, n ? new o.Directive(r, n) : new o.ExpressionStatement(r)) }, Parser.prototype.parseDirectivePrologues = function () { for (var e = null, t = []; ;) { const r = this.lookahead; if (r.type !== 8) break; const n = this.parseDirective(); t.push(n); const i = n.directive; if (typeof i !== 'string') break; i === 'use strict' ? (this.context.strict = !0, e && this.tolerateUnexpectedToken(e, a.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(r, a.Messages.IllegalLanguageModeDirective)) : !e && r.octal && (e = r) } return t }, Parser.prototype.qualifiedPropertyName = function (e) { switch (e.type) { case 3: case 8: case 1: case 5: case 6: case 4: return !0; case 7: return e.value === '['; } return !1 }, Parser.prototype.parseGetterMethod = function () { const e = this.createNode(); const t = this.context.allowYield; this.context.allowYield = !1; const r = this.parseFormalParameters(); r.params.length > 0 && this.tolerateError(a.Messages.BadGetterArity); const n = this.parsePropertyMethod(r); return this.context.allowYield = t, this.finalize(e, new o.FunctionExpression(null, r.params, n, !1)) }, Parser.prototype.parseSetterMethod = function () { const e = this.createNode(); const t = this.context.allowYield; this.context.allowYield = !1; const r = this.parseFormalParameters(); r.params.length !== 1 ? this.tolerateError(a.Messages.BadSetterArity) : r.params[0] instanceof o.RestElement && this.tolerateError(a.Messages.BadSetterRestParameter); const n = this.parsePropertyMethod(r); return this.context.allowYield = t, this.finalize(e, new o.FunctionExpression(null, r.params, n, !1)) }, Parser.prototype.parseGeneratorMethod = function () { const e = this.createNode(); const t = this.context.allowYield; this.context.allowYield = !0; const r = this.parseFormalParameters(); this.context.allowYield = !1; const n = this.parsePropertyMethod(r); return this.context.allowYield = t, this.finalize(e, new o.FunctionExpression(null, r.params, n, !0)) }, Parser.prototype.isStartOfExpression = function () { let e = !0; const t = this.lookahead.value; switch (this.lookahead.type) { case 7: e = t === '[' || t === '(' || t === '{' || t === '+' || t === '-' || t === '!' || t === '~' || t === '++' || t === '--' || t === '/' || t === '/='; break; case 4: e = t === 'class' || t === 'delete' || t === 'function' || t === 'let' || t === 'new' || t === 'super' || t === 'this' || t === 'typeof' || t === 'void' || t === 'yield'; } return e }, Parser.prototype.parseYieldExpression = function () { const e = this.createNode(); this.expectKeyword('yield'); let t = null; let r = !1; if (!this.hasLineTerminator) { const n = this.context.allowYield; this.context.allowYield = !1, (r = this.match('*')) ? (this.nextToken(), t = this.parseAssignmentExpression()) : this.isStartOfExpression() && (t = this.parseAssignmentExpression()), this.context.allowYield = n } return this.finalize(e, new o.YieldExpression(t, r)) }, Parser.prototype.parseClassElement = function (e) { let t = this.lookahead; const r = this.createNode(); let n = ''; let i = null; let s = null; let u = !1; let l = !1; let c = !1; let p = !1; if (this.match('*')) this.nextToken(); else if (u = this.match('['), (i = this.parseObjectPropertyKey()).name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*')) && (t = this.lookahead, c = !0, u = this.match('['), this.match('*') ? this.nextToken() : i = this.parseObjectPropertyKey()), t.type === 3 && !this.hasLineTerminator && t.value === 'async') { const f = this.lookahead.value; f !== ':' && f !== '(' && f !== '*' && (p = !0, t = this.lookahead, i = this.parseObjectPropertyKey(), t.type === 3 && (t.value === 'get' || t.value === 'set' ? this.tolerateUnexpectedToken(t) : t.value === 'constructor' && this.tolerateUnexpectedToken(t, a.Messages.ConstructorIsAsync))) } const d = this.qualifiedPropertyName(this.lookahead); return t.type === 3 ? t.value === 'get' && d ? (n = 'get', u = this.match('['), i = this.parseObjectPropertyKey(), this.context.allowYield = !1, s = this.parseGetterMethod()) : t.value === 'set' && d && (n = 'set', u = this.match('['), i = this.parseObjectPropertyKey(), s = this.parseSetterMethod()) : t.type === 7 && t.value === '*' && d && (n = 'init', u = this.match('['), i = this.parseObjectPropertyKey(), s = this.parseGeneratorMethod(), l = !0), !n && i && this.match('(') && (n = 'init', s = p ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l = !0), n || this.throwUnexpectedToken(this.lookahead), n === 'init' && (n = 'method'), u || (c && this.isPropertyKey(i, 'prototype') && this.throwUnexpectedToken(t, a.Messages.StaticPrototype), !c && this.isPropertyKey(i, 'constructor') && ((n !== 'method' || !l || s && s.generator) && this.throwUnexpectedToken(t, a.Messages.ConstructorSpecialMethod), e.value ? this.throwUnexpectedToken(t, a.Messages.DuplicateConstructor) : e.value = !0, n = 'constructor')), this.finalize(r, new o.MethodDefinition(i, u, s, n, c)) }, Parser.prototype.parseClassElementList = function () { const e = []; const t = { value: !1 }; for (this.expect('{'); !this.match('}');) this.match(';') ? this.nextToken() : e.push(this.parseClassElement(t)); return this.expect('}'), e }, Parser.prototype.parseClassBody = function () { const e = this.createNode(); const t = this.parseClassElementList(); return this.finalize(e, new o.ClassBody(t)) }, Parser.prototype.parseClassDeclaration = function (e) { const t = this.createNode(); const r = this.context.strict; this.context.strict = !0, this.expectKeyword('class'); const n = e && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(); let i = null; this.matchKeyword('extends') && (this.nextToken(), i = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall)); const a = this.parseClassBody(); return this.context.strict = r, this.finalize(t, new o.ClassDeclaration(n, i, a)) }, Parser.prototype.parseClassExpression = function () { const e = this.createNode(); const t = this.context.strict; this.context.strict = !0, this.expectKeyword('class'); const r = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null; let n = null; this.matchKeyword('extends') && (this.nextToken(), n = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall)); const i = this.parseClassBody(); return this.context.strict = t, this.finalize(e, new o.ClassExpression(r, n, i)) }, Parser.prototype.parseModule = function () { this.context.strict = !0, this.context.isModule = !0; for (var e = this.createNode(), t = this.parseDirectivePrologues(); this.lookahead.type !== 2;)t.push(this.parseStatementListItem()); return this.finalize(e, new o.Module(t)) }, Parser.prototype.parseScript = function () { for (var e = this.createNode(), t = this.parseDirectivePrologues(); this.lookahead.type !== 2;)t.push(this.parseStatementListItem()); return this.finalize(e, new o.Script(t)) }, Parser.prototype.parseModuleSpecifier = function () { const e = this.createNode(); this.lookahead.type !== 8 && this.throwError(a.Messages.InvalidModuleSpecifier); const t = this.nextToken(); const r = this.getTokenRaw(t); return this.finalize(e, new o.Literal(t.value, r)) }, Parser.prototype.parseImportSpecifier = function () { let e; let t; const r = this.createNode(); return this.lookahead.type === 3 ? (t = e = this.parseVariableIdentifier(), this.matchContextualKeyword('as') && (this.nextToken(), t = this.parseVariableIdentifier())) : (t = e = this.parseIdentifierName(), this.matchContextualKeyword('as') ? (this.nextToken(), t = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(r, new o.ImportSpecifier(t, e)) }, Parser.prototype.parseNamedImports = function () { this.expect('{'); for (var e = []; !this.match('}');)e.push(this.parseImportSpecifier()), this.match('}') || this.expect(','); return this.expect('}'), e }, Parser.prototype.parseImportDefaultSpecifier = function () { const e = this.createNode(); const t = this.parseIdentifierName(); return this.finalize(e, new o.ImportDefaultSpecifier(t)) }, Parser.prototype.parseImportNamespaceSpecifier = function () { const e = this.createNode(); this.expect('*'), this.matchContextualKeyword('as') || this.throwError(a.Messages.NoAsAfterImportNamespace), this.nextToken(); const t = this.parseIdentifierName(); return this.finalize(e, new o.ImportNamespaceSpecifier(t)) }, Parser.prototype.parseImportDeclaration = function () { this.context.inFunctionBody && this.throwError(a.Messages.IllegalImportDeclaration); let e; const t = this.createNode(); this.expectKeyword('import'); let r = []; if (this.lookahead.type === 8)e = this.parseModuleSpecifier(); else { if (this.match('{') ? r = r.concat(this.parseNamedImports()) : this.match('*') ? r.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword('default') ? (r.push(this.parseImportDefaultSpecifier()), this.match(',') && (this.nextToken(), this.match('*') ? r.push(this.parseImportNamespaceSpecifier()) : this.match('{') ? r = r.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword('from')) { const n = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause; this.throwError(n, this.lookahead.value) } this.nextToken(), e = this.parseModuleSpecifier() } return this.consumeSemicolon(), this.finalize(t, new o.ImportDeclaration(r, e)) }, Parser.prototype.parseExportSpecifier = function () { const e = this.createNode(); const t = this.parseIdentifierName(); let r = t; return this.matchContextualKeyword('as') && (this.nextToken(), r = this.parseIdentifierName()), this.finalize(e, new o.ExportSpecifier(t, r)) }, Parser.prototype.parseExportDeclaration = function () { this.context.inFunctionBody && this.throwError(a.Messages.IllegalExportDeclaration); let e; const t = this.createNode(); if (this.expectKeyword('export'), this.matchKeyword('default')) if (this.nextToken(), this.matchKeyword('function')) { var r = this.parseFunctionDeclaration(!0); e = this.finalize(t, new o.ExportDefaultDeclaration(r)) } else if (this.matchKeyword('class')) { r = this.parseClassDeclaration(!0); e = this.finalize(t, new o.ExportDefaultDeclaration(r)) } else if (this.matchContextualKeyword('async')) { r = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression(); e = this.finalize(t, new o.ExportDefaultDeclaration(r)) } else { this.matchContextualKeyword('from') && this.throwError(a.Messages.UnexpectedToken, this.lookahead.value); r = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression(); this.consumeSemicolon(), e = this.finalize(t, new o.ExportDefaultDeclaration(r)) } else if (this.match('*')) { if (this.nextToken(), !this.matchContextualKeyword('from')) { var n = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause; this.throwError(n, this.lookahead.value) } this.nextToken(); const i = this.parseModuleSpecifier(); this.consumeSemicolon(), e = this.finalize(t, new o.ExportAllDeclaration(i)) } else if (this.lookahead.type === 4) { r = void 0; switch (this.lookahead.value) { case 'let': case 'const': r = this.parseLexicalDeclaration({ inFor: !1 }); break; case 'var': case 'class': case 'function': r = this.parseStatementListItem(); break; default: this.throwUnexpectedToken(this.lookahead); }e = this.finalize(t, new o.ExportNamedDeclaration(r, [], null)) } else if (this.matchAsyncFunction()) { r = this.parseFunctionDeclaration(); e = this.finalize(t, new o.ExportNamedDeclaration(r, [], null)) } else { const s = []; let u = null; let l = !1; for (this.expect('{'); !this.match('}');)l = l || this.matchKeyword('default'), s.push(this.parseExportSpecifier()), this.match('}') || this.expect(','); if (this.expect('}'), this.matchContextualKeyword('from')) this.nextToken(), u = this.parseModuleSpecifier(), this.consumeSemicolon(); else if (l) { n = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause; this.throwError(n, this.lookahead.value) } else this.consumeSemicolon(); e = this.finalize(t, new o.ExportNamedDeclaration(null, s, u)) } return e }, Parser;
    }()); t.Parser = c;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.assert = function assert(e, t) { if (!e) throw new Error(`ASSERT: ${t}`); };
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const r = (function () { function ErrorHandler() { this.errors = [], this.tolerant = !1 } return ErrorHandler.prototype.recordError = function (e) { this.errors.push(e) }, ErrorHandler.prototype.tolerate = function (e) { if (!this.tolerant) throw e; this.recordError(e) }, ErrorHandler.prototype.constructError = function (e, t) { let r = new Error(e); try { throw r } catch (e) { Object.create && Object.defineProperty && (r = Object.create(e), Object.defineProperty(r, 'column', { value: t })) } return r }, ErrorHandler.prototype.createError = function (e, t, r, n) { const i = `Line ${t }: ${n}`; const a = this.constructError(i, r); return a.index = e, a.lineNumber = t, a.description = n, a }, ErrorHandler.prototype.throwError = function (e, t, r, n) { throw this.createError(e, t, r, n) }, ErrorHandler.prototype.tolerateError = function (e, t, r, n) { const i = this.createError(e, t, r, n); if (!this.tolerant) throw i; this.recordError(i) }, ErrorHandler }()); t.ErrorHandler = r;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.Messages = {
      BadGetterArity: 'Getter must not have any formal parameters', BadSetterArity: 'Setter must have exactly one formal parameter', BadSetterRestParameter: 'Setter function argument must not be a rest parameter', ConstructorIsAsync: 'Class constructor may not be an async method', ConstructorSpecialMethod: 'Class constructor may not be an accessor', DeclarationMissingInitializer: 'Missing initializer in %0 declaration', DefaultRestParameter: 'Unexpected token =', DuplicateBinding: 'Duplicate binding %0', DuplicateConstructor: 'A class may only have one constructor', DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals', ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer', GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts', IllegalBreak: 'Illegal break statement', IllegalContinue: 'Illegal continue statement', IllegalExportDeclaration: 'Unexpected token', IllegalImportDeclaration: 'Unexpected token', IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: 'Illegal return statement', InvalidEscapedReservedWord: 'Keyword must not contain escaped characters', InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence', InvalidLHSInAssignment: 'Invalid left-hand side in assignment', InvalidLHSInForIn: 'Invalid left-hand side in for-in', InvalidLHSInForLoop: 'Invalid left-hand side in for-loop', InvalidModuleSpecifier: 'Unexpected token', InvalidRegExp: 'Invalid regular expression', LetInLexicalBinding: 'let is disallowed as a lexically bound name', MissingFromClause: 'Unexpected token', MultipleDefaultsInSwitch: 'More than one default clause in switch statement', NewlineAfterThrow: 'Illegal newline after throw', NoAsAfterImportNamespace: 'Unexpected token', NoCatchOrFinally: 'Missing catch or finally after try', ParameterAfterRestParameter: 'Rest parameter must be last formal parameter', Redeclaration: "%0 '%1' has already been declared", StaticPrototype: 'Classes may not have static property named prototype', StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode', StrictDelete: 'Delete of an unqualified identifier in strict mode.', StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block', StrictFunctionName: 'Function name may not be eval or arguments in strict mode', StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode', StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode', StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode', StrictModeWith: 'Strict mode code may not include a with statement', StrictOctalLiteral: 'Octal literals are not allowed in strict mode.', StrictParamDupe: 'Strict mode function may not have duplicate parameter names', StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode', StrictReservedWord: 'Use of future reserved word in strict mode', StrictVarName: 'Variable name may not be eval or arguments in strict mode', TemplateOctalLiteral: 'Octal literals are not allowed in template strings.', UnexpectedEOS: 'Unexpected end of input', UnexpectedIdentifier: 'Unexpected identifier', UnexpectedNumber: 'Unexpected number', UnexpectedReserved: 'Unexpected reserved word', UnexpectedString: 'Unexpected string', UnexpectedTemplate: 'Unexpected quasi %0', UnexpectedToken: 'Unexpected token %0', UnexpectedTokenIllegal: 'Unexpected token ILLEGAL', UnknownLabel: "Undefined label '%0'", UnterminatedRegExp: 'Invalid regular expression: missing /',
    };
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(9); const i = r(4); const a = r(11); function hexValue(e) { return '0123456789abcdef'.indexOf(e.toLowerCase()) } function octalValue(e) { return '01234567'.indexOf(e) } const o = (function () {
      function Scanner(e, t) { this.source = e, this.errorHandler = t, this.trackComment = !1, this.length = e.length, this.index = 0, this.lineNumber = e.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [] } return Scanner.prototype.saveState = function () { return { index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart } }, Scanner.prototype.restoreState = function (e) { this.index = e.index, this.lineNumber = e.lineNumber, this.lineStart = e.lineStart }, Scanner.prototype.eof = function () { return this.index >= this.length }, Scanner.prototype.throwUnexpectedToken = function (e) { return void 0 === e && (e = a.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, e) }, Scanner.prototype.tolerateUnexpectedToken = function (e) { void 0 === e && (e = a.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e) }, Scanner.prototype.skipSingleLineComment = function (e) {
        let t; let r; let n = []; for (this.trackComment && (n = [], t = this.index - e, r = { start: { line: this.lineNumber, column: this.index - this.lineStart - e }, end: {} }); !this.eof();) {
          const a = this.source.charCodeAt(this.index); if (++this.index, i.Character.isLineTerminator(a)) {
            if (this.trackComment) {
              r.end = { line: this.lineNumber, column: this.index - this.lineStart - 1 }; var o = {
                multiLine: !1, slice: [t + e, this.index - 1], range: [t, this.index - 1], loc: r,
              }; n.push(o);
            } return a === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, n;
          }
        } if (this.trackComment) {
          r.end = { line: this.lineNumber, column: this.index - this.lineStart }; o = {
            multiLine: !1, slice: [t + e, this.index], range: [t, this.index], loc: r,
          }; n.push(o);
        } return n;
      }, Scanner.prototype.skipMultiLineComment = function () {
        let e; let t; let r = []; for (this.trackComment && (r = [], e = this.index - 2, t = { start: { line: this.lineNumber, column: this.index - this.lineStart - 2 }, end: {} }); !this.eof();) {
          const n = this.source.charCodeAt(this.index); if (i.Character.isLineTerminator(n))n === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index; else if (n === 42) {
            if (this.source.charCodeAt(this.index + 1) === 47) {
              if (this.index += 2, this.trackComment) {
                t.end = { line: this.lineNumber, column: this.index - this.lineStart }; var a = {
                  multiLine: !0, slice: [e + 2, this.index - 2], range: [e, this.index], loc: t,
                }; r.push(a);
              } return r;
            }++this.index;
          } else ++this.index;
        } if (this.trackComment) {
          t.end = { line: this.lineNumber, column: this.index - this.lineStart }; a = {
            multiLine: !0, slice: [e + 2, this.index], range: [e, this.index], loc: t,
          }; r.push(a);
        } return this.tolerateUnexpectedToken(), r;
      }, Scanner.prototype.scanComments = function () { let e; this.trackComment && (e = []); for (let t = this.index === 0; !this.eof();) { let r = this.source.charCodeAt(this.index); if (i.Character.isWhiteSpace(r))++this.index; else if (i.Character.isLineTerminator(r))++this.index, r === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, t = !0; else if (r === 47) if ((r = this.source.charCodeAt(this.index + 1)) === 47) { this.index += 2; var n = this.skipSingleLineComment(2); this.trackComment && (e = e.concat(n)), t = !0 } else { if (r !== 42) break; this.index += 2; n = this.skipMultiLineComment(); this.trackComment && (e = e.concat(n)) } else if (t && r === 45) { if (this.source.charCodeAt(this.index + 1) !== 45 || this.source.charCodeAt(this.index + 2) !== 62) break; this.index += 3; n = this.skipSingleLineComment(3); this.trackComment && (e = e.concat(n)) } else { if (r !== 60) break; if (this.source.slice(this.index + 1, this.index + 4) !== '!--') break; this.index += 4; n = this.skipSingleLineComment(4); this.trackComment && (e = e.concat(n)) } } return e }, Scanner.prototype.isFutureReservedWord = function (e) { switch (e) { case 'enum': case 'export': case 'import': case 'super': return !0; default: return !1; } }, Scanner.prototype.isStrictModeReservedWord = function (e) { switch (e) { case 'implements': case 'interface': case 'package': case 'private': case 'protected': case 'public': case 'static': case 'yield': case 'let': return !0; default: return !1; } }, Scanner.prototype.isRestrictedWord = function (e) { return e === 'eval' || e === 'arguments' }, Scanner.prototype.isKeyword = function (e) { switch (e.length) { case 2: return e === 'if' || e === 'in' || e === 'do'; case 3: return e === 'var' || e === 'for' || e === 'new' || e === 'try' || e === 'let'; case 4: return e === 'this' || e === 'else' || e === 'case' || e === 'void' || e === 'with' || e === 'enum'; case 5: return e === 'while' || e === 'break' || e === 'catch' || e === 'throw' || e === 'const' || e === 'yield' || e === 'class' || e === 'super'; case 6: return e === 'return' || e === 'typeof' || e === 'delete' || e === 'switch' || e === 'export' || e === 'import'; case 7: return e === 'default' || e === 'finally' || e === 'extends'; case 8: return e === 'function' || e === 'continue' || e === 'debugger'; case 10: return e === 'instanceof'; default: return !1; } }, Scanner.prototype.codePointAt = function (e) { let t = this.source.charCodeAt(e); if (t >= 55296 && t <= 56319) { const r = this.source.charCodeAt(e + 1); if (r >= 56320 && r <= 57343)t = 1024 * (t - 55296) + r - 56320 + 65536; } return t }, Scanner.prototype.scanHexEscape = function (e) { for (var t = e === 'u' ? 4 : 2, r = 0, n = 0; n < t; ++n) { if (this.eof() || !i.Character.isHexDigit(this.source.charCodeAt(this.index))) return null; r = 16 * r + hexValue(this.source[this.index++]) } return String.fromCharCode(r) }, Scanner.prototype.scanUnicodeCodePointEscape = function () { let e = this.source[this.index]; let t = 0; for (e === '}' && this.throwUnexpectedToken(); !this.eof() && (e = this.source[this.index++], i.Character.isHexDigit(e.charCodeAt(0)));)t = 16 * t + hexValue(e); return (t > 1114111 || e !== '}') && this.throwUnexpectedToken(), i.Character.fromCodePoint(t) }, Scanner.prototype.getIdentifier = function () { for (var e = this.index++; !this.eof();) { const t = this.source.charCodeAt(this.index); if (t === 92) return this.index = e, this.getComplexIdentifier(); if (t >= 55296 && t < 57343) return this.index = e, this.getComplexIdentifier(); if (!i.Character.isIdentifierPart(t)) break; ++this.index } return this.source.slice(e, this.index) }, Scanner.prototype.getComplexIdentifier = function () { let e; let t = this.codePointAt(this.index); let r = i.Character.fromCodePoint(t); for (this.index += r.length, t === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === '{' ? (++this.index, e = this.scanUnicodeCodePointEscape()) : (e = this.scanHexEscape('u')) !== null && e !== '\\' && i.Character.isIdentifierStart(e.charCodeAt(0)) || this.throwUnexpectedToken(), r = e); !this.eof() && (t = this.codePointAt(this.index), i.Character.isIdentifierPart(t));)r += e = i.Character.fromCodePoint(t), this.index += e.length, t === 92 && (r = r.substr(0, r.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === '{' ? (++this.index, e = this.scanUnicodeCodePointEscape()) : (e = this.scanHexEscape('u')) !== null && e !== '\\' && i.Character.isIdentifierPart(e.charCodeAt(0)) || this.throwUnexpectedToken(), r += e); return r }, Scanner.prototype.octalToDecimal = function (e) { let t = e !== '0'; let r = octalValue(e); return !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (t = !0, r = 8 * r + octalValue(this.source[this.index++]), '0123'.indexOf(e) >= 0 && !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (r = 8 * r + octalValue(this.source[this.index++]))), { code: r, octal: t } }, Scanner.prototype.scanIdentifier = function () {
        let e; const t = this.index; const r = this.source.charCodeAt(t) === 92 ? this.getComplexIdentifier() : this.getIdentifier(); if ((e = r.length === 1 ? 3 : this.isKeyword(r) ? 4 : r === 'null' ? 5 : r === 'true' || r === 'false' ? 1 : 3) !== 3 && t + r.length !== this.index) { const n = this.index; this.index = t, this.tolerateUnexpectedToken(a.Messages.InvalidEscapedReservedWord), this.index = n } return {
          type: e, value: r, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t, end: this.index,
        };
      }, Scanner.prototype.scanPunctuator = function () {
        const e = this.index; let t = this.source[this.index]; switch (t) { case '(': case '{': t === '{' && this.curlyStack.push('{'), ++this.index; break; case '.': ++this.index, this.source[this.index] === '.' && this.source[this.index + 1] === '.' && (this.index += 2, t = '...'); break; case '}': ++this.index, this.curlyStack.pop(); break; case ')': case ';': case ',': case '[': case ']': case ':': case '?': case '~': ++this.index; break; default: (t = this.source.substr(this.index, 4)) === '>>>=' ? this.index += 4 : (t = t.substr(0, 3)) === '===' || t === '!==' || t === '>>>' || t === '<<=' || t === '>>=' || t === '**=' ? this.index += 3 : (t = t.substr(0, 2)) === '&&' || t === '||' || t === '==' || t === '!=' || t === '+=' || t === '-=' || t === '*=' || t === '/=' || t === '++' || t === '--' || t === '<<' || t === '>>' || t === '&=' || t === '|=' || t === '^=' || t === '%=' || t === '<=' || t === '>=' || t === '=>' || t === '**' ? this.index += 2 : (t = this.source[this.index], '<>=!+-*%&|^/'.indexOf(t) >= 0 && ++this.index); } return this.index === e && this.throwUnexpectedToken(), {
          type: 7, value: t, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.scanHexLiteral = function (e) {
        for (var t = ''; !this.eof() && i.Character.isHexDigit(this.source.charCodeAt(this.index));)t += this.source[this.index++]; return t.length === 0 && this.throwUnexpectedToken(), i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
          type: 6, value: parseInt(`0x${t}`, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.scanBinaryLiteral = function (e) {
        for (var t, r = ''; !this.eof() && ((t = this.source[this.index]) === '0' || t === '1');)r += this.source[this.index++]; return r.length === 0 && this.throwUnexpectedToken(), this.eof() || (t = this.source.charCodeAt(this.index), (i.Character.isIdentifierStart(t) || i.Character.isDecimalDigit(t)) && this.throwUnexpectedToken()), {
          type: 6, value: parseInt(r, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.scanOctalLiteral = function (e, t) {
        let r = ''; let n = !1; for (i.Character.isOctalDigit(e.charCodeAt(0)) ? (n = !0, r = `0${this.source[this.index++]}`) : ++this.index; !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index));)r += this.source[this.index++]; return n || r.length !== 0 || this.throwUnexpectedToken(), (i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || i.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
          type: 6, value: parseInt(r, 8), octal: n, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t, end: this.index,
        };
      }, Scanner.prototype.isImplicitOctalLiteral = function () { for (let e = this.index + 1; e < this.length; ++e) { const t = this.source[e]; if (t === '8' || t === '9') return !1; if (!i.Character.isOctalDigit(t.charCodeAt(0))) return !0; } return !0 }, Scanner.prototype.scanNumericLiteral = function () {
        const e = this.index; let t = this.source[e]; n.assert(i.Character.isDecimalDigit(t.charCodeAt(0)) || t === '.', 'Numeric literal must start with a decimal digit or a decimal point'); let r = ''; if (t !== '.') { if (r = this.source[this.index++], t = this.source[this.index], r === '0') { if (t === 'x' || t === 'X') return ++this.index, this.scanHexLiteral(e); if (t === 'b' || t === 'B') return ++this.index, this.scanBinaryLiteral(e); if (t === 'o' || t === 'O') return this.scanOctalLiteral(t, e); if (t && i.Character.isOctalDigit(t.charCodeAt(0)) && this.isImplicitOctalLiteral()) return this.scanOctalLiteral(t, e); } for (;i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r += this.source[this.index++]; t = this.source[this.index] } if (t === '.') { for (r += this.source[this.index++]; i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r += this.source[this.index++]; t = this.source[this.index] } if (t === 'e' || t === 'E') if (r += this.source[this.index++], (t = this.source[this.index]) !== '+' && t !== '-' || (r += this.source[this.index++]), i.Character.isDecimalDigit(this.source.charCodeAt(this.index))) for (;i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r += this.source[this.index++]; else this.throwUnexpectedToken(); return i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
          type: 6, value: parseFloat(r), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.scanStringLiteral = function () {
        const e = this.index; let t = this.source[e]; n.assert(t === "'" || t === '"', 'String literal must starts with a quote'), ++this.index; for (var r = !1, o = ''; !this.eof();) { let s = this.source[this.index++]; if (s === t) { t = ''; break } if (s === '\\') if ((s = this.source[this.index++]) && i.Character.isLineTerminator(s.charCodeAt(0)))++this.lineNumber, s === '\r' && this.source[this.index] === '\n' && ++this.index, this.lineStart = this.index; else switch (s) { case 'u': if (this.source[this.index] === '{')++this.index, o += this.scanUnicodeCodePointEscape(); else { const u = this.scanHexEscape(s); u === null && this.throwUnexpectedToken(), o += u } break; case 'x': var l = this.scanHexEscape(s); l === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), o += l; break; case 'n': o += '\n'; break; case 'r': o += '\r'; break; case 't': o += '\t'; break; case 'b': o += '\b'; break; case 'f': o += '\f'; break; case 'v': o += '\v'; break; case '8': case '9': o += s, this.tolerateUnexpectedToken(); break; default: if (s && i.Character.isOctalDigit(s.charCodeAt(0))) { const c = this.octalToDecimal(s); r = c.octal || r, o += String.fromCharCode(c.code) } else o += s; } else { if (i.Character.isLineTerminator(s.charCodeAt(0))) break; o += s } } return t !== '' && (this.index = e, this.throwUnexpectedToken()), {
          type: 8, value: o, octal: r, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.scanTemplate = function () {
        let e = ''; let t = !1; const r = this.index; const n = this.source[r] === '`'; let o = !1; let s = 2; for (++this.index; !this.eof();) { let u = this.source[this.index++]; if (u === '`') { s = 1, o = !0, t = !0; break } if (u === '$') { if (this.source[this.index] === '{') { this.curlyStack.push('${'), ++this.index, t = !0; break }e += u } else if (u === '\\') if (u = this.source[this.index++], i.Character.isLineTerminator(u.charCodeAt(0)))++this.lineNumber, u === '\r' && this.source[this.index] === '\n' && ++this.index, this.lineStart = this.index; else switch (u) { case 'n': e += '\n'; break; case 'r': e += '\r'; break; case 't': e += '\t'; break; case 'u': if (this.source[this.index] === '{')++this.index, e += this.scanUnicodeCodePointEscape(); else { const l = this.index; const c = this.scanHexEscape(u); c !== null ? e += c : (this.index = l, e += u) } break; case 'x': var p = this.scanHexEscape(u); p === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), e += p; break; case 'b': e += '\b'; break; case 'f': e += '\f'; break; case 'v': e += '\v'; break; default: u === '0' ? (i.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral), e += '\0') : i.Character.isOctalDigit(u.charCodeAt(0)) ? this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral) : e += u; } else i.Character.isLineTerminator(u.charCodeAt(0)) ? (++this.lineNumber, u === '\r' && this.source[this.index] === '\n' && ++this.index, this.lineStart = this.index, e += '\n') : e += u; } return t || this.throwUnexpectedToken(), n || this.curlyStack.pop(), {
          type: 10, value: this.source.slice(r + 1, this.index - s), cooked: e, head: n, tail: o, lineNumber: this.lineNumber, lineStart: this.lineStart, start: r, end: this.index,
        };
      }, Scanner.prototype.testRegExp = function (e, t) { let r = e; const n = this; t.indexOf('u') >= 0 && (r = r.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, (e, t, r) => { const i = parseInt(t || r, 16); return i > 1114111 && n.throwUnexpectedToken(a.Messages.InvalidRegExp), i <= 65535 ? String.fromCharCode(i) : '' }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '')); try { RegExp(r) } catch (e) { this.throwUnexpectedToken(a.Messages.InvalidRegExp) } try { return new RegExp(e, t) } catch (e) { return null } }, Scanner.prototype.scanRegExpBody = function () { let e = this.source[this.index]; n.assert(e === '/', 'Regular expression literal must start with a slash'); for (var t = this.source[this.index++], r = !1, o = !1; !this.eof();) if (t += e = this.source[this.index++], e === '\\')e = this.source[this.index++], i.Character.isLineTerminator(e.charCodeAt(0)) && this.throwUnexpectedToken(a.Messages.UnterminatedRegExp), t += e; else if (i.Character.isLineTerminator(e.charCodeAt(0))) this.throwUnexpectedToken(a.Messages.UnterminatedRegExp); else if (r)e === ']' && (r = !1); else { if (e === '/') { o = !0; break }e === '[' && (r = !0) } return o || this.throwUnexpectedToken(a.Messages.UnterminatedRegExp), t.substr(1, t.length - 2) }, Scanner.prototype.scanRegExpFlags = function () { for (var e = ''; !this.eof();) { let t = this.source[this.index]; if (!i.Character.isIdentifierPart(t.charCodeAt(0))) break; if (++this.index, t !== '\\' || this.eof())e += t, t; else if ((t = this.source[this.index]) === 'u') { ++this.index; let r = this.index; const n = this.scanHexEscape('u'); if (n !== null) for (e += n, '\\u'; r < this.index; ++r) this.source[r]; else this.index = r, e += 'u', '\\u'; this.tolerateUnexpectedToken() } else '\\', this.tolerateUnexpectedToken(); } return e }, Scanner.prototype.scanRegExp = function () {
        const e = this.index; const t = this.scanRegExpBody(); const r = this.scanRegExpFlags(); return {
          type: 9, value: '', pattern: t, flags: r, regex: this.testRegExp(t, r), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e, end: this.index,
        };
      }, Scanner.prototype.lex = function () {
        if (this.eof()) { return {
          type: 2, value: '', lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index, 
        };
} const e = this.source.charCodeAt(this.index); return i.Character.isIdentifierStart(e) ? this.scanIdentifier() : e === 40 || e === 41 || e === 59 ? this.scanPunctuator() : e === 39 || e === 34 ? this.scanStringLiteral() : e === 46 ? i.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : i.Character.isDecimalDigit(e) ? this.scanNumericLiteral() : e === 96 || e === 125 && this.curlyStack[this.curlyStack.length - 1] === '${' ? this.scanTemplate() : e >= 55296 && e < 57343 && i.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
      }, Scanner;
    }()); t.Scanner = o;
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.TokenName = {}, t.TokenName[1] = 'Boolean', t.TokenName[2] = '<end>', t.TokenName[3] = 'Identifier', t.TokenName[4] = 'Keyword', t.TokenName[5] = 'Null', t.TokenName[6] = 'Numeric', t.TokenName[7] = 'Punctuator', t.TokenName[8] = 'String', t.TokenName[9] = 'RegularExpression', t.TokenName[10] = 'Template';
  }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.XHTMLEntities = {
      quot: '"', amp: '&', apos: "'", gt: '>', nbsp: '', iexcl: '', cent: '', pound: '', curren: '', yen: '', brvbar: '', sect: '', uml: '', copy: '', ordf: '', laquo: '', not: '', shy: '', reg: '', macr: '', deg: '', plusmn: '', sup2: '', sup3: '', acute: '', micro: '', para: '', middot: '', cedil: '', sup1: '', ordm: '', raquo: '', frac14: '', frac12: '', frac34: '', iquest: '', Agrave: '', Aacute: '', Acirc: '', Atilde: '', Auml: '', Aring: '', AElig: '', Ccedil: '', Egrave: '', Eacute: '', Ecirc: '', Euml: '', Igrave: '', Iacute: '', Icirc: '', Iuml: '', ETH: '', Ntilde: '', Ograve: '', Oacute: '', Ocirc: '', Otilde: '', Ouml: '', times: '', Oslash: '', Ugrave: '', Uacute: '', Ucirc: '', Uuml: '', Yacute: '', THORN: '', szlig: '', agrave: '', aacute: '', acirc: '', atilde: '', auml: '', aring: '', aelig: '', ccedil: '', egrave: '', eacute: '', ecirc: '', euml: '', igrave: '', iacute: '', icirc: '', iuml: '', eth: '', ntilde: '', ograve: '', oacute: '', ocirc: '', otilde: '', ouml: '', divide: '', oslash: '', ugrave: '', uacute: '', ucirc: '', uuml: '', yacute: '', thorn: '', yuml: '', OElig: '', oelig: '', Scaron: '', scaron: '', Yuml: '', fnof: '', circ: '', tilde: '', Alpha: '', Beta: '', Gamma: '', Delta: '', Epsilon: '', Zeta: '', Eta: '', Theta: '', Iota: '', Kappa: '', Lambda: '', Mu: '', Nu: '', Xi: '', Omicron: '', Pi: '', Rho: '', Sigma: '', Tau: '', Upsilon: '', Phi: '', Chi: '', Psi: '', Omega: '', alpha: '', beta: '', gamma: '', delta: '', epsilon: '', zeta: '', eta: '', theta: '', iota: '', kappa: '', lambda: '', mu: '', nu: '', xi: '', omicron: '', pi: '', rho: '', sigmaf: '', sigma: '', tau: '', upsilon: '', phi: '', chi: '', psi: '', omega: '', thetasym: '', upsih: '', piv: '', ensp: '', emsp: '', thinsp: '', zwnj: '', zwj: '', lrm: '', rlm: '', ndash: '', mdash: '', lsquo: '', rsquo: '', sbquo: '', ldquo: '', rdquo: '', bdquo: '', dagger: '', Dagger: '', bull: '', hellip: '', permil: '', prime: '', Prime: '', lsaquo: '', rsaquo: '', oline: '', frasl: '', euro: '', image: '', weierp: '', real: '', trade: '', alefsym: '', larr: '', uarr: '', rarr: '', darr: '', harr: '', crarr: '', lArr: '', uArr: '', rArr: '', dArr: '', hArr: '', forall: '', part: '', exist: '', empty: '', nabla: '', isin: '', notin: '', ni: '', prod: '', sum: '', minus: '', lowast: '', radic: '', prop: '', infin: '', ang: '', and: '', or: '', cap: '', cup: '', int: '', there4: '', sim: '', cong: '', asymp: '', ne: '', equiv: '', le: '', ge: '', sub: '', sup: '', nsub: '', sube: '', supe: '', oplus: '', otimes: '', perp: '', sdot: '', lceil: '', rceil: '', lfloor: '', rfloor: '', loz: '', spades: '', clubs: '', hearts: '', diams: '', lang: '', rang: '',
    };
  }, function (e, t, r) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(10); const i = r(12); const a = r(13); const o = (function () { function Reader() { this.values = [], this.curly = this.paren = -1 } return Reader.prototype.beforeFunctionExpression = function (e) { return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(e) >= 0 }, Reader.prototype.isRegexStart = function () { const e = this.values[this.values.length - 1]; let t = e !== null; switch (e) { case 'this': case ']': t = !1; break; case ')': var r = this.values[this.paren - 1]; t = r === 'if' || r === 'while' || r === 'for' || r === 'with'; break; case '}': if (t = !1, this.values[this.curly - 3] === 'function')t = !!(n = this.values[this.curly - 4]) && !this.beforeFunctionExpression(n); else if (this.values[this.curly - 4] === 'function') { var n; t = !(n = this.values[this.curly - 5]) || !this.beforeFunctionExpression(n) } } return t }, Reader.prototype.push = function (e) { e.type === 7 || e.type === 4 ? (e.value === '{' ? this.curly = this.values.length : e.value === '(' && (this.paren = this.values.length), this.values.push(e.value)) : this.values.push(null) }, Reader }()); const s = (function () { function Tokenizer(e, t) { this.errorHandler = new n.ErrorHandler(), this.errorHandler.tolerant = !!t && (typeof t.tolerant === 'boolean' && t.tolerant), this.scanner = new i.Scanner(e, this.errorHandler), this.scanner.trackComment = !!t && (typeof t.comment === 'boolean' && t.comment), this.trackRange = !!t && (typeof t.range === 'boolean' && t.range), this.trackLoc = !!t && (typeof t.loc === 'boolean' && t.loc), this.buffer = [], this.reader = new o() } return Tokenizer.prototype.errors = function () { return this.errorHandler.errors }, Tokenizer.prototype.getNextToken = function () { if (this.buffer.length === 0) { const e = this.scanner.scanComments(); if (this.scanner.trackComment) for (let t = 0; t < e.length; ++t) { const r = e[t]; const n = this.scanner.source.slice(r.slice[0], r.slice[1]); const i = { type: r.multiLine ? 'BlockComment' : 'LineComment', value: n }; this.trackRange && (i.range = r.range), this.trackLoc && (i.loc = r.loc), this.buffer.push(i) } if (!this.scanner.eof()) { let o = void 0; this.trackLoc && (o = { start: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, end: {} }); const s = this.scanner.source[this.scanner.index] === '/' && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex(); this.reader.push(s); const u = { type: a.TokenName[s.type], value: this.scanner.source.slice(s.start, s.end) }; if (this.trackRange && (u.range = [s.start, s.end]), this.trackLoc && (o.end = { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, u.loc = o), s.type === 9) { const l = s.pattern; const c = s.flags; u.regex = { pattern: l, flags: c } } this.buffer.push(u) } } return this.buffer.shift() }, Tokenizer }()); t.Tokenizer = s;
  }]))));
}, function (e, t, r) {
  (function (e, t) {
    !(function (e, r) {
      if (!e.setImmediate) { let n; let i = 1; var a = {}; var o = !1; const s = e.document; let u = Object.getPrototypeOf && Object.getPrototypeOf(e); u = u && u.setTimeout ? u : e, {}.toString.call(e.process) === '[object process]' ? (function installNextTickImplementation() { n = function (e) { t.nextTick(() => { runIfPresent(e) }) } }()) : !(function canUsePostMessage() { if (e.postMessage && !e.importScripts) { let t = !0; const r = e.onmessage; return e.onmessage = function () { t = !1 }, e.postMessage('', '*'), e.onmessage = r, t } }()) ? e.MessageChannel ? (function installMessageChannelImplementation() { const e = new MessageChannel(); e.port1.onmessage = function (e) { runIfPresent(e.data) }, n = function (t) { e.port2.postMessage(t) } }()) : s && 'onreadystatechange' in s.createElement('script') ? (function installReadyStateChangeImplementation() { const e = s.documentElement; n = function (t) { let r = s.createElement('script'); r.onreadystatechange = function () { runIfPresent(t), r.onreadystatechange = null, e.removeChild(r), r = null }, e.appendChild(r) } }()) : (function installSetTimeoutImplementation() { n = function (e) { setTimeout(runIfPresent, 0, e) } }()) : (function installPostMessageImplementation() { const t = `setImmediate$${Math.random()}$`; const r = function (r) { r.source === e && typeof r.data === 'string' && r.data.indexOf(t) === 0 && runIfPresent(+r.data.slice(t.length)) }; e.addEventListener ? e.addEventListener('message', r, !1) : e.attachEvent('onmessage', r), n = function (r) { e.postMessage(t + r, '*') } }()), u.setImmediate = function setImmediate(e) { typeof e !== 'function' && (e = new Function(`${e}`)); for (var t = new Array(arguments.length - 1), r = 0; r < t.length; r++)t[r] = arguments[r + 1]; const o = { callback: e, args: t }; return a[i] = o, n(i), i++ }, u.clearImmediate = clearImmediate } function clearImmediate(e) { delete a[e] } function runIfPresent(e) { if (o)setTimeout(runIfPresent, 0, e); else { const t = a[e]; if (t) { o = !0; try { !(function run(e) { const t = e.callback; const n = e.args; switch (n.length) { case 0: t(); break; case 1: t(n[0]); break; case 2: t(n[0], n[1]); break; case 3: t(n[0], n[1], n[2]); break; default: t.apply(r, n); } }(t)) } finally { clearImmediate(e), o = !1 } } } }
    }(typeof self === 'undefined' ? void 0 === e ? this : e : self));
  }).call(t, r(14), r(45));
}, function (e, t, r) {
  const n = r(60); const i = r(489); const a = r(490); e.exports.isSingleFileComponent = function isSingleFileComponent(e) { try { return i.parseComponent(e, { pad: 'line' }).template !== null } catch (e) { return !1 } }, e.exports.transformSingleFileComponent = function transformSingleFileComponent(e) { const t = (function getSingleFileComponentParts(e) { const t = i.parseComponent(e, { pad: 'line' }); return t.script.content = a(t.script.content, { preserveNewLines: !0 }), t }(e)); const r = (function injectTemplateAndParseExport(e) { const t = e.script.content; let r = -1; if (t.indexOf('module.exports') !== -1) { const i = t.indexOf('module.exports'); r = t.indexOf('{', i) + 1 } else if (t.indexOf('exports.default') !== -1) { const a = t.indexOf('exports.default'); r = t.indexOf('{', a) + 1 } else if (t.indexOf('export ') !== -1) { const o = t.indexOf('export '); r = t.indexOf('{', o) + 1 } if (r === -1) throw new Error(`Failed to parse single file component: ${t}`); const s = t.substr(r); return `{\ntemplate: \`${(0, n.replaceAll)(`${e.template.content}`, '`', '\\`')}\`,\n${s}` }(t)); return { component: `\n\t\t\t${(function extractImports(e) { let t = ''; return e.split('\n').forEach((e) => { (e.startsWith('import') || e.indexOf('require(') !== -1) && (t += `${e}\n`) }), `${t}\n` }(t.script.content))}\n\t\t\tnew Vue(${r});\n\t\t`, style: (function buildStyles(e) { let t = ''; if (e && e.forEach((e) => { e.content && (t += e.content) }), t !== '') return `<style scoped>${t.trim()}</style>`; }(t.styles)) } };
}, function (e, t, r) {
  (function (e, r) {
    (function (t) {
      const n = /\r?\n/g; const i = /^\s*$/; const a = /^(\r?\n)*[\t\s]/; const o = function deindent(e) { if (!a.test(e)) return e; for (var t, r, o, s = e.split(n), u = 1 / 0, l = 0; l < s.length; l++) { const c = s[l]; if (!i.test(c)) if (t)(r = count(c, t)) < u && (u = r); else { if ((o = c.charAt(0)) !== ' ' && o !== '\t') return e; (r = count(c, t = o)) < u && (u = r) } } return s.map(e => e.slice(u)).join('\n') }; function count(e, t) { for (var r = 0; e.charAt(r) === t;)r++; return r } const s = Object.freeze({}); const u = Object.prototype.toString; function isPlainObject(e) { return u.call(e) === '[object Object]' } function makeMap(e, t) { for (var r = Object.create(null), n = e.split(','), i = 0; i < n.length; i++)r[n[i]] = !0; return t ? function (e) { return r[e.toLowerCase()] } : function (e) { return r[e] } } const l = makeMap('slot,component', !0); makeMap('key,ref,slot,slot-scope,is'); const c = Object.prototype.hasOwnProperty; function hasOwn(e, t) { return c.call(e, t) } function cached(e) { const t = Object.create(null); return function cachedFn(r) { return t[r] || (t[r] = e(r)) } } const p = /-(\w)/g; const f = cached(e => e.replace(p, (e, t) => (t ? t.toUpperCase() : ''))); Function.prototype.bind; function extend(e, t) { for (const r in t)e[r] = t[r]; return e } function noop(e, t, r) {} const d = function (e, t, r) { return !1 }; const h = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr'); const m = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); const g = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track'); const v = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/; const y = '[a-zA-Z_][\\w\\-\\.]*'; const b = `((?:${y}\\:)?${y})`; const x = new RegExp(`^<${b}`); const D = /^\s*(\/?)>/; const _ = new RegExp(`^<\\/${b}[^>]*>`); const C = /^<!DOCTYPE [^>]+>/i; const w = /^<!\--/; const E = /^<!\[/; let S = !1; 'x'.replace(/x(.)?/g, (e, t) => { S = t === '' }); const k = makeMap('script,style,textarea', !0); const A = {}; const T = {
        '&lt;': '<', '&gt;': '>', '&quot;': '"', '&amp;': '&', '&#10;': '\n', '&#9;': '\t',
      }; const P = /&(?:lt|gt|quot|amp);/g; const R = /&(?:lt|gt|quot|amp|#10|#9);/g; const O = makeMap('pre,textarea', !0); const F = function (e, t) { return e && O(e) && t[0] === '\n' }; function decodeAttr(e, t) { const r = t ? R : P; return e.replace(r, e => T[e]) } function parseHTML(e, t) { for (var r, n, i = [], a = t.expectHTML, o = t.isUnaryTag || d, s = t.canBeLeftOpenTag || d, u = 0; e;) { if (r = e, n && k(n)) { var l = 0; const c = n.toLowerCase(); const p = A[c] || (A[c] = new RegExp(`([\\s\\S]*?)(</${c}[^>]*>)`, 'i')); const f = e.replace(p, (e, r, n) => l = n.length, k(c) || c === 'noscript' || (r = r.replace(/<!\--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')), F(c, r) && (r = r.slice(1)), t.chars && t.chars(r), ''); u += e.length - f.length, e = f, parseEndTag(c, u - l, u) } else { let h = e.indexOf('<'); if (h === 0) { if (w.test(e)) { const m = e.indexOf('--\x3e'); if (m >= 0) { t.shouldKeepComment && t.comment(e.substring(4, m)), advance(m + 3); continue } } if (E.test(e)) { const y = e.indexOf(']>'); if (y >= 0) { advance(y + 2); continue } } const b = e.match(C); if (b) { advance(b[0].length); continue } const T = e.match(_); if (T) { const P = u; advance(T[0].length), parseEndTag(T[1], P, u); continue } const R = parseStartTag(); if (R) { handleStartTag(R), F(n, e) && advance(1); continue } } let O = void 0; let L = void 0; let M = void 0; if (h >= 0) { for (L = e.slice(h); !(_.test(L) || x.test(L) || w.test(L) || E.test(L) || (M = L.indexOf('<', 1)) < 0);)h += M, L = e.slice(h); O = e.substring(0, h), advance(h) }h < 0 && (O = e, e = ''), t.chars && O && t.chars(O) } if (e === r) { t.chars && t.chars(e), !i.length && t.warn && t.warn(`Mal-formatted tag at end of template: "${e}"`); break } } function advance(t) { u += t, e = e.substring(t) } function parseStartTag() { const t = e.match(x); if (t) { let r; let n; const i = { tagName: t[1], attrs: [], start: u }; for (advance(t[0].length); !(r = e.match(D)) && (n = e.match(v));)advance(n[0].length), i.attrs.push(n); if (r) return i.unarySlash = r[1], advance(r[0].length), i.end = u, i; } } function handleStartTag(e) { const r = e.tagName; const u = e.unarySlash; a && (n === 'p' && g(r) && parseEndTag(n), s(r) && n === r && parseEndTag(r)); for (var l = o(r) || !!u, c = e.attrs.length, p = new Array(c), f = 0; f < c; f++) { const d = e.attrs[f]; S && d[0].indexOf('""') === -1 && (d[3] === '' && delete d[3], d[4] === '' && delete d[4], d[5] === '' && delete d[5]); const h = d[3] || d[4] || d[5] || ''; const m = r === 'a' && d[1] === 'href' ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines; p[f] = { name: d[1], value: decodeAttr(h, m) } }l || (i.push({ tag: r, lowerCasedTag: r.toLowerCase(), attrs: p }), n = r), t.start && t.start(r, p, l, e.start, e.end) } function parseEndTag(e, r, a) { let o; let s; if (r == null && (r = u), a == null && (a = u), e && (s = e.toLowerCase()), e) for (o = i.length - 1; o >= 0 && i[o].lowerCasedTag !== s; o--);else o = 0; if (o >= 0) { for (let l = i.length - 1; l >= o; l--)(l > o || !e) && t.warn && t.warn(`tag <${i[l].tag}> has no matching end tag.`), t.end && t.end(i[l].tag, r, a); i.length = o, n = o && i[o - 1].tag } else s === 'br' ? t.start && t.start(e, [], !0, r, a) : s === 'p' && (t.start && t.start(e, [], !1, r, a), t.end && t.end(e, r, a)); }parseEndTag() } const L = /\r?\n/g; const M = /./g; const j = makeMap('script,style,template', !0); function def(e, t, r, n) {
        Object.defineProperty(e, t, {
          value: r, enumerable: !!n, writable: !0, configurable: !0,
        });
      } let N; const I = '__proto__' in {}; const B = typeof window !== 'undefined'; const q = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform; const U = q && WXEnvironment.platform.toLowerCase(); const z = B && window.navigator.userAgent.toLowerCase(); const V = z && /msie|trident/.test(z); const H = (z && z.indexOf('msie 9.0'), z && z.indexOf('edge/') > 0); const $ = (z && z.indexOf('android'), z && /iphone|ipad|ipod|ios/.test(z), z && /chrome\/\d+/.test(z), {}.watch); if (B) try { const G = {}; Object.defineProperty(G, 'passive', { get: function get() {} }), window.addEventListener('test-passive', null, G) } catch (e) {} const J = function () { return void 0 === N && (N = !B && !q && void 0 !== e && e.process.env.VUE_ENV === 'server'), N }; B && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function isNative(e) { return typeof e === 'function' && /native code/.test(e.toString()) } typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys); typeof Set !== 'undefined' && isNative(Set); let W; const K = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured']; const X = {
        optionMergeStrategies: Object.create(null), silent: !1, productionTip: !0, devtools: !0, performance: !1, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: d, isReservedAttr: d, isUnknownElement: d, getTagNamespace: noop, parsePlatformTagName(e) { return e }, mustUseProp: d, _lifecycleHooks: K,
      }; let Y = noop; let Q = noop; let Z = noop; const ee = typeof console !== 'undefined'; const te = /(?:^|[-_])(\w)/g; Y = function (e, t) { const r = t ? Z(t) : ''; X.warnHandler ? X.warnHandler.call(null, e, t, r) : ee && !X.silent && console.error(`[Vue warn]: ${e}${r}`) }, Q = function (e, t) { ee && !X.silent && console.warn(`[Vue tip]: ${e}${t ? Z(t) : ''}`) }, W = function (e, t) { if (e.$root === e) return '<Root>'; const r = typeof e === 'function' && e.cid != null ? e.options : e._isVue ? e.$options || e.constructor.options : e || {}; let n = r.name || r._componentTag; const i = r.__file; if (!n && i) { const a = i.match(/([^/\\]+)\.vue$/); n = a && a[1] } return (n ? `<${n.replace(te, e => e.toUpperCase()).replace(/[-_]/g, '')}>` : '<Anonymous>') + (i && !1 !== t ? ` at ${i}` : '') }; Z = function (e) { if (e._isVue && e.$parent) { for (var t = [], r = 0; e;) { if (t.length > 0) { const n = t[t.length - 1]; if (n.constructor === e.constructor) { r++, e = e.$parent; continue }r > 0 && (t[t.length - 1] = [n, r], r = 0) }t.push(e), e = e.$parent } return `\n\nfound in\n\n${t.map((e, t) => `${t === 0 ? '---\x3e ' : (function (e, t) { for (var r = ''; t;)t % 2 == 1 && (r += e), t > 1 && (e += e), t >>= 1; return r }(' ', 5 + 2 * t))}${Array.isArray(e) ? `${W(e[0])}... (${e[1]} recursive calls)` : W(e)}`).join('\n')}` } return `\n\n(found in ${W(e)})` }; let re = 0; const ne = function Dep() { this.id = re++, this.subs = [] }; ne.prototype.addSub = function addSub(e) { this.subs.push(e) }, ne.prototype.removeSub = function removeSub(e) { !(function remove(e, t) { if (e.length) { const r = e.indexOf(t); if (r > -1) return e.splice(r, 1); } }(this.subs, e)) }, ne.prototype.depend = function depend() { ne.target && ne.target.addDep(this) }, ne.prototype.notify = function notify() { for (let e = this.subs.slice(), t = 0, r = e.length; t < r; t++)e[t].update(); }, ne.target = null; const ie = function VNode(e, t, r, n, i, a, o, s) { this.tag = e, this.data = t, this.children = r, this.text = n, this.elm = i, this.ns = void 0, this.context = a, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = o, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1 }; const ae = { child: { configurable: !0 } }; ae.child.get = function () { return this.componentInstance }, Object.defineProperties(ie.prototype, ae); const oe = Array.prototype; const se = Object.create(oe); ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach((e) => { const t = oe[e]; def(se, e, function mutator() { for (var r = [], n = arguments.length; n--;)r[n] = arguments[n]; let i; const a = t.apply(this, r); const o = this.__ob__; switch (e) { case 'push': case 'unshift': i = r; break; case 'splice': i = r.slice(2); } return i && o.observeArray(i), o.dep.notify(), a }) }); const ue = Object.getOwnPropertyNames(se); const le = !0; const ce = function Observer(e) { (this.value = e, this.dep = new ne(), this.vmCount = 0, def(e, '__ob__', this), Array.isArray(e)) ? ((I ? protoAugment : copyAugment)(e, se, ue), this.observeArray(e)) : this.walk(e) }; function protoAugment(e, t, r) { e.__proto__ = t } function copyAugment(e, t, r) { for (let n = 0, i = r.length; n < i; n++) { const a = r[n]; def(e, a, t[a]) } } function observe(e, t) { let r; if ((function isObject(e) { return e !== null && typeof e === 'object' }(e)) && !(e instanceof ie)) return hasOwn(e, '__ob__') && e.__ob__ instanceof ce ? r = e.__ob__ : le && !J() && (Array.isArray(e) || isPlainObject(e)) && Object.isExtensible(e) && !e._isVue && (r = new ce(e)), t && r && r.vmCount++, r; } function defineReactive(e, t, r, n, i) {
        const a = new ne(); const
          o = Object.getOwnPropertyDescriptor(e, t); if (!o || !1 !== o.configurable) {
          const s = o && o.get; s || arguments.length !== 2 || (r = e[t]); const u = o && o.set; let l = !i && observe(r); Object.defineProperty(e, t, {
            enumerable: !0, configurable: !0, get: function reactiveGetter() { const t = s ? s.call(e) : r; return ne.target && (a.depend(), l && (l.dep.depend(), Array.isArray(t) && (function dependArray(e) { for (let t = void 0, r = 0, n = e.length; r < n; r++)(t = e[r]) && t.__ob__ && t.__ob__.dep.depend(), Array.isArray(t) && dependArray(t); }(t)))), t }, set: function reactiveSetter(t) { const o = s ? s.call(e) : r; t === o || t != t && o != o || (n && n(), u ? u.call(e, t) : r = t, l = !i && observe(t), a.notify()) },
          });
        }
      } function set(e, t, r) { if (((function isUndef(e) { return void 0 === e || e === null }(e)) || (function isPrimitive(e) { return typeof e === 'string' || typeof e === 'number' || typeof e === 'symbol' || typeof e === 'boolean' }(e))) && Y(`Cannot set reactive property on undefined, null, or primitive value: ${e}`), Array.isArray(e) && (function isValidArrayIndex(e) { const t = parseFloat(String(e)); return t >= 0 && Math.floor(t) === t && isFinite(e) }(t))) return e.length = Math.max(e.length, t), e.splice(t, 1, r), r; if (t in e && !(t in Object.prototype)) return e[t] = r, r; const n = e.__ob__; return e._isVue || n && n.vmCount ? (Y('Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.'), r) : n ? (defineReactive(n.value, t, r), n.dep.notify(), r) : (e[t] = r, r) }ce.prototype.walk = function walk(e) { for (let t = Object.keys(e), r = 0; r < t.length; r++)defineReactive(e, t[r]); }, ce.prototype.observeArray = function observeArray(e) { for (let t = 0, r = e.length; t < r; t++)observe(e[t]); }; const pe = X.optionMergeStrategies; function mergeData(e, t) { if (!t) return e; for (var r, n, i, a = Object.keys(t), o = 0; o < a.length; o++)n = e[r = a[o]], i = t[r], hasOwn(e, r) ? isPlainObject(n) && isPlainObject(i) && mergeData(n, i) : set(e, r, i); return e } function mergeDataOrFn(e, t, r) { return r ? function mergedInstanceDataFn() { const n = typeof t === 'function' ? t.call(r, r) : t; const i = typeof e === 'function' ? e.call(r, r) : e; return n ? mergeData(n, i) : i } : t ? e ? function mergedDataFn() { return mergeData(typeof t === 'function' ? t.call(this, this) : t, typeof e === 'function' ? e.call(this, this) : e) } : t : e } function mergeHook(e, t) { return t ? e ? e.concat(t) : Array.isArray(t) ? t : [t] : e } function mergeAssets(e, t, r, n) { const i = Object.create(e || null); return t ? (assertObjectType(n, t, r), extend(i, t)) : i }pe.el = pe.propsData = function (e, t, r, n) { return r || Y(`option "${n}" can only be used during instance creation with the \`new\` keyword.`), fe(e, t) }, pe.data = function (e, t, r) { return r ? mergeDataOrFn(e, t, r) : t && typeof t !== 'function' ? (Y('The "data" option should be a function that returns a per-instance value in component definitions.', r), e) : mergeDataOrFn(e, t) }, K.forEach((e) => { pe[e] = mergeHook }), ['component', 'directive', 'filter'].forEach((e) => { pe[`${e}s`] = mergeAssets }), pe.watch = function (e, t, r, n) { if (e === $ && (e = void 0), t === $ && (t = void 0), !t) return Object.create(e || null); if (assertObjectType(n, t, r), !e) return t; const i = {}; for (const a in extend(i, e), t) { let o = i[a]; const s = t[a]; o && !Array.isArray(o) && (o = [o]), i[a] = o ? o.concat(s) : Array.isArray(s) ? s : [s] } return i }, pe.props = pe.methods = pe.inject = pe.computed = function (e, t, r, n) { if (t && assertObjectType(n, t, r), !e) return t; const i = Object.create(null); return extend(i, e), t && extend(i, t), i }, pe.provide = mergeDataOrFn; var fe = function (e, t) { return void 0 === t ? e : t }; function assertObjectType(e, t, r) { isPlainObject(t) || Y(`Invalid value for option "${e}": expected an Object, but got ${(function toRawType(e) { return u.call(e).slice(8, -1) }(t))}.`, r) } const de = []; if (void 0 !== r && isNative(r));else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || MessageChannel.toString() === '[object MessageChannelConstructor]')) { (new MessageChannel()).port1.onmessage = function flushCallbacks() { const e = de.slice(0); de.length = 0; for (let t = 0; t < e.length; t++)e[t](); } } typeof Promise !== 'undefined' && isNative(Promise); makeMap('style,class'); const he = makeMap('input,textarea,option,select,progress'); const me = makeMap('contenteditable,draggable,spellcheck'); const ge = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible'); const ve = makeMap('html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot'); const ye = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', !0); makeMap('text,number,password,search,email,tel,url'); const be = /[\w).+\-_$\]]/; function parseFilters(e) { let t; let r; let n; let i; let a; let o = !1; let s = !1; let u = !1; let l = !1; let c = 0; let p = 0; let f = 0; let d = 0; for (n = 0; n < e.length; n++) if (r = t, t = e.charCodeAt(n), o)t === 39 && r !== 92 && (o = !1); else if (s)t === 34 && r !== 92 && (s = !1); else if (u)t === 96 && r !== 92 && (u = !1); else if (l)t === 47 && r !== 92 && (l = !1); else if (t !== 124 || e.charCodeAt(n + 1) === 124 || e.charCodeAt(n - 1) === 124 || c || p || f) { switch (t) { case 34: s = !0; break; case 39: o = !0; break; case 96: u = !0; break; case 40: f++; break; case 41: f--; break; case 91: p++; break; case 93: p--; break; case 123: c++; break; case 125: c--; } if (t === 47) { for (var h = n - 1, m = void 0; h >= 0 && (m = e.charAt(h)) === ' '; h--);m && be.test(m) || (l = !0) } } else void 0 === i ? (d = n + 1, i = e.slice(0, n).trim()) : pushFilter(); function pushFilter() { (a || (a = [])).push(e.slice(d, n).trim()), d = n + 1 } if (void 0 === i ? i = e.slice(0, n).trim() : d !== 0 && pushFilter(), a) for (n = 0; n < a.length; n++)i = wrapFilter(i, a[n]); return i } function wrapFilter(e, t) { const r = t.indexOf('('); if (r < 0) return `_f("${t}")(${e})`; const n = t.slice(0, r); const i = t.slice(r + 1); return `_f("${n}")(${e}${i !== ')' ? `,${i}` : i}` } const xe = /\{\{((?:.|\n)+?)\}\}/g; const De = /[-.*+?^${}()|[\]\/\\]/g; const _e = cached((e) => { const t = e[0].replace(De, '\\$&'); const r = e[1].replace(De, '\\$&'); return new RegExp(`${t}((?:.|\\n)+?)${r}`, 'g') }); function parseText(e, t) { const r = t ? _e(t) : xe; if (r.test(e)) { for (var n, i, a, o = [], s = [], u = r.lastIndex = 0; n = r.exec(e);) { (i = n.index) > u && (s.push(a = e.slice(u, i)), o.push(JSON.stringify(a))); const l = parseFilters(n[1].trim()); o.push(`_s(${l})`), s.push({ '@binding': l }), u = i + n[0].length } return u < e.length && (s.push(a = e.slice(u)), o.push(JSON.stringify(a))), { expression: o.join('+'), tokens: s } } } function baseWarn(e) { console.error(`[Vue compiler]: ${e}`) } function pluckModuleFunction(e, t) { return e ? e.map(e => e[t]).filter(e => e) : [] } function addProp(e, t, r) { (e.props || (e.props = [])).push({ name: t, value: r }), e.plain = !1 } function addAttr(e, t, r) { (e.attrs || (e.attrs = [])).push({ name: t, value: r }), e.plain = !1 } function addRawAttr(e, t, r) { e.attrsMap[t] = r, e.attrsList.push({ name: t, value: r }) } function addDirective(e, t, r, n, i, a) {
        (e.directives || (e.directives = [])).push({
          name: t, rawName: r, value: n, arg: i, modifiers: a,
        }), e.plain = !1;
      } function addHandler(e, t, r, n, i, a) { let o; n = n || s, a && n.prevent && n.passive && a("passive and prevent can't be used together. Passive handler can't prevent default event."), n.capture && (delete n.capture, t = `!${t}`), n.once && (delete n.once, t = `~${t}`), n.passive && (delete n.passive, t = `&${t}`), t === 'click' && (n.right ? (t = 'contextmenu', delete n.right) : n.middle && (t = 'mouseup')), n.native ? (delete n.native, o = e.nativeEvents || (e.nativeEvents = {})) : o = e.events || (e.events = {}); const u = { value: r.trim() }; n !== s && (u.modifiers = n); const l = o[t]; Array.isArray(l) ? i ? l.unshift(u) : l.push(u) : o[t] = l ? i ? [u, l] : [l, u] : u, e.plain = !1 } function getBindingAttr(e, t, r) { const n = getAndRemoveAttr(e, `:${t}`) || getAndRemoveAttr(e, `v-bind:${t}`); if (n != null) return parseFilters(n); if (!1 !== r) { const i = getAndRemoveAttr(e, t); if (i != null) return JSON.stringify(i); } } function getAndRemoveAttr(e, t, r) { let n; if ((n = e.attrsMap[t]) != null) for (let i = e.attrsList, a = 0, o = i.length; a < o; a++) if (i[a].name === t) { i.splice(a, 1); break } return r && delete e.attrsMap[t], n } const Ce = { staticKeys: ['staticClass'], transformNode: function transformNode(e, t) { const r = t.warn || baseWarn; const n = getAndRemoveAttr(e, 'class'); n && parseText(n, t.delimiters) && r(`class="${n}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div class="{{ val }}">, use <div :class="val">.`), n && (e.staticClass = JSON.stringify(n)); const i = getBindingAttr(e, 'class', !1); i && (e.classBinding = i) }, genData: function genData(e) { let t = ''; return e.staticClass && (t += `staticClass:${e.staticClass},`), e.classBinding && (t += `class:${e.classBinding},`), t } }; const we = cached((e) => { const t = {}; const r = /:(.+)/; return e.split(/;(?![^(]*\))/g).forEach((e) => { if (e) { const n = e.split(r); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } }), t }); let Ee; let Se; let ke; let Ae; let Te; let Pe; const Re = { staticKeys: ['staticStyle'], transformNode: function transformNode$1(e, t) { const r = t.warn || baseWarn; const n = getAndRemoveAttr(e, 'style'); n && (parseText(n, t.delimiters) && r(`style="${n}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div style="{{ val }}">, use <div :style="val">.`), e.staticStyle = JSON.stringify(we(n))); const i = getBindingAttr(e, 'style', !1); i && (e.styleBinding = i) }, genData: function genData$1(e) { let t = ''; return e.staticStyle && (t += `staticStyle:${e.staticStyle},`), e.styleBinding && (t += `style:(${e.styleBinding}),`), t } }; const Oe = typeof window !== 'undefined' ? window : void 0 !== e ? e : typeof self !== 'undefined' ? self : {}; function genComponentModel(e, t, r) { const n = r || {}; const i = n.number; let a = '$$v'; n.trim && (a = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i && (a = `_n(${a})`); const o = genAssignmentCode(t, a); e.model = { value: `(${t})`, expression: `"${t}"`, callback: `function ($$v) {${o}}` } } function genAssignmentCode(e, t) { const r = (function parseModel(e) { if (e = e.trim(), Ee = e.length, e.indexOf('[') < 0 || e.lastIndexOf(']') < Ee - 1) return (Ae = e.lastIndexOf('.')) > -1 ? { exp: e.slice(0, Ae), key: `"${e.slice(Ae + 1)}"` } : { exp: e, key: null }; Se = e, Ae = Te = Pe = 0; for (;!eof();)isStringStart(ke = next()) ? parseString(ke) : ke === 91 && parseBracket(ke); return { exp: e.slice(0, Te), key: e.slice(Te + 1, Pe) } }(e)); return r.key === null ? `${e}=${t}` : `$set(${r.exp}, ${r.key}, ${t})` } function next() { return Se.charCodeAt(++Ae) } function eof() { return Ae >= Ee } function isStringStart(e) { return e === 34 || e === 39 } function parseBracket(e) { let t = 1; for (Te = Ae; !eof();) if (isStringStart(e = next()))parseString(e); else if (e === 91 && t++, e === 93 && t--, t === 0) { Pe = Ae; break } } function parseString(e) { for (let t = e; !eof() && (e = next()) !== t;); } let Fe; let Le; let Me; let je; let Ne; let Ie; let Be; let qe; const Ue = /^@|^v-on:/; const ze = /^v-|^@|^:/; const Ve = /([^]*?)\s+(?:in|of)\s+([^]*)/; const He = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/; const $e = /^\(|\)$/g; const Ge = /:(.*)$/; const Je = /^:|^v-bind:/; const We = /\.[^.]+/g; const Ke = cached((function createCommonjsModule(e, t) { return e(t = { exports: {} }, t.exports), t.exports }((e, t) => {
        /*! https://mths.be/he v1.1.1 by @mathias | MIT license */
        !(function (r) {
          const n = t; const i = e && e.exports == n && e; const a = typeof Oe === 'object' && Oe; a.global !== a && a.window !== a || (r = a); const o = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; const s = /[\x01-\x7F]/g; const u = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g; const l = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g; const c = {
            '': 'shy', '': 'zwnj', '': 'zwj', '': 'lrm', '': 'ic', '': 'it', '': 'af', '': 'rlm', '': 'ZeroWidthSpace', '': 'NoBreak', '': 'DownBreve', '': 'tdot', '': 'DotDot', '\t': 'Tab', '\n': 'NewLine', '': 'puncsp', '': 'MediumSpace', '': 'thinsp', '': 'hairsp', '': 'emsp13', '': 'ensp', '': 'emsp14', '': 'emsp', '': 'numsp', '': 'nbsp', '': 'ThickSpace', '': 'oline', _: 'lowbar', '': 'dash', '': 'ndash', '': 'mdash', '': 'horbar', ',': 'comma', ';': 'semi', '': 'bsemi', ':': 'colon', '': 'Colone', '!': 'excl', '': 'iexcl', '?': 'quest', '': 'iquest', '.': 'period', '': 'nldr', '': 'mldr', '': 'middot', "'": 'apos', '': 'lsquo', '': 'rsquo', '': 'sbquo', '': 'lsaquo', '': 'rsaquo', '"': 'quot', '': 'ldquo', '': 'rdquo', '': 'bdquo', '': 'laquo', '': 'raquo', '(': 'lpar', ')': 'rpar', '[': 'lsqb', ']': 'rsqb', '{': 'lcub', '}': 'rcub', '': 'lceil', '': 'rceil', '': 'lfloor', '': 'rfloor', '': 'lopar', '': 'ropar', '': 'lbrke', '': 'rbrke', '': 'lbrkslu', '': 'rbrksld', '': 'lbrksld', '': 'rbrkslu', '': 'langd', '': 'rangd', '': 'lparlt', '': 'rpargt', '': 'gtlPar', '': 'ltrPar', '': 'lobrk', '': 'robrk', '': 'lang', '': 'rang', '': 'Lang', '': 'Rang', '': 'loang', '': 'roang', '': 'lbbrk', '': 'rbbrk', '': 'Vert', '': 'sect', '': 'para', '@': 'commat', '*': 'ast', '/': 'sol', undefined: null, '&': 'amp', '#': 'num', '%': 'percnt', '': 'permil', '': 'pertenk', '': 'dagger', '': 'Dagger', '': 'bull', '': 'hybull', '': 'prime', '': 'Prime', '': 'tprime', '': 'qprime', '': 'bprime', '': 'caret', '`': 'grave', '': 'acute', '': 'tilde', '^': 'Hat', '': 'macr', '': 'breve', '': 'dot', '': 'die', '': 'ring', '': 'dblac', '': 'cedil', '': 'ogon', : 'circ', : 'caron', '': 'deg', '': 'copy', '': 'reg', '': 'copysr', : 'wp', '': 'rx', '': 'mho', '': 'iiota', '': 'larr', '': 'nlarr', '': 'rarr', '': 'nrarr', '': 'uarr', '': 'darr', '': 'harr', '': 'nharr', '': 'varr', '': 'nwarr', '': 'nearr', '': 'searr', '': 'swarr', '': 'rarrw', '': 'nrarrw', '': 'Larr', '': 'Uarr', '': 'Rarr', '': 'Darr', '': 'larrtl', '': 'rarrtl', '': 'mapstoleft', '': 'mapstoup', '': 'map', '': 'mapstodown', '': 'larrhk', '': 'rarrhk', '': 'larrlp', '': 'rarrlp', '': 'harrw', '': 'lsh', '': 'rsh', '': 'ldsh', '': 'rdsh', '': 'crarr', '': 'cularr', '': 'curarr', '': 'olarr', '': 'orarr', '': 'lharu', '': 'lhard', '': 'uharr', '': 'uharl', '': 'rharu', '': 'rhard', '': 'dharr', '': 'dharl', '': 'rlarr', '': 'udarr', '': 'lrarr', '': 'llarr', '': 'uuarr', '': 'rrarr', '': 'ddarr', '': 'lrhar', '': 'rlhar', '': 'lArr', '': 'nlArr', '': 'uArr', '': 'rArr', '': 'nrArr', '': 'dArr', '': 'iff', '': 'nhArr', '': 'vArr', '': 'nwArr', '': 'neArr', '': 'seArr', '': 'swArr', '': 'lAarr', '': 'rAarr', '': 'zigrarr', '': 'larrb', '': 'rarrb', '': 'duarr', '': 'loarr', '': 'roarr', '': 'hoarr', '': 'forall', '': 'comp', '': 'part', '': 'npart', '': 'exist', '': 'nexist', '': 'empty', '': 'Del', '': 'in', '': 'notin', '': 'ni', '': 'notni', '': 'bepsi', '': 'prod', '': 'coprod', '': 'sum', '+': 'plus', '': 'pm', '': 'div', '': 'times', '<': 'lt', '': 'nlt', '<': 'nvlt', '=': 'equals', '': 'ne', '=': 'bne', '': 'Equal', '>': 'gt', '': 'ngt', '>': 'nvgt', '': 'not', '|': 'vert', '': 'brvbar', '': 'minus', '': 'mp', '': 'plusdo', '': 'frasl', '': 'setmn', '': 'lowast', '': 'compfn', '': 'Sqrt', '': 'prop', '': 'infin', '': 'angrt', '': 'ang', '': 'nang', '': 'angmsd', '': 'angsph', '': 'mid', '': 'nmid', '': 'par', '': 'npar', '': 'and', '': 'or', '': 'cap', '': 'caps', '': 'cup', '': 'cups', '': 'int', '': 'Int', '': 'tint', '': 'qint', '': 'oint', '': 'Conint', '': 'Cconint', '': 'cwint', '': 'cwconint', '': 'awconint', '': 'there4', '': 'becaus', '': 'ratio', '': 'Colon', '': 'minusd', '': 'mDDot', '': 'homtht', '': 'sim', '': 'nsim', '': 'nvsim', '': 'bsim', '': 'race', '': 'ac', '': 'acE', '': 'acd', '': 'wr', '': 'esim', '': 'nesim', '': 'sime', '': 'nsime', '': 'cong', '': 'ncong', '': 'simne', '': 'ap', '': 'nap', '': 'ape', '': 'apid', '': 'napid', '': 'bcong', '': 'CupCap', '': 'NotCupCap', '': 'nvap', '': 'bump', '': 'nbump', '': 'bumpe', '': 'nbumpe', '': 'doteq', '': 'nedot', '': 'eDot', '': 'efDot', '': 'erDot', '': 'colone', '': 'ecolon', '': 'ecir', '': 'cire', '': 'wedgeq', '': 'veeeq', '': 'trie', '': 'equest', '': 'equiv', '': 'nequiv', '': 'bnequiv', '': 'le', '': 'nle', '': 'nvle', '': 'ge', '': 'nge', '': 'nvge', '': 'lE', '': 'nlE', '': 'gE', '': 'ngE', '': 'lvnE', '': 'lnE', '': 'gnE', '': 'gvnE', '': 'll', '': 'nLtv', '': 'nLt', '': 'gg', '': 'nGtv', '': 'nGt', '': 'twixt', '': 'lsim', '': 'nlsim', '': 'gsim', '': 'ngsim', '': 'lg', '': 'ntlg', '': 'gl', '': 'ntgl', '': 'pr', '': 'npr', '': 'sc', '': 'nsc', '': 'prcue', '': 'nprcue', '': 'sccue', '': 'nsccue', '': 'prsim', '': 'scsim', '': 'NotSucceedsTilde', '': 'sub', '': 'nsub', '': 'vnsub', '': 'sup', '': 'nsup', '': 'vnsup', '': 'sube', '': 'nsube', '': 'supe', '': 'nsupe', '': 'vsubne', '': 'subne', '': 'vsupne', '': 'supne', '': 'cupdot', '': 'uplus', '': 'sqsub', '': 'NotSquareSubset', '': 'sqsup', '': 'NotSquareSuperset', '': 'sqsube', '': 'nsqsube', '': 'sqsupe', '': 'nsqsupe', '': 'sqcap', '': 'sqcaps', '': 'sqcup', '': 'sqcups', '': 'oplus', '': 'ominus', '': 'otimes', '': 'osol', '': 'odot', '': 'ocir', '': 'oast', '': 'odash', '': 'plusb', '': 'minusb', '': 'timesb', '': 'sdotb', '': 'vdash', '': 'nvdash', '': 'dashv', '': 'top', '': 'bot', '': 'models', '': 'vDash', '': 'nvDash', '': 'Vdash', '': 'nVdash', '': 'Vvdash', '': 'VDash', '': 'nVDash', '': 'prurel', '': 'vltri', '': 'nltri', '': 'vrtri', '': 'nrtri', '': 'ltrie', '': 'nltrie', '': 'nvltrie', '': 'rtrie', '': 'nrtrie', '': 'nvrtrie', '': 'origof', '': 'imof', '': 'mumap', '': 'hercon', '': 'intcal', '': 'veebar', '': 'barvee', '': 'angrtvb', '': 'lrtri', '': 'Wedge', '': 'Vee', '': 'xcap', '': 'xcup', '': 'diam', '': 'sdot', '': 'Star', '': 'divonx', '': 'bowtie', '': 'ltimes', '': 'rtimes', '': 'lthree', '': 'rthree', '': 'bsime', '': 'cuvee', '': 'cuwed', '': 'Sub', '': 'Sup', '': 'Cap', '': 'Cup', '': 'fork', '': 'epar', '': 'ltdot', '': 'gtdot', '': 'Ll', '': 'nLl', '': 'Gg', '': 'nGg', '': 'lesg', '': 'leg', '': 'gel', '': 'gesl', '': 'cuepr', '': 'cuesc', '': 'lnsim', '': 'gnsim', '': 'prnsim', '': 'scnsim', '': 'vellip', '': 'ctdot', '': 'utdot', '': 'dtdot', '': 'disin', '': 'isinsv', '': 'isins', '': 'isindot', '': 'notindot', '': 'notinvc', '': 'notinvb', '': 'isinE', '': 'notinE', '': 'nisd', '': 'xnis', '': 'nis', '': 'notnivc', '': 'notnivb', '': 'barwed', '': 'Barwed', '': 'drcrop', '': 'dlcrop', '': 'urcrop', '': 'ulcrop', '': 'bnot', '': 'profline', '': 'profsurf', '': 'telrec', '': 'target', '': 'ulcorn', '': 'urcorn', '': 'dlcorn', '': 'drcorn', '': 'frown', '': 'smile', '': 'cylcty', '': 'profalar', '': 'topbot', '': 'ovbar', '': 'solbar', '': 'angzarr', '': 'lmoust', '': 'rmoust', '': 'tbrk', '': 'bbrk', '': 'bbrktbrk', '': 'OverParenthesis', '': 'UnderParenthesis', '': 'OverBrace', '': 'UnderBrace', '': 'trpezium', '': 'elinters', '': 'blank', '': 'boxh', '': 'boxv', '': 'boxdr', '': 'boxdl', '': 'boxur', '': 'boxul', '': 'boxvr', '': 'boxvl', '': 'boxhd', '': 'boxhu', '': 'boxvh', '': 'boxH', '': 'boxV', '': 'boxdR', '': 'boxDr', '': 'boxDR', '': 'boxdL', '': 'boxDl', '': 'boxDL', '': 'boxuR', '': 'boxUr', '': 'boxUR', '': 'boxuL', '': 'boxUl', '': 'boxUL', '': 'boxvR', '': 'boxVr', '': 'boxVR', '': 'boxvL', '': 'boxVl', '': 'boxVL', '': 'boxHd', '': 'boxhD', '': 'boxHD', '': 'boxHu', '': 'boxhU', '': 'boxHU', '': 'boxvH', '': 'boxVh', '': 'boxVH', '': 'uhblk', '': 'lhblk', '': 'block', '': 'blk14', '': 'blk12', '': 'blk34', '': 'squ', '': 'squf', '': 'EmptyVerySmallSquare', '': 'rect', '': 'marker', '': 'fltns', '': 'xutri', '': 'utrif', '': 'utri', '': 'rtrif', '': 'rtri', '': 'xdtri', '': 'dtrif', '': 'dtri', '': 'ltrif', '': 'ltri', '': 'loz', '': 'cir', '': 'tridot', '': 'xcirc', '': 'ultri', '': 'urtri', '': 'lltri', '': 'EmptySmallSquare', '': 'FilledSmallSquare', '': 'starf', '': 'star', '': 'phone', '': 'female', '': 'male', '': 'spades', '': 'clubs', '': 'hearts', '': 'diams', '': 'sung', '': 'check', '': 'cross', '': 'malt', '': 'sext', '': 'VerticalSeparator', '': 'bsolhsub', '': 'suphsol', '': 'xlarr', '': 'xrarr', '': 'xharr', '': 'xlArr', '': 'xrArr', '': 'xhArr', '': 'xmap', '': 'dzigrarr', '': 'nvlArr', '': 'nvrArr', '': 'nvHarr', '': 'Map', '': 'lbarr', '': 'rbarr', '': 'lBarr', '': 'rBarr', '': 'RBarr', '': 'DDotrahd', '': 'UpArrowBar', '': 'DownArrowBar', '': 'Rarrtl', '': 'latail', '': 'ratail', '': 'lAtail', '': 'rAtail', '': 'larrfs', '': 'rarrfs', '': 'larrbfs', '': 'rarrbfs', '': 'nwarhk', '': 'nearhk', '': 'searhk', '': 'swarhk', '': 'nwnear', '': 'toea', '': 'tosa', '': 'swnwar', '': 'rarrc', '': 'nrarrc', '': 'cudarrr', '': 'ldca', '': 'rdca', '': 'cudarrl', '': 'larrpl', '': 'curarrm', '': 'cularrp', '': 'rarrpl', '': 'harrcir', '': 'Uarrocir', '': 'lurdshar', '': 'ldrushar', '': 'LeftRightVector', '': 'RightUpDownVector', '': 'DownLeftRightVector', '': 'LeftUpDownVector', '': 'LeftVectorBar', '': 'RightVectorBar', '': 'RightUpVectorBar', '': 'RightDownVectorBar', '': 'DownLeftVectorBar', '': 'DownRightVectorBar', '': 'LeftUpVectorBar', '': 'LeftDownVectorBar', '': 'LeftTeeVector', '': 'RightTeeVector', '': 'RightUpTeeVector', '': 'RightDownTeeVector', '': 'DownLeftTeeVector', '': 'DownRightTeeVector', '': 'LeftUpTeeVector', '': 'LeftDownTeeVector', '': 'lHar', '': 'uHar', '': 'rHar', '': 'dHar', '': 'luruhar', '': 'ldrdhar', '': 'ruluhar', '': 'rdldhar', '': 'lharul', '': 'llhard', '': 'rharul', '': 'lrhard', '': 'udhar', '': 'duhar', '': 'RoundImplies', '': 'erarr', '': 'simrarr', '': 'larrsim', '': 'rarrsim', '': 'rarrap', '': 'ltlarr', '': 'gtrarr', '': 'subrarr', '': 'suplarr', '': 'lfisht', '': 'rfisht', '': 'ufisht', '': 'dfisht', '': 'vzigzag', '': 'vangrt', '': 'angrtvbd', '': 'ange', '': 'range', '': 'dwangle', '': 'uwangle', '': 'angmsdaa', '': 'angmsdab', '': 'angmsdac', '': 'angmsdad', '': 'angmsdae', '': 'angmsdaf', '': 'angmsdag', '': 'angmsdah', '': 'bemptyv', '': 'demptyv', '': 'cemptyv', '': 'raemptyv', '': 'laemptyv', '': 'ohbar', '': 'omid', '': 'opar', '': 'operp', '': 'olcross', '': 'odsold', '': 'olcir', '': 'ofcir', '': 'olt', '': 'ogt', '': 'cirscir', '': 'cirE', '': 'solb', '': 'bsolb', '': 'boxbox', '': 'trisb', '': 'rtriltri', '': 'LeftTriangleBar', '': 'NotLeftTriangleBar', '': 'RightTriangleBar', '': 'NotRightTriangleBar', '': 'iinfin', '': 'infintie', '': 'nvinfin', '': 'eparsl', '': 'smeparsl', '': 'eqvparsl', '': 'lozf', '': 'RuleDelayed', '': 'dsol', '': 'xodot', '': 'xoplus', '': 'xotime', '': 'xuplus', '': 'xsqcup', '': 'fpartint', '': 'cirfnint', '': 'awint', '': 'rppolint', '': 'scpolint', '': 'npolint', '': 'pointint', '': 'quatint', '': 'intlarhk', '': 'pluscir', '': 'plusacir', '': 'simplus', '': 'plusdu', '': 'plussim', '': 'plustwo', '': 'mcomma', '': 'minusdu', '': 'loplus', '': 'roplus', '': 'Cross', '': 'timesd', '': 'timesbar', '': 'smashp', '': 'lotimes', '': 'rotimes', '': 'otimesas', '': 'Otimes', '': 'odiv', '': 'triplus', '': 'triminus', '': 'tritime', '': 'iprod', '': 'amalg', '': 'capdot', '': 'ncup', '': 'ncap', '': 'capand', '': 'cupor', '': 'cupcap', '': 'capcup', '': 'cupbrcap', '': 'capbrcup', '': 'cupcup', '': 'capcap', '': 'ccups', '': 'ccaps', '': 'ccupssm', '': 'And', '': 'Or', '': 'andand', '': 'oror', '': 'orslope', '': 'andslope', '': 'andv', '': 'orv', '': 'andd', '': 'ord', '': 'wedbar', '': 'sdote', '': 'simdot', '': 'congdot', '': 'ncongdot', '': 'easter', '': 'apacir', '': 'apE', '': 'napE', '': 'eplus', '': 'pluse', '': 'Esim', '': 'eDDot', '': 'equivDD', '': 'ltcir', '': 'gtcir', '': 'ltquest', '': 'gtquest', '': 'les', '': 'nles', '': 'ges', '': 'nges', '': 'lesdot', '': 'gesdot', '': 'lesdoto', '': 'gesdoto', '': 'lesdotor', '': 'gesdotol', '': 'lap', '': 'gap', '': 'lne', '': 'gne', '': 'lnap', '': 'gnap', '': 'lEg', '': 'gEl', '': 'lsime', '': 'gsime', '': 'lsimg', '': 'gsiml', '': 'lgE', '': 'glE', '': 'lesges', '': 'gesles', '': 'els', '': 'egs', '': 'elsdot', '': 'egsdot', '': 'el', '': 'eg', '': 'siml', '': 'simg', '': 'simlE', '': 'simgE', '': 'LessLess', '': 'NotNestedLessLess', '': 'GreaterGreater', '': 'NotNestedGreaterGreater', '': 'glj', '': 'gla', '': 'ltcc', '': 'gtcc', '': 'lescc', '': 'gescc', '': 'smt', '': 'lat', '': 'smte', '': 'smtes', '': 'late', '': 'lates', '': 'bumpE', '': 'pre', '': 'npre', '': 'sce', '': 'nsce', '': 'prE', '': 'scE', '': 'prnE', '': 'scnE', '': 'prap', '': 'scap', '': 'prnap', '': 'scnap', '': 'Pr', '': 'Sc', '': 'subdot', '': 'supdot', '': 'subplus', '': 'supplus', '': 'submult', '': 'supmult', '': 'subedot', '': 'supedot', '': 'subE', '': 'nsubE', '': 'supE', '': 'nsupE', '': 'subsim', '': 'supsim', '': 'vsubnE', '': 'subnE', '': 'vsupnE', '': 'supnE', '': 'csub', '': 'csup', '': 'csube', '': 'csupe', '': 'subsup', '': 'supsub', '': 'subsub', '': 'supsup', '': 'suphsub', '': 'supdsub', '': 'forkv', '': 'topfork', '': 'mlcp', '': 'Dashv', '': 'Vdashl', '': 'Barv', '': 'vBar', '': 'vBarv', '': 'Vbar', '': 'Not', '': 'bNot', '': 'rnmid', '': 'cirmid', '': 'midcir', '': 'topcir', '': 'nhpar', '': 'parsim', '': 'parsl', '': 'nparsl', '': 'flat', '': 'natur', '': 'sharp', '': 'curren', '': 'cent', $: 'dollar', '': 'pound', '': 'yen', '': 'euro', '': 'sup1', '': 'half', '': 'frac13', '': 'frac14', '': 'frac15', '': 'frac16', '': 'frac18', '': 'sup2', '': 'frac23', '': 'frac25', '': 'sup3', '': 'frac34', '': 'frac35', '': 'frac38', '': 'frac45', '': 'frac56', '': 'frac58', '': 'frac78', '': 'ascr', '': 'aopf', '': 'afr', '': 'Aopf', '': 'Afr', '': 'Ascr', : 'ordf', : 'aacute', : 'Aacute', : 'agrave', : 'Agrave', : 'abreve', : 'Abreve', : 'acirc', : 'Acirc', : 'aring', : 'angst', : 'auml', : 'Auml', : 'atilde', : 'Atilde', : 'aogon', : 'Aogon', : 'amacr', : 'Amacr', : 'aelig', : 'AElig', '': 'bscr', '': 'bopf', '': 'bfr', '': 'Bopf', : 'Bscr', '': 'Bfr', '': 'cfr', '': 'cscr', '': 'copf', : 'Cfr', '': 'Cscr', : 'Copf', : 'cacute', : 'Cacute', : 'ccirc', : 'Ccirc', : 'ccaron', : 'Ccaron', : 'cdot', : 'Cdot', : 'ccedil', : 'Ccedil', '': 'incare', '': 'dfr', : 'dd', '': 'dopf', '': 'dscr', '': 'Dscr', '': 'Dfr', : 'DD', '': 'Dopf', : 'dcaron', : 'Dcaron', : 'dstrok', : 'Dstrok', : 'eth', : 'ETH', : 'ee', : 'escr', '': 'efr', '': 'eopf', : 'Escr', '': 'Efr', '': 'Eopf', : 'eacute', : 'Eacute', : 'egrave', : 'Egrave', : 'ecirc', : 'Ecirc', : 'ecaron', : 'Ecaron', : 'euml', : 'Euml', : 'edot', : 'Edot', : 'eogon', : 'Eogon', : 'emacr', : 'Emacr', '': 'ffr', '': 'fopf', '': 'fscr', '': 'Ffr', '': 'Fopf', : 'Fscr', : 'fflig', : 'ffilig', : 'ffllig', : 'filig', fj: 'fjlig', : 'fllig', : 'fnof', : 'gscr', '': 'gopf', '': 'gfr', '': 'Gscr', '': 'Gopf', '': 'Gfr', : 'gacute', : 'gbreve', : 'Gbreve', : 'gcirc', : 'Gcirc', : 'gdot', : 'Gdot', : 'Gcedil', '': 'hfr', : 'planckh', '': 'hscr', '': 'hopf', : 'Hscr', : 'Hfr', : 'Hopf', : 'hcirc', : 'Hcirc', : 'hbar', : 'hstrok', : 'Hstrok', '': 'iopf', '': 'ifr', '': 'iscr', : 'ii', '': 'Iopf', : 'Iscr', : 'Im', : 'iacute', : 'Iacute', : 'igrave', : 'Igrave', : 'icirc', : 'Icirc', : 'iuml', : 'Iuml', : 'itilde', : 'Itilde', : 'Idot', : 'iogon', : 'Iogon', : 'imacr', : 'Imacr', : 'ijlig', : 'IJlig', : 'imath', '': 'jscr', '': 'jopf', '': 'jfr', '': 'Jscr', '': 'Jfr', '': 'Jopf', : 'jcirc', : 'Jcirc', : 'jmath', '': 'kopf', '': 'kscr', '': 'kfr', '': 'Kscr', '': 'Kopf', '': 'Kfr', : 'kcedil', : 'Kcedil', '': 'lfr', '': 'lscr', : 'ell', '': 'lopf', : 'Lscr', '': 'Lfr', '': 'Lopf', : 'lacute', : 'Lacute', : 'lcaron', : 'Lcaron', : 'lcedil', : 'Lcedil', : 'lstrok', : 'Lstrok', : 'lmidot', : 'Lmidot', '': 'mfr', '': 'mopf', '': 'mscr', '': 'Mfr', '': 'Mopf', : 'Mscr', '': 'nfr', '': 'nopf', '': 'nscr', : 'Nopf', '': 'Nscr', '': 'Nfr', : 'nacute', : 'Nacute', : 'ncaron', : 'Ncaron', : 'ntilde', : 'Ntilde', : 'ncedil', : 'Ncedil', '': 'numero', : 'eng', : 'ENG', '': 'oopf', '': 'ofr', : 'oscr', '': 'Oscr', '': 'Ofr', '': 'Oopf', : 'ordm', : 'oacute', : 'Oacute', : 'ograve', : 'Ograve', : 'ocirc', : 'Ocirc', : 'ouml', : 'Ouml', : 'odblac', : 'Odblac', : 'otilde', : 'Otilde', : 'oslash', : 'Oslash', : 'omacr', : 'Omacr', : 'oelig', : 'OElig', '': 'pfr', '': 'pscr', '': 'popf', : 'Popf', '': 'Pfr', '': 'Pscr', '': 'qopf', '': 'qfr', '': 'qscr', '': 'Qscr', '': 'Qfr', : 'Qopf', : 'kgreen', '': 'rfr', '': 'ropf', '': 'rscr', : 'Rscr', : 'Re', : 'Ropf', : 'racute', : 'Racute', : 'rcaron', : 'Rcaron', : 'rcedil', : 'Rcedil', '': 'sopf', '': 'sscr', '': 'sfr', '': 'Sopf', '': 'Sfr', '': 'Sscr', '': 'oS', : 'sacute', : 'Sacute', : 'scirc', : 'Scirc', : 'scaron', : 'Scaron', : 'scedil', : 'Scedil', : 'szlig', '': 'tfr', '': 'tscr', '': 'topf', '': 'Tscr', '': 'Tfr', '': 'Topf', : 'tcaron', : 'Tcaron', : 'tcedil', : 'Tcedil', '': 'trade', : 'tstrok', : 'Tstrok', '': 'uscr', '': 'uopf', '': 'ufr', '': 'Uopf', '': 'Ufr', '': 'Uscr', : 'uacute', : 'Uacute', : 'ugrave', : 'Ugrave', : 'ubreve', : 'Ubreve', : 'ucirc', : 'Ucirc', : 'uring', : 'Uring', : 'uuml', : 'Uuml', : 'udblac', : 'Udblac', : 'utilde', : 'Utilde', : 'uogon', : 'Uogon', : 'umacr', : 'Umacr', '': 'vfr', '': 'vopf', '': 'vscr', '': 'Vfr', '': 'Vopf', '': 'Vscr', '': 'wopf', '': 'wscr', '': 'wfr', '': 'Wscr', '': 'Wopf', '': 'Wfr', : 'wcirc', : 'Wcirc', '': 'xfr', '': 'xscr', '': 'xopf', '': 'Xopf', '': 'Xfr', '': 'Xscr', '': 'yfr', '': 'yscr', '': 'yopf', '': 'Yscr', '': 'Yfr', '': 'Yopf', : 'yacute', : 'Yacute', : 'ycirc', : 'Ycirc', : 'yuml', : 'Yuml', '': 'zscr', '': 'zfr', '': 'zopf', : 'Zfr', : 'Zopf', '': 'Zscr', : 'zacute', : 'Zacute', : 'zcaron', : 'Zcaron', : 'zdot', : 'Zdot', : 'imped', : 'thorn', : 'THORN', : 'napos', : 'alpha', : 'Alpha', : 'beta', : 'Beta', : 'gamma', : 'Gamma', : 'delta', : 'Delta', : 'epsi', : 'epsiv', : 'Epsilon', : 'gammad', : 'Gammad', : 'zeta', : 'Zeta', : 'eta', : 'Eta', : 'theta', : 'thetav', : 'Theta', : 'iota', : 'Iota', : 'kappa', : 'kappav', : 'Kappa', : 'lambda', : 'Lambda', : 'mu', : 'micro', : 'Mu', : 'nu', : 'Nu', : 'xi', : 'Xi', : 'omicron', : 'Omicron', : 'pi', : 'piv', : 'Pi', : 'rho', : 'rhov', : 'Rho', : 'sigma', : 'Sigma', : 'sigmaf', : 'tau', : 'Tau', : 'upsi', : 'Upsilon', : 'Upsi', : 'phi', : 'phiv', : 'Phi', : 'chi', : 'Chi', : 'psi', : 'Psi', : 'omega', : 'ohm', : 'acy', : 'Acy', : 'bcy', : 'Bcy', : 'vcy', : 'Vcy', : 'gcy', : 'Gcy', : 'gjcy', : 'GJcy', : 'dcy', : 'Dcy', : 'djcy', : 'DJcy', : 'iecy', : 'IEcy', : 'iocy', : 'IOcy', : 'jukcy', : 'Jukcy', : 'zhcy', : 'ZHcy', : 'zcy', : 'Zcy', : 'dscy', : 'DScy', : 'icy', : 'Icy', : 'iukcy', : 'Iukcy', : 'yicy', : 'YIcy', : 'jcy', : 'Jcy', : 'jsercy', : 'Jsercy', : 'kcy', : 'Kcy', : 'kjcy', : 'KJcy', : 'lcy', : 'Lcy', : 'ljcy', : 'LJcy', : 'mcy', : 'Mcy', : 'ncy', : 'Ncy', : 'njcy', : 'NJcy', : 'ocy', : 'Ocy', : 'pcy', : 'Pcy', : 'rcy', : 'Rcy', : 'scy', : 'Scy', : 'tcy', : 'Tcy', : 'tshcy', : 'TSHcy', : 'ucy', : 'Ucy', : 'ubrcy', : 'Ubrcy', : 'fcy', : 'Fcy', : 'khcy', : 'KHcy', : 'tscy', : 'TScy', : 'chcy', : 'CHcy', : 'dzcy', : 'DZcy', : 'shcy', : 'SHcy', : 'shchcy', : 'SHCHcy', : 'hardcy', : 'HARDcy', : 'ycy', : 'Ycy', : 'softcy', : 'SOFTcy', : 'ecy', : 'Ecy', : 'yucy', : 'YUcy', : 'yacy', : 'YAcy', : 'aleph', : 'beth', : 'gimel', : 'daleth',
          }; const p = /["&'<>`]/g; const f = {
            '"': '&quot;', '&': '&amp;', "'": '&#x27;', '<': '&lt;', '>': '&gt;', '`': '&#x60;',
          }; const d = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/; const h = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/; const m = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g; const g = {
            aacute: '', Aacute: '', abreve: '', Abreve: '', ac: '', acd: '', acE: '', acirc: '', Acirc: '', acute: '', acy: '', Acy: '', aelig: '', AElig: '', af: '', afr: '', Afr: '', agrave: '', Agrave: '', alefsym: '', aleph: '', alpha: '', Alpha: '', amacr: '', Amacr: '', amalg: '', amp: '&', AMP: '&', and: '', And: '', andand: '', andd: '', andslope: '', andv: '', ang: '', ange: '', angle: '', angmsd: '', angmsdaa: '', angmsdab: '', angmsdac: '', angmsdad: '', angmsdae: '', angmsdaf: '', angmsdag: '', angmsdah: '', angrt: '', angrtvb: '', angrtvbd: '', angsph: '', angst: '', angzarr: '', aogon: '', Aogon: '', aopf: '', Aopf: '', ap: '', apacir: '', ape: '', apE: '', apid: '', apos: "'", ApplyFunction: '', approx: '', approxeq: '', aring: '', Aring: '', ascr: '', Ascr: '', Assign: '', ast: '*', asymp: '', asympeq: '', atilde: '', Atilde: '', auml: '', Auml: '', awconint: '', awint: '', backcong: '', backepsilon: '', backprime: '', backsim: '', backsimeq: '', Backslash: '', Barv: '', barvee: '', barwed: '', Barwed: '', barwedge: '', bbrk: '', bbrktbrk: '', bcong: '', bcy: '', Bcy: '', bdquo: '', becaus: '', because: '', Because: '', bemptyv: '', bepsi: '', bernou: '', Bernoullis: '', beta: '', Beta: '', beth: '', between: '', bfr: '', Bfr: '', bigcap: '', bigcirc: '', bigcup: '', bigodot: '', bigoplus: '', bigotimes: '', bigsqcup: '', bigstar: '', bigtriangledown: '', bigtriangleup: '', biguplus: '', bigvee: '', bigwedge: '', bkarow: '', blacklozenge: '', blacksquare: '', blacktriangle: '', blacktriangledown: '', blacktriangleleft: '', blacktriangleright: '', blank: '', blk12: '', blk14: '', blk34: '', block: '', bne: '=', bnequiv: '', bnot: '', bNot: '', bopf: '', Bopf: '', bot: '', bottom: '', bowtie: '', boxbox: '', boxdl: '', boxdL: '', boxDl: '', boxDL: '', boxdr: '', boxdR: '', boxDr: '', boxDR: '', boxh: '', boxH: '', boxhd: '', boxhD: '', boxHd: '', boxHD: '', boxhu: '', boxhU: '', boxHu: '', boxHU: '', boxminus: '', boxplus: '', boxtimes: '', boxul: '', boxuL: '', boxUl: '', boxUL: '', boxur: '', boxuR: '', boxUr: '', boxUR: '', boxv: '', boxV: '', boxvh: '', boxvH: '', boxVh: '', boxVH: '', boxvl: '', boxvL: '', boxVl: '', boxVL: '', boxvr: '', boxvR: '', boxVr: '', boxVR: '', bprime: '', breve: '', Breve: '', brvbar: '', bscr: '', Bscr: '', bsemi: '', bsim: '', bsime: '', bsol: '\\', bsolb: '', bsolhsub: '', bull: '', bullet: '', bump: '', bumpe: '', bumpE: '', bumpeq: '', Bumpeq: '', cacute: '', Cacute: '', cap: '', Cap: '', capand: '', capbrcup: '', capcap: '', capcup: '', capdot: '', CapitalDifferentialD: '', caps: '', caret: '', caron: '', Cayleys: '', ccaps: '', ccaron: '', Ccaron: '', ccedil: '', Ccedil: '', ccirc: '', Ccirc: '', Cconint: '', ccups: '', ccupssm: '', cdot: '', Cdot: '', cedil: '', Cedilla: '', cemptyv: '', cent: '', centerdot: '', CenterDot: '', cfr: '', Cfr: '', chcy: '', CHcy: '', check: '', checkmark: '', chi: '', Chi: '', cir: '', circ: '', circeq: '', circlearrowleft: '', circlearrowright: '', circledast: '', circledcirc: '', circleddash: '', CircleDot: '', circledR: '', circledS: '', CircleMinus: '', CirclePlus: '', CircleTimes: '', cire: '', cirE: '', cirfnint: '', cirmid: '', cirscir: '', ClockwiseContourIntegral: '', CloseCurlyDoubleQuote: '', CloseCurlyQuote: '', clubs: '', clubsuit: '', colon: ':', Colon: '', colone: '', Colone: '', coloneq: '', comma: ',', commat: '@', comp: '', compfn: '', complement: '', complexes: '', cong: '', congdot: '', Congruent: '', conint: '', Conint: '', ContourIntegral: '', copf: '', Copf: '', coprod: '', Coproduct: '', copy: '', COPY: '', copysr: '', CounterClockwiseContourIntegral: '', crarr: '', cross: '', Cross: '', cscr: '', Cscr: '', csub: '', csube: '', csup: '', csupe: '', ctdot: '', cudarrl: '', cudarrr: '', cuepr: '', cuesc: '', cularr: '', cularrp: '', cup: '', Cup: '', cupbrcap: '', cupcap: '', CupCap: '', cupcup: '', cupdot: '', cupor: '', cups: '', curarr: '', curarrm: '', curlyeqprec: '', curlyeqsucc: '', curlyvee: '', curlywedge: '', curren: '', curvearrowleft: '', curvearrowright: '', cuvee: '', cuwed: '', cwconint: '', cwint: '', cylcty: '', dagger: '', Dagger: '', daleth: '', darr: '', dArr: '', Darr: '', dash: '', dashv: '', Dashv: '', dbkarow: '', dblac: '', dcaron: '', Dcaron: '', dcy: '', Dcy: '', dd: '', DD: '', ddagger: '', ddarr: '', DDotrahd: '', ddotseq: '', deg: '', Del: '', delta: '', Delta: '', demptyv: '', dfisht: '', dfr: '', Dfr: '', dHar: '', dharl: '', dharr: '', DiacriticalAcute: '', DiacriticalDot: '', DiacriticalDoubleAcute: '', DiacriticalGrave: '`', DiacriticalTilde: '', diam: '', diamond: '', Diamond: '', diamondsuit: '', diams: '', die: '', DifferentialD: '', digamma: '', disin: '', div: '', divide: '', divideontimes: '', divonx: '', djcy: '', DJcy: '', dlcorn: '', dlcrop: '', dollar: '$', dopf: '', Dopf: '', dot: '', Dot: '', DotDot: '', doteq: '', doteqdot: '', DotEqual: '', dotminus: '', dotplus: '', dotsquare: '', doublebarwedge: '', DoubleContourIntegral: '', DoubleDot: '', DoubleDownArrow: '', DoubleLeftArrow: '', DoubleLeftRightArrow: '', DoubleLeftTee: '', DoubleLongLeftArrow: '', DoubleLongLeftRightArrow: '', DoubleLongRightArrow: '', DoubleRightArrow: '', DoubleRightTee: '', DoubleUpArrow: '', DoubleUpDownArrow: '', DoubleVerticalBar: '', downarrow: '', Downarrow: '', DownArrow: '', DownArrowBar: '', DownArrowUpArrow: '', DownBreve: '', downdownarrows: '', downharpoonleft: '', downharpoonright: '', DownLeftRightVector: '', DownLeftTeeVector: '', DownLeftVector: '', DownLeftVectorBar: '', DownRightTeeVector: '', DownRightVector: '', DownRightVectorBar: '', DownTee: '', DownTeeArrow: '', drbkarow: '', drcorn: '', drcrop: '', dscr: '', Dscr: '', dscy: '', DScy: '', dsol: '', dstrok: '', Dstrok: '', dtdot: '', dtri: '', dtrif: '', duarr: '', duhar: '', dwangle: '', dzcy: '', DZcy: '', dzigrarr: '', eacute: '', Eacute: '', easter: '', ecaron: '', Ecaron: '', ecir: '', ecirc: '', Ecirc: '', ecolon: '', ecy: '', Ecy: '', eDDot: '', edot: '', eDot: '', Edot: '', ee: '', efDot: '', efr: '', Efr: '', eg: '', egrave: '', Egrave: '', egs: '', egsdot: '', el: '', Element: '', elinters: '', ell: '', els: '', elsdot: '', emacr: '', Emacr: '', empty: '', emptyset: '', EmptySmallSquare: '', emptyv: '', EmptyVerySmallSquare: '', emsp: '', emsp13: '', emsp14: '', eng: '', ENG: '', ensp: '', eogon: '', Eogon: '', eopf: '', Eopf: '', epar: '', eparsl: '', eplus: '', epsi: '', epsilon: '', Epsilon: '', epsiv: '', eqcirc: '', eqcolon: '', eqsim: '', eqslantgtr: '', eqslantless: '', Equal: '', equals: '=', EqualTilde: '', equest: '', Equilibrium: '', equiv: '', equivDD: '', eqvparsl: '', erarr: '', erDot: '', escr: '', Escr: '', esdot: '', esim: '', Esim: '', eta: '', Eta: '', eth: '', ETH: '', euml: '', Euml: '', euro: '', excl: '!', exist: '', Exists: '', expectation: '', exponentiale: '', ExponentialE: '', fallingdotseq: '', fcy: '', Fcy: '', female: '', ffilig: '', fflig: '', ffllig: '', ffr: '', Ffr: '', filig: '', FilledSmallSquare: '', FilledVerySmallSquare: '', fjlig: 'fj', flat: '', fllig: '', fltns: '', fnof: '', fopf: '', Fopf: '', forall: '', ForAll: '', fork: '', forkv: '', Fouriertrf: '', fpartint: '', frac12: '', frac13: '', frac14: '', frac15: '', frac16: '', frac18: '', frac23: '', frac25: '', frac34: '', frac35: '', frac38: '', frac45: '', frac56: '', frac58: '', frac78: '', frasl: '', frown: '', fscr: '', Fscr: '', gacute: '', gamma: '', Gamma: '', gammad: '', Gammad: '', gap: '', gbreve: '', Gbreve: '', Gcedil: '', gcirc: '', Gcirc: '', gcy: '', Gcy: '', gdot: '', Gdot: '', ge: '', gE: '', gel: '', gEl: '', geq: '', geqq: '', geqslant: '', ges: '', gescc: '', gesdot: '', gesdoto: '', gesdotol: '', gesl: '', gesles: '', gfr: '', Gfr: '', gg: '', Gg: '', ggg: '', gimel: '', gjcy: '', GJcy: '', gl: '', gla: '', glE: '', glj: '', gnap: '', gnapprox: '', gne: '', gnE: '', gneq: '', gneqq: '', gnsim: '', gopf: '', Gopf: '', grave: '`', GreaterEqual: '', GreaterEqualLess: '', GreaterFullEqual: '', GreaterGreater: '', GreaterLess: '', GreaterSlantEqual: '', GreaterTilde: '', gscr: '', Gscr: '', gsim: '', gsime: '', gsiml: '', gt: '>', Gt: '', GT: '>', gtcc: '', gtcir: '', gtdot: '', gtlPar: '', gtquest: '', gtrapprox: '', gtrarr: '', gtrdot: '', gtreqless: '', gtreqqless: '', gtrless: '', gtrsim: '', gvertneqq: '', gvnE: '', Hacek: '', hairsp: '', half: '', hamilt: '', hardcy: '', HARDcy: '', harr: '', hArr: '', harrcir: '', harrw: '', Hat: '^', hbar: '', hcirc: '', Hcirc: '', hearts: '', heartsuit: '', hellip: '', hercon: '', hfr: '', Hfr: '', HilbertSpace: '', hksearow: '', hkswarow: '', hoarr: '', homtht: '', hookleftarrow: '', hookrightarrow: '', hopf: '', Hopf: '', horbar: '', HorizontalLine: '', hscr: '', Hscr: '', hslash: '', hstrok: '', Hstrok: '', HumpDownHump: '', HumpEqual: '', hybull: '', hyphen: '', iacute: '', Iacute: '', ic: '', icirc: '', Icirc: '', icy: '', Icy: '', Idot: '', iecy: '', IEcy: '', iexcl: '', iff: '', ifr: '', Ifr: '', igrave: '', Igrave: '', ii: '', iiiint: '', iiint: '', iinfin: '', iiota: '', ijlig: '', IJlig: '', Im: '', imacr: '', Imacr: '', image: '', ImaginaryI: '', imagline: '', imagpart: '', imath: '', imof: '', imped: '', Implies: '', in: '', incare: '', infin: '', infintie: '', inodot: '', int: '', Int: '', intcal: '', integers: '', Integral: '', intercal: '', Intersection: '', intlarhk: '', intprod: '', InvisibleComma: '', InvisibleTimes: '', iocy: '', IOcy: '', iogon: '', Iogon: '', iopf: '', Iopf: '', iota: '', Iota: '', iprod: '', iquest: '', iscr: '', Iscr: '', isin: '', isindot: '', isinE: '', isins: '', isinsv: '', isinv: '', it: '', itilde: '', Itilde: '', iukcy: '', Iukcy: '', iuml: '', Iuml: '', jcirc: '', Jcirc: '', jcy: '', Jcy: '', jfr: '', Jfr: '', jmath: '', jopf: '', Jopf: '', jscr: '', Jscr: '', jsercy: '', Jsercy: '', jukcy: '', Jukcy: '', kappa: '', Kappa: '', kappav: '', kcedil: '', Kcedil: '', kcy: '', Kcy: '', kfr: '', Kfr: '', kgreen: '', khcy: '', KHcy: '', kjcy: '', KJcy: '', kopf: '', Kopf: '', kscr: '', Kscr: '', lAarr: '', lacute: '', Lacute: '', laemptyv: '', lagran: '', lambda: '', Lambda: '', lang: '', Lang: '', langd: '', langle: '', lap: '', Laplacetrf: '', laquo: '', larr: '', lArr: '', Larr: '', larrb: '', larrbfs: '', larrfs: '', larrhk: '', larrlp: '', larrpl: '', larrsim: '', larrtl: '', lat: '', latail: '', lAtail: '', late: '', lates: '', lbarr: '', lBarr: '', lbbrk: '', lbrace: '{', lbrack: '[', lbrke: '', lbrksld: '', lbrkslu: '', lcaron: '', Lcaron: '', lcedil: '', Lcedil: '', lceil: '', lcub: '{', lcy: '', Lcy: '', ldca: '', ldquo: '', ldquor: '', ldrdhar: '', ldrushar: '', ldsh: '', le: '', lE: '', LeftAngleBracket: '', leftarrow: '', Leftarrow: '', LeftArrow: '', LeftArrowBar: '', LeftArrowRightArrow: '', leftarrowtail: '', LeftCeiling: '', LeftDoubleBracket: '', LeftDownTeeVector: '', LeftDownVector: '', LeftDownVectorBar: '', LeftFloor: '', leftharpoondown: '', leftharpoonup: '', leftleftarrows: '', leftrightarrow: '', Leftrightarrow: '', LeftRightArrow: '', leftrightarrows: '', leftrightharpoons: '', leftrightsquigarrow: '', LeftRightVector: '', LeftTee: '', LeftTeeArrow: '', LeftTeeVector: '', leftthreetimes: '', LeftTriangle: '', LeftTriangleBar: '', LeftTriangleEqual: '', LeftUpDownVector: '', LeftUpTeeVector: '', LeftUpVector: '', LeftUpVectorBar: '', LeftVector: '', LeftVectorBar: '', leg: '', lEg: '', leq: '', leqq: '', leqslant: '', les: '', lescc: '', lesdot: '', lesdoto: '', lesdotor: '', lesg: '', lesges: '', lessapprox: '', lessdot: '', lesseqgtr: '', lesseqqgtr: '', LessEqualGreater: '', LessFullEqual: '', LessGreater: '', lessgtr: '', LessLess: '', lesssim: '', LessSlantEqual: '', LessTilde: '', lfisht: '', lfloor: '', lfr: '', Lfr: '', lg: '', lgE: '', lHar: '', lhard: '', lharu: '', lharul: '', lhblk: '', ljcy: '', LJcy: '', ll: '', Ll: '', llarr: '', llcorner: '', Lleftarrow: '', llhard: '', lltri: '', lmidot: '', Lmidot: '', lmoust: '', lmoustache: '', lnap: '', lnapprox: '', lne: '', lnE: '', lneq: '', lneqq: '', lnsim: '', loang: '', loarr: '', lobrk: '', longleftarrow: '', Longleftarrow: '', LongLeftArrow: '', longleftrightarrow: '', Longleftrightarrow: '', LongLeftRightArrow: '', longmapsto: '', longrightarrow: '', Longrightarrow: '', LongRightArrow: '', looparrowleft: '', looparrowright: '', lopar: '', lopf: '', Lopf: '', loplus: '', lotimes: '', lowast: '', lowbar: '_', LowerLeftArrow: '', LowerRightArrow: '', loz: '', lozenge: '', lozf: '', lpar: '(', lparlt: '', lrarr: '', lrcorner: '', lrhar: '', lrhard: '', lrm: '', lrtri: '', lsaquo: '', lscr: '', Lscr: '', lsh: '', Lsh: '', lsim: '', lsime: '', lsimg: '', lsqb: '[', lsquo: '', lsquor: '', lstrok: '', Lstrok: '', lt: '<', Lt: '', LT: '<', ltcc: '', ltcir: '', ltdot: '', lthree: '', ltimes: '', ltlarr: '', ltquest: '', ltri: '', ltrie: '', ltrif: '', ltrPar: '', lurdshar: '', luruhar: '', lvertneqq: '', lvnE: '', macr: '', male: '', malt: '', maltese: '', map: '', Map: '', mapsto: '', mapstodown: '', mapstoleft: '', mapstoup: '', marker: '', mcomma: '', mcy: '', Mcy: '', mdash: '', mDDot: '', measuredangle: '', MediumSpace: '', Mellintrf: '', mfr: '', Mfr: '', mho: '', micro: '', mid: '', midast: '*', midcir: '', middot: '', minus: '', minusb: '', minusd: '', minusdu: '', MinusPlus: '', mlcp: '', mldr: '', mnplus: '', models: '', mopf: '', Mopf: '', mp: '', mscr: '', Mscr: '', mstpos: '', mu: '', Mu: '', multimap: '', mumap: '', nabla: '', nacute: '', Nacute: '', nang: '', nap: '', napE: '', napid: '', napos: '', napprox: '', natur: '', natural: '', naturals: '', nbsp: '', nbump: '', nbumpe: '', ncap: '', ncaron: '', Ncaron: '', ncedil: '', Ncedil: '', ncong: '', ncongdot: '', ncup: '', ncy: '', Ncy: '', ndash: '', ne: '', nearhk: '', nearr: '', neArr: '', nearrow: '', nedot: '', NegativeMediumSpace: '', NegativeThickSpace: '', NegativeThinSpace: '', NegativeVeryThinSpace: '', nequiv: '', nesear: '', nesim: '', NestedGreaterGreater: '', NestedLessLess: '', NewLine: '\n', nexist: '', nexists: '', nfr: '', Nfr: '', nge: '', ngE: '', ngeq: '', ngeqq: '', ngeqslant: '', nges: '', nGg: '', ngsim: '', ngt: '', nGt: '', ngtr: '', nGtv: '', nharr: '', nhArr: '', nhpar: '', ni: '', nis: '', nisd: '', niv: '', njcy: '', NJcy: '', nlarr: '', nlArr: '', nldr: '', nle: '', nlE: '', nleftarrow: '', nLeftarrow: '', nleftrightarrow: '', nLeftrightarrow: '', nleq: '', nleqq: '', nleqslant: '', nles: '', nless: '', nLl: '', nlsim: '', nlt: '', nLt: '', nltri: '', nltrie: '', nLtv: '', nmid: '', NoBreak: '', NonBreakingSpace: '', nopf: '', Nopf: '', not: '', Not: '', NotCongruent: '', NotCupCap: '', NotDoubleVerticalBar: '', NotElement: '', NotEqual: '', NotEqualTilde: '', NotExists: '', NotGreater: '', NotGreaterEqual: '', NotGreaterFullEqual: '', NotGreaterGreater: '', NotGreaterLess: '', NotGreaterSlantEqual: '', NotGreaterTilde: '', NotHumpDownHump: '', NotHumpEqual: '', notin: '', notindot: '', notinE: '', notinva: '', notinvb: '', notinvc: '', NotLeftTriangle: '', NotLeftTriangleBar: '', NotLeftTriangleEqual: '', NotLess: '', NotLessEqual: '', NotLessGreater: '', NotLessLess: '', NotLessSlantEqual: '', NotLessTilde: '', NotNestedGreaterGreater: '', NotNestedLessLess: '', notni: '', notniva: '', notnivb: '', notnivc: '', NotPrecedes: '', NotPrecedesEqual: '', NotPrecedesSlantEqual: '', NotReverseElement: '', NotRightTriangle: '', NotRightTriangleBar: '', NotRightTriangleEqual: '', NotSquareSubset: '', NotSquareSubsetEqual: '', NotSquareSuperset: '', NotSquareSupersetEqual: '', NotSubset: '', NotSubsetEqual: '', NotSucceeds: '', NotSucceedsEqual: '', NotSucceedsSlantEqual: '', NotSucceedsTilde: '', NotSuperset: '', NotSupersetEqual: '', NotTilde: '', NotTildeEqual: '', NotTildeFullEqual: '', NotTildeTilde: '', NotVerticalBar: '', npar: '', nparallel: '', nparsl: '', npart: '', npolint: '', npr: '', nprcue: '', npre: '', nprec: '', npreceq: '', nrarr: '', nrArr: '', nrarrc: '', nrarrw: '', nrightarrow: '', nRightarrow: '', nrtri: '', nrtrie: '', nsc: '', nsccue: '', nsce: '', nscr: '', Nscr: '', nshortmid: '', nshortparallel: '', nsim: '', nsime: '', nsimeq: '', nsmid: '', nspar: '', nsqsube: '', nsqsupe: '', nsub: '', nsube: '', nsubE: '', nsubset: '', nsubseteq: '', nsubseteqq: '', nsucc: '', nsucceq: '', nsup: '', nsupe: '', nsupE: '', nsupset: '', nsupseteq: '', nsupseteqq: '', ntgl: '', ntilde: '', Ntilde: '', ntlg: '', ntriangleleft: '', ntrianglelefteq: '', ntriangleright: '', ntrianglerighteq: '', nu: '', Nu: '', num: '#', numero: '', numsp: '', nvap: '', nvdash: '', nvDash: '', nVdash: '', nVDash: '', nvge: '', nvgt: '>', nvHarr: '', nvinfin: '', nvlArr: '', nvle: '', nvlt: '<', nvltrie: '', nvrArr: '', nvrtrie: '', nvsim: '', nwarhk: '', nwarr: '', nwArr: '', nwarrow: '', nwnear: '', oacute: '', Oacute: '', oast: '', ocir: '', ocirc: '', Ocirc: '', ocy: '', Ocy: '', odash: '', odblac: '', Odblac: '', odiv: '', odot: '', odsold: '', oelig: '', OElig: '', ofcir: '', ofr: '', Ofr: '', ogon: '', ograve: '', Ograve: '', ogt: '', ohbar: '', ohm: '', oint: '', olarr: '', olcir: '', olcross: '', oline: '', olt: '', omacr: '', Omacr: '', omega: '', Omega: '', omicron: '', Omicron: '', omid: '', ominus: '', oopf: '', Oopf: '', opar: '', OpenCurlyDoubleQuote: '', OpenCurlyQuote: '', operp: '', oplus: '', or: '', Or: '', orarr: '', ord: '', order: '', orderof: '', ordf: '', ordm: '', origof: '', oror: '', orslope: '', orv: '', oS: '', oscr: '', Oscr: '', oslash: '', Oslash: '', osol: '', otilde: '', Otilde: '', otimes: '', Otimes: '', otimesas: '', ouml: '', Ouml: '', ovbar: '', OverBar: '', OverBrace: '', OverBracket: '', OverParenthesis: '', par: '', para: '', parallel: '', parsim: '', parsl: '', part: '', PartialD: '', pcy: '', Pcy: '', percnt: '%', period: '.', permil: '', perp: '', pertenk: '', pfr: '', Pfr: '', phi: '', Phi: '', phiv: '', phmmat: '', phone: '', pi: '', Pi: '', pitchfork: '', piv: '', planck: '', planckh: '', plankv: '', plus: '+', plusacir: '', plusb: '', pluscir: '', plusdo: '', plusdu: '', pluse: '', PlusMinus: '', plusmn: '', plussim: '', plustwo: '', pm: '', Poincareplane: '', pointint: '', popf: '', Popf: '', pound: '', pr: '', Pr: '', prap: '', prcue: '', pre: '', prE: '', prec: '', precapprox: '', preccurlyeq: '', Precedes: '', PrecedesEqual: '', PrecedesSlantEqual: '', PrecedesTilde: '', preceq: '', precnapprox: '', precneqq: '', precnsim: '', precsim: '', prime: '', Prime: '', primes: '', prnap: '', prnE: '', prnsim: '', prod: '', Product: '', profalar: '', profline: '', profsurf: '', prop: '', Proportion: '', Proportional: '', propto: '', prsim: '', prurel: '', pscr: '', Pscr: '', psi: '', Psi: '', puncsp: '', qfr: '', Qfr: '', qint: '', qopf: '', Qopf: '', qprime: '', qscr: '', Qscr: '', quaternions: '', quatint: '', quest: '?', questeq: '', quot: '"', QUOT: '"', rAarr: '', race: '', racute: '', Racute: '', radic: '', raemptyv: '', rang: '', Rang: '', rangd: '', range: '', rangle: '', raquo: '', rarr: '', rArr: '', Rarr: '', rarrap: '', rarrb: '', rarrbfs: '', rarrc: '', rarrfs: '', rarrhk: '', rarrlp: '', rarrpl: '', rarrsim: '', rarrtl: '', Rarrtl: '', rarrw: '', ratail: '', rAtail: '', ratio: '', rationals: '', rbarr: '', rBarr: '', RBarr: '', rbbrk: '', rbrace: '}', rbrack: ']', rbrke: '', rbrksld: '', rbrkslu: '', rcaron: '', Rcaron: '', rcedil: '', Rcedil: '', rceil: '', rcub: '}', rcy: '', Rcy: '', rdca: '', rdldhar: '', rdquo: '', rdquor: '', rdsh: '', Re: '', real: '', realine: '', realpart: '', reals: '', rect: '', reg: '', REG: '', ReverseElement: '', ReverseEquilibrium: '', ReverseUpEquilibrium: '', rfisht: '', rfloor: '', rfr: '', Rfr: '', rHar: '', rhard: '', rharu: '', rharul: '', rho: '', Rho: '', rhov: '', RightAngleBracket: '', rightarrow: '', Rightarrow: '', RightArrow: '', RightArrowBar: '', RightArrowLeftArrow: '', rightarrowtail: '', RightCeiling: '', RightDoubleBracket: '', RightDownTeeVector: '', RightDownVector: '', RightDownVectorBar: '', RightFloor: '', rightharpoondown: '', rightharpoonup: '', rightleftarrows: '', rightleftharpoons: '', rightrightarrows: '', rightsquigarrow: '', RightTee: '', RightTeeArrow: '', RightTeeVector: '', rightthreetimes: '', RightTriangle: '', RightTriangleBar: '', RightTriangleEqual: '', RightUpDownVector: '', RightUpTeeVector: '', RightUpVector: '', RightUpVectorBar: '', RightVector: '', RightVectorBar: '', ring: '', risingdotseq: '', rlarr: '', rlhar: '', rlm: '', rmoust: '', rmoustache: '', rnmid: '', roang: '', roarr: '', robrk: '', ropar: '', ropf: '', Ropf: '', roplus: '', rotimes: '', RoundImplies: '', rpar: ')', rpargt: '', rppolint: '', rrarr: '', Rrightarrow: '', rsaquo: '', rscr: '', Rscr: '', rsh: '', Rsh: '', rsqb: ']', rsquo: '', rsquor: '', rthree: '', rtimes: '', rtri: '', rtrie: '', rtrif: '', rtriltri: '', RuleDelayed: '', ruluhar: '', rx: '', sacute: '', Sacute: '', sbquo: '', sc: '', Sc: '', scap: '', scaron: '', Scaron: '', sccue: '', sce: '', scE: '', scedil: '', Scedil: '', scirc: '', Scirc: '', scnap: '', scnE: '', scnsim: '', scpolint: '', scsim: '', scy: '', Scy: '', sdot: '', sdotb: '', sdote: '', searhk: '', searr: '', seArr: '', searrow: '', sect: '', semi: ';', seswar: '', setminus: '', setmn: '', sext: '', sfr: '', Sfr: '', sfrown: '', sharp: '', shchcy: '', SHCHcy: '', shcy: '', SHcy: '', ShortDownArrow: '', ShortLeftArrow: '', shortmid: '', shortparallel: '', ShortRightArrow: '', ShortUpArrow: '', shy: '', sigma: '', Sigma: '', sigmaf: '', sigmav: '', sim: '', simdot: '', sime: '', simeq: '', simg: '', simgE: '', siml: '', simlE: '', simne: '', simplus: '', simrarr: '', slarr: '', SmallCircle: '', smallsetminus: '', smashp: '', smeparsl: '', smid: '', smile: '', smt: '', smte: '', smtes: '', softcy: '', SOFTcy: '', sol: '/', solb: '', solbar: '', sopf: '', Sopf: '', spades: '', spadesuit: '', spar: '', sqcap: '', sqcaps: '', sqcup: '', sqcups: '', Sqrt: '', sqsub: '', sqsube: '', sqsubset: '', sqsubseteq: '', sqsup: '', sqsupe: '', sqsupset: '', sqsupseteq: '', squ: '', square: '', Square: '', SquareIntersection: '', SquareSubset: '', SquareSubsetEqual: '', SquareSuperset: '', SquareSupersetEqual: '', SquareUnion: '', squarf: '', squf: '', srarr: '', sscr: '', Sscr: '', ssetmn: '', ssmile: '', sstarf: '', star: '', Star: '', starf: '', straightepsilon: '', straightphi: '', strns: '', sub: '', Sub: '', subdot: '', sube: '', subE: '', subedot: '', submult: '', subne: '', subnE: '', subplus: '', subrarr: '', subset: '', Subset: '', subseteq: '', subseteqq: '', SubsetEqual: '', subsetneq: '', subsetneqq: '', subsim: '', subsub: '', subsup: '', succ: '', succapprox: '', succcurlyeq: '', Succeeds: '', SucceedsEqual: '', SucceedsSlantEqual: '', SucceedsTilde: '', succeq: '', succnapprox: '', succneqq: '', succnsim: '', succsim: '', SuchThat: '', sum: '', Sum: '', sung: '', sup: '', Sup: '', sup1: '', sup2: '', sup3: '', supdot: '', supdsub: '', supe: '', supE: '', supedot: '', Superset: '', SupersetEqual: '', suphsol: '', suphsub: '', suplarr: '', supmult: '', supne: '', supnE: '', supplus: '', supset: '', Supset: '', supseteq: '', supseteqq: '', supsetneq: '', supsetneqq: '', supsim: '', supsub: '', supsup: '', swarhk: '', swarr: '', swArr: '', swarrow: '', swnwar: '', szlig: '', Tab: '\t', target: '', tau: '', Tau: '', tbrk: '', tcaron: '', Tcaron: '', tcedil: '', Tcedil: '', tcy: '', Tcy: '', tdot: '', telrec: '', tfr: '', Tfr: '', there4: '', therefore: '', Therefore: '', theta: '', Theta: '', thetasym: '', thetav: '', thickapprox: '', thicksim: '', ThickSpace: '', thinsp: '', ThinSpace: '', thkap: '', thksim: '', thorn: '', THORN: '', tilde: '', Tilde: '', TildeEqual: '', TildeFullEqual: '', TildeTilde: '', times: '', timesb: '', timesbar: '', timesd: '', tint: '', toea: '', top: '', topbot: '', topcir: '', topf: '', Topf: '', topfork: '', tosa: '', tprime: '', trade: '', TRADE: '', triangle: '', triangledown: '', triangleleft: '', trianglelefteq: '', triangleq: '', triangleright: '', trianglerighteq: '', tridot: '', trie: '', triminus: '', TripleDot: '', triplus: '', trisb: '', tritime: '', trpezium: '', tscr: '', Tscr: '', tscy: '', TScy: '', tshcy: '', TSHcy: '', tstrok: '', Tstrok: '', twixt: '', twoheadleftarrow: '', twoheadrightarrow: '', uacute: '', Uacute: '', uarr: '', uArr: '', Uarr: '', Uarrocir: '', ubrcy: '', Ubrcy: '', ubreve: '', Ubreve: '', ucirc: '', Ucirc: '', ucy: '', Ucy: '', udarr: '', udblac: '', Udblac: '', udhar: '', ufisht: '', ufr: '', Ufr: '', ugrave: '', Ugrave: '', uHar: '', uharl: '', uharr: '', uhblk: '', ulcorn: '', ulcorner: '', ulcrop: '', ultri: '', umacr: '', Umacr: '', uml: '', UnderBar: '_', UnderBrace: '', UnderBracket: '', UnderParenthesis: '', Union: '', UnionPlus: '', uogon: '', Uogon: '', uopf: '', Uopf: '', uparrow: '', Uparrow: '', UpArrow: '', UpArrowBar: '', UpArrowDownArrow: '', updownarrow: '', Updownarrow: '', UpDownArrow: '', UpEquilibrium: '', upharpoonleft: '', upharpoonright: '', uplus: '', UpperLeftArrow: '', UpperRightArrow: '', upsi: '', Upsi: '', upsih: '', upsilon: '', Upsilon: '', UpTee: '', UpTeeArrow: '', upuparrows: '', urcorn: '', urcorner: '', urcrop: '', uring: '', Uring: '', urtri: '', uscr: '', Uscr: '', utdot: '', utilde: '', Utilde: '', utri: '', utrif: '', uuarr: '', uuml: '', Uuml: '', uwangle: '', vangrt: '', varepsilon: '', varkappa: '', varnothing: '', varphi: '', varpi: '', varpropto: '', varr: '', vArr: '', varrho: '', varsigma: '', varsubsetneq: '', varsubsetneqq: '', varsupsetneq: '', varsupsetneqq: '', vartheta: '', vartriangleleft: '', vartriangleright: '', vBar: '', Vbar: '', vBarv: '', vcy: '', Vcy: '', vdash: '', vDash: '', Vdash: '', VDash: '', Vdashl: '', vee: '', Vee: '', veebar: '', veeeq: '', vellip: '', verbar: '|', Verbar: '', vert: '|', Vert: '', VerticalBar: '', VerticalLine: '|', VerticalSeparator: '', VerticalTilde: '', VeryThinSpace: '', vfr: '', Vfr: '', vltri: '', vnsub: '', vnsup: '', vopf: '', Vopf: '', vprop: '', vrtri: '', vscr: '', Vscr: '', vsubne: '', vsubnE: '', vsupne: '', vsupnE: '', Vvdash: '', vzigzag: '', wcirc: '', Wcirc: '', wedbar: '', wedge: '', Wedge: '', wedgeq: '', weierp: '', wfr: '', Wfr: '', wopf: '', Wopf: '', wp: '', wr: '', wreath: '', wscr: '', Wscr: '', xcap: '', xcirc: '', xcup: '', xdtri: '', xfr: '', Xfr: '', xharr: '', xhArr: '', xi: '', Xi: '', xlarr: '', xlArr: '', xmap: '', xnis: '', xodot: '', xopf: '', Xopf: '', xoplus: '', xotime: '', xrarr: '', xrArr: '', xscr: '', Xscr: '', xsqcup: '', xuplus: '', xutri: '', xvee: '', xwedge: '', yacute: '', Yacute: '', yacy: '', YAcy: '', ycirc: '', Ycirc: '', ycy: '', Ycy: '', yen: '', yfr: '', Yfr: '', yicy: '', YIcy: '', yopf: '', Yopf: '', yscr: '', Yscr: '', yucy: '', YUcy: '', yuml: '', Yuml: '', zacute: '', Zacute: '', zcaron: '', Zcaron: '', zcy: '', Zcy: '', zdot: '', Zdot: '', zeetrf: '', ZeroWidthSpace: '', zeta: '', Zeta: '', zfr: '', Zfr: '', zhcy: '', ZHcy: '', zigrarr: '', zopf: '', Zopf: '', zscr: '', Zscr: '', zwj: '', zwnj: '',
          }; const v = {
            aacute: '', Aacute: '', acirc: '', Acirc: '', acute: '', aelig: '', AElig: '', agrave: '', Agrave: '', amp: '&', AMP: '&', aring: '', Aring: '', atilde: '', Atilde: '', auml: '', Auml: '', brvbar: '', ccedil: '', Ccedil: '', cedil: '', cent: '', copy: '', COPY: '', curren: '', deg: '', divide: '', eacute: '', Eacute: '', ecirc: '', Ecirc: '', egrave: '', Egrave: '', eth: '', ETH: '', euml: '', Euml: '', frac12: '', frac14: '', frac34: '', gt: '>', GT: '>', iacute: '', Iacute: '', icirc: '', Icirc: '', iexcl: '', igrave: '', Igrave: '', iquest: '', iuml: '', Iuml: '', laquo: '', lt: '<', LT: '<', macr: '', micro: '', middot: '', nbsp: '', not: '', ntilde: '', Ntilde: '', oacute: '', Oacute: '', ocirc: '', Ocirc: '', ograve: '', Ograve: '', ordf: '', ordm: '', oslash: '', Oslash: '', otilde: '', Otilde: '', ouml: '', Ouml: '', para: '', plusmn: '', pound: '', quot: '"', QUOT: '"', raquo: '', reg: '', REG: '', sect: '', shy: '', sup1: '', sup2: '', sup3: '', szlig: '', thorn: '', THORN: '', times: '', uacute: '', Uacute: '', ucirc: '', Ucirc: '', ugrave: '', Ugrave: '', uml: '', uuml: '', Uuml: '', yacute: '', Yacute: '', yen: '', yuml: '',
          }; const y = {
            0: '', 128: '', 130: '', 131: '', 132: '', 133: '', 134: '', 135: '', 136: '', 137: '', 138: '', 139: '', 140: '', 142: '', 145: '', 146: '', 147: '', 148: '', 149: '', 150: '', 151: '', 152: '', 153: '', 154: '', 155: '', 156: '', 158: '', 159: '',
          }; const b = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]; const x = String.fromCharCode; const D = {}.hasOwnProperty; const _ = function (e, t) { return D.call(e, t) }; const C = function (e, t) { if (!e) return t; let r; const n = {}; for (r in t)n[r] = _(e, r) ? e[r] : t[r]; return n }; const w = function (e, t) { let r = ''; return e >= 55296 && e <= 57343 || e > 1114111 ? (t && k('character reference outside the permissible Unicode range'), '') : _(y, e) ? (t && k('disallowed character reference'), y[e]) : (t && (function (e, t) { for (let r = -1, n = e.length; ++r < n;) if (e[r] == t) return !0; return !1 }(b, e)) && k('disallowed character reference'), e > 65535 && (r += x((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), r += x(e)) }; const E = function (e) { return `&#x${e.toString(16).toUpperCase()};` }; const S = function (e) { return `&#${e};` }; var k = function (e) { throw Error(`Parse error: ${e}`) }; var A = function (e, t) { (t = C(t, A.options)).strict && h.test(e) && k('forbidden code point'); const r = t.encodeEverything; const n = t.useNamedReferences; const i = t.allowUnsafeSymbols; const a = t.decimal ? S : E; const f = function (e) { return a(e.charCodeAt(0)) }; return r ? (e = e.replace(s, e => (n && _(c, e) ? `&${  c[e]  };`:f(e))), n && (e = e.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;')), n && (e = e.replace(l, e => `&${ c[e] };`))) : n ? (i || (e = e.replace(p, e => `&${c[e]};`)), e = (e = e.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;')).replace(l, e => `&${c[e] };`)) : i || (e = e.replace(p, f)), e.replace(o, (e) => { const t = e.charCodeAt(0); const r = e.charCodeAt(1); return a(1024 * (t - 55296) + r - 56320 + 65536) }).replace(u, f) }; A.options = {
            allowUnsafeSymbols: !1, encodeEverything: !1, strict: !1, useNamedReferences: !1, decimal: !1,
          }; var T = function (e, t) { const r = (t = C(t, T.options)).strict; return r && d.test(e) && k('malformed character reference'), e.replace(m, (e, n, i, a, o, s, u, l) => { let c; let p; let f; let d; let h; let m; return n ? (f = n, p = i, r && !p && k('character reference was not terminated by a semicolon'), c = parseInt(f, 10), w(c, r)) : a ? (d = a, p = o, r && !p && k('character reference was not terminated by a semicolon'), c = parseInt(d, 16), w(c, r)) : s ? _(g, h = s) ? g[h] : (r && k('named character reference was not terminated by a semicolon'), e) : (h = u, (m = l) && t.isAttributeValue ? (r && m == '=' && k('`&` did not start a character reference'), e) : (r && k('named character reference was not terminated by a semicolon'), v[h] + (m || ''))) }) }; T.options = { isAttributeValue: !1, strict: !1 }; const P = {
            version: '1.1.1', encode: A, decode: T, escape(e) { return e.replace(p, e => f[e]) }, unescape: T,
          }; if (n && !n.nodeType) if (i)i.exports = P; else for (const R in P)_(P, R) && (n[R] = P[R]); else r.he = P;
        }(Oe));
      })).decode); function createASTElement(e, t, r) {
        return {
          type: 1, tag: e, attrsList: t, attrsMap: (function makeAttrsMap(e) { for (var t = {}, r = 0, n = e.length; r < n; r++)!t[e[r].name] || V || H || Fe(`duplicate attribute: ${e[r].name}`), t[e[r].name] = e[r].value; return t }(t)), parent: r, children: [],
        };
      } function parse(e, t) {
        Fe = t.warn || baseWarn, Ie = t.isPreTag || d, Be = t.mustUseProp || d, qe = t.getTagNamespace || d, Me = pluckModuleFunction(t.modules, 'transformNode'), je = pluckModuleFunction(t.modules, 'preTransformNode'), Ne = pluckModuleFunction(t.modules, 'postTransformNode'), Le = t.delimiters; let r; let n; const i = []; const a = !1 !== t.preserveWhitespace; let o = !1; let s = !1; let u = !1; function warnOnce(e) { u || (u = !0, Fe(e)) } function closeElement(e) { e.pre && (o = !1), Ie(e.tag) && (s = !1); for (let r = 0; r < Ne.length; r++)Ne[r](e, t); } return parseHTML(e, {
          warn: Fe,
          expectHTML: t.expectHTML,
          isUnaryTag: t.isUnaryTag,
          canBeLeftOpenTag: t.canBeLeftOpenTag,
          shouldDecodeNewlines: t.shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,
          shouldKeepComment: t.comments,
          start: function start(e, a, u) { const l = n && n.ns || qe(e); V && l === 'svg' && (a = (function guardIESVGBug(e) { for (var t = [], r = 0; r < e.length; r++) { const n = e[r]; Xe.test(n.name) || (n.name = n.name.replace(Ye, ''), t.push(n)) } return t }(a))); let c = createASTElement(e, a, n); l && (c.ns = l), (function isForbiddenTag(e) { return e.tag === 'style' || e.tag === 'script' && (!e.attrsMap.type || e.attrsMap.type === 'text/javascript') }(c)) && !J() && (c.forbidden = !0, Fe(`Templates should only be responsible for mapping the state to the UI. Avoid placing tags with side-effects in your templates, such as <${e}>, as they will not be parsed.`)); for (let p = 0; p < je.length; p++)c = je[p](c, t) || c; function checkRootConstraints(e) { e.tag !== 'slot' && e.tag !== 'template' || warnOnce(`Cannot use <${e.tag}> as component root element because it may contain multiple nodes.`), e.attrsMap.hasOwnProperty('v-for') && warnOnce('Cannot use v-for on stateful component root element because it renders multiple elements.') } if (o || (!(function processPre(e) { getAndRemoveAttr(e, 'v-pre') != null && (e.pre = !0) }(c)), c.pre && (o = !0)), Ie(c.tag) && (s = !0), o ? (function processRawAttrs(e) { const t = e.attrsList.length; if (t) for (let r = e.attrs = new Array(t), n = 0; n < t; n++)r[n] = { name: e.attrsList[n].name, value: JSON.stringify(e.attrsList[n].value) }; else e.pre || (e.plain = !0); }(c)) : c.processed || (processFor(c), (function processIf(e) { const t = getAndRemoveAttr(e, 'v-if'); if (t)e.if = t, addIfCondition(e, { exp: t, block: e }); else { getAndRemoveAttr(e, 'v-else') != null && (e.else = !0); const r = getAndRemoveAttr(e, 'v-else-if'); r && (e.elseif = r) } }(c)), (function processOnce(e) { getAndRemoveAttr(e, 'v-once') != null && (e.once = !0) }(c)), processElement(c, t)), r ? i.length || (r.if && (c.elseif || c.else) ? (checkRootConstraints(c), addIfCondition(r, { exp: c.elseif, block: c })) : warnOnce('Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.')) : checkRootConstraints(r = c), n && !c.forbidden) if (c.elseif || c.else)!(function processIfConditions(e, t) { const r = (function findPrevElement(e) { let t = e.length; for (;t--;) { if (e[t].type === 1) return e[t]; e[t].text !== ' ' && Fe(`text "${e[t].text.trim()}" between v-if and v-else(-if) will be ignored.`), e.pop() } }(t.children)); r && r.if ? addIfCondition(r, { exp: e.elseif, block: e }) : Fe(`v-${e.elseif ? `else-if="${e.elseif}"` : 'else'} used on element <${e.tag}> without corresponding v-if.`) }(c, n)); else if (c.slotScope) { n.plain = !1; const f = c.slotTarget || '"default"'; (n.scopedSlots || (n.scopedSlots = {}))[f] = c } else n.children.push(c), c.parent = n; u ? closeElement(c) : (n = c, i.push(c)) },
          end: function end() { const e = i[i.length - 1]; const t = e.children[e.children.length - 1]; t && t.type === 3 && t.text === ' ' && !s && e.children.pop(), i.length -= 1, n = i[i.length - 1], closeElement(e) },
          chars: function chars(t) {
            if (n) {
              if (!V || n.tag !== 'textarea' || n.attrsMap.placeholder !== t) {
                let r; const i = n.children; if (t = s || t.trim() ? (function isTextTag(e) { return e.tag === 'script' || e.tag === 'style' }(n)) ? t : Ke(t) : a && i.length ? ' ' : '') {
                  !o && t !== ' ' && (r = parseText(t, Le)) ? i.push({
                    type: 2, expression: r.expression, tokens: r.tokens, text: t,
                  }) : t === ' ' && i.length && i[i.length - 1].text === ' ' || i.push({ type: 3, text: t });
                }
              }
            } else t === e ? warnOnce('Component template requires a root element, rather than just text.') : (t = t.trim()) && warnOnce(`text "${t}" outside root element will be ignored.`);
          },
          comment: function comment(e) { n.children.push({ type: 3, text: e, isComment: !0 }) },
        }), r;
      } function processElement(e, t) { !(function processKey(e) { const t = getBindingAttr(e, 'key'); t && (e.tag === 'template' && Fe('<template> cannot be keyed. Place the key on real elements instead.'), e.key = t) }(e)), e.plain = !e.key && !e.attrsList.length, (function processRef(e) { const t = getBindingAttr(e, 'ref'); t && (e.ref = t, e.refInFor = (function checkInFor(e) { let t = e; for (;t;) { if (void 0 !== t.for) return !0; t = t.parent } return !1 }(e))) }(e)), (function processSlot(e) { if (e.tag === 'slot')e.slotName = getBindingAttr(e, 'name'), e.key && Fe('`key` does not work on <slot> because slots are abstract outlets and can possibly expand into multiple elements. Use the key on a wrapping element instead.'); else { let t; e.tag === 'template' ? ((t = getAndRemoveAttr(e, 'scope')) && Fe('the "scope" attribute for scoped slots have been deprecated and replaced by "slot-scope" since 2.5. The new "slot-scope" attribute can also be used on plain elements in addition to <template> to denote scoped slots.', !0), e.slotScope = t || getAndRemoveAttr(e, 'slot-scope')) : (t = getAndRemoveAttr(e, 'slot-scope')) && (e.attrsMap['v-for'] && Fe(`Ambiguous combined usage of slot-scope and v-for on <${e.tag}> (v-for takes higher priority). Use a wrapper <template> for the scoped slot to make it clearer.`, !0), e.slotScope = t); const r = getBindingAttr(e, 'slot'); r && (e.slotTarget = r === '""' ? '"default"' : r, e.tag === 'template' || e.slotScope || addAttr(e, 'slot', r)) } }(e)), (function processComponent(e) { let t; (t = getBindingAttr(e, 'is')) && (e.component = t); getAndRemoveAttr(e, 'inline-template') != null && (e.inlineTemplate = !0) }(e)); for (let r = 0; r < Me.length; r++)e = Me[r](e, t) || e; !(function processAttrs(e) { let t; let r; let n; let i; let a; let o; let s; const u = e.attrsList; for (t = 0, r = u.length; t < r; t++) if (n = i = u[t].name, a = u[t].value, ze.test(n)) if (e.hasBindings = !0, (o = parseModifiers(n)) && (n = n.replace(We, '')), Je.test(n))n = n.replace(Je, ''), a = parseFilters(a), s = !1, o && (o.prop && (s = !0, (n = f(n)) === 'innerHtml' && (n = 'innerHTML')), o.camel && (n = f(n)), o.sync && addHandler(e, `update:${f(n)}`, genAssignmentCode(a, '$event'))), s || !e.component && Be(e.tag, e.attrsMap.type, n) ? addProp(e, n, a) : addAttr(e, n, a); else if (Ue.test(n))n = n.replace(Ue, ''), addHandler(e, n, a, o, !1, Fe); else { const l = (n = n.replace(ze, '')).match(Ge); const c = l && l[1]; c && (n = n.slice(0, -(c.length + 1))), addDirective(e, n, i, a, c, o), n === 'model' && checkForAliasModel(e, a) } else { const p = parseText(a, Le); p && Fe(`${n}="${a}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div id="{{ val }}">, use <div :id="val">.`), addAttr(e, n, JSON.stringify(a)), !e.component && n === 'muted' && Be(e.tag, e.attrsMap.type, n) && addProp(e, n, 'true') } }(e)) } function processFor(e) { let t; if (t = getAndRemoveAttr(e, 'v-for')) { const r = (function parseFor(e) { const t = e.match(Ve); if (!t) return; const r = {}; r.for = t[2].trim(); const n = t[1].trim().replace($e, ''); const i = n.match(He); i ? (r.alias = n.replace(He, ''), r.iterator1 = i[1].trim(), i[2] && (r.iterator2 = i[2].trim())) : r.alias = n; return r }(t)); r ? extend(e, r) : Fe(`Invalid v-for expression: ${t}`) } } function addIfCondition(e, t) { e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t) } function parseModifiers(e) { const t = e.match(We); if (t) { const r = {}; return t.forEach((e) => { r[e.slice(1)] = !0 }), r } } var Xe = /^xmlns:NS\d+/; var Ye = /^NS\d+:/; function checkForAliasModel(e, t) { for (let r = e; r;)r.for && r.alias === t && Fe(`<${e.tag} v-model="${t}">: You are binding v-model directly to a v-for iteration alias. This will not be able to modify the v-for source array because writing to the alias is like modifying a function local variable. Consider using an array of objects and use v-model on an object property instead.`), r = r.parent; } function cloneASTElement(e) { return createASTElement(e.tag, e.attrsList.slice(), e.parent) } let Qe; const Ze = [Ce, Re, { preTransformNode: function preTransformNode(e, t) { if (e.tag === 'input') { let r; const n = e.attrsMap; if (!n['v-model']) return; if ((n[':type'] || n['v-bind:type']) && (r = getBindingAttr(e, 'type')), n.type || r || !n['v-bind'] || (r = `(${n['v-bind']}).type`), r) { const i = getAndRemoveAttr(e, 'v-if', !0); const a = i ? `&&(${i})` : ''; const o = getAndRemoveAttr(e, 'v-else', !0) != null; const s = getAndRemoveAttr(e, 'v-else-if', !0); const u = cloneASTElement(e); processFor(u), addRawAttr(u, 'type', 'checkbox'), processElement(u, t), u.processed = !0, u.if = `(${r})==='checkbox'${a}`, addIfCondition(u, { exp: u.if, block: u }); const l = cloneASTElement(e); getAndRemoveAttr(l, 'v-for', !0), addRawAttr(l, 'type', 'radio'), processElement(l, t), addIfCondition(u, { exp: `(${r})==='radio'${a}`, block: l }); const c = cloneASTElement(e); return getAndRemoveAttr(c, 'v-for', !0), addRawAttr(c, ':type', r), processElement(c, t), addIfCondition(u, { exp: i, block: c }), o ? u.else = !0 : s && (u.elseif = s), u } } } }]; const et = '__r'; let tt; let rt; const nt = {
        expectHTML: !0, modules: Ze, directives: { model: function model$1(e, t, r) { Qe = r; const n = t.value; const i = t.modifiers; const a = e.tag; const o = e.attrsMap.type; if (a === 'input' && o === 'file' && Qe(`<${e.tag} v-model="${n}" type="file">:\nFile inputs are read only. Use a v-on:change listener instead.`), e.component) return genComponentModel(e, n, i), !1; if (a === 'select')!(function genSelect(e, t, r) { let n = `var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ${r && r.number ? '_n(val)' : 'val'}});`; n = `${n} ${genAssignmentCode(t, '$event.target.multiple ? $$selectedVal : $$selectedVal[0]')}`, addHandler(e, 'change', n, null, !0) }(e, n, i)); else if (a === 'input' && o === 'checkbox')!(function genCheckboxModel(e, t, r) { const n = r && r.number; const i = getBindingAttr(e, 'value') || 'null'; const a = getBindingAttr(e, 'true-value') || 'true'; const o = getBindingAttr(e, 'false-value') || 'false'; addProp(e, 'checked', `Array.isArray(${t})?_i(${t},${i})>-1${a === 'true' ? `:(${t})` : `:_q(${t},${a})`}`), addHandler(e, 'change', `var $$a=${t},$$el=$event.target,$$c=$$el.checked?(${a}):(${o});if(Array.isArray($$a)){var $$v=${n ? `_n(${i})` : i},$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(${genAssignmentCode(t, '$$a.concat([$$v])')})}else{$$i>-1&&(${genAssignmentCode(t, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')})}}else{${genAssignmentCode(t, '$$c')}}`, null, !0) }(e, n, i)); else if (a === 'input' && o === 'radio')!(function genRadioModel(e, t, r) { const n = r && r.number; let i = getBindingAttr(e, 'value') || 'null'; addProp(e, 'checked', `_q(${t},${i = n ? `_n(${i})` : i})`), addHandler(e, 'change', genAssignmentCode(t, i), null, !0) }(e, n, i)); else if (a === 'input' || a === 'textarea')!(function genDefaultModel(e, t, r) { const n = e.attrsMap.type; const i = e.attrsMap['v-bind:value'] || e.attrsMap[':value']; const a = e.attrsMap['v-bind:type'] || e.attrsMap[':type']; if (i && !a) { const o = e.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value'; Qe(`${o}="${i}" conflicts with v-model on the same element because the latter already expands to a value binding internally`) } const s = r || {}; const u = s.lazy; const l = s.number; const c = s.trim; const p = !u && n !== 'range'; const f = u ? 'change' : n === 'range' ? et : 'input'; let d = '$event.target.value'; c && (d = '$event.target.value.trim()'), l && (d = `_n(${d})`); let h = genAssignmentCode(t, d); p && (h = `if($event.target.composing)return;${h}`), addProp(e, 'value', `(${t})`), addHandler(e, f, h, null, !0), (c || l) && addHandler(e, 'blur', '$forceUpdate()') }(e, n, i)); else { if (!X.isReservedTag(a)) return genComponentModel(e, n, i), !1; Qe(`<${e.tag} v-model="${n}">: v-model is not supported on this element type. If you are working with contenteditable, it's recommended to wrap a library dedicated for that purpose inside a custom component.`) } return !0 }, text: function text(e, t) { t.value && addProp(e, 'textContent', `_s(${t.value})`) }, html: function html(e, t) { t.value && addProp(e, 'innerHTML', `_s(${t.value})`) } }, isPreTag(e) { return e === 'pre' }, isUnaryTag: h, mustUseProp(e, t, r) { return r === 'value' && he(e) && t !== 'button' || r === 'selected' && e === 'option' || r === 'checked' && e === 'input' || r === 'muted' && e === 'video' }, canBeLeftOpenTag: m, isReservedTag(e) { return ve(e) || ye(e) }, getTagNamespace: function getTagNamespace(e) { return ye(e) ? 'svg' : e === 'math' ? 'math' : void 0 }, staticKeys: (function genStaticKeys(e) { return e.reduce((e, t) => e.concat(t.staticKeys || []), []).join(',') }(Ze)),
      }; const it = cached(e => makeMap(`type,tag,attrsList,attrsMap,plain,parent,children,attrs${e ? `,${e}` : ''}`)); function optimize(e, t) { e && (tt = it(t.staticKeys || ''), rt = t.isReservedTag || d, (function markStatic(e) { e.static = (function isStatic(e) { if (e.type === 2) return !1; if (e.type === 3) return !0; return !(!e.pre && (e.hasBindings || e.if || e.for || l(e.tag) || !rt(e.tag) || (function isDirectChildOfTemplateFor(e) { for (;e.parent;) { if ((e = e.parent).tag !== 'template') return !1; if (e.for) return !0; } return !1 }(e)) || !Object.keys(e).every(tt))) }(e)); if (e.type === 1) { if (!rt(e.tag) && e.tag !== 'slot' && e.attrsMap['inline-template'] == null) return; for (let t = 0, r = e.children.length; t < r; t++) { const n = e.children[t]; markStatic(n), n.static || (e.static = !1) } if (e.ifConditions) for (let i = 1, a = e.ifConditions.length; i < a; i++) { const o = e.ifConditions[i].block; markStatic(o), o.static || (e.static = !1) } } }(e)), (function markStaticRoots(e, t) { if (e.type === 1) { if ((e.static || e.once) && (e.staticInFor = t), e.static && e.children.length && (e.children.length !== 1 || e.children[0].type !== 3)) return void (e.staticRoot = !0); if (e.staticRoot = !1, e.children) for (let r = 0, n = e.children.length; r < n; r++)markStaticRoots(e.children[r], t || !!e.for); if (e.ifConditions) for (let i = 1, a = e.ifConditions.length; i < a; i++)markStaticRoots(e.ifConditions[i].block, t); } }(e, !1))) } const at = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/; const ot = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; const st = {
        esc: 27, tab: 9, enter: 13, space: 32, up: 38, left: 37, right: 39, down: 40, delete: [8, 46],
      }; const ut = {
        esc: 'Escape', tab: 'Tab', enter: 'Enter', space: ' ', up: ['Up', 'ArrowUp'], left: ['Left', 'ArrowLeft'], right: ['Right', 'ArrowRight'], down: ['Down', 'ArrowDown'], delete: ['Backspace', 'Delete'],
      }; const lt = function (e) { return `if(${e})return null;` }; const ct = {
        stop: '$event.stopPropagation();', prevent: '$event.preventDefault();', self: lt('$event.target !== $event.currentTarget'), ctrl: lt('!$event.ctrlKey'), shift: lt('!$event.shiftKey'), alt: lt('!$event.altKey'), meta: lt('!$event.metaKey'), left: lt("'button' in $event && $event.button !== 0"), middle: lt("'button' in $event && $event.button !== 1"), right: lt("'button' in $event && $event.button !== 2"),
      }; function genHandlers(e, t, r) { let n = t ? 'nativeOn:{' : 'on:{'; for (const i in e)n += `"${i}":${genHandler(i, e[i])},`; return `${n.slice(0, -1)}}` } function genHandler(e, t) { if (!t) return 'function(){}'; if (Array.isArray(t)) return `[${t.map(t => genHandler(e, t)).join(',')}]`; const r = ot.test(t.value); const n = at.test(t.value); if (t.modifiers) { let i = ''; let a = ''; const o = []; for (const s in t.modifiers) if (ct[s])a += ct[s], st[s] && o.push(s); else if (s === 'exact') { var u = t.modifiers; a += lt(['ctrl', 'shift', 'alt', 'meta'].filter(e => !u[e]).map(e => `$event.${e}Key`).join('||')) } else o.push(s); return o.length && (i += (function genKeyFilter(e) { return `if(!('button' in $event)&&${e.map(genFilterCode).join('&&')})return null;` }(o))), a && (i += a), `function($event){${i}${r ? `return ${t.value}($event)` : n ? `return (${t.value})($event)` : t.value}}` } return r || n ? t.value : `function($event){${t.value}}` } function genFilterCode(e) { const t = parseInt(e, 10); if (t) return `$event.keyCode!==${t}`; const r = st[e]; const n = ut[e]; return `_k($event.keyCode,${JSON.stringify(e)},${JSON.stringify(r)},$event.key,${JSON.stringify(n)})` } const pt = { on: function on(e, t) { t.modifiers && Y('v-on without argument does not support modifiers.'), e.wrapListeners = function (e) { return `_g(${e},${t.value})` } }, bind: function bind$1(e, t) { e.wrapData = function (r) { return `_b(${r},'${e.tag}',${t.value},${t.modifiers && t.modifiers.prop ? 'true' : 'false'}${t.modifiers && t.modifiers.sync ? ',true' : ''})` } }, cloak: noop }; const ft = function CodegenState(e) { this.options = e, this.warn = e.warn || baseWarn, this.transforms = pluckModuleFunction(e.modules, 'transformCode'), this.dataGenFns = pluckModuleFunction(e.modules, 'genData'), this.directives = extend(extend({}, pt), e.directives); const t = e.isReservedTag || d; this.maybeComponent = function (e) { return !t(e.tag) }, this.onceId = 0, this.staticRenderFns = [] }; function generate(e, t) { const r = new ft(t); return { render: `with(this){return ${e ? genElement(e, r) : '_c("div")'}}`, staticRenderFns: r.staticRenderFns } } function genElement(e, t) { if (e.staticRoot && !e.staticProcessed) return genStatic(e, t); if (e.once && !e.onceProcessed) return genOnce(e, t); if (e.for && !e.forProcessed) return genFor(e, t); if (e.if && !e.ifProcessed) return genIf(e, t); if (e.tag !== 'template' || e.slotTarget) { if (e.tag === 'slot') return (function genSlot(e, t) { const r = e.slotName || '"default"'; const n = genChildren(e, t); let i = `_t(${r}${n ? `,${n}` : ''}`; const a = e.attrs && `{${e.attrs.map(e => `${f(e.name)}:${e.value}`).join(',')}}`; const o = e.attrsMap['v-bind']; !a && !o || n || (i += ',null'); a && (i += `,${a}`); o && (i += `${a ? '' : ',null'},${o}`); return `${i})` }(e, t)); let r; if (e.component)r = (function genComponent(e, t, r) { const n = t.inlineTemplate ? null : genChildren(t, r, !0); return `_c(${e},${genData$2(t, r)}${n ? `,${n}` : ''})` }(e.component, e, t)); else { const n = e.plain ? void 0 : genData$2(e, t); const i = e.inlineTemplate ? null : genChildren(e, t, !0); r = `_c('${e.tag}'${n ? `,${n}` : ''}${i ? `,${i}` : ''})` } for (let a = 0; a < t.transforms.length; a++)r = t.transforms[a](e, r); return r } return genChildren(e, t) || 'void 0' } function genStatic(e, t) { return e.staticProcessed = !0, t.staticRenderFns.push(`with(this){return ${genElement(e, t)}}`), `_m(${t.staticRenderFns.length - 1}${e.staticInFor ? ',true' : ''})` } function genOnce(e, t) { if (e.onceProcessed = !0, e.if && !e.ifProcessed) return genIf(e, t); if (e.staticInFor) { for (var r = '', n = e.parent; n;) { if (n.for) { r = n.key; break }n = n.parent } return r ? `_o(${genElement(e, t)},${t.onceId++},${r})` : (t.warn('v-once can only be used inside v-for that is keyed. '), genElement(e, t)) } return genStatic(e, t) } function genIf(e, t, r, n) { return e.ifProcessed = !0, (function genIfConditions(e, t, r, n) { if (!e.length) return n || '_e()'; const i = e.shift(); return i.exp ? `(${i.exp})?${genTernaryExp(i.block)}:${genIfConditions(e, t, r, n)}` : `${genTernaryExp(i.block)}`; function genTernaryExp(e) { return r ? r(e, t) : e.once ? genOnce(e, t) : genElement(e, t) } }(e.ifConditions.slice(), t, r, n)) } function genFor(e, t, r, n) { const i = e.for; const a = e.alias; const o = e.iterator1 ? `,${e.iterator1}` : ''; const s = e.iterator2 ? `,${e.iterator2}` : ''; return t.maybeComponent(e) && e.tag !== 'slot' && e.tag !== 'template' && !e.key && t.warn(`<${e.tag} v-for="${a} in ${i}">: component lists rendered with v-for should have explicit keys. See https://vuejs.org/guide/list.html#key for more info.`, !0), e.forProcessed = !0, `${n || '_l'}((${i}),function(${a}${o}${s}){return ${(r || genElement)(e, t)}})` } function genData$2(e, t) { let r = '{'; const n = (function genDirectives(e, t) { const r = e.directives; if (!r) return; let n; let i; let a; let o; let s = 'directives:['; let u = !1; for (n = 0, i = r.length; n < i; n++) { a = r[n], o = !0; const l = t.directives[a.name]; l && (o = !!l(e, a, t.warn)), o && (u = !0, s += `{name:"${a.name}",rawName:"${a.rawName}"${a.value ? `,value:(${a.value}),expression:${JSON.stringify(a.value)}` : ''}${a.arg ? `,arg:"${a.arg}"` : ''}${a.modifiers ? `,modifiers:${JSON.stringify(a.modifiers)}` : ''}},`) } if (u) return `${s.slice(0, -1)}]`; }(e, t)); n && (r += `${n},`), e.key && (r += `key:${e.key},`), e.ref && (r += `ref:${e.ref},`), e.refInFor && (r += 'refInFor:true,'), e.pre && (r += 'pre:true,'), e.component && (r += `tag:"${e.tag}",`); for (let i = 0; i < t.dataGenFns.length; i++)r += t.dataGenFns[i](e); if (e.attrs && (r += `attrs:{${genProps(e.attrs)}},`), e.props && (r += `domProps:{${genProps(e.props)}},`), e.events && (r += `${genHandlers(e.events, !1, t.warn)},`), e.nativeEvents && (r += `${genHandlers(e.nativeEvents, !0, t.warn)},`), e.slotTarget && !e.slotScope && (r += `slot:${e.slotTarget},`), e.scopedSlots && (r += `${(function genScopedSlots(e, t) { return `scopedSlots:_u([${Object.keys(e).map(r => genScopedSlot(r, e[r], t)).join(',')}])` }(e.scopedSlots, t))},`), e.model && (r += `model:{value:${e.model.value},callback:${e.model.callback},expression:${e.model.expression}},`), e.inlineTemplate) { const a = (function genInlineTemplate(e, t) { const r = e.children[0]; e.children.length === 1 && r.type === 1 || t.warn('Inline-template components must have exactly one child element.'); if (r.type === 1) { const n = generate(r, t.options); return `inlineTemplate:{render:function(){${n.render}},staticRenderFns:[${n.staticRenderFns.map(e => `function(){${e}}`).join(',')}]}` } }(e, t)); a && (r += `${a},`) } return r = `${r.replace(/,$/, '')}}`, e.wrapData && (r = e.wrapData(r)), e.wrapListeners && (r = e.wrapListeners(r)), r } function genScopedSlot(e, t, r) { return t.for && !t.forProcessed ? (function genForScopedSlot(e, t, r) { const n = t.for; const i = t.alias; const a = t.iterator1 ? `,${t.iterator1}` : ''; const o = t.iterator2 ? `,${t.iterator2}` : ''; return t.forProcessed = !0, `_l((${n}),function(${i}${a}${o}){return ${genScopedSlot(e, t, r)}})` }(e, t, r)) : `{key:${e},fn:` + `function(${String(t.slotScope)}){return ${t.tag === 'template' ? t.if ? `${t.if}?${genChildren(t, r) || 'undefined'}:undefined` : genChildren(t, r) || 'undefined' : genElement(t, r)}}` + '}' } function genChildren(e, t, r, n, i) { const a = e.children; if (a.length) { const o = a[0]; if (a.length === 1 && o.for && o.tag !== 'template' && o.tag !== 'slot') return (n || genElement)(o, t); const s = r ? (function getNormalizationType(e, t) { for (var r = 0, n = 0; n < e.length; n++) { const i = e[n]; if (i.type === 1) { if (needsNormalization(i) || i.ifConditions && i.ifConditions.some(e => needsNormalization(e.block))) { r = 2; break }(t(i) || i.ifConditions && i.ifConditions.some(e => t(e.block))) && (r = 1) } } return r }(a, t.maybeComponent)) : 0; const u = i || genNode; return `[${a.map(e => u(e, t)).join(',')}]${s ? `,${s}` : ''}` } } function needsNormalization(e) { return void 0 !== e.for || e.tag === 'template' || e.tag === 'slot' } function genNode(e, t) { return e.type === 1 ? genElement(e, t) : e.type === 3 && e.isComment ? (function genComment(e) { return `_e(${JSON.stringify(e.text)})` }(e)) : genText(e) } function genText(e) { return `_v(${e.type === 2 ? e.expression : transformSpecialNewlines(JSON.stringify(e.text))})` } function genProps(e) { for (var t = '', r = 0; r < e.length; r++) { const n = e[r]; t += `"${n.name}":${transformSpecialNewlines(n.value)},` } return t.slice(0, -1) } function transformSpecialNewlines(e) { return e.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029') } const dt = new RegExp(`\\b${'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments'.split(',').join('\\b|\\b')}\\b`); const ht = new RegExp(`\\b${'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b')}\\s*\\([^\\)]*\\)`); const mt = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; function detectErrors(e) { const t = []; return e && (function checkNode(e, t) { if (e.type === 1) { for (const r in e.attrsMap) if (ze.test(r)) { const n = e.attrsMap[r]; n && (r === 'v-for' ? checkFor(e, `v-for="${n}"`, t) : Ue.test(r) ? checkEvent(n, `${r}="${n}"`, t) : checkExpression(n, `${r}="${n}"`, t)) } if (e.children) for (let i = 0; i < e.children.length; i++)checkNode(e.children[i], t); } else e.type === 2 && checkExpression(e.expression, e.text, t); }(e, t)), t } function checkEvent(e, t, r) { const n = e.replace(mt, ''); const i = n.match(ht); i && n.charAt(i.index - 1) !== '$' && r.push(`avoid using JavaScript unary operator as property name: "${i[0]}" in expression ${t.trim()}`), checkExpression(e, t, r) } function checkFor(e, t, r) { checkExpression(e.for || '', t, r), checkIdentifier(e.alias, 'v-for alias', t, r), checkIdentifier(e.iterator1, 'v-for iterator', t, r), checkIdentifier(e.iterator2, 'v-for iterator', t, r) } function checkIdentifier(e, t, r, n) { if (typeof e === 'string') try { new Function(`var ${e}=_`) } catch (i) { n.push(`invalid ${t} "${e}" in expression: ${r.trim()}`) } } function checkExpression(e, t, r) { try { new Function(`return ${e}`) } catch (i) { const n = e.replace(mt, '').match(dt); n ? r.push(`avoid using JavaScript keyword as property name: "${n[0]}"\n  Raw expression: ${t.trim()}`) : r.push(`invalid expression: ${i.message} in\n\n    ${e}\n\n  Raw expression: ${t.trim()}\n`) } } function createFunction(e, t) { try { return new Function(e) } catch (r) { return t.push({ err: r, code: e }), noop } } function createCompilerCreator(e) { return function createCompiler(t) { function compile(r, n) { const i = Object.create(t); const a = []; const o = []; if (i.warn = function (e, t) { (t ? o : a).push(e) }, n) for (const s in n.modules && (i.modules = (t.modules || []).concat(n.modules)), n.directives && (i.directives = extend(Object.create(t.directives || null), n.directives)), n)s !== 'modules' && s !== 'directives' && (i[s] = n[s]); const u = e(r, i); return a.push(...detectErrors(u.ast)), u.errors = a, u.tips = o, u } return { compile, compileToFunctions: (function createCompileToFunctionFn(e) { const t = Object.create(null); return function compileToFunctions(r, n, i) { const a = (n = extend({}, n)).warn || Y; delete n.warn; try { new Function('return 1') } catch (e) { e.toString().match(/unsafe-eval|CSP/) && a('It seems you are using the standalone build of Vue.js in an environment with Content Security Policy that prohibits unsafe-eval. The template compiler cannot work in this environment. Consider relaxing the policy to allow unsafe-eval or pre-compiling your templates into render functions.') } const o = n.delimiters ? String(n.delimiters) + r : r; if (t[o]) return t[o]; const s = e(r, n); s.errors && s.errors.length && a(`Error compiling template:\n\n${r}\n\n${s.errors.map(e => `- ${e}`).join('\n')}\n`, i), s.tips && s.tips.length && s.tips.forEach(e => Q(e, i)); const u = {}; const l = []; return u.render = createFunction(s.render, l), u.staticRenderFns = s.staticRenderFns.map(e => createFunction(e, l)), s.errors && s.errors.length || !l.length || a(`Failed to generate render function:\n\n${l.map((e) => { const t = e.err; const r = e.code; return `${t.toString()} in\n\n${r}\n` }).join('\n')}`, i), t[o] = u } }(compile)) } } } const gt = createCompilerCreator((e, t) => { const r = parse(e.trim(), t); !1 !== t.optimize && optimize(r, t); const n = generate(r, t); return { ast: r, render: n.render, staticRenderFns: n.staticRenderFns } })(nt); const vt = gt.compile; const yt = gt.compileToFunctions; const bt = makeMap('accept,accept-charset,accesskey,action,align,alt,async,autocomplete,autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,name,contenteditable,contextmenu,controls,coords,data,datetime,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,type,usemap,value,width,wrap'); const xt = function (e) { return bt(e) || e.indexOf('data-') === 0 || e.indexOf('aria-') === 0 }; const Dt = {
        acceptCharset: 'accept-charset', className: 'class', htmlFor: 'for', httpEquiv: 'http-equiv',
      }; const _t = {
        '<': '&lt;', '>': '&gt;', '"': '&quot;', '&': '&amp;',
      }; function escapeChar(e) { return _t[e] || e } const Ct = /^"(?:[^"\\]|\\.)*"$|^'(?:[^'\\]|\\.)*'$/; function genAttrSegment(e, t) { return Ct.test(t) ? (t = t.replace(/^'|'$/g, '"'), me(e) && t !== '"false"' && (t = '"true"'), { type: kt, value: ge(e) ? ` ${e}="${e}"` : t === '""' ? ` ${e}` : ` ${e}="${JSON.parse(t)}"` }) : { type: Tt, value: `_ssrAttr(${JSON.stringify(e)},${t})` } } let wt; const Et = {
        FALSE: 0, FULL: 1, SELF: 2, CHILDREN: 3, PARTIAL: 4,
      }; function optimize$1(e, t) {
        e && (wt = t.isReservedTag || d, (function walk(e, t) {
          if (function isUnOptimizableTree(e) { if (e.type === 2 || e.type === 3) return !1; return l(e.tag) || !wt(e.tag) || !!e.component || (function isSelectWithModel(e) { return e.type === 1 && e.tag === 'select' && e.directives != null && e.directives.some(e => e.name === 'model') }(e)) }(e)) return void (e.ssrOptimizability = Et.FALSE); const r = t || (function hasCustomDirective(e) { return e.type === 1 && e.directives && e.directives.some(e => !St(e.name)) }(e)); const n = function (t) { t.ssrOptimizability !== Et.FULL && (e.ssrOptimizability = r ? Et.PARTIAL : Et.SELF) }; r && (e.ssrOptimizability = Et.CHILDREN); if (e.type === 1) {
            for (let i = 0, a = e.children.length; i < a; i++) { const o = e.children[i]; walk(o), n(o) } if (e.ifConditions) for (let s = 1, u = e.ifConditions.length; s < u; s++) { const c = e.ifConditions[s].block; walk(c, t), n(c) }e.ssrOptimizability == null || !t && (e.attrsMap['v-html'] || e.attrsMap['v-text']) ? e.ssrOptimizability = Et.FULL : e.children = (function optimizeSiblings(e) {
              for (var t = e.children, r = [], n = [], i = function () {
                  n.length && r.push({
                    type: 1, parent: e, tag: 'template', attrsList: [], attrsMap: {}, children: n, ssrOptimizability: Et.FULL,
                  }), n = [];
                }, a = 0; a < t.length; a++) { const o = t[a]; o.ssrOptimizability === Et.FULL ? n.push(o) : (i(), r.push(o)) } return i(), r;
            }(e));
          } else e.ssrOptimizability = Et.FULL;
        }(e, !0)));
      } var St = makeMap('text,html,show,on,bind,model,pre,cloak,once'); var kt = 0; const At = 1; var Tt = 2; function genSSRElement(e, t) { if (e.for && !e.forProcessed) return genFor(e, t, genSSRElement); if (e.if && !e.ifProcessed) return genIf(e, t, genSSRElement); if (e.tag === 'template' && !e.slotTarget) return e.ssrOptimizability === Et.FULL ? genChildrenAsStringNode(e, t) : genSSRChildren(e, t) || 'void 0'; switch (e.ssrOptimizability) { case Et.FULL: return (function genStringElement(e, t) { return `_ssrNode(${elementToString(e, t)})` }(e, t)); case Et.SELF: return (function genStringElementWithChildren(e, t) { const r = genSSRChildren(e, t, !0); return `_ssrNode(${flattenSegments(elementToOpenTagSegments(e, t))},"</${e.tag}>"${r ? `,${r}` : ''})` }(e, t)); case Et.CHILDREN: return genNormalElement(e, t, !0); case Et.PARTIAL: return genNormalElement(e, t, !1); default: return genElement(e, t); } } function genNormalElement(e, t, r) { const n = e.plain ? void 0 : genData$2(e, t); const i = r ? `[${genChildrenAsStringNode(e, t)}]` : genSSRChildren(e, t, !0); return `_c('${e.tag}'${n ? `,${n}` : ''}${i ? `,${i}` : ''})` } function genSSRChildren(e, t, r) { return genChildren(e, t, r, genSSRElement, genSSRNode) } function genSSRNode(e, t) { return e.type === 1 ? genSSRElement(e, t) : genText(e) } function genChildrenAsStringNode(e, t) { return e.children.length ? `_ssrNode(${flattenSegments(childrenToSegments(e, t))})` : '' } function elementToString(e, t) { return `(${flattenSegments(elementToSegments(e, t))})` } function elementToSegments(e, t) { if (e.for && !e.forProcessed) return e.forProcessed = !0, [{ type: Tt, value: genFor(e, t, elementToString, '_ssrList') }]; if (e.if && !e.ifProcessed) return e.ifProcessed = !0, [{ type: Tt, value: genIf(e, t, elementToString, '"\x3c!----\x3e"') }]; if (e.tag === 'template') return childrenToSegments(e, t); const r = elementToOpenTagSegments(e, t); const n = childrenToSegments(e, t); const i = t.options.isUnaryTag; const a = i && i(e.tag) ? [] : [{ type: kt, value: `</${e.tag}>` }]; return r.concat(n, a) } function elementToOpenTagSegments(e, t) { let r; !(function applyModelTransform(e, t) { if (e.directives) for (let r = 0; r < e.directives.length; r++) { const n = e.directives[r]; if (n.name === 'model') { t.directives.model(e, n, t.warn), e.tag === 'textarea' && e.props && (e.props = e.props.filter(e => e.name !== 'value')); break } } }(e, t)); const n = [{ type: kt, value: `<${e.tag}` }]; return e.attrs && n.push(...(function genAttrSegments(e) { return e.map(e => genAttrSegment(e.name, e.value)) }(e.attrs))), e.props && n.push(...(function genDOMPropSegments(e, t) { const r = []; return e.forEach((e) => { let n = e.name; const i = e.value; n = Dt[n] || n.toLowerCase(), !xt(n) || t && t.some(e => e.name === n) || r.push(genAttrSegment(n, i)) }), r }(e.props, e.attrs))), (r = e.attrsMap['v-bind']) && n.push({ type: Tt, value: `_ssrAttrs(${r})` }), (r = e.attrsMap['v-bind.prop']) && n.push({ type: Tt, value: `_ssrDOMProps(${r})` }), (e.staticClass || e.classBinding) && n.push(...(function genClassSegments(e, t) { return e && !t ? [{ type: kt, value: ` class=${e}` }] : [{ type: Tt, value: `_ssrClass(${e || 'null'},${t || 'null'})` }] }(e.staticClass, e.classBinding))), (e.staticStyle || e.styleBinding || e.attrsMap['v-show']) && n.push(...(function genStyleSegments(e, t, r, n) { return !e || r || n ? [{ type: Tt, value: `_ssrStyle(${t || 'null'},${r || 'null'}, ${n ? `{ display: (${n}) ? '' : 'none' }` : 'null'})` }] : [{ type: kt, value: ` style=${JSON.stringify(e)}` }] }(e.attrsMap.style, e.staticStyle, e.styleBinding, e.attrsMap['v-show']))), t.options.scopeId && n.push({ type: kt, value: ` ${t.options.scopeId}` }), n.push({ type: kt, value: '>' }), n } function childrenToSegments(e, t) { let r; return (r = e.attrsMap['v-html']) ? [{ type: Tt, value: `_s(${r})` }] : (r = e.attrsMap['v-text']) ? [{ type: At, value: `_s(${r})` }] : e.tag === 'textarea' && (r = e.attrsMap['v-model']) ? [{ type: At, value: `_s(${r})` }] : e.children ? (function nodesToSegments(e, t) { for (var r = [], n = 0; n < e.length; n++) { const i = e[n]; i.type === 1 ? r.push(...elementToSegments(i, t)) : i.type === 2 ? r.push({ type: At, value: i.expression }) : i.type === 3 && r.push({ type: kt, value: (a = i.text, a.replace(/[<>"&]/g, escapeChar)) }) } let a; return r }(e.children, t)) : [] } function flattenSegments(e) { for (var t = [], r = '', n = function () { r && (t.push(JSON.stringify(r)), r = '') }, i = 0; i < e.length; i++) { const a = e[i]; a.type === kt ? r += a.value : a.type === At ? (n(), t.push(`_ssrEscape(${a.value})`)) : a.type === Tt && (n(), t.push(`(${a.value})`)) } return n(), t.join('+') } const Pt = createCompilerCreator((e, t) => { const r = parse(e.trim(), t); optimize$1(r, t); const n = (function generate$1(e, t) { const r = new ft(t); return { render: `with(this){return ${e ? genSSRElement(e, r) : '_c("div")'}}`, staticRenderFns: r.staticRenderFns } }(r, t)); return { ast: r, render: n.render, staticRenderFns: n.staticRenderFns } })(nt); const Rt = Pt.compile; const Ot = Pt.compileToFunctions; t.parseComponent = function parseComponent(e, t) {
        void 0 === t && (t = {}); const r = {
          template: null, script: null, styles: [], customBlocks: [],
        }; let n = 0; let i = null; return parseHTML(e, {
          start: function start(e, t, a, o, s) {
            n === 0 && (i = {
              type: e, content: '', start: s, attrs: t.reduce((e, t) => { const r = t.name; const n = t.value; return e[r] = n || !0, e }, {}),
            }, j(e) ? ((function checkAttrs(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.name === 'lang' && (e.lang = n.value), n.name === 'scoped' && (e.scoped = !0), n.name === 'module' && (e.module = n.value || !0), n.name === 'src' && (e.src = n.value) } }(i, t)), e === 'style' ? r.styles.push(i) : r[e] = i) : r.customBlocks.push(i)), a || n++;
          },
          end: function end(r, a, s) { if (n === 1 && i) { i.end = a; let u = o(e.slice(i.start, i.end)); i.type !== 'template' && t.pad && (u = (function padContent(t, r) { if (r === 'space') return e.slice(0, t.start).replace(M, ' '); const n = e.slice(0, t.start).split(L).length; const i = t.type !== 'script' || t.lang ? '\n' : '//\n'; return Array(n).join(i) }(i, t.pad)) + u), i.content = u, i = null }n-- },
        }), r;
      }, t.compile = vt, t.compileToFunctions = yt, t.ssrCompile = Rt, t.ssrCompileToFunctions = Ot, Object.defineProperty(t, '__esModule', { value: !0 });
    }(t));
  }).call(t, r(14), r(154).setImmediate);
}, function (e, t, r) {
  /*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Released under the MIT license.
 */const n = r(98); const i = r(492); function stripComments(e, t) {
    (t = n({
      block: !1, line: !1, safe: !1, first: !1,
    }, t)).keepProtected = t.safe; for (let r = i(e, t), a = r.length, o = 0; o < a;) { e = discard(e, r[o++], t) } return e;
  } function discard(e, t, r) { const n = t.value.charAt(0); if (r && !0 === r.safe && n === '!') return e; let i = ''; return r && r.preserveNewlines && (i = t.raw.replace(/[^\r\n]/g, '')), t.type === 'line' && (e = e.replace(`//${t.raw}`, i)), t.type === 'block' && (e = e.replace(`/*${t.raw}*/`, i)), e }(t = e.exports = function stripAllComments(e, t) { return stripComments(e, t = n({ block: !0, line: !0 }, t)) }).block = function stripBlockComments(e, t) { return stripComments(e, t = n({ block: !0 }, t)) }, t.line = function stripLineComments(e, t) { return stripComments(e, t = n({ line: !0 }, t)) }, t.first = function stripFirstComment(e, t) { return stripComments(e, t = n({ block: !0, line: !0, first: !0 }, t)) };
}, function (e, t, r) {
  /*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */e.exports = function isExtendable(e) { return void 0 !== e && e !== null && (typeof e === 'object' || typeof e === 'function') };
}, function (e, t, r) {
  /*!
 * extract-comments <https://github.com/jonschlinkert/extract-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */const n = r(98); const i = r(493); function extract(e, t, r) { return typeof t === 'function' && (r = t, t = {}), new i(t, r).extract(e).comments || [] }e.exports = extract, e.exports.block = function block(e, t) { return extract(e, n({ line: !1 }, t)) }, e.exports.line = function line(e, t) { return extract(e, n({ block: !1 }, t)) }, e.exports.first = function first(e) { return extract(e, { first: !0 }) }, e.exports.Comments = i;
}, function (e, t, r) {
  /*!
 * extract-comments <https://github.com/jonschlinkert/extract-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */const n = r(494); const i = r(98); const a = r(496); const o = r(503); const s = r(505); const u = r(507); function Comments(e, t) { this.options = i({ type: 'block' }, e), this.transform = t, this.comments = [] }Comments.prototype.extract = function (e) { if (typeof e !== 'string') throw new TypeError('expected a string'); a(this, 'input', e); const t = this.options; let r = []; try { r = n(this.input) } catch (e) { if (!0 !== t.silent) throw e; } let i = t.stripProtected; const l = t.keepProtected; void 0 === l && void 0 === i ? i = !1 : void 0 !== l && (i = !l); for (let c = r.length, p = -1; ++p < c;) { const f = r[p]; if (f.type = f.type.toLowerCase(), !(typeof this.options.filter === 'function' && this.options.filter(f) || /^\*?!/.test(f.value) && !1 === i)) { if (f.type === 'block' && !1 !== t.block) { let d = new s(e, f, t); if (!1 !== t.context && (d.code = new o(e, d, t)), typeof this.transform === 'function') { const h = this.transform(d, this.options); h && (d = h) } this.comments.push(d) } if (f.type === 'line' && !1 !== t.line && this.comments.push(new u(e, f, t)), (t.first || t.banner) && this.comments.length === 1) break; } } return this }, e.exports = Comments;
}, function (e, t, r) {
  /*!
 * esprima-extract-comments <https://github.com/jonschlinkert/esprima-extract-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */const n = r(495); e.exports = function (e) {
    return n.parse(e, {
      tolerant: !0, comment: !0, tokens: !0, range: !0, loc: !0,
    }).comments;
  };
}, function (e, t, r) {
  let n; let i; let a; !(function (r, o) {
    i = [t], void 0 === (a = typeof (n = o) === 'function' ? n.apply(t, i) : n) || (e.exports = a);
  }(0, (e) => {
    let t; let r; let n; let i; let a; let o; let s; let u; let l; let c; let p; let f; let d; let h; let m; let g; let v; let y; let b; let x; let D; let _; let C; let w; let E; let S; let k; function assert(e, t) { if (!e) throw new Error(`ASSERT: ${t}`); } function isDecimalDigit(e) { return e >= 48 && e <= 57 } function isHexDigit(e) { return '0123456789abcdefABCDEF'.indexOf(e) >= 0 } function isOctalDigit(e) { return '01234567'.indexOf(e) >= 0 } function octalToDecimal(e) { let t = e !== '0'; let r = '01234567'.indexOf(e); return c < D && isOctalDigit(u[c]) && (t = !0, r = 8 * r + '01234567'.indexOf(u[c++]), '0123'.indexOf(e) >= 0 && c < D && isOctalDigit(u[c]) && (r = 8 * r + '01234567'.indexOf(u[c++]))), { code: r, octal: t } } function isWhiteSpace(e) { return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0 } function isLineTerminator(e) { return e === 10 || e === 13 || e === 8232 || e === 8233 } function fromCodePoint(e) { return e < 65536 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10)) + String.fromCharCode(56320 + (e - 65536 & 1023)) } function isIdentifierStart(e) { return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && s.NonAsciiIdentifierStart.test(fromCodePoint(e)) } function isIdentifierPart(e) { return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && s.NonAsciiIdentifierPart.test(fromCodePoint(e)) } function isStrictModeReservedWord(e) { switch (e) { case 'implements': case 'interface': case 'package': case 'private': case 'protected': case 'public': case 'static': case 'yield': case 'let': return !0; default: return !1; } } function isRestrictedWord(e) { return e === 'eval' || e === 'arguments' } function addComment(e, t, r, n, i) { let a; assert(typeof r === 'number', 'Comment must have valid position'), C.lastCommentStart = r, a = { type: e, value: t }, w.range && (a.range = [r, n]), w.loc && (a.loc = i), w.comments.push(a), w.attachComment && (w.leadingComments.push(a), w.trailingComments.push(a)), w.tokenize && (a.type += 'Comment', w.delegate && (a = w.delegate(a)), w.tokens.push(a)) } function skipSingleLineComment(e) { let t; let r; let n; let i; for (t = c - e, r = { start: { line: p, column: c - f - e } }; c < D;) if (n = u.charCodeAt(c), ++c, isLineTerminator(n)) return d = !0, w.comments && (i = u.slice(t + e, c - 1), r.end = { line: p, column: c - f - 1 }, addComment('Line', i, t, c - 1, r)), n === 13 && u.charCodeAt(c) === 10 && ++c, ++p, void (f = c); w.comments && (i = u.slice(t + e, c), r.end = { line: p, column: c - f }, addComment('Line', i, t, c, r)) } function skipMultiLineComment() { let e; let t; let r; let n; for (w.comments && (e = c - 2, t = { start: { line: p, column: c - f - 2 } }); c < D;) if (isLineTerminator(r = u.charCodeAt(c)))r === 13 && u.charCodeAt(c + 1) === 10 && ++c, d = !0, ++p, f = ++c; else if (r === 42) { if (u.charCodeAt(c + 1) === 47) return ++c, ++c, void (w.comments && (n = u.slice(e + 2, c - 2), t.end = { line: p, column: c - f }, addComment('Block', n, e, c, t))); ++c } else ++c; w.comments && (t.end = { line: p, column: c - f }, addComment('Block', n = u.slice(e + 2, c), e, c, t)), tolerateUnexpectedToken() } function skipComment() { let e; let t; for (d = !1, t = c === 0; c < D;) if (isWhiteSpace(e = u.charCodeAt(c)))++c; else if (isLineTerminator(e))d = !0, ++c, e === 13 && u.charCodeAt(c) === 10 && ++c, ++p, f = c, t = !0; else if (e === 47) if ((e = u.charCodeAt(c + 1)) === 47)++c, ++c, skipSingleLineComment(2), t = !0; else { if (e !== 42) break; ++c, ++c, skipMultiLineComment() } else if (t && e === 45) { if (u.charCodeAt(c + 1) !== 45 || u.charCodeAt(c + 2) !== 62) break; c += 3, skipSingleLineComment(3) } else { if (e !== 60) break; if (u.slice(c + 1, c + 4) !== '!--') break; ++c, ++c, ++c, ++c, skipSingleLineComment(4) } } function scanHexEscape(e) { let t; let r; let n; let i = 0; for (r = e === 'u' ? 4 : 2, t = 0; t < r; ++t) { if (!(c < D && isHexDigit(u[c]))) return ''; n = u[c++], i = 16 * i + '0123456789abcdef'.indexOf(n.toLowerCase()) } return String.fromCharCode(i) } function scanUnicodeCodePointEscape() { let e; let t; for (t = 0, (e = u[c]) === '}' && throwUnexpectedToken(); c < D && isHexDigit(e = u[c++]);)t = 16 * t + '0123456789abcdef'.indexOf(e.toLowerCase()); return (t > 1114111 || e !== '}') && throwUnexpectedToken(), fromCodePoint(t) } function codePointAt(e) { let t; let r; return (t = u.charCodeAt(e)) >= 55296 && t <= 56319 && (r = u.charCodeAt(e + 1)) >= 56320 && r <= 57343 && (t = 1024 * (t - 55296) + r - 56320 + 65536), t } function getComplexIdentifier() { let e; let t; let r; for (r = fromCodePoint(e = codePointAt(c)), c += r.length, e === 92 && (u.charCodeAt(c) !== 117 && throwUnexpectedToken(), u[++c] === '{' ? (++c, t = scanUnicodeCodePointEscape()) : (e = (t = scanHexEscape('u')).charCodeAt(0), t && t !== '\\' && isIdentifierStart(e) || throwUnexpectedToken()), r = t); c < D && isIdentifierPart(e = codePointAt(c));)r += t = fromCodePoint(e), c += t.length, e === 92 && (r = r.substr(0, r.length - 1), u.charCodeAt(c) !== 117 && throwUnexpectedToken(), u[++c] === '{' ? (++c, t = scanUnicodeCodePointEscape()) : (e = (t = scanHexEscape('u')).charCodeAt(0), t && t !== '\\' && isIdentifierPart(e) || throwUnexpectedToken()), r += t); return r } function scanIdentifier() {
      let e; let r; return e = c, {
        type: (r = u.charCodeAt(c) === 92 ? getComplexIdentifier() : (function getIdentifier() { let e; let t; for (e = c++; c < D;) { if ((t = u.charCodeAt(c)) === 92) return c = e, getComplexIdentifier(); if (t >= 55296 && t < 57343) return c = e, getComplexIdentifier(); if (!isIdentifierPart(t)) break; ++c } return u.slice(e, c) }())).length === 1 ? t.Identifier : (function isKeyword(e) { switch (e.length) { case 2: return e === 'if' || e === 'in' || e === 'do'; case 3: return e === 'var' || e === 'for' || e === 'new' || e === 'try' || e === 'let'; case 4: return e === 'this' || e === 'else' || e === 'case' || e === 'void' || e === 'with' || e === 'enum'; case 5: return e === 'while' || e === 'break' || e === 'catch' || e === 'throw' || e === 'const' || e === 'yield' || e === 'class' || e === 'super'; case 6: return e === 'return' || e === 'typeof' || e === 'delete' || e === 'switch' || e === 'export' || e === 'import'; case 7: return e === 'default' || e === 'finally' || e === 'extends'; case 8: return e === 'function' || e === 'continue' || e === 'debugger'; case 10: return e === 'instanceof'; default: return !1; } }(r)) ? t.Keyword : r === 'null' ? t.NullLiteral : r === 'true' || r === 'false' ? t.BooleanLiteral : t.Identifier, value: r, lineNumber: p, lineStart: f, start: e, end: c,
      };
    } function scanPunctuator() {
      let e; let r; switch (e = {
        type: t.Punctuator, value: '', lineNumber: p, lineStart: f, start: c, end: c,
      }, r = u[c]) { case '(': w.tokenize && (w.openParenToken = w.tokenValues.length), ++c; break; case '{': w.tokenize && (w.openCurlyToken = w.tokenValues.length), C.curlyStack.push('{'), ++c; break; case '.': u[++c] === '.' && u[c + 1] === '.' && (c += 2, r = '...'); break; case '}': ++c, C.curlyStack.pop(); break; case ')': case ';': case ',': case '[': case ']': case ':': case '?': case '~': ++c; break; default: (r = u.substr(c, 4)) === '>>>=' ? c += 4 : (r = r.substr(0, 3)) === '===' || r === '!==' || r === '>>>' || r === '<<=' || r === '>>=' ? c += 3 : (r = r.substr(0, 2)) === '&&' || r === '||' || r === '==' || r === '!=' || r === '+=' || r === '-=' || r === '*=' || r === '/=' || r === '++' || r === '--' || r === '<<' || r === '>>' || r === '&=' || r === '|=' || r === '^=' || r === '%=' || r === '<=' || r === '>=' || r === '=>' ? c += 2 : (r = u[c], '<>=!+-*%&|^/'.indexOf(r) >= 0 && ++c); } return c === e.start && throwUnexpectedToken(), e.end = c, e.value = r, e;
    } function scanOctalLiteral(e, r) {
      let n; let i; for (isOctalDigit(e) ? (i = !0, n = `0${u[c++]}`) : (i = !1, ++c, n = ''); c < D && isOctalDigit(u[c]);)n += u[c++]; return i || n.length !== 0 || throwUnexpectedToken(), (isIdentifierStart(u.charCodeAt(c)) || isDecimalDigit(u.charCodeAt(c))) && throwUnexpectedToken(), {
        type: t.NumericLiteral, value: parseInt(n, 8), octal: i, lineNumber: p, lineStart: f, start: r, end: c,
      };
    } function scanNumericLiteral() {
      let e; let r; let n; if (assert(isDecimalDigit((n = u[c]).charCodeAt(0)) || n === '.', 'Numeric literal must start with a decimal digit or a decimal point'), r = c, e = '', n !== '.') {
        if (e = u[c++], n = u[c], e === '0') {
          if (n === 'x' || n === 'X') {
            return ++c, (function scanHexLiteral(e) {
              for (var r = ''; c < D && isHexDigit(u[c]);)r += u[c++]; return r.length === 0 && throwUnexpectedToken(), isIdentifierStart(u.charCodeAt(c)) && throwUnexpectedToken(), {
                type: t.NumericLiteral, value: parseInt(`0x${r}`, 16), lineNumber: p, lineStart: f, start: e, end: c,
              };
            }(r));
          } if (n === 'b' || n === 'B') {
            return ++c, (function scanBinaryLiteral(e) {
              let r; let n; for (n = ''; c < D && ((r = u[c]) === '0' || r === '1');)n += u[c++]; return n.length === 0 && throwUnexpectedToken(), c < D && (isIdentifierStart(r = u.charCodeAt(c)) || isDecimalDigit(r)) && throwUnexpectedToken(), {
                type: t.NumericLiteral, value: parseInt(n, 2), lineNumber: p, lineStart: f, start: e, end: c,
              };
            }(r));
          } if (n === 'o' || n === 'O') return scanOctalLiteral(n, r); if (isOctalDigit(n) && (function isImplicitOctalLiteral() { let e; let t; for (e = c + 1; e < D; ++e) { if ((t = u[e]) === '8' || t === '9') return !1; if (!isOctalDigit(t)) return !0; } return !0 }())) return scanOctalLiteral(n, r);
        } for (;isDecimalDigit(u.charCodeAt(c));)e += u[c++]; n = u[c];
      } if (n === '.') { for (e += u[c++]; isDecimalDigit(u.charCodeAt(c));)e += u[c++]; n = u[c] } if (n === 'e' || n === 'E') if (e += u[c++], (n = u[c]) !== '+' && n !== '-' || (e += u[c++]), isDecimalDigit(u.charCodeAt(c))) for (;isDecimalDigit(u.charCodeAt(c));)e += u[c++]; else throwUnexpectedToken(); return isIdentifierStart(u.charCodeAt(c)) && throwUnexpectedToken(), {
        type: t.NumericLiteral, value: parseFloat(e), lineNumber: p, lineStart: f, start: r, end: c,
      };
    } function scanRegExp() {
      let e; let r; let n; let i; return x = !0, _ = null, skipComment(), e = c, r = (function scanRegExpBody() { let e; let t; let r; let n; for (assert((e = u[c]) === '/', 'Regular expression literal must start with a slash'), t = u[c++], r = !1, n = !1; c < D;) if (t += e = u[c++], e === '\\')isLineTerminator((e = u[c++]).charCodeAt(0)) && throwUnexpectedToken(null, o.UnterminatedRegExp), t += e; else if (isLineTerminator(e.charCodeAt(0)))throwUnexpectedToken(null, o.UnterminatedRegExp); else if (r)e === ']' && (r = !1); else { if (e === '/') { n = !0; break }e === '[' && (r = !0) } return n || throwUnexpectedToken(null, o.UnterminatedRegExp), { value: t.substr(1, t.length - 2), literal: t } }()), n = (function scanRegExpFlags() { let e; let t; let r; let n; for (t = '', r = ''; c < D && isIdentifierPart((e = u[c]).charCodeAt(0));) if (++c, e === '\\' && c < D) if ((e = u[c]) === 'u') { if (n = ++c, e = scanHexEscape('u')) for (r += e, t += '\\u'; n < c; ++n)t += u[n]; else c = n, r += 'u', t += '\\u'; tolerateUnexpectedToken() } else t += '\\', tolerateUnexpectedToken(); else r += e, t += e; return { value: r, literal: t } }()), i = (function testRegExp(e, t) { let r = e; t.indexOf('u') >= 0 && (r = r.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, (e, t, r) => { const n = parseInt(t || r, 16); return n > 1114111 && throwUnexpectedToken(null, o.InvalidRegExp), n <= 65535 ? String.fromCharCode(n) : '' }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '')); try { RegExp(r) } catch (e) { throwUnexpectedToken(null, o.InvalidRegExp) } try { return new RegExp(e, t) } catch (e) { return null } }(r.value, n.value)), x = !1, w.tokenize ? {
        type: t.RegularExpression, value: i, regex: { pattern: r.value, flags: n.value }, lineNumber: p, lineStart: f, start: e, end: c,
      } : {
        literal: r.literal + n.literal, value: i, regex: { pattern: r.value, flags: n.value }, start: e, end: c,
      };
    } function collectRegex() {
      let e; let t; let r; let n; return skipComment(), e = c, t = { start: { line: p, column: c - f } }, r = scanRegExp(), t.end = { line: p, column: c - f }, w.tokenize || (w.tokens.length > 0 && (n = w.tokens[w.tokens.length - 1]).range[0] === e && n.type === 'Punctuator' && (n.value !== '/' && n.value !== '/=' || w.tokens.pop()), w.tokens.push({
        type: 'RegularExpression', value: r.literal, regex: r.regex, range: [e, c], loc: t,
      })), r;
    } function isIdentifierName(e) { return e.type === t.Identifier || e.type === t.Keyword || e.type === t.BooleanLiteral || e.type === t.NullLiteral } function advance() {
      let e; let r; return c >= D ? {
        type: t.EOF, lineNumber: p, lineStart: f, start: c, end: c,
      } : isIdentifierStart(e = u.charCodeAt(c)) ? (r = scanIdentifier(), l && isStrictModeReservedWord(r.value) && (r.type = t.Keyword), r) : e === 40 || e === 41 || e === 59 ? scanPunctuator() : e === 39 || e === 34 ? (function scanStringLiteral() {
        let e; let r; let n; let i; let a; let o = ''; let s = !1; for (assert((e = u[c]) === "'" || e === '"', 'String literal must starts with a quote'), r = c, ++c; c < D;) { if ((n = u[c++]) === e) { e = ''; break } if (n === '\\') if ((n = u[c++]) && isLineTerminator(n.charCodeAt(0)))++p, n === '\r' && u[c] === '\n' && ++c, f = c; else switch (n) { case 'u': case 'x': if (u[c] === '{')++c, o += scanUnicodeCodePointEscape(); else { if (!(i = scanHexEscape(n))) throw throwUnexpectedToken(); o += i } break; case 'n': o += '\n'; break; case 'r': o += '\r'; break; case 't': o += '\t'; break; case 'b': o += '\b'; break; case 'f': o += '\f'; break; case 'v': o += '\v'; break; case '8': case '9': o += n, tolerateUnexpectedToken(); break; default: isOctalDigit(n) ? (s = (a = octalToDecimal(n)).octal || s, o += String.fromCharCode(a.code)) : o += n; } else { if (isLineTerminator(n.charCodeAt(0))) break; o += n } } return e !== '' && (c = r, throwUnexpectedToken()), {
          type: t.StringLiteral, value: o, octal: s, lineNumber: y, lineStart: b, start: r, end: c,
        };
      }()) : e === 46 ? isDecimalDigit(u.charCodeAt(c + 1)) ? scanNumericLiteral() : scanPunctuator() : isDecimalDigit(e) ? scanNumericLiteral() : w.tokenize && e === 47 ? (function advanceSlash() { let e; let t; let r; function testKeyword(e) { return e && e.length > 1 && e[0] >= 'a' && e[0] <= 'z' } switch (e = (t = w.tokenValues[w.tokenValues.length - 1]) !== null, t) { case 'this': case ']': e = !1; break; case ')': e = (r = w.tokenValues[w.openParenToken - 1]) === 'if' || r === 'while' || r === 'for' || r === 'with'; break; case '}': e = !1, testKeyword(w.tokenValues[w.openCurlyToken - 3]) ? e = !!(r = w.tokenValues[w.openCurlyToken - 4]) && n.indexOf(r) < 0 : testKeyword(w.tokenValues[w.openCurlyToken - 4]) && (e = !(r = w.tokenValues[w.openCurlyToken - 5]) || n.indexOf(r) < 0); } return e ? collectRegex() : scanPunctuator() }()) : e === 96 || e === 125 && C.curlyStack[C.curlyStack.length - 1] === '${' ? (function scanTemplate() {
        let e; let r; let n; let i; let a; let s; let l; let d; let h = ''; for (i = !1, s = !1, r = c, a = u[c] === '`', n = 2, ++c; c < D;) { if ((e = u[c++]) === '`') { n = 1, s = !0, i = !0; break } if (e === '$') { if (u[c] === '{') { C.curlyStack.push('${'), ++c, i = !0; break }h += e } else if (e === '\\') if (isLineTerminator((e = u[c++]).charCodeAt(0)))++p, e === '\r' && u[c] === '\n' && ++c, f = c; else switch (e) { case 'n': h += '\n'; break; case 'r': h += '\r'; break; case 't': h += '\t'; break; case 'u': case 'x': u[c] === '{' ? (++c, h += scanUnicodeCodePointEscape()) : (l = c, (d = scanHexEscape(e)) ? h += d : (c = l, h += e)); break; case 'b': h += '\b'; break; case 'f': h += '\f'; break; case 'v': h += '\v'; break; default: e === '0' ? (isDecimalDigit(u.charCodeAt(c)) && throwError(o.TemplateOctalLiteral), h += '\0') : isOctalDigit(e) ? throwError(o.TemplateOctalLiteral) : h += e; } else isLineTerminator(e.charCodeAt(0)) ? (++p, e === '\r' && u[c] === '\n' && ++c, f = c, h += '\n') : h += e; } return i || throwUnexpectedToken(), a || C.curlyStack.pop(), {
          type: t.Template, value: { cooked: h, raw: u.slice(r + 1, c - n) }, head: a, tail: s, lineNumber: p, lineStart: f, start: r, end: c,
        };
      }()) : e >= 55296 && e < 57343 && isIdentifierStart(e = codePointAt(c)) ? scanIdentifier() : scanPunctuator();
    } function collectToken() {
      let e; let n; let i; let a; return e = { start: { line: p, column: c - f } }, n = advance(), e.end = { line: p, column: c - f }, n.type !== t.EOF && (i = u.slice(n.start, n.end), a = {
        type: r[n.type], value: i, range: [n.start, n.end], loc: e,
      }, n.regex && (a.regex = { pattern: n.regex.pattern, flags: n.regex.flags }), w.tokenValues && w.tokenValues.push(a.type === 'Punctuator' || a.type === 'Keyword' ? a.value : null), w.tokenize && (w.range || delete a.range, w.loc || delete a.loc, w.delegate && (a = w.delegate(a))), w.tokens.push(a)), n;
    } function lex() { let e; return x = !0, h = c, m = p, g = f, skipComment(), e = _, v = c, y = p, b = f, _ = void 0 !== w.tokens ? collectToken() : advance(), x = !1, e } function peek() { x = !0, skipComment(), h = c, m = p, g = f, v = c, y = p, b = f, _ = void 0 !== w.tokens ? collectToken() : advance(), x = !1 } function SourceLocation() { this.start = new function Position() { this.line = y, this.column = v - b }(), this.end = null } function Node() { w.range && (this.range = [v, 0]), w.loc && (this.loc = new SourceLocation()) } function WrappingNode(e) { w.range && (this.range = [e.start, 0]), w.loc && (this.loc = new function WrappingSourceLocation(e) { this.start = { line: e.lineNumber, column: e.start - e.lineStart }, this.end = null }(e)) } function recordError(e) { let t; let r; for (t = 0; t < w.errors.length; t++) if ((r = w.errors[t]).index === e.index && r.message === e.message) return; w.errors.push(e) } function createError(e, t, r) { let n; return (n = (function constructError(e, t) { let r = new Error(e); try { throw r } catch (e) { Object.create && Object.defineProperty && (r = Object.create(e), Object.defineProperty(r, 'column', { value: t })) } finally { return r } }(`Line ${e}: ${r}`, t - (x ? f : g) + 1))).lineNumber = e, n.description = r, n.index = t, n } function throwError(e) { let t; let r; throw t = Array.prototype.slice.call(arguments, 1), r = e.replace(/%(\d)/g, (e, r) => assert(r < t.length, 'Message reference must be in range'), t[r]), createError(m, h, r) } function tolerateError(e) { let t; let r; let n; if (t = Array.prototype.slice.call(arguments, 1), r = e.replace(/%(\d)/g, (e, r) => assert(r < t.length, 'Message reference must be in range'), t[r]), n = createError(p, h, r), !w.errors) throw n; recordError(n) } function unexpectedTokenError(e, r) { let n; let i = r || o.UnexpectedToken; return e ? (r || (i = e.type === t.EOF ? o.UnexpectedEOS : e.type === t.Identifier ? o.UnexpectedIdentifier : e.type === t.NumericLiteral ? o.UnexpectedNumber : e.type === t.StringLiteral ? o.UnexpectedString : e.type === t.Template ? o.UnexpectedTemplate : o.UnexpectedToken, e.type === t.Keyword && (!(function isFutureReservedWord(e) { switch (e) { case 'enum': case 'export': case 'import': case 'super': return !0; default: return !1; } }(e.value)) ? l && isStrictModeReservedWord(e.value) && (i = o.StrictReservedWord) : i = o.UnexpectedReserved)), n = e.type === t.Template ? e.value.raw : e.value) : n = 'ILLEGAL', i = i.replace('%0', n), e && typeof e.lineNumber === 'number' ? createError(e.lineNumber, e.start, i) : createError(x ? p : m, x ? c : h, i) } function throwUnexpectedToken(e, t) { throw unexpectedTokenError(e, t) } function tolerateUnexpectedToken(e, t) { const r = unexpectedTokenError(e, t); if (!w.errors) throw r; recordError(r) } function expect(e) { const r = lex(); r.type === t.Punctuator && r.value === e || throwUnexpectedToken(r) } function expectCommaSeparator() { let e; w.errors ? (e = _).type === t.Punctuator && e.value === ',' ? lex() : e.type === t.Punctuator && e.value === ';' ? (lex(), tolerateUnexpectedToken(e)) : tolerateUnexpectedToken(e, o.UnexpectedToken) : expect(',') } function expectKeyword(e) { const r = lex(); r.type === t.Keyword && r.value === e || throwUnexpectedToken(r) } function match(e) { return _.type === t.Punctuator && _.value === e } function matchKeyword(e) { return _.type === t.Keyword && _.value === e } function matchContextualKeyword(e) { return _.type === t.Identifier && _.value === e } function consumeSemicolon() { u.charCodeAt(v) === 59 || match(';') ? lex() : d || (h = v, m = y, g = b, _.type === t.EOF || match('}') || throwUnexpectedToken(_)) } function isolateCoverGrammar(e) { let t; const r = E; const n = S; const i = k; return E = !0, S = !0, k = null, t = e(), k !== null && throwUnexpectedToken(k), E = r, S = n, k = i, t } function inheritCoverGrammar(e) { let t; const r = E; const n = S; const i = k; return E = !0, S = !0, k = null, t = e(), E = E && r, S = S && n, k = i || k, t } function parsePropertyPattern(e, r) { let n; let i; let a; const o = new Node(); const s = match('['); if (_.type === t.Identifier) { if (i = _, n = parseVariableIdentifier(), match('=')) return e.push(i), lex(), a = parseAssignmentExpression(), o.finishProperty('init', n, !1, new WrappingNode(i).finishAssignmentPattern(n, a), !1, !0); if (!match(':')) return e.push(i), o.finishProperty('init', n, !1, n, !1, !0); } else n = parseObjectPropertyKey(); return expect(':'), a = parsePatternWithDefault(e, r), o.finishProperty('init', n, s, a, !1, !1) } function parsePattern(e, t) {
      return match('[') ? (function parseArrayPattern(e, t) { let r; let n; const i = new Node(); const a = []; for (expect('['); !match(']');) if (match(','))lex(), a.push(null); else { if (match('...')) { n = new Node(), lex(), e.push(_), r = parseVariableIdentifier(t), a.push(n.finishRestElement(r)); break }a.push(parsePatternWithDefault(e, t)), match(']') || expect(',') } return expect(']'), i.finishArrayPattern(a) }(e, t)) : match('{') ? (function parseObjectPattern(e, t) {
        const r = new Node();


        const n = []; for (expect('{'); !match('}');)n.push(parsePropertyPattern(e, t)), match('}') || expect(','); return lex(), r.finishObjectPattern(n);
      }(e, t)) : (matchKeyword('let') && (t !== 'const' && t !== 'let' || tolerateUnexpectedToken(_, o.UnexpectedToken)), e.push(_), parseVariableIdentifier(t));
    } function parsePatternWithDefault(e, t) { let r; let n; let i; const a = _; return r = parsePattern(e, t), match('=') && (lex(), n = C.allowYield, C.allowYield = !0, i = isolateCoverGrammar(parseAssignmentExpression), C.allowYield = n, r = new WrappingNode(a).finishAssignmentPattern(r, i)), r } function parseArrayInitializer() { let e; const t = []; const r = new Node(); for (expect('['); !match(']');)match(',') ? (lex(), t.push(null)) : match('...') ? (e = new Node(), lex(), e.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression)), match(']') || (S = E = !1, expect(',')), t.push(e)) : (t.push(inheritCoverGrammar(parseAssignmentExpression)), match(']') || expect(',')); return lex(), r.finishArrayExpression(t) } function parsePropertyFunction(e, t, r) { let n; let i; return S = E = !1, n = l, i = isolateCoverGrammar(parseFunctionSourceElements), l && t.firstRestricted && tolerateUnexpectedToken(t.firstRestricted, t.message), l && t.stricted && tolerateUnexpectedToken(t.stricted, t.message), l = n, e.finishFunctionExpression(null, t.params, t.defaults, i, r) } function parseObjectPropertyKey() { let e; let r; const n = new Node(); switch ((e = lex()).type) { case t.StringLiteral: case t.NumericLiteral: return l && e.octal && tolerateUnexpectedToken(e, o.StrictOctalLiteral), n.finishLiteral(e); case t.Identifier: case t.BooleanLiteral: case t.NullLiteral: case t.Keyword: return n.finishIdentifier(e.value); case t.Punctuator: if (e.value === '[') return r = isolateCoverGrammar(parseAssignmentExpression), expect(']'), r; }throwUnexpectedToken(e) } function lookaheadPropertyName() { switch (_.type) { case t.Identifier: case t.StringLiteral: case t.BooleanLiteral: case t.NullLiteral: case t.NumericLiteral: case t.Keyword: return !0; case t.Punctuator: return _.value === '['; } return !1 } function tryParseMethodDefinition(e, r, n, i) {
      let a; let o; let s; let u; const l = C.allowYield; if (e.type === t.Identifier) {
        if (e.value === 'get' && lookaheadPropertyName()) {
          return n = match('['), r = parseObjectPropertyKey(), s = new Node(), expect('('), expect(')'), C.allowYield = !1, a = parsePropertyFunction(s, {
            params: [], defaults: [], stricted: null, firstRestricted: null, message: null,
          }, !1), C.allowYield = l, i.finishProperty('get', r, n, a, !1, !1);
        } if (e.value === 'set' && lookaheadPropertyName()) {
          return n = match('['), r = parseObjectPropertyKey(), s = new Node(), expect('('), o = {
            params: [], defaultCount: 0, defaults: [], firstRestricted: null, paramSet: {},
          }, match(')') ? tolerateUnexpectedToken(_) : (C.allowYield = !1, parseParam(o), C.allowYield = l, o.defaultCount === 0 && (o.defaults = [])), expect(')'), C.allowYield = !1, a = parsePropertyFunction(s, o, !1), C.allowYield = l, i.finishProperty('set', r, n, a, !1, !1);
        }
      } else if (e.type === t.Punctuator && e.value === '*' && lookaheadPropertyName()) return n = match('['), r = parseObjectPropertyKey(), s = new Node(), C.allowYield = !0, u = parseParams(), C.allowYield = l, C.allowYield = !1, a = parsePropertyFunction(s, u, !0), C.allowYield = l, i.finishProperty('init', r, n, a, !0, !1); return r && match('(') ? (a = (function parsePropertyMethodFunction() { let e; let t; const r = new Node(); const n = C.allowYield; return C.allowYield = !1, e = parseParams(), C.allowYield = n, C.allowYield = !1, t = parsePropertyFunction(r, e, !1), C.allowYield = n, t }()), i.finishProperty('init', r, n, a, !0, !1)) : null;
    } function parseObjectProperty(e) { let r; let n; let a; let s; let u; const l = _; const c = new Node(); return r = match('['), match('*') ? lex() : n = parseObjectPropertyKey(), (a = tryParseMethodDefinition(l, n, r, c)) ? a : (n || throwUnexpectedToken(_), r || (s = n.type === i.Identifier && n.name === '__proto__' || n.type === i.Literal && n.value === '__proto__', e.value && s && tolerateError(o.DuplicateProtoProperty), e.value |= s), match(':') ? (lex(), u = inheritCoverGrammar(parseAssignmentExpression), c.finishProperty('init', n, r, u, !1, !1)) : l.type === t.Identifier ? match('=') ? (k = _, lex(), u = isolateCoverGrammar(parseAssignmentExpression), c.finishProperty('init', n, r, new WrappingNode(l).finishAssignmentPattern(n, u), !1, !0)) : c.finishProperty('init', n, r, n, !1, !0) : void throwUnexpectedToken(_)) } function parseObjectInitializer() { const e = []; const t = { value: !1 }; const r = new Node(); for (expect('{'); !match('}');)e.push(parseObjectProperty(t)), match('}') || expectCommaSeparator(); return expect('}'), r.finishObjectExpression(e) } function reinterpretExpressionAsPattern(e) { let t; switch (e.type) { case i.Identifier: case i.MemberExpression: case i.RestElement: case i.AssignmentPattern: break; case i.SpreadElement: e.type = i.RestElement, reinterpretExpressionAsPattern(e.argument); break; case i.ArrayExpression: for (e.type = i.ArrayPattern, t = 0; t < e.elements.length; t++)e.elements[t] !== null && reinterpretExpressionAsPattern(e.elements[t]); break; case i.ObjectExpression: for (e.type = i.ObjectPattern, t = 0; t < e.properties.length; t++)reinterpretExpressionAsPattern(e.properties[t].value); break; case i.AssignmentExpression: e.type = i.AssignmentPattern, reinterpretExpressionAsPattern(e.left); } } function parseTemplateElement(e) { let r; let n; return (_.type !== t.Template || e.head && !_.head) && throwUnexpectedToken(), r = new Node(), n = lex(), r.finishTemplateElement({ raw: n.value.raw, cooked: n.value.cooked }, n.tail) } function parseTemplateLiteral() { let e; let t; let r; const n = new Node(); for (t = [e = parseTemplateElement({ head: !0 })], r = []; !e.tail;)r.push(parseExpression()), e = parseTemplateElement({ head: !1 }), t.push(e); return n.finishTemplateLiteral(t, r) } function parseGroupExpression() { let e; let t; let r; let n; const o = []; if (expect('('), match(')')) return lex(), match('=>') || expect('=>'), { type: a.ArrowParameterPlaceHolder, params: [], rawParams: [] }; if (r = _, match('...')) return e = parseRestElement(o), expect(')'), match('=>') || expect('=>'), { type: a.ArrowParameterPlaceHolder, params: [e] }; if (E = !0, e = inheritCoverGrammar(parseAssignmentExpression), match(',')) { for (S = !1, t = [e]; v < D && match(',');) { if (lex(), match('...')) { for (E || throwUnexpectedToken(_), t.push(parseRestElement(o)), expect(')'), match('=>') || expect('=>'), E = !1, n = 0; n < t.length; n++)reinterpretExpressionAsPattern(t[n]); return { type: a.ArrowParameterPlaceHolder, params: t } }t.push(inheritCoverGrammar(parseAssignmentExpression)) }e = new WrappingNode(r).finishSequenceExpression(t) } if (expect(')'), match('=>')) { if (e.type === i.Identifier && e.name === 'yield') return { type: a.ArrowParameterPlaceHolder, params: [e] }; if (E || throwUnexpectedToken(_), e.type === i.SequenceExpression) for (n = 0; n < e.expressions.length; n++)reinterpretExpressionAsPattern(e.expressions[n]); else reinterpretExpressionAsPattern(e); e = { type: a.ArrowParameterPlaceHolder, params: e.type === i.SequenceExpression ? e.expressions : [e] } } return E = !1, e } function parsePrimaryExpression() { let e; let r; let n; let i; if (match('(')) return E = !1, inheritCoverGrammar(parseGroupExpression); if (match('[')) return inheritCoverGrammar(parseArrayInitializer); if (match('{')) return inheritCoverGrammar(parseObjectInitializer); if (e = _.type, i = new Node(), e === t.Identifier)C.sourceType === 'module' && _.value === 'await' && tolerateUnexpectedToken(_), n = i.finishIdentifier(lex().value); else if (e === t.StringLiteral || e === t.NumericLiteral)S = E = !1, l && _.octal && tolerateUnexpectedToken(_, o.StrictOctalLiteral), n = i.finishLiteral(lex()); else if (e === t.Keyword) { if (!l && C.allowYield && matchKeyword('yield')) return parseNonComputedProperty(); if (!l && matchKeyword('let')) return i.finishIdentifier(lex().value); if (S = E = !1, matchKeyword('function')) return (function parseFunctionExpression() { let e; let t; let r; let n; let i; let a; let s; let u; let c; let p = null; let f = []; let d = []; const h = new Node(); c = C.allowYield, expectKeyword('function'), (u = match('*')) && lex(); C.allowYield = !u, match('(') || (e = _, p = l || u || !matchKeyword('yield') ? parseVariableIdentifier() : parseNonComputedProperty(), l ? isRestrictedWord(e.value) && tolerateUnexpectedToken(e, o.StrictFunctionName) : isRestrictedWord(e.value) ? (r = e, n = o.StrictFunctionName) : isStrictModeReservedWord(e.value) && (r = e, n = o.StrictReservedWord)); i = parseParams(r), f = i.params, d = i.defaults, t = i.stricted, r = i.firstRestricted, i.message && (n = i.message); s = l, a = parseFunctionSourceElements(), l && r && throwUnexpectedToken(r, n); l && t && tolerateUnexpectedToken(t, n); return l = s, C.allowYield = c, h.finishFunctionExpression(p, f, d, a, u) }()); if (matchKeyword('this')) return lex(), i.finishThisExpression(); if (matchKeyword('class')) return (function parseClassExpression() { let e; let r = null; let n = null; const i = new Node(); const a = l; l = !0, expectKeyword('class'), _.type === t.Identifier && (r = parseVariableIdentifier()); matchKeyword('extends') && (lex(), n = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)); return e = parseClassBody(), l = a, i.finishClassExpression(r, n, e) }()); throwUnexpectedToken(lex()) } else e === t.BooleanLiteral ? (S = E = !1, (r = lex()).value = r.value === 'true', n = i.finishLiteral(r)) : e === t.NullLiteral ? (S = E = !1, (r = lex()).value = null, n = i.finishLiteral(r)) : match('/') || match('/=') ? (S = E = !1, c = v, r = void 0 !== w.tokens ? collectRegex() : scanRegExp(), lex(), n = i.finishLiteral(r)) : e === t.Template ? n = parseTemplateLiteral() : throwUnexpectedToken(lex()); return n } function parseArguments() { let e; const t = []; if (expect('('), !match(')')) for (;v < D && (match('...') ? (e = new Node(), lex(), e.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression))) : e = isolateCoverGrammar(parseAssignmentExpression), t.push(e), !match(')'));)expectCommaSeparator(); return expect(')'), t } function parseNonComputedProperty() { let e; const t = new Node(); return isIdentifierName(e = lex()) || throwUnexpectedToken(e), t.finishIdentifier(e.value) } function parseNonComputedMember() { return expect('.'), parseNonComputedProperty() } function parseComputedMember() { let e; return expect('['), e = isolateCoverGrammar(parseExpression), expect(']'), e } function parseNewExpression() { let e; let r; const n = new Node(); if (expectKeyword('new'), match('.')) { if (lex(), _.type === t.Identifier && _.value === 'target' && C.inFunctionBody) return lex(), n.finishMetaProperty('new', 'target'); throwUnexpectedToken(_) } return e = isolateCoverGrammar(parseLeftHandSideExpression), r = match('(') ? parseArguments() : [], S = E = !1, n.finishNewExpression(e, r) } function parseLeftHandSideExpressionAllowCall() { let e; let r; let n; let i; let a; const o = C.allowIn; for (a = _, C.allowIn = !0, matchKeyword('super') && C.inFunctionBody ? (r = new Node(), lex(), r = r.finishSuper(), match('(') || match('.') || match('[') || throwUnexpectedToken(_)) : r = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression); ;) if (match('.'))E = !1, S = !0, i = parseNonComputedMember(), r = new WrappingNode(a).finishMemberExpression('.', r, i); else if (match('('))E = !1, S = !1, n = parseArguments(), r = new WrappingNode(a).finishCallExpression(r, n); else if (match('['))E = !1, S = !0, i = parseComputedMember(), r = new WrappingNode(a).finishMemberExpression('[', r, i); else { if (_.type !== t.Template || !_.head) break; e = parseTemplateLiteral(), r = new WrappingNode(a).finishTaggedTemplateExpression(r, e) } return C.allowIn = o, r } function parseLeftHandSideExpression() { let e; let r; let n; let i; for (assert(C.allowIn, 'callee of new expression always allow in keyword.'), i = _, matchKeyword('super') && C.inFunctionBody ? (r = new Node(), lex(), r = r.finishSuper(), match('[') || match('.') || throwUnexpectedToken(_)) : r = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression); ;) if (match('['))E = !1, S = !0, n = parseComputedMember(), r = new WrappingNode(i).finishMemberExpression('[', r, n); else if (match('.'))E = !1, S = !0, n = parseNonComputedMember(), r = new WrappingNode(i).finishMemberExpression('.', r, n); else { if (_.type !== t.Template || !_.head) break; e = parseTemplateLiteral(), r = new WrappingNode(i).finishTaggedTemplateExpression(r, e) } return r } function parsePostfixExpression() { let e; let r; const n = _; return e = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall), d || _.type !== t.Punctuator || (match('++') || match('--')) && (l && e.type === i.Identifier && isRestrictedWord(e.name) && tolerateError(o.StrictLHSPostfix), S || tolerateError(o.InvalidLHSInAssignment), S = E = !1, r = lex(), e = new WrappingNode(n).finishPostfixExpression(r.value, e)), e } function parseUnaryExpression() { let e; let r; let n; return _.type !== t.Punctuator && _.type !== t.Keyword ? r = parsePostfixExpression() : match('++') || match('--') ? (n = _, e = lex(), r = inheritCoverGrammar(parseUnaryExpression), l && r.type === i.Identifier && isRestrictedWord(r.name) && tolerateError(o.StrictLHSPrefix), S || tolerateError(o.InvalidLHSInAssignment), r = new WrappingNode(n).finishUnaryExpression(e.value, r), S = E = !1) : match('+') || match('-') || match('~') || match('!') ? (n = _, e = lex(), r = inheritCoverGrammar(parseUnaryExpression), r = new WrappingNode(n).finishUnaryExpression(e.value, r), S = E = !1) : matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof') ? (n = _, e = lex(), r = inheritCoverGrammar(parseUnaryExpression), r = new WrappingNode(n).finishUnaryExpression(e.value, r), l && r.operator === 'delete' && r.argument.type === i.Identifier && tolerateError(o.StrictDelete), S = E = !1) : r = parsePostfixExpression(), r } function binaryPrecedence(e, r) { let n = 0; if (e.type !== t.Punctuator && e.type !== t.Keyword) return 0; switch (e.value) { case '||': n = 1; break; case '&&': n = 2; break; case '|': n = 3; break; case '^': n = 4; break; case '&': n = 5; break; case '==': case '!=': case '===': case '!==': n = 6; break; case '<': case '>': case '<=': case '>=': case 'instanceof': n = 7; break; case 'in': n = r ? 7 : 0; break; case '<<': case '>>': case '>>>': n = 8; break; case '+': case '-': n = 9; break; case '*': case '/': case '%': n = 11; } return n } function parseBinaryExpression() { let e; let t; let r; let n; let i; let a; let o; let s; let u; let l; if (e = _, u = inheritCoverGrammar(parseUnaryExpression), (i = binaryPrecedence(n = _, C.allowIn)) === 0) return u; for (S = E = !1, n.prec = i, lex(), t = [e, _], a = [u, n, o = isolateCoverGrammar(parseUnaryExpression)]; (i = binaryPrecedence(_, C.allowIn)) > 0;) { for (;a.length > 2 && i <= a[a.length - 2].prec;)o = a.pop(), s = a.pop().value, u = a.pop(), t.pop(), r = new WrappingNode(t[t.length - 1]).finishBinaryExpression(s, u, o), a.push(r); (n = lex()).prec = i, a.push(n), t.push(_), r = isolateCoverGrammar(parseUnaryExpression), a.push(r) } for (r = a[l = a.length - 1], t.pop(); l > 1;)r = new WrappingNode(t.pop()).finishBinaryExpression(a[l - 1].value, a[l - 2], r), l -= 2; return r } function checkPatternParam(e, t) { let r; switch (t.type) { case i.Identifier: validateParam(e, t, t.name); break; case i.RestElement: checkPatternParam(e, t.argument); break; case i.AssignmentPattern: checkPatternParam(e, t.left); break; case i.ArrayPattern: for (r = 0; r < t.elements.length; r++)t.elements[r] !== null && checkPatternParam(e, t.elements[r]); break; case i.YieldExpression: break; default: for (assert(t.type === i.ObjectPattern, 'Invalid type'), r = 0; r < t.properties.length; r++)checkPatternParam(e, t.properties[r].value); } } function parseArrowFunctionExpression(e, t) { let r; let n; let a; return d && tolerateUnexpectedToken(_), expect('=>'), r = l, n = C.allowYield, C.allowYield = !0, a = (function parseConciseBody() { return match('{') ? parseFunctionSourceElements() : isolateCoverGrammar(parseAssignmentExpression) }()), l && e.firstRestricted && throwUnexpectedToken(e.firstRestricted, e.message), l && e.stricted && tolerateUnexpectedToken(e.stricted, e.message), l = r, C.allowYield = n, t.finishArrowFunctionExpression(e.params, e.defaults, a, a.type !== i.BlockStatement) } function parseAssignmentExpression() {
      let e; let r; let n; let s; let u; return u = _, e = _, !C.allowYield && matchKeyword('yield') ? (function parseYieldExpression() { let e; let r; let n; let i; return e = null, r = new Node(), n = !1, expectKeyword('yield'), d || (i = C.allowYield, C.allowYield = !1, (n = match('*')) ? (lex(), e = parseAssignmentExpression()) : match(';') || match('}') || match(')') || _.type === t.EOF || (e = parseAssignmentExpression()), C.allowYield = i), r.finishYieldExpression(e, n) }()) : (r = (function parseConditionalExpression() { let e; let t; let r; let n; let i; return i = _, e = inheritCoverGrammar(parseBinaryExpression), match('?') && (lex(), t = C.allowIn, C.allowIn = !0, r = isolateCoverGrammar(parseAssignmentExpression), C.allowIn = t, expect(':'), n = isolateCoverGrammar(parseAssignmentExpression), e = new WrappingNode(i).finishConditionalExpression(e, r, n), S = E = !1), e }())).type === a.ArrowParameterPlaceHolder || match('=>') ? (S = E = !1, (s = (function reinterpretAsCoverFormalsList(e) {
        let t; let r; let n; let s; let u; let c; let p; switch (u = [], c = 0, s = [e], e.type) { case i.Identifier: break; case a.ArrowParameterPlaceHolder: s = e.params; break; default: return null; } for (p = { paramSet: {} }, t = 0, r = s.length; t < r; t += 1) switch ((n = s[t]).type) { case i.AssignmentPattern: s[t] = n.left, n.right.type === i.YieldExpression && (n.right.argument && throwUnexpectedToken(_), n.right.type = i.Identifier, n.right.name = 'yield', delete n.right.argument, delete n.right.delegate), u.push(n.right), ++c, checkPatternParam(p, n.left); break; default: checkPatternParam(p, n), s[t] = n, u.push(null); } if (l || !C.allowYield) for (t = 0, r = s.length; t < r; t += 1)(n = s[t]).type === i.YieldExpression && throwUnexpectedToken(_); return p.message === o.StrictParamDupe && throwUnexpectedToken(l ? p.stricted : p.firstRestricted, p.message), c === 0 && (u = []), {
          params: s, defaults: u, stricted: p.stricted, firstRestricted: p.firstRestricted, message: p.message,
        };
      }(r))) ? (k = null, parseArrowFunctionExpression(s, new WrappingNode(u))) : r) : ((function matchAssign() { let e; return _.type === t.Punctuator && ((e = _.value) === '=' || e === '*=' || e === '/=' || e === '%=' || e === '+=' || e === '-=' || e === '<<=' || e === '>>=' || e === '>>>=' || e === '&=' || e === '^=' || e === '|=') }()) && (S || tolerateError(o.InvalidLHSInAssignment), l && r.type === i.Identifier && (isRestrictedWord(r.name) && tolerateUnexpectedToken(e, o.StrictLHSAssignment), isStrictModeReservedWord(r.name) && tolerateUnexpectedToken(e, o.StrictReservedWord)), match('=') ? reinterpretExpressionAsPattern(r) : S = E = !1, e = lex(), n = isolateCoverGrammar(parseAssignmentExpression), r = new WrappingNode(u).finishAssignmentExpression(e.value, r, n), k = null), r);
    } function parseExpression() { let e; let t; const r = _; if (e = isolateCoverGrammar(parseAssignmentExpression), match(',')) { for (t = [e]; v < D && match(',');)lex(), t.push(isolateCoverGrammar(parseAssignmentExpression)); e = new WrappingNode(r).finishSequenceExpression(t) } return e } function parseStatementListItem() {
      if (_.type === t.Keyword) switch (_.value) { case 'export': return C.sourceType !== 'module' && tolerateUnexpectedToken(_, o.IllegalExportDeclaration), (function parseExportDeclaration() { const e = new Node(); C.inFunctionBody && throwError(o.IllegalExportDeclaration); if (expectKeyword('export'), matchKeyword('default')) return (function parseExportDefaultDeclaration(e) { let t = null; let r = null; if (expectKeyword('default'), matchKeyword('function')) return t = parseFunctionDeclaration(new Node(), !0), e.finishExportDefaultDeclaration(t); if (matchKeyword('class')) return t = parseClassDeclaration(!0), e.finishExportDefaultDeclaration(t); matchContextualKeyword('from') && throwError(o.UnexpectedToken, _.value); r = match('{') ? parseObjectInitializer() : match('[') ? parseArrayInitializer() : parseAssignmentExpression(); return consumeSemicolon(), e.finishExportDefaultDeclaration(r) }(e)); if (match('*')) return (function parseExportAllDeclaration(e) { let t; expect('*'), matchContextualKeyword('from') || throwError(_.value ? o.UnexpectedToken : o.MissingFromClause, _.value); return lex(), t = parseModuleSpecifier(), consumeSemicolon(), e.finishExportAllDeclaration(t) }(e)); return (function parseExportNamedDeclaration(e) { let r; let n = null; let i = null; const a = []; if (_.type === t.Keyword) switch (_.value) { case 'let': case 'const': return n = parseLexicalDeclaration({ inFor: !1 }), e.finishExportNamedDeclaration(n, a, null); case 'var': case 'class': case 'function': return n = parseStatementListItem(), e.finishExportNamedDeclaration(n, a, null); }expect('{'); for (;!match('}') && (r = r || matchKeyword('default'), a.push(parseExportSpecifier()), match('}') || (expect(','), !match('}'))););expect('}'), matchContextualKeyword('from') ? (lex(), i = parseModuleSpecifier(), consumeSemicolon()) : r ? throwError(_.value ? o.UnexpectedToken : o.MissingFromClause, _.value) : consumeSemicolon(); return e.finishExportNamedDeclaration(n, a, i) }(e)) }()); case 'import': return C.sourceType !== 'module' && tolerateUnexpectedToken(_, o.IllegalImportDeclaration), (function parseImportDeclaration() { let e; let r = []; const n = new Node(); C.inFunctionBody && throwError(o.IllegalImportDeclaration); expectKeyword('import'), _.type === t.StringLiteral ? e = parseModuleSpecifier() : (match('{') ? r = r.concat(parseNamedImports()) : match('*') ? r.push(parseImportNamespaceSpecifier()) : isIdentifierName(_) && !matchKeyword('default') ? (r.push(function parseImportDefaultSpecifier() { let e; const t = new Node(); return e = parseNonComputedProperty(), t.finishImportDefaultSpecifier(e) }()), match(',') && (lex(), match('*') ? r.push(parseImportNamespaceSpecifier()) : match('{') ? r = r.concat(parseNamedImports()) : throwUnexpectedToken(_))) : throwUnexpectedToken(lex()), matchContextualKeyword('from') || throwError(_.value ? o.UnexpectedToken : o.MissingFromClause, _.value), lex(), e = parseModuleSpecifier()); return consumeSemicolon(), n.finishImportDeclaration(r, e) }()); case 'const': return parseLexicalDeclaration({ inFor: !1 }); case 'function': return parseFunctionDeclaration(new Node()); case 'class': return parseClassDeclaration(); } return matchKeyword('let') && (function isLexicalDeclaration() {
        let e; let r; return r = (function tokenizerState() {
          return {
            index: c, lineNumber: p, lineStart: f, hasLineTerminator: d, lastIndex: h, lastLineNumber: m, lastLineStart: g, startIndex: v, startLineNumber: y, startLineStart: b, lookahead: _, tokenCount: w.tokens ? w.tokens.length : 0,
          };
        }()), lex(), e = _.type === t.Identifier || match('[') || match('{') || matchKeyword('let') || matchKeyword('yield'), (function resetTokenizerState(e) { c = e.index, p = e.lineNumber, f = e.lineStart, d = e.hasLineTerminator, h = e.lastIndex, m = e.lastLineNumber, g = e.lastLineStart, v = e.startIndex, y = e.startLineNumber, b = e.startLineStart, _ = e.lookahead, w.tokens && w.tokens.splice(e.tokenCount, w.tokens.length) }(r)), e;
      }()) ? parseLexicalDeclaration({ inFor: !1 }) : parseStatement();
    } function parseBlock() { let e; const t = new Node(); return expect('{'), e = (function parseStatementList() { for (var e = []; v < D && !match('}');)e.push(parseStatementListItem()); return e }()), expect('}'), t.finishBlockStatement(e) } function parseVariableIdentifier(e) { let r; const n = new Node(); return (r = lex()).type === t.Keyword && r.value === 'yield' ? (l && tolerateUnexpectedToken(r, o.StrictReservedWord), C.allowYield || throwUnexpectedToken(r)) : r.type !== t.Identifier ? l && r.type === t.Keyword && isStrictModeReservedWord(r.value) ? tolerateUnexpectedToken(r, o.StrictReservedWord) : (l || r.value !== 'let' || e !== 'var') && throwUnexpectedToken(r) : C.sourceType === 'module' && r.type === t.Identifier && r.value === 'await' && tolerateUnexpectedToken(r), n.finishIdentifier(r.value) } function parseVariableDeclaration(e) { let t; let r = null; const n = new Node(); return t = parsePattern([], 'var'), l && isRestrictedWord(t.name) && tolerateError(o.StrictVarName), match('=') ? (lex(), r = isolateCoverGrammar(parseAssignmentExpression)) : t.type === i.Identifier || e.inFor || expect('='), n.finishVariableDeclarator(t, r) } function parseVariableDeclarationList(e) { let t; let r; for (r = [parseVariableDeclaration(t = { inFor: e.inFor })]; match(',');)lex(), r.push(parseVariableDeclaration(t)); return r } function parseLexicalBinding(e, t) { let r; let n = null; const a = new Node(); return r = parsePattern([], e), l && r.type === i.Identifier && isRestrictedWord(r.name) && tolerateError(o.StrictVarName), e === 'const' ? matchKeyword('in') || matchContextualKeyword('of') || (expect('='), n = isolateCoverGrammar(parseAssignmentExpression)) : (!t.inFor && r.type !== i.Identifier || match('=')) && (expect('='), n = isolateCoverGrammar(parseAssignmentExpression)), a.finishVariableDeclarator(r, n) } function parseBindingList(e, t) { for (var r = [parseLexicalBinding(e, t)]; match(',');)lex(), r.push(parseLexicalBinding(e, t)); return r } function parseLexicalDeclaration(e) { let t; let r; const n = new Node(); return assert((t = lex().value) === 'let' || t === 'const', 'Lexical declaration must be either let or const'), r = parseBindingList(t, e), consumeSemicolon(), n.finishLexicalDeclaration(r, t) } function parseRestElement(e) { let t; const r = new Node(); return lex(), match('{') && throwError(o.ObjectPatternAsRestParameter), e.push(_), t = parseVariableIdentifier(), match('=') && throwError(o.DefaultRestParameter), match(')') || throwError(o.ParameterAfterRestParameter), r.finishRestElement(t) } function parseSwitchCase() { let e; let t; const r = []; const n = new Node(); for (matchKeyword('default') ? (lex(), e = null) : (expectKeyword('case'), e = parseExpression()), expect(':'); v < D && !(match('}') || matchKeyword('default') || matchKeyword('case'));)t = parseStatementListItem(), r.push(t); return n.finishSwitchCase(e, r) } function parseTryStatement(e) { let t; let r = null; let n = null; return expectKeyword('try'), t = parseBlock(), matchKeyword('catch') && (r = (function parseCatchClause() { let e; let t; let r; let n; const i = []; const a = {}; const s = new Node(); for (expectKeyword('catch'), expect('('), match(')') && throwUnexpectedToken(_), e = parsePattern(i), r = 0; r < i.length; r++)t = `$${i[r].value}`, Object.prototype.hasOwnProperty.call(a, t) && tolerateError(o.DuplicateBinding, i[r].value), a[t] = !0; return l && isRestrictedWord(e.name) && tolerateError(o.StrictCatchVariable), expect(')'), n = parseBlock(), s.finishCatchClause(e, n) }())), matchKeyword('finally') && (lex(), n = parseBlock()), r || n || throwError(o.NoCatchOrFinally), e.finishTryStatement(t, r, n) } function parseStatement() { let e; let r; let n; let a; const s = _.type; if (s === t.EOF && throwUnexpectedToken(_), s === t.Punctuator && _.value === '{') return parseBlock(); if (S = E = !0, a = new Node(), s === t.Punctuator) switch (_.value) { case ';': return (function parseEmptyStatement(e) { return expect(';'), e.finishEmptyStatement() }(a)); case '(': return (function parseExpressionStatement(e) { const t = parseExpression(); return consumeSemicolon(), e.finishExpressionStatement(t) }(a)); } else if (s === t.Keyword) switch (_.value) { case 'break': return (function parseBreakStatement(e) { let r; let n = null; return expectKeyword('break'), u.charCodeAt(h) === 59 ? (lex(), C.inIteration || C.inSwitch || throwError(o.IllegalBreak), e.finishBreakStatement(null)) : (d ? C.inIteration || C.inSwitch || throwError(o.IllegalBreak) : _.type === t.Identifier && (r = `$${(n = parseVariableIdentifier()).name}`, Object.prototype.hasOwnProperty.call(C.labelSet, r) || throwError(o.UnknownLabel, n.name)), consumeSemicolon(), n !== null || C.inIteration || C.inSwitch || throwError(o.IllegalBreak), e.finishBreakStatement(n)) }(a)); case 'continue': return (function parseContinueStatement(e) { let r; let n = null; return expectKeyword('continue'), u.charCodeAt(v) === 59 ? (lex(), C.inIteration || throwError(o.IllegalContinue), e.finishContinueStatement(null)) : d ? (C.inIteration || throwError(o.IllegalContinue), e.finishContinueStatement(null)) : (_.type === t.Identifier && (r = `$${(n = parseVariableIdentifier()).name}`, Object.prototype.hasOwnProperty.call(C.labelSet, r) || throwError(o.UnknownLabel, n.name)), consumeSemicolon(), n !== null || C.inIteration || throwError(o.IllegalContinue), e.finishContinueStatement(n)) }(a)); case 'debugger': return (function parseDebuggerStatement(e) { return expectKeyword('debugger'), consumeSemicolon(), e.finishDebuggerStatement() }(a)); case 'do': return (function parseDoWhileStatement(e) { let t; let r; let n; return expectKeyword('do'), n = C.inIteration, C.inIteration = !0, t = parseStatement(), C.inIteration = n, expectKeyword('while'), expect('('), r = parseExpression(), expect(')'), match(';') && lex(), e.finishDoWhileStatement(t, r) }(a)); case 'for': return (function parseForStatement(e) { let t; let r; let n; let i; let a; let s; let u; let c; let p; let f; let d; let h; const m = C.allowIn; if (t = a = s = null, r = !0, expectKeyword('for'), expect('('), match(';'))lex(); else if (matchKeyword('var'))t = new Node(), lex(), C.allowIn = !1, f = parseVariableDeclarationList({ inFor: !0 }), C.allowIn = m, f.length === 1 && matchKeyword('in') ? (t = t.finishVariableDeclaration(f), lex(), u = t, c = parseExpression(), t = null) : f.length === 1 && f[0].init === null && matchContextualKeyword('of') ? (t = t.finishVariableDeclaration(f), lex(), u = t, c = parseAssignmentExpression(), t = null, r = !1) : (t = t.finishVariableDeclaration(f), expect(';')); else if (matchKeyword('const') || matchKeyword('let'))t = new Node(), p = lex().value, l || _.value !== 'in' ? (C.allowIn = !1, f = parseBindingList(p, { inFor: !0 }), C.allowIn = m, f.length === 1 && f[0].init === null && matchKeyword('in') ? (t = t.finishLexicalDeclaration(f, p), lex(), u = t, c = parseExpression(), t = null) : f.length === 1 && f[0].init === null && matchContextualKeyword('of') ? (t = t.finishLexicalDeclaration(f, p), lex(), u = t, c = parseAssignmentExpression(), t = null, r = !1) : (consumeSemicolon(), t = t.finishLexicalDeclaration(f, p))) : (t = t.finishIdentifier(p), lex(), u = t, c = parseExpression(), t = null); else if (i = _, C.allowIn = !1, t = inheritCoverGrammar(parseAssignmentExpression), C.allowIn = m, matchKeyword('in'))S || tolerateError(o.InvalidLHSInForIn), lex(), reinterpretExpressionAsPattern(t), u = t, c = parseExpression(), t = null; else if (matchContextualKeyword('of'))S || tolerateError(o.InvalidLHSInForLoop), lex(), reinterpretExpressionAsPattern(t), u = t, c = parseAssignmentExpression(), t = null, r = !1; else { if (match(',')) { for (n = [t]; match(',');)lex(), n.push(isolateCoverGrammar(parseAssignmentExpression)); t = new WrappingNode(i).finishSequenceExpression(n) }expect(';') } return void 0 === u && (match(';') || (a = parseExpression()), expect(';'), match(')') || (s = parseExpression())), expect(')'), h = C.inIteration, C.inIteration = !0, d = isolateCoverGrammar(parseStatement), C.inIteration = h, void 0 === u ? e.finishForStatement(t, a, s, d) : r ? e.finishForInStatement(u, c, d) : e.finishForOfStatement(u, c, d) }(a)); case 'function': return parseFunctionDeclaration(a); case 'if': return (function parseIfStatement(e) { let t; let r; let n; return expectKeyword('if'), expect('('), t = parseExpression(), expect(')'), r = parseStatement(), matchKeyword('else') ? (lex(), n = parseStatement()) : n = null, e.finishIfStatement(t, r, n) }(a)); case 'return': return (function parseReturnStatement(e) { let r = null; return expectKeyword('return'), C.inFunctionBody || tolerateError(o.IllegalReturn), u.charCodeAt(h) === 32 && isIdentifierStart(u.charCodeAt(h + 1)) ? (r = parseExpression(), consumeSemicolon(), e.finishReturnStatement(r)) : d ? e.finishReturnStatement(null) : (match(';') || match('}') || _.type === t.EOF || (r = parseExpression()), consumeSemicolon(), e.finishReturnStatement(r)) }(a)); case 'switch': return (function parseSwitchStatement(e) { let t; let r; let n; let i; let a; if (expectKeyword('switch'), expect('('), t = parseExpression(), expect(')'), expect('{'), r = [], match('}')) return lex(), e.finishSwitchStatement(t, r); for (i = C.inSwitch, C.inSwitch = !0, a = !1; v < D && !match('}');)(n = parseSwitchCase()).test === null && (a && throwError(o.MultipleDefaultsInSwitch), a = !0), r.push(n); return C.inSwitch = i, expect('}'), e.finishSwitchStatement(t, r) }(a)); case 'throw': return (function parseThrowStatement(e) { let t; return expectKeyword('throw'), d && throwError(o.NewlineAfterThrow), t = parseExpression(), consumeSemicolon(), e.finishThrowStatement(t) }(a)); case 'try': return parseTryStatement(a); case 'var': return (function parseVariableStatement(e) { let t; return expectKeyword('var'), t = parseVariableDeclarationList({ inFor: !1 }), consumeSemicolon(), e.finishVariableDeclaration(t) }(a)); case 'while': return (function parseWhileStatement(e) { let t; let r; let n; return expectKeyword('while'), expect('('), t = parseExpression(), expect(')'), n = C.inIteration, C.inIteration = !0, r = parseStatement(), C.inIteration = n, e.finishWhileStatement(t, r) }(a)); case 'with': return (function parseWithStatement(e) { let t; let r; return l && tolerateError(o.StrictModeWith), expectKeyword('with'), expect('('), t = parseExpression(), expect(')'), r = parseStatement(), e.finishWithStatement(t, r) }(a)); } return (e = parseExpression()).type === i.Identifier && match(':') ? (lex(), n = `$${e.name}`, Object.prototype.hasOwnProperty.call(C.labelSet, n) && throwError(o.Redeclaration, 'Label', e.name), C.labelSet[n] = !0, r = parseStatement(), delete C.labelSet[n], a.finishLabeledStatement(e, r)) : (consumeSemicolon(), a.finishExpressionStatement(e)) } function parseFunctionSourceElements() { let e; let r; let n; let a; let s; let c; let p; const f = []; const d = new Node(); for (expect('{'); v < D && _.type === t.StringLiteral && (r = _, e = parseStatementListItem(), f.push(e), e.expression.type === i.Literal);)u.slice(r.start + 1, r.end - 1) === 'use strict' ? (l = !0, n && tolerateUnexpectedToken(n, o.StrictOctalLiteral)) : !n && r.octal && (n = r); for (a = C.labelSet, s = C.inIteration, c = C.inSwitch, p = C.inFunctionBody, C.labelSet = {}, C.inIteration = !1, C.inSwitch = !1, C.inFunctionBody = !0; v < D && !match('}');)f.push(parseStatementListItem()); return expect('}'), C.labelSet = a, C.inIteration = s, C.inSwitch = c, C.inFunctionBody = p, d.finishBlockStatement(f) } function validateParam(e, t, r) { const n = `$${r}`; l ? (isRestrictedWord(r) && (e.stricted = t, e.message = o.StrictParamName), Object.prototype.hasOwnProperty.call(e.paramSet, n) && (e.stricted = t, e.message = o.StrictParamDupe)) : e.firstRestricted || (isRestrictedWord(r) ? (e.firstRestricted = t, e.message = o.StrictParamName) : isStrictModeReservedWord(r) ? (e.firstRestricted = t, e.message = o.StrictReservedWord) : Object.prototype.hasOwnProperty.call(e.paramSet, n) && (e.stricted = t, e.message = o.StrictParamDupe)), e.paramSet[n] = !0 } function parseParam(e) { let t; let r; let n; const a = []; if (_.value === '...') return validateParam(e, (t = parseRestElement(a)).argument, t.argument.name), e.params.push(t), e.defaults.push(null), !1; for (t = parsePatternWithDefault(a), r = 0; r < a.length; r++)validateParam(e, a[r], a[r].value); return t.type === i.AssignmentPattern && (n = t.right, t = t.left, ++e.defaultCount), e.params.push(t), e.defaults.push(n), !match(')') } function parseParams(e) {
      let t; if (t = {
        params: [], defaultCount: 0, defaults: [], firstRestricted: e,
      }, expect('('), !match(')')) for (t.paramSet = {}; v < D && parseParam(t);)expect(','); return expect(')'), t.defaultCount === 0 && (t.defaults = []), {
        params: t.params, defaults: t.defaults, stricted: t.stricted, firstRestricted: t.firstRestricted, message: t.message,
      };
    } function parseFunctionDeclaration(e, t) { let r; let n; let i; let a; let s; let u; let c; let p; let f; let d; let h; let m = null; return h = C.allowYield, expectKeyword('function'), (d = match('*')) && lex(), t && match('(') || (a = _, m = parseVariableIdentifier(), l ? isRestrictedWord(a.value) && tolerateUnexpectedToken(a, o.StrictFunctionName) : isRestrictedWord(a.value) ? (c = a, p = o.StrictFunctionName) : isStrictModeReservedWord(a.value) && (c = a, p = o.StrictReservedWord)), C.allowYield = !d, r = (u = parseParams(c)).params, n = u.defaults, s = u.stricted, c = u.firstRestricted, u.message && (p = u.message), f = l, i = parseFunctionSourceElements(), l && c && throwUnexpectedToken(c, p), l && s && tolerateUnexpectedToken(s, p), l = f, C.allowYield = h, e.finishFunctionDeclaration(m, r, n, i, d) } function parseClassBody() { let e; let t; let r; let n; let a; let s; let u; let l = !1; for (e = new Node(), expect('{'), n = []; !match('}');)match(';') ? lex() : (a = new Node(), t = _, r = !1, s = match('['), match('*') ? lex() : (u = parseObjectPropertyKey()).name === 'static' && (lookaheadPropertyName() || match('*')) && (t = _, r = !0, s = match('['), match('*') ? lex() : u = parseObjectPropertyKey()), (a = tryParseMethodDefinition(t, u, s, a)) ? (a.static = r, a.kind === 'init' && (a.kind = 'method'), r ? a.computed || (a.key.name || a.key.value.toString()) !== 'prototype' || throwUnexpectedToken(t, o.StaticPrototype) : a.computed || (a.key.name || a.key.value.toString()) !== 'constructor' || (a.kind === 'method' && a.method && !a.value.generator || throwUnexpectedToken(t, o.ConstructorSpecialMethod), l ? throwUnexpectedToken(t, o.DuplicateConstructor) : l = !0, a.kind = 'constructor'), a.type = i.MethodDefinition, delete a.method, delete a.shorthand, n.push(a)) : throwUnexpectedToken(_)); return lex(), e.finishClassBody(n) } function parseClassDeclaration(e) { let r; let n = null; let i = null; const a = new Node(); const o = l; return l = !0, expectKeyword('class'), e && _.type !== t.Identifier || (n = parseVariableIdentifier()), matchKeyword('extends') && (lex(), i = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)), r = parseClassBody(), l = o, a.finishClassDeclaration(n, i, r) } function parseModuleSpecifier() { const e = new Node(); return _.type !== t.StringLiteral && throwError(o.InvalidModuleSpecifier), e.finishLiteral(lex()) } function parseExportSpecifier() { let e; let t; let r; const n = new Node(); return matchKeyword('default') ? (r = new Node(), lex(), t = r.finishIdentifier('default')) : t = parseVariableIdentifier(), matchContextualKeyword('as') && (lex(), e = parseNonComputedProperty()), n.finishExportSpecifier(t, e) } function parseNamedImports() { let e; let t; let r; const n = []; for (expect('{'); !match('}') && (n.push((e = void 0, t = void 0, r = void 0, r = new Node(), t = parseNonComputedProperty(), matchContextualKeyword('as') && (lex(), e = parseVariableIdentifier()), r.finishImportSpecifier(e, t))), match('}') || (expect(','), !match('}'))););return expect('}'), n } function parseImportNamespaceSpecifier() { let e; const t = new Node(); return expect('*'), matchContextualKeyword('as') || throwError(o.NoAsAfterImportNamespace), lex(), e = parseNonComputedProperty(), t.finishImportNamespaceSpecifier(e) } function parseProgram() { let e; let r; return peek(), r = new Node(), e = (function parseScriptBody() { for (var e, r, n, a = []; v < D && (r = _).type === t.StringLiteral && (e = parseStatementListItem(), a.push(e), e.expression.type === i.Literal);)u.slice(r.start + 1, r.end - 1) === 'use strict' ? (l = !0, n && tolerateUnexpectedToken(n, o.StrictOctalLiteral)) : !n && r.octal && (n = r); for (;v < D && void 0 !== (e = parseStatementListItem());)a.push(e); return a }()), r.finishProgram(e, C.sourceType) }(r = {})[(t = {
      BooleanLiteral: 1, EOF: 2, Identifier: 3, Keyword: 4, NullLiteral: 5, NumericLiteral: 6, Punctuator: 7, StringLiteral: 8, RegularExpression: 9, Template: 10,
    }).BooleanLiteral] = 'Boolean', r[t.EOF] = '<end>', r[t.Identifier] = 'Identifier', r[t.Keyword] = 'Keyword', r[t.NullLiteral] = 'Null', r[t.NumericLiteral] = 'Numeric', r[t.Punctuator] = 'Punctuator', r[t.StringLiteral] = 'String', r[t.RegularExpression] = 'RegularExpression', r[t.Template] = 'Template', n = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='], i = {
      AssignmentExpression: 'AssignmentExpression', AssignmentPattern: 'AssignmentPattern', ArrayExpression: 'ArrayExpression', ArrayPattern: 'ArrayPattern', ArrowFunctionExpression: 'ArrowFunctionExpression', BlockStatement: 'BlockStatement', BinaryExpression: 'BinaryExpression', BreakStatement: 'BreakStatement', CallExpression: 'CallExpression', CatchClause: 'CatchClause', ClassBody: 'ClassBody', ClassDeclaration: 'ClassDeclaration', ClassExpression: 'ClassExpression', ConditionalExpression: 'ConditionalExpression', ContinueStatement: 'ContinueStatement', DoWhileStatement: 'DoWhileStatement', DebuggerStatement: 'DebuggerStatement', EmptyStatement: 'EmptyStatement', ExportAllDeclaration: 'ExportAllDeclaration', ExportDefaultDeclaration: 'ExportDefaultDeclaration', ExportNamedDeclaration: 'ExportNamedDeclaration', ExportSpecifier: 'ExportSpecifier', ExpressionStatement: 'ExpressionStatement', ForStatement: 'ForStatement', ForOfStatement: 'ForOfStatement', ForInStatement: 'ForInStatement', FunctionDeclaration: 'FunctionDeclaration', FunctionExpression: 'FunctionExpression', Identifier: 'Identifier', IfStatement: 'IfStatement', ImportDeclaration: 'ImportDeclaration', ImportDefaultSpecifier: 'ImportDefaultSpecifier', ImportNamespaceSpecifier: 'ImportNamespaceSpecifier', ImportSpecifier: 'ImportSpecifier', Literal: 'Literal', LabeledStatement: 'LabeledStatement', LogicalExpression: 'LogicalExpression', MemberExpression: 'MemberExpression', MetaProperty: 'MetaProperty', MethodDefinition: 'MethodDefinition', NewExpression: 'NewExpression', ObjectExpression: 'ObjectExpression', ObjectPattern: 'ObjectPattern', Program: 'Program', Property: 'Property', RestElement: 'RestElement', ReturnStatement: 'ReturnStatement', SequenceExpression: 'SequenceExpression', SpreadElement: 'SpreadElement', Super: 'Super', SwitchCase: 'SwitchCase', SwitchStatement: 'SwitchStatement', TaggedTemplateExpression: 'TaggedTemplateExpression', TemplateElement: 'TemplateElement', TemplateLiteral: 'TemplateLiteral', ThisExpression: 'ThisExpression', ThrowStatement: 'ThrowStatement', TryStatement: 'TryStatement', UnaryExpression: 'UnaryExpression', UpdateExpression: 'UpdateExpression', VariableDeclaration: 'VariableDeclaration', VariableDeclarator: 'VariableDeclarator', WhileStatement: 'WhileStatement', WithStatement: 'WithStatement', YieldExpression: 'YieldExpression',
    }, a = { ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder' }, o = {
      UnexpectedToken: 'Unexpected token %0', UnexpectedNumber: 'Unexpected number', UnexpectedString: 'Unexpected string', UnexpectedIdentifier: 'Unexpected identifier', UnexpectedReserved: 'Unexpected reserved word', UnexpectedTemplate: 'Unexpected quasi %0', UnexpectedEOS: 'Unexpected end of input', NewlineAfterThrow: 'Illegal newline after throw', InvalidRegExp: 'Invalid regular expression', UnterminatedRegExp: 'Invalid regular expression: missing /', InvalidLHSInAssignment: 'Invalid left-hand side in assignment', InvalidLHSInForIn: 'Invalid left-hand side in for-in', InvalidLHSInForLoop: 'Invalid left-hand side in for-loop', MultipleDefaultsInSwitch: 'More than one default clause in switch statement', NoCatchOrFinally: 'Missing catch or finally after try', UnknownLabel: "Undefined label '%0'", Redeclaration: "%0 '%1' has already been declared", IllegalContinue: 'Illegal continue statement', IllegalBreak: 'Illegal break statement', IllegalReturn: 'Illegal return statement', StrictModeWith: 'Strict mode code may not include a with statement', StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode', StrictVarName: 'Variable name may not be eval or arguments in strict mode', StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode', StrictParamDupe: 'Strict mode function may not have duplicate parameter names', StrictFunctionName: 'Function name may not be eval or arguments in strict mode', StrictOctalLiteral: 'Octal literals are not allowed in strict mode.', StrictDelete: 'Delete of an unqualified identifier in strict mode.', StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode', StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode', StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode', StrictReservedWord: 'Use of future reserved word in strict mode', TemplateOctalLiteral: 'Octal literals are not allowed in template strings.', ParameterAfterRestParameter: 'Rest parameter must be last formal parameter', DefaultRestParameter: 'Unexpected token =', ObjectPatternAsRestParameter: 'Unexpected token {', DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals', ConstructorSpecialMethod: 'Class constructor may not be an accessor', DuplicateConstructor: 'A class may only have one constructor', StaticPrototype: 'Classes may not have static property named prototype', MissingFromClause: 'Unexpected token', NoAsAfterImportNamespace: 'Unexpected token', InvalidModuleSpecifier: 'Unexpected token', IllegalImportDeclaration: 'Unexpected token', IllegalExportDeclaration: 'Unexpected token', DuplicateBinding: 'Duplicate binding %0',
    }, s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, WrappingNode.prototype = Node.prototype = {
      processComment() { let e; let t; let r; let n; let a; let o; const s = w.bottomRightStack; let u = s[s.length - 1]; if (!(this.type === i.Program && this.body.length > 0)) { if (this.type === i.BlockStatement && this.body.length === 0) { for (t = [], a = w.leadingComments.length - 1; a >= 0; --a)o = w.leadingComments[a], this.range[1] >= o.range[1] && (t.unshift(o), w.leadingComments.splice(a, 1), w.trailingComments.splice(a, 1)); if (t.length) return void (this.innerComments = t); } if (w.trailingComments.length > 0) { for (n = [], a = w.trailingComments.length - 1; a >= 0; --a)(o = w.trailingComments[a]).range[0] >= this.range[1] && (n.unshift(o), w.trailingComments.splice(a, 1)); w.trailingComments = [] } else u && u.trailingComments && u.trailingComments[0].range[0] >= this.range[1] && (n = u.trailingComments, delete u.trailingComments); for (;u && u.range[0] >= this.range[0];)e = s.pop(), u = s[s.length - 1]; if (e) { if (e.leadingComments) { for (r = [], a = e.leadingComments.length - 1; a >= 0; --a)(o = e.leadingComments[a]).range[1] <= this.range[0] && (r.unshift(o), e.leadingComments.splice(a, 1)); e.leadingComments.length || (e.leadingComments = void 0) } } else if (w.leadingComments.length > 0) for (r = [], a = w.leadingComments.length - 1; a >= 0; --a)(o = w.leadingComments[a]).range[1] <= this.range[0] && (r.unshift(o), w.leadingComments.splice(a, 1)); r && r.length > 0 && (this.leadingComments = r), n && n.length > 0 && (this.trailingComments = n), s.push(this) } }, finish() { w.range && (this.range[1] = h), w.loc && (this.loc.end = { line: m, column: h - g }, w.source && (this.loc.source = w.source)), w.attachComment && this.processComment() }, finishArrayExpression(e) { return this.type = i.ArrayExpression, this.elements = e, this.finish(), this }, finishArrayPattern(e) { return this.type = i.ArrayPattern, this.elements = e, this.finish(), this }, finishArrowFunctionExpression(e, t, r, n) { return this.type = i.ArrowFunctionExpression, this.id = null, this.params = e, this.defaults = t, this.body = r, this.generator = !1, this.expression = n, this.finish(), this }, finishAssignmentExpression(e, t, r) { return this.type = i.AssignmentExpression, this.operator = e, this.left = t, this.right = r, this.finish(), this }, finishAssignmentPattern(e, t) { return this.type = i.AssignmentPattern, this.left = e, this.right = t, this.finish(), this }, finishBinaryExpression(e, t, r) { return this.type = e === '||' || e === '&&' ? i.LogicalExpression : i.BinaryExpression, this.operator = e, this.left = t, this.right = r, this.finish(), this }, finishBlockStatement(e) { return this.type = i.BlockStatement, this.body = e, this.finish(), this }, finishBreakStatement(e) { return this.type = i.BreakStatement, this.label = e, this.finish(), this }, finishCallExpression(e, t) { return this.type = i.CallExpression, this.callee = e, this.arguments = t, this.finish(), this }, finishCatchClause(e, t) { return this.type = i.CatchClause, this.param = e, this.body = t, this.finish(), this }, finishClassBody(e) { return this.type = i.ClassBody, this.body = e, this.finish(), this }, finishClassDeclaration(e, t, r) { return this.type = i.ClassDeclaration, this.id = e, this.superClass = t, this.body = r, this.finish(), this }, finishClassExpression(e, t, r) { return this.type = i.ClassExpression, this.id = e, this.superClass = t, this.body = r, this.finish(), this }, finishConditionalExpression(e, t, r) { return this.type = i.ConditionalExpression, this.test = e, this.consequent = t, this.alternate = r, this.finish(), this }, finishContinueStatement(e) { return this.type = i.ContinueStatement, this.label = e, this.finish(), this }, finishDebuggerStatement() { return this.type = i.DebuggerStatement, this.finish(), this }, finishDoWhileStatement(e, t) { return this.type = i.DoWhileStatement, this.body = e, this.test = t, this.finish(), this }, finishEmptyStatement() { return this.type = i.EmptyStatement, this.finish(), this }, finishExpressionStatement(e) { return this.type = i.ExpressionStatement, this.expression = e, this.finish(), this }, finishForStatement(e, t, r, n) { return this.type = i.ForStatement, this.init = e, this.test = t, this.update = r, this.body = n, this.finish(), this }, finishForOfStatement(e, t, r) { return this.type = i.ForOfStatement, this.left = e, this.right = t, this.body = r, this.finish(), this }, finishForInStatement(e, t, r) { return this.type = i.ForInStatement, this.left = e, this.right = t, this.body = r, this.each = !1, this.finish(), this }, finishFunctionDeclaration(e, t, r, n, a) { return this.type = i.FunctionDeclaration, this.id = e, this.params = t, this.defaults = r, this.body = n, this.generator = a, this.expression = !1, this.finish(), this }, finishFunctionExpression(e, t, r, n, a) { return this.type = i.FunctionExpression, this.id = e, this.params = t, this.defaults = r, this.body = n, this.generator = a, this.expression = !1, this.finish(), this }, finishIdentifier(e) { return this.type = i.Identifier, this.name = e, this.finish(), this }, finishIfStatement(e, t, r) { return this.type = i.IfStatement, this.test = e, this.consequent = t, this.alternate = r, this.finish(), this }, finishLabeledStatement(e, t) { return this.type = i.LabeledStatement, this.label = e, this.body = t, this.finish(), this }, finishLiteral(e) { return this.type = i.Literal, this.value = e.value, this.raw = u.slice(e.start, e.end), e.regex && (this.regex = e.regex), this.finish(), this }, finishMemberExpression(e, t, r) { return this.type = i.MemberExpression, this.computed = e === '[', this.object = t, this.property = r, this.finish(), this }, finishMetaProperty(e, t) { return this.type = i.MetaProperty, this.meta = e, this.property = t, this.finish(), this }, finishNewExpression(e, t) { return this.type = i.NewExpression, this.callee = e, this.arguments = t, this.finish(), this }, finishObjectExpression(e) { return this.type = i.ObjectExpression, this.properties = e, this.finish(), this }, finishObjectPattern(e) { return this.type = i.ObjectPattern, this.properties = e, this.finish(), this }, finishPostfixExpression(e, t) { return this.type = i.UpdateExpression, this.operator = e, this.argument = t, this.prefix = !1, this.finish(), this }, finishProgram(e, t) { return this.type = i.Program, this.body = e, this.sourceType = t, this.finish(), this }, finishProperty(e, t, r, n, a, o) { return this.type = i.Property, this.key = t, this.computed = r, this.value = n, this.kind = e, this.method = a, this.shorthand = o, this.finish(), this }, finishRestElement(e) { return this.type = i.RestElement, this.argument = e, this.finish(), this }, finishReturnStatement(e) { return this.type = i.ReturnStatement, this.argument = e, this.finish(), this }, finishSequenceExpression(e) { return this.type = i.SequenceExpression, this.expressions = e, this.finish(), this }, finishSpreadElement(e) { return this.type = i.SpreadElement, this.argument = e, this.finish(), this }, finishSwitchCase(e, t) { return this.type = i.SwitchCase, this.test = e, this.consequent = t, this.finish(), this }, finishSuper() { return this.type = i.Super, this.finish(), this }, finishSwitchStatement(e, t) { return this.type = i.SwitchStatement, this.discriminant = e, this.cases = t, this.finish(), this }, finishTaggedTemplateExpression(e, t) { return this.type = i.TaggedTemplateExpression, this.tag = e, this.quasi = t, this.finish(), this }, finishTemplateElement(e, t) { return this.type = i.TemplateElement, this.value = e, this.tail = t, this.finish(), this }, finishTemplateLiteral(e, t) { return this.type = i.TemplateLiteral, this.quasis = e, this.expressions = t, this.finish(), this }, finishThisExpression() { return this.type = i.ThisExpression, this.finish(), this }, finishThrowStatement(e) { return this.type = i.ThrowStatement, this.argument = e, this.finish(), this }, finishTryStatement(e, t, r) { return this.type = i.TryStatement, this.block = e, this.guardedHandlers = [], this.handlers = t ? [t] : [], this.handler = t, this.finalizer = r, this.finish(), this }, finishUnaryExpression(e, t) { return this.type = e === '++' || e === '--' ? i.UpdateExpression : i.UnaryExpression, this.operator = e, this.argument = t, this.prefix = !0, this.finish(), this }, finishVariableDeclaration(e) { return this.type = i.VariableDeclaration, this.declarations = e, this.kind = 'var', this.finish(), this }, finishLexicalDeclaration(e, t) { return this.type = i.VariableDeclaration, this.declarations = e, this.kind = t, this.finish(), this }, finishVariableDeclarator(e, t) { return this.type = i.VariableDeclarator, this.id = e, this.init = t, this.finish(), this }, finishWhileStatement(e, t) { return this.type = i.WhileStatement, this.test = e, this.body = t, this.finish(), this }, finishWithStatement(e, t) { return this.type = i.WithStatement, this.object = e, this.body = t, this.finish(), this }, finishExportSpecifier(e, t) { return this.type = i.ExportSpecifier, this.exported = t || e, this.local = e, this.finish(), this }, finishImportDefaultSpecifier(e) { return this.type = i.ImportDefaultSpecifier, this.local = e, this.finish(), this }, finishImportNamespaceSpecifier(e) { return this.type = i.ImportNamespaceSpecifier, this.local = e, this.finish(), this }, finishExportNamedDeclaration(e, t, r) { return this.type = i.ExportNamedDeclaration, this.declaration = e, this.specifiers = t, this.source = r, this.finish(), this }, finishExportDefaultDeclaration(e) { return this.type = i.ExportDefaultDeclaration, this.declaration = e, this.finish(), this }, finishExportAllDeclaration(e) { return this.type = i.ExportAllDeclaration, this.source = e, this.finish(), this }, finishImportSpecifier(e, t) { return this.type = i.ImportSpecifier, this.local = e || t, this.imported = t, this.finish(), this }, finishImportDeclaration(e, t) { return this.type = i.ImportDeclaration, this.specifiers = e, this.source = t, this.finish(), this }, finishYieldExpression(e, t) { return this.type = i.YieldExpression, this.argument = e, this.delegate = t, this.finish(), this },
    }, e.version = '2.7.3', e.tokenize = function tokenize(e, r, n) {
      let i; let a; i = String, typeof e === 'string' || e instanceof String || (e = i(e)), c = 0, p = (u = e).length > 0 ? 1 : 0, v = c, y = p, b = f = 0, D = u.length, _ = null, C = {
        allowIn: !0, allowYield: !0, labelSet: {}, inFunctionBody: !1, inIteration: !1, inSwitch: !1, lastCommentStart: -1, curlyStack: [],
      }, w = {}, (r = r || {}).tokens = !0, w.tokens = [], w.tokenValues = [], w.tokenize = !0, w.delegate = n, w.openParenToken = -1, w.openCurlyToken = -1, w.range = typeof r.range === 'boolean' && r.range, w.loc = typeof r.loc === 'boolean' && r.loc, typeof r.comment === 'boolean' && r.comment && (w.comments = []), typeof r.tolerant === 'boolean' && r.tolerant && (w.errors = []); try { if (peek(), _.type === t.EOF) return w.tokens; for (lex(); _.type !== t.EOF;) try { lex() } catch (e) { if (w.errors) { recordError(e); break } throw e }a = w.tokens, void 0 !== w.errors && (a.errors = w.errors) } catch (e) { throw e } finally { w = {} } return a;
    }, e.parse = function parse(e, t) {
      let r; let n; n = String, typeof e === 'string' || e instanceof String || (e = n(e)), c = 0, p = (u = e).length > 0 ? 1 : 0, v = c, y = p, b = f = 0, D = u.length, _ = null, C = {
        allowIn: !0, allowYield: !0, labelSet: {}, inFunctionBody: !1, inIteration: !1, inSwitch: !1, lastCommentStart: -1, curlyStack: [], sourceType: 'script',
      }, l = !1, w = {}, void 0 !== t && (w.range = typeof t.range === 'boolean' && t.range, w.loc = typeof t.loc === 'boolean' && t.loc, w.attachComment = typeof t.attachComment === 'boolean' && t.attachComment, w.loc && t.source !== null && void 0 !== t.source && (w.source = n(t.source)), typeof t.tokens === 'boolean' && t.tokens && (w.tokens = []), typeof t.comment === 'boolean' && t.comment && (w.comments = []), typeof t.tolerant === 'boolean' && t.tolerant && (w.errors = []), w.attachComment && (w.range = !0, w.comments = [], w.bottomRightStack = [], w.trailingComments = [], w.leadingComments = []), t.sourceType === 'module' && (C.sourceType = t.sourceType, l = !0)); try { r = parseProgram(), void 0 !== w.comments && (r.comments = w.comments), void 0 !== w.tokens && ((function filterTokenLocation() { let e; let t; let r; const n = []; for (e = 0; e < w.tokens.length; ++e)r = { type: (t = w.tokens[e]).type, value: t.value }, t.regex && (r.regex = { pattern: t.regex.pattern, flags: t.regex.flags }), w.range && (r.range = t.range), w.loc && (r.loc = t.loc), n.push(r); w.tokens = n }()), r.tokens = w.tokens), void 0 !== w.errors && (r.errors = w.errors) } catch (e) { throw e } finally { w = {} } return r;
    }, e.Syntax = (function () { let e; let t = {}; for (e in typeof Object.create === 'function' && (t = Object.create(null)), i)i.hasOwnProperty(e) && (t[e] = i[e]); return typeof Object.freeze === 'function' && Object.freeze(t), t }());
  }));
}, function (e, t, r) {
  /*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */const n = r(497); e.exports = function defineProperty(e, t, r) {
    if (typeof e !== 'object' && typeof e !== 'function') throw new TypeError('expected an object or function.'); if (typeof t !== 'string') throw new TypeError('expected `prop` to be a string.'); return n(r) && ('set' in r || 'get' in r) ? Object.defineProperty(e, t, r) : Object.defineProperty(e, t, {
      configurable: !0, enumerable: !1, writable: !0, value: r,
    });
  };
}, function (e, t, r) {
  /*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */const n = r(498); const i = r(499); const a = r(501); e.exports = function isDescriptor(e, t) { return n(e) === 'object' && ('get' in e ? i(e, t) : a(e, t)) };
}, function (e, t) { const r = Object.prototype.toString; e.exports = function kindOf(e) { let t = typeof e; return t === 'undefined' ? 'undefined' : e === null ? 'null' : !0 === e || !1 === e || e instanceof Boolean ? 'boolean' : t === 'string' || e instanceof String ? 'string' : t === 'number' || e instanceof Number ? 'number' : t === 'function' || e instanceof Function ? void 0 !== e.constructor.name && e.constructor.name.slice(0, 9) === 'Generator' ? 'generatorfunction' : 'function' : void 0 !== Array.isArray && Array.isArray(e) ? 'array' : e instanceof RegExp ? 'regexp' : e instanceof Date ? 'date' : (t = r.call(e)) === '[object RegExp]' ? 'regexp' : t === '[object Date]' ? 'date' : t === '[object Arguments]' ? 'arguments' : t === '[object Error]' ? 'error' : t === '[object Promise]' ? 'promise' : (function isBuffer(e) { return e.constructor && typeof e.constructor.isBuffer === 'function' && e.constructor.isBuffer(e) }(e)) ? 'buffer' : t === '[object Set]' ? 'set' : t === '[object WeakSet]' ? 'weakset' : t === '[object Map]' ? 'map' : t === '[object WeakMap]' ? 'weakmap' : t === '[object Symbol]' ? 'symbol' : t === '[object Map Iterator]' ? 'mapiterator' : t === '[object Set Iterator]' ? 'setiterator' : t === '[object String Iterator]' ? 'stringiterator' : t === '[object Array Iterator]' ? 'arrayiterator' : t === '[object Int8Array]' ? 'int8array' : t === '[object Uint8Array]' ? 'uint8array' : t === '[object Uint8ClampedArray]' ? 'uint8clampedarray' : t === '[object Int16Array]' ? 'int16array' : t === '[object Uint16Array]' ? 'uint16array' : t === '[object Int32Array]' ? 'int32array' : t === '[object Uint32Array]' ? 'uint32array' : t === '[object Float32Array]' ? 'float32array' : t === '[object Float64Array]' ? 'float64array' : 'object' } }, function (e, t, r) {
  /*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */const n = r(500); const i = {
    get: 'function', set: 'function', configurable: 'boolean', enumerable: 'boolean',
  }; function has(e, t) { return {}.hasOwnProperty.call(e, t) }e.exports = function isAccessorDescriptor(e, t) { if (typeof t === 'string') return void 0 !== Object.getOwnPropertyDescriptor(e, t); if (n(e) !== 'object') return !1; if (has(e, 'value') || has(e, 'writable')) return !1; if (!has(e, 'get') || typeof e.get !== 'function') return !1; if (has(e, 'set') && typeof e[r] !== 'function' && void 0 !== e[r]) return !1; for (var r in e) if (i.hasOwnProperty(r) && n(e[r]) !== i[r] && void 0 !== e[r]) return !1; return !0 };
}, function (e, t, r) { const n = r(155); const i = Object.prototype.toString; e.exports = function kindOf(e) { if (void 0 === e) return 'undefined'; if (e === null) return 'null'; if (!0 === e || !1 === e || e instanceof Boolean) return 'boolean'; if (typeof e === 'string' || e instanceof String) return 'string'; if (typeof e === 'number' || e instanceof Number) return 'number'; if (typeof e === 'function' || e instanceof Function) return 'function'; if (void 0 !== Array.isArray && Array.isArray(e)) return 'array'; if (e instanceof RegExp) return 'regexp'; if (e instanceof Date) return 'date'; const t = i.call(e); return t === '[object RegExp]' ? 'regexp' : t === '[object Date]' ? 'date' : t === '[object Arguments]' ? 'arguments' : t === '[object Error]' ? 'error' : n(e) ? 'buffer' : t === '[object Set]' ? 'set' : t === '[object WeakSet]' ? 'weakset' : t === '[object Map]' ? 'map' : t === '[object WeakMap]' ? 'weakmap' : t === '[object Symbol]' ? 'symbol' : t === '[object Int8Array]' ? 'int8array' : t === '[object Uint8Array]' ? 'uint8array' : t === '[object Uint8ClampedArray]' ? 'uint8clampedarray' : t === '[object Int16Array]' ? 'int16array' : t === '[object Uint16Array]' ? 'uint16array' : t === '[object Int32Array]' ? 'int32array' : t === '[object Uint32Array]' ? 'uint32array' : t === '[object Float32Array]' ? 'float32array' : t === '[object Float64Array]' ? 'float64array' : 'object' } }, function (e, t, r) {
  /*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */const n = r(502); const i = { configurable: 'boolean', enumerable: 'boolean', writable: 'boolean' }; e.exports = function isDataDescriptor(e, t) { if (n(e) !== 'object') return !1; if (typeof t === 'string') return void 0 !== Object.getOwnPropertyDescriptor(e, t); if (!('value' in e || 'writable' in e)) return !1; for (const r in e) if (r !== 'value' && i.hasOwnProperty(r) && n(e[r]) !== i[r] && void 0 !== e[r]) return !1; return !0 };
}, function (e, t, r) { const n = r(155); const i = Object.prototype.toString; e.exports = function kindOf(e) { if (void 0 === e) return 'undefined'; if (e === null) return 'null'; if (!0 === e || !1 === e || e instanceof Boolean) return 'boolean'; if (typeof e === 'string' || e instanceof String) return 'string'; if (typeof e === 'number' || e instanceof Number) return 'number'; if (typeof e === 'function' || e instanceof Function) return 'function'; if (void 0 !== Array.isArray && Array.isArray(e)) return 'array'; if (e instanceof RegExp) return 'regexp'; if (e instanceof Date) return 'date'; const t = i.call(e); return t === '[object RegExp]' ? 'regexp' : t === '[object Date]' ? 'date' : t === '[object Arguments]' ? 'arguments' : t === '[object Error]' ? 'error' : n(e) ? 'buffer' : t === '[object Set]' ? 'set' : t === '[object WeakSet]' ? 'weakset' : t === '[object Map]' ? 'map' : t === '[object WeakMap]' ? 'weakmap' : t === '[object Symbol]' ? 'symbol' : t === '[object Int8Array]' ? 'int8array' : t === '[object Uint8Array]' ? 'uint8array' : t === '[object Uint8ClampedArray]' ? 'uint8clampedarray' : t === '[object Int16Array]' ? 'int16array' : t === '[object Uint16Array]' ? 'uint16array' : t === '[object Int32Array]' ? 'int32array' : t === '[object Uint32Array]' ? 'uint32array' : t === '[object Float32Array]' ? 'float32array' : t === '[object Float64Array]' ? 'float64array' : 'object' } }, function (e, t, r) {
  const n = r(504); e.exports = function Context(e, t) { const r = t.range[1]; const i = t.loc.end.line; const a = e.slice(r); const o = a.length; let s = 0; let u = 0; let l = null; for (this.context = {}, this.value = '', this.line = null; ++s < o;) { const c = a[s]; if (c === '/' || c === '*') break; if (c !== '\n' && c !== ' ' && c !== '\t') { l = r + s; const p = e.slice(l, e.indexOf('\n', l)); const f = n(p); f && (this.context = f, this.value = p, this.line = i + u + 1); break }c === '\n' && u++ } const d = l !== null ? l + (this.value || '').length : null; this.loc = { start: { line: this.line, column: l }, end: { line: this.line, column: d } } };
}, function (e, t, r) {
  function Parser(e, t) { this.string = e, this.parent = t, this.fns = [] } function trim(e) { return (function toString(e) { return e || '' }(e)).trim() }Parser.prototype.name = function (e) { return this.parent ? this.parent + e : '' }, Parser.prototype.use = function (e, t) { return this.fns.push({ regex: e, fn: t }), this }, Parser.prototype.parse = function () { this.init(); for (let e = this.fns.length, t = -1; ++t < e;) { const r = this.fns[t]; const n = r.regex; const i = r.fn; const a = n.exec(this.string); if (a) { const o = i.call(this, a, this.parent); if (o) return this.value = o, o; } } return null }, Parser.prototype.init = function () {
    this.use(/^(module\.exports)\s*=\s*function\s*\(([^)]+)/, (e, t) => ({
      type: 'method', receiver: e[1], name: '', params: (e[2] || '').split(/[, ]+/), string: `${e[1]}.${e[2]}()`, original: e.input,
    })), this.use(/^(module\.exports)\s*=\s*function\s([\w$]+)\s*\(([^)]+)/, (e, t) => ({
      type: 'function', subtype: 'expression', receiver: e[1], name: e[2], params: (e[3] || '').split(/[, ]+/), string: `${e[2]}()`, original: e.input,
    })), this.use(/^\s*(export(\s+default)?\s+)?class\s+([\w$]+)(\s+extends\s+([\w$.]+(?:\(.*\))?))?\s*{/, (e, t) => ({
      type: 'class', ctor: e[3], name: e[3], extends: e[5], string: `new ${e[3]}()`,
    })), this.use(/^\s*constructor\s*\(([^)]+)/, function (e, t) {
      return {
        type: 'constructor', ctor: this.parent, name: 'constructor', params: (e[4] || '').split(/[, ]+/), string: `${this.name('.prototype.')}constructor()`,
      };
    }), this.use(/^\s*(static)?\s*(\*)?\s*([\w$]+|\[.*\])\s*\(([^)]+)/, function (e, t) {
      return {
        type: 'method', ctor: this.parent, name: e[2] + e[3], params: (e[4] || '').split(/[, ]+/), string: `${this.name(e[1] ? '.' : '.prototype.') + e[2] + e[3]}()`,
      };
    }), this.use(/^\s*(export(\s+default)?\s+)?function\s+([\w$]+)\s*\(([^)]+)/, (e, t) => ({
      type: 'function', subtype: 'statement', name: e[3], params: (e[4] || '').split(/[, ]+/), string: `${e[3]}()`,
    })), this.use(/^\s*export\s+default\s+function\s*\(([^)]+)/, (e, t) => ({
      type: 'function', name: e[1], params: (e[4] || '').split(/[, ]+/), string: `${e[1]}()`,
    })), this.use(/^return\s+function(?:\s+([\w$]+))?\s*\(([^)]+)/, (e, t) => ({
      type: 'function', subtype: 'expression', name: e[1], params: (e[4] || '').split(/[, ]+/), string: `${e[1]}()`,
    })), this.use(/^\s*(?:const|let|var)\s+([\w$]+)\s*=\s*function\s*\(([^)]+)/, (e, t) => ({
      type: 'function', subtype: 'expression', name: e[1], params: (e[2] || '').split(/[, ]+/), string: `${e[1] || ''}()`,
    })), this.use(/^\s*([\w$.]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*=\s*function\s*\(([^)]+)/, (e, t) => ({
      type: 'prototype method', category: 'method', ctor: e[1], name: e[2], params: (e[3] || '').split(/[, ]+/), string: `${e[1]}.prototype.${e[2]}()`,
    })), this.use(/^\s*([\w$.]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*=\s*([^\n;]+)/, (e, t) => ({
      type: 'prototype property', ctor: e[1], name: e[2], value: trim(e[3]), string: `${e[1]}.prototype.${e[2]}`,
    })), this.use(/^\s*([\w$]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*/, (e, t) => ({
      type: 'prototype property', ctor: e[1], name: e[2], string: `${e[1]}.prototype.${e[2]}`,
    })), this.use(/^\s*([\w$.]+)\s*\.\s*prototype\s*=\s*{/, (e, t) => ({
      type: 'prototype', ctor: e[1], name: e[1], string: `${e[1]}.prototype`,
    })), this.use(/^\s*\(*\s*([\w$.]+)\s*\)*\s*=>/, function (e, t) {
      return {
        type: 'function', ctor: this.parent, name: e[1], string: `${this.name('.prototype.') + e[1]}()`,
      };
    }), this.use(/^\s*([\w$.]+)\s*:\s*function\s*\(([^)]+)/, function (e, t) {
      return {
        type: 'method', ctor: this.parent, name: e[1], string: `${this.name('.prototype.') + e[1]}()`,
      };
    }), this.use(/^\s*([\w$.]+)\s*:\s*([^\n;]+)/, function (e, t) {
      return {
        type: 'property', ctor: this.parent, name: e[1], value: trim(e[2]), string: this.name('.') + e[1],
      };
    }), this.use(/^\s*(get|set)\s*([\w$.]+)\s*\(([^)]+)/, function (e, t) {
      return {
        type: 'property', ctor: this.parent, name: e[2], string: this.name('.prototype.') + e[2],
      };
    }), this.use(/^\s*([\w$.]+)\s*\.\s*([\w$]+)\s*=\s*function\s*\(([^)]+)/, (e, t) => ({
      type: 'method', receiver: e[1], name: e[2], params: (e[3] || '').split(/[, ]+/), string: `${e[1]}.${e[2]}()`,
    })), this.use(/^\s*([\w$.]+)\s*\.\s*([\w$]+)\s*=\s*([^\n;]+)/, (e, t) => ({
      type: 'property', receiver: e[1], name: e[2], value: trim(e[3]), string: `${e[1]}.${e[2]}`,
    })), this.use(/^\s*(?:const|let|var)\s+([\w$]+)\s*=\s*([^\n;]+)/, (e, t) => ({
      type: 'declaration', name: e[1], value: trim(e[2]), string: e[1],
    }));
  }, e.exports = function (e, t, r) { return new Parser(e, t, r).parse() }, e.exports.Parser = Parser;
}, function (e, t, r) {
  const n = r(506); e.exports = function BlockComment(e, t) { this.type = t.type, this.range = t.range, this.loc = t.loc, this.raw = t.value, this.value = n.stripStars(this.raw) };
}, function (e, t, r) {
  const n = e.exports; n.toPrefixRegex = function (e) { const t = `(${e.join('|')})`; return new RegExp(`^${t}`) }, n.trimRight = function (e) { return e.replace(/\s+$/, '') }, n.stripStars = function (e) { return e = (e = e.replace(/^[ \t]/gm, '')).replace(/^[ \t]*\*[ \t]?/gm, ''), n.trimRight(e) }, e.exports = n;
}, function (e, t, r) {
  e.exports = function LineComment(e, t) { this.type = t.type, this.range = t.range, this.loc = t.loc, this.raw = t.value, this.value = this.raw.trim() };
}, function (e, t, r) {
  function scoper(e, t) { const r = new RegExp('([^\r\n,{}]+)(,(?=[^}]*{)|s*{)', 'g'); return e = e.replace(r, (e, r, n) => (r.match(/^\s*(@media|@keyframes|to|from|@font-face)/) ? r + n : (r.match(/:scope/) && (r = r.replace(/([^\s]*):scope/, (e, t) => (t === '' ? '> *' : `> ${t}`))), (r = (r = `${r.trim()} `).replace(/ /g, `${t} `)) + n))) }Object.defineProperty(t, '__esModule', { value: !0 }), (function init() { const e = document.createElement('style'); e.appendChild(document.createTextNode('')), document.head.appendChild(e), e.sheet.insertRule('body { visibility: hidden; }', 0) }()), t.default = function process() { const e = document.body.querySelectorAll('style[scoped]'); if (e.length !== 0) { const t = document.head || document.getElementsByTagName('head')[0]; const r = document.createElement('style'); r.dataset.cssscoper = 'true'; let n = ''; let i = void 0; for (i = 0; i < e.length; i++) { const a = e[i]; const o = a.id; const s = a.innerHTML; if (s && a.parentElement.nodeName !== 'BODY') { const u = `[${o}]`; a.parentNode.removeChild(a), n += scoper(s, u) } }r.styleSheet ? r.styleSheet.cssText = n : r.appendChild(document.createTextNode(n)), t.appendChild(r), document.getElementsByTagName('body')[0].style.visibility = 'visible' } else document.getElementsByTagName('body')[0].style.visibility = 'visible'; };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = Slot; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Slot(e, t) { const r = e.name; const a = e.active; const o = e.onlyActive; const s = e.className; const u = e.props; let l = void 0 === u ? {} : u; const c = t.slots; const p = c[r]; if (!p) throw new Error(`Slot "${r}" not found, available slots: ${Object.keys(c).join(', ')}`); const f = p.map((e, t) => { const r = e; const s = r.id; const u = r.render; if (s && u) { if (o && s !== a) return null; const c = l.onClick; l = n({}, l, { name: s, active: a && s === a, onClick: c && function () { for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return c(...[s].concat(t)) } }), e = u } return i.default.createElement(e, n({ key: t }, l)) }).filter(Boolean); return f.length === 0 ? null : i.default.createElement('div', { className: s }, f) }Slot.propTypes = {
    name: a.default.string.isRequired, active: a.default.string, onlyActive: a.default.bool, props: a.default.object, className: a.default.string,
  }, Slot.contextTypes = { slots: a.default.object.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0; const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.PlaygroundRenderer = PlaygroundRenderer; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(11)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const u = t.styles = function styles(e) {
    const t = e.space; const r = e.color; const n = e.borderRadius; return {
      root: { marginBottom: t[4] },
      preview: {
        padding: t[2], border: [[1, r.border, 'solid']], borderRadius: n, width: '100%', display: 'inline-block',
      },
      controls: { display: 'flex', alignItems: 'center' },
      toolbar: { marginLeft: 'auto' },
      tab: {},
    };
  }; function PlaygroundRenderer(e) { const t = e.classes; const r = e.name; const a = e.preview; const s = e.previewProps; const u = e.tabButtons; const l = e.tabBody; const c = e.toolbar; const p = s.className; const f = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(s, ['className'])); return i.default.createElement('div', { className: t.root }, i.default.createElement('div', n({ className: (0, o.default)(t.preview, p) }, f, { 'data-preview': r }), a), i.default.createElement('div', { className: t.controls }, i.default.createElement('div', { className: t.tabs }, u), i.default.createElement('div', { className: t.toolbar }, c)), i.default.createElement('div', { className: t.tab }, l)) }PlaygroundRenderer.propTypes = {
    classes: a.default.object.isRequired, name: a.default.string.isRequired, preview: a.default.node.isRequired, previewProps: a.default.object.isRequired, tabButtons: a.default.node.isRequired, tabBody: a.default.node.isRequired, toolbar: a.default.node.isRequired,
  }, t.default = (0, s.default)(u)(PlaygroundRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.ExamplesRenderer = ExamplesRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ExamplesRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('article', { className: t.root }, r) }ExamplesRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node }, t.default = (0, a.default)(() => ({ root: {} }))(ExamplesRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(513); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = Components; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(514)); const o = _interopRequireDefault(r(523)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function Components(e) { const t = e.components; const r = e.depth; return n.default.createElement(o.default, null, t.map(e => n.default.createElement(a.default, { key: e.filepath, component: e, depth: r }))) }Components.propTypes = { components: i.default.array.isRequired, depth: i.default.number.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(515); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const a = r(0); const o = _interopRequireDefault(a); const s = _interopRequireDefault(r(1)); const u = _interopRequireDefault(r(153)); const l = _interopRequireDefault(r(156)); const c = _interopRequireDefault(r(57)); const p = _interopRequireDefault(r(16)); const f = _interopRequireDefault(r(99)); const d = _interopRequireDefault(r(518)); const h = r(71); const m = r(32); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const g = function () { return o.default.createElement('div', null) }; const v = (function (e) {
    function ReactComponent(e, t) { !(function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, ReactComponent)); const r = (function _possibleConstructorReturn(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t }(this, (ReactComponent.__proto__ || Object.getPrototypeOf(ReactComponent)).call(this, e, t))); const n = t.config.showUsage; return r.handleTabChange = r.handleTabChange.bind(r), r.state = { activeTab: n ? h.DOCS_TAB_USAGE : void 0 }, r } return (function _inherits(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }(ReactComponent, a.Component)), i(ReactComponent, [{ key: 'handleTabChange', value: function handleTabChange(e) { this.setState(t => ({ activeTab: t.activeTab !== e ? e : void 0 })) } }, {
      key: 'render',
      value: function render() {
        const e = this.state.activeTab; const t = this.context.displayMode; const r = this.props; const i = r.component; const a = r.depth; const s = i.name; const h = i.level; const v = i.nameParent; const y = i.slug; const b = i.filepath; const x = i.pathLine; const D = i.props; const _ = D.description; const C = D.examples; const w = void 0 === C ? [] : C; const E = D.tags; const S = void 0 === E ? {} : E; return s ? o.default.createElement(d.default, {
          name: s,
          slug: y,
          filepath: b,
          pathLine: x,
          docs: o.default.createElement(c.default, S),
          description: _ && o.default.createElement(p.default, { text: _ }),
          heading: o.default.createElement(l.default, {
            id: y, name: s, level: h, nameParent: v, deprecated: !!S.deprecated, slotName: 'componentToolbar', slotProps: n({}, i, { isolated: t !== m.DisplayModes.all }), depth: a,
          }, s),
          examples: w.length > 0 ? o.default.createElement(u.default, { examples: w, name: s }) : o.default.createElement(g, { name: s }),
          tabButtons: o.default.createElement(f.default, { name: 'docsTabButtons', active: e, props: n({}, i, { onClick: this.handleTabChange }) }),
          tabBody: o.default.createElement(f.default, {
            name: 'docsTabs', active: e, onlyActive: !0, props: i,
          }),
        }) : null;
      },
    }]), ReactComponent;
  }()); v.propTypes = { component: s.default.object.isRequired, depth: s.default.number.isRequired }, v.contextTypes = { config: s.default.object.isRequired, displayMode: s.default.string }, t.default = v;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = SectionHeading; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(1)); const o = _interopRequireDefault(r(99)); const s = _interopRequireDefault(r(517)); const u = r(60); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function SectionHeading(e, t) {
    const r = t.config; const a = e.slotName; const l = e.slotProps; const c = e.children; const p = e.id; const f = e.level; const d = e.name; const h = e.nameParent; const m = e.collection; const g = void 0 === m ? {} : m; const v = (function _objectWithoutProperties(e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r }(e, ['slotName', 'slotProps', 'children', 'id', 'level', 'name', 'nameParent', 'collection'])); const y = r.navigation; const b = (0, u.getUrlNavigation)(y, {
      level: f, sections: g.sections, components: g.components, nameParent: h, name: d, slug: p, anchor: !0,
    }); return i.default.createElement(s.default, n({ toolbar: i.default.createElement(o.default, { name: a, props: l }), id: p, href: b }, v), c);
  }SectionHeading.propTypes = {
    children: a.default.node, id: a.default.string.isRequired, name: a.default.string.isRequired, nameParent: a.default.string.isRequired, level: a.default.number.isRequired, slotName: a.default.string.isRequired, slotProps: a.default.object.isRequired, depth: a.default.number.isRequired, deprecated: a.default.bool, collection: a.default.object,
  }, SectionHeading.contextTypes = { config: a.default.object };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(11)); const o = _interopRequireDefault(r(89)); const s = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function SectionHeadingRenderer(e) {
    const t = e.classes; const r = e.children; const i = e.toolbar; const s = e.id; const u = e.href; const l = e.depth; const c = e.deprecated; const p = Math.min(6, l); const f = (0, a.default)(t.sectionName, (function _defineProperty(e, t, r) {
      return t in e ? Object.defineProperty(e, t, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = r, e;
    }({}, t.isDeprecated, c))); return n.default.createElement('div', { className: t.wrapper }, n.default.createElement(o.default, { level: p, id: s }, n.default.createElement('a', { href: u, className: f }, r)), n.default.createElement('div', { className: t.toolbar }, i));
  }SectionHeadingRenderer.propTypes = {
    classes: i.default.object.isRequired, children: i.default.node, toolbar: i.default.node, id: i.default.string.isRequired, href: i.default.string.isRequired, depth: i.default.number.isRequired, deprecated: i.default.bool,
  }, t.default = (0, s.default)((e) => {
    const t = e.color; return {
      wrapper: {
        display: 'flex', flexDirection: 'row', alignItems: 'center', marginBottom: e.space[1],
      },
      toolbar: { marginLeft: 'auto' },
      sectionName: { '&:hover, &:active': { isolate: !1, textDecoration: 'underline', cursor: 'pointer' } },
      isDeprecated: { textDecoration: 'line-through', color: t.light },
    };
  })(SectionHeadingRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.ReactComponentRenderer = ReactComponentRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(519)); const o = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ReactComponentRenderer(e) { const t = e.classes; const r = e.name; const i = e.heading; const o = e.pathLine; const s = e.description; const u = e.docs; const l = e.examples; const c = e.tabButtons; const p = e.tabBody; return n.default.createElement('div', { className: t.root, id: `${r}-container` }, n.default.createElement('header', { className: t.header }, i, o && n.default.createElement(a.default, null, o)), (s || u) && n.default.createElement('div', { className: t.docs }, s, u), c && n.default.createElement('div', { className: t.tabs }, n.default.createElement('div', { className: t.tabButtons }, c), p), l) }ReactComponentRenderer.propTypes = {
    classes: i.default.object.isRequired, name: i.default.string.isRequired, heading: i.default.node.isRequired, filepath: i.default.string, pathLine: i.default.string, tabButtons: i.default.node, tabBody: i.default.node, description: i.default.node, docs: i.default.node, examples: i.default.node, isolated: i.default.bool,
  }, t.default = (0, o.default)((e) => {
    const t = e.color; const r = e.fontSize; const n = e.space; return {
      root: { marginBottom: n[6] }, header: { marginBottom: n[3] }, tabs: { marginBottom: n[3] }, tabButtons: { marginBottom: n[2] }, docs: { color: t.base, fontSize: r.text },
    };
  })(ReactComponentRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(520); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.styles = void 0, t.PathlineRenderer = PathlineRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(521)); const o = _interopRequireDefault(r(522)); const s = _interopRequireDefault(r(149)); const u = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = t.styles = function styles(e) { const t = e.space; const r = e.fontFamily; const n = e.fontSize; const i = e.color; return { pathline: { fontFamily: r.monospace, fontSize: n.small, color: i.light }, copyButton: { marginLeft: t[0] } } }; function PathlineRenderer(e) {
    const t = e.classes; const r = e.children; return n.default.createElement('div', { className: t.pathline }, r, n.default.createElement(s.default, {
      small: !0, className: t.copyButton, onClick: function onClick() { return (0, a.default)(r) }, title: 'Copy to clipboard',
    }, n.default.createElement(o.default, null)));
  }PathlineRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.string }, t.default = (0, u.default)(l)(PathlineRenderer);
}, function (e, t) { e.exports = function clipboardCopy(e) { if (navigator.clipboard) return navigator.clipboard.writeText(e); const t = document.createElement('span'); t.textContent = e, t.style.whiteSpace = 'pre'; const r = document.createElement('iframe'); r.sandbox = 'allow-same-origin', document.body.appendChild(r); let n = r.contentWindow; n.document.body.appendChild(t); let i = n.getSelection(); i || (n = window, i = n.getSelection(), document.body.appendChild(t)); const a = n.document.createRange(); i.removeAllRanges(), a.selectNode(t), i.addRange(a); let o = !1; try { o = n.document.execCommand('copy') } catch (e) {} return i.removeAllRanges(), n.document.body.removeChild(t), document.body.removeChild(r), o ? Promise.resolve() : Promise.reject() } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const i = _interopRequireDefault(r(0)); const a = _interopRequireDefault(r(97)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }t.default = function MdContentCopy(e) { return i.default.createElement(a.default, n({ viewBox: '0 0 40 40' }, e), i.default.createElement('g', null, i.default.createElement('path', { d: 'm31.6 35v-23.4h-18.2v23.4h18.2z m0-26.6c1.8 0 3.4 1.4 3.4 3.2v23.4c0 1.8-1.6 3.4-3.4 3.4h-18.2c-1.8 0-3.4-1.6-3.4-3.4v-23.4c0-1.8 1.6-3.2 3.4-3.2h18.2z m-5-6.8v3.4h-20v23.4h-3.2v-23.4c0-1.8 1.4-3.4 3.2-3.4h20z' }))) }, e.exports = t.default;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = ComponentsRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ComponentsRenderer(e) { const t = e.children; return n.default.createElement('div', null, t) }ComponentsRenderer.propTypes = { children: i.default.node.isRequired };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.SectionRenderer = SectionRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); const o = _interopRequireDefault(r(156)); const s = _interopRequireDefault(r(16)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function SectionRenderer(e) {
    const t = e.classes; const r = e.name; const i = e.slug; const a = e.content; const u = e.components; const l = e.sections; const c = e.collection; const p = e.depth; const f = e.description; const d = e.nameParent; const h = e.level; return n.default.createElement('section', { className: t.root }, r && n.default.createElement(o.default, {
      nameParent: d, name: r, level: h, depth: p, id: i, collection: c, slotName: 'sectionToolbar', slotProps: e,
    }, r), f && n.default.createElement(s.default, { text: f }), a, l, u);
  }SectionRenderer.propTypes = {
    classes: i.default.object.isRequired, name: i.default.string, nameParent: i.default.string, level: i.default.number, description: i.default.string, slug: i.default.string, filepath: i.default.string, content: i.default.node, components: i.default.node, sections: i.default.node, isolated: i.default.bool, collection: i.default.object, depth: i.default.number.isRequired,
  }, t.default = (0, a.default)(e => ({ root: { marginBottom: e.space[4] } }))(SectionRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.SectionsRenderer = SectionsRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function SectionsRenderer(e) { const t = e.classes; const r = e.children; return n.default.createElement('section', { className: t.root }, r) }SectionsRenderer.propTypes = { classes: i.default.object.isRequired, children: i.default.node }, t.default = (0, a.default)(() => ({ root: {} }))(SectionsRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(527); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.WelcomeRenderer = WelcomeRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(16)); const o = _interopRequireDefault(r(2)); const s = r(157); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function WelcomeRenderer(e) { const t = e.classes; const r = e.patterns; return n.default.createElement('div', { className: t.root }, n.default.createElement(a.default, { text: `\n# Welcome to Vue Styleguidist!\n\n**We couldnt find any components** using these patterns:\n\n${r.map(e => `- \`${e}\``).join('\n')}\n\nCreate **styleguide.config.js** file in your project root directory like this:\n\n    module.exports = {\n      components: 'src/components/**/*.vue'\n    };\n\nRead more in the [locating components guide](${s.DOCS_COMPONENTS}).\n\t\t\t\t` })) }WelcomeRenderer.propTypes = { classes: i.default.object.isRequired, patterns: i.default.array.isRequired }, t.default = (0, o.default)((e) => { const t = e.space; return { root: { maxWidth: e.maxWidth, margin: [[0, 'auto']], padding: t[4] } } })(WelcomeRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(529); Object.defineProperty(t, 'default', { enumerable: !0, get: function get() { return (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(n)).default } });
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.ErrorRenderer = ErrorRenderer; const n = _interopRequireDefault(r(0)); const i = _interopRequireDefault(r(1)); const a = _interopRequireDefault(r(2)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function ErrorRenderer(e) { const t = e.classes; const r = e.error; const i = e.info; return n.default.createElement('div', { className: t.root }, n.default.createElement('pre', { className: t.stack }, r.toString(), i.componentStack.toString()), n.default.createElement('div', { className: t.message }, n.default.createElement('p', null, 'This may be due to an error in a component you are overriding, or a bug in React Styleguidist.'), n.default.createElement('p', null, 'If you believe this is a bug,', n.default.createElement('a', { style: { color: 'inherit' }, href: 'https://github.com/styleguidist/react-styleguidist/issues' }, 'please submit an issue'), '.'))) }ErrorRenderer.propTypes = { classes: i.default.object.isRequired, error: i.default.object.isRequired, info: i.default.shape({ componentStack: i.default.any.isRequired }).isRequired }, t.default = (0, a.default)((e) => { const t = e.fontFamily; const r = e.fontSize; const n = e.color; return { root: { margin: e.space[2], lineHeight: 1.2, fontSize: r.small }, stack: { color: n.error, whiteSpace: 'pre', fontFamily: t.monospace }, message: { color: n.error, fontFamily: t.base } } })(ErrorRenderer);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function scrollTo() { (document.scrollingElement || document.documentElement).scrollTop = 0 };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getPageTitle(e, t, r) { if (!e[0]) return ''; if (r === n.DisplayModes.component || r === n.DisplayModes.example || !e[0].name) return `${e[0].components[0].name}  ${t}`; if (r === n.DisplayModes.section) return `${e[0].name}  ${t}`; return t }; var n = r(32);
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getRouteData(e, t, r) { const h = (0, c.default)(t); const m = h.targetName; const g = h.targetIndex; const v = (0, p.default)(); let y = f.DisplayModes.all; if (r && !m && e[0]) { const b = e[0].name; window.location.href = (0, d.default)({ name: b, isolated: !0 }) } if (m) { const x = (0, a.default)(e, m); if (x.length)e = [{ components: x }], y = f.DisplayModes.component; else { let D = void 0; if ((D = (0, u.default)(e, m)) && r && !v)D = (0, s.default)(D); else if (D && r && v) { const _ = (0, l.default)(D, v); _ ? D = _ : window.location.href = (0, d.default)({ name, isolated: !0 }) }e = D ? [D] : [], y = f.DisplayModes.section }(0, n.default)(g) && (x.length === 1 ? (e = [{ components: [(0, i.default)(x[0], g)] }], y = f.DisplayModes.example) : e.length === 1 && (e = [(0, o.default)(e[0], g)], y = f.DisplayModes.example)) } return { sections: e, displayMode: y } }; var n = _interopRequireDefault(r(533)); var i = _interopRequireDefault(r(534)); var a = _interopRequireDefault(r(535)); var o = _interopRequireDefault(r(537)); var s = _interopRequireDefault(r(538)); var u = _interopRequireDefault(r(539)); var l = _interopRequireDefault(r(540)); var c = _interopRequireDefault(r(541)); var p = _interopRequireDefault(r(544)); var f = r(32); var d = _interopRequireDefault(r(96)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }
}, function (e, t, r) { const n = r(10).isFinite; e.exports = function isFinite(e) { return typeof e === 'number' && n(e) } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function filterComponentExamples(e, t) { return n({}, e, { props: n({}, e.props, { examples: [e.props.examples[t]] }) }) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function filterComponentsInSectionsByExactName(e, t) { const r = []; e.forEach((e) => { e.components && r.push(..._toConsumableArray((0, n.default)(e.components, t))), e.sections && r.push(..._toConsumableArray(filterComponentsInSectionsByExactName(e.sections, t))) }); return r }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(536))); function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) }
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function filterComponentsByExactName(e, t) { return e.filter(e => e.name === t) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function filterSectionExamples(e, t) { return n({}, e, { content: [e.content[t]] }) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function filterSectionByLevel(e) { if (!e) return e; return n({}, e, { sections: [], components: [] }) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function findSection(e, t) { const r = e.find(e => e.name.replace(/\s/g, '%20') === t.replace(/\s/g, '%20')); if (r) return r; let n = !0; let i = !1; let a = void 0; try { for (var o, s = e[Symbol.iterator](); !(n = (o = s.next()).done); n = !0) { const u = o.value; if (u.sections && u.sections.length !== 0) { const l = findSection(u.sections, t); if (l) return l; } } } catch (e) { i = !0, a = e } finally { try { !n && s.return && s.return() } finally { if (i) throw a; } } };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function findSectionForSlug(e, t) { const r = e.sections.find(e => e.slug.replace(/\s/g, '%20') === t.replace(/\s/g, '%20')); if (r) return r; const n = e.components.find(e => e.slug === t); if (n) return { components: [n] }; };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getInfoFromHash(e) { if (e.substr(0, 3) === '#!/') { let t = e.substr(3); t.indexOf('?id') > -1 && (t = t.replace(t.slice(t.indexOf('?id')), '')); const r = t.split('/'); const i = parseInt(r[1], 10); return { targetName: decodeURIComponent(r[0]), targetIndex: (0, n.default)(i) ? void 0 : i } } return {} }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(542)));
}, function (e, t, r) { const n = r(543); e.exports = function isNaN(e) { return n(e) && e != +e } }, function (e, t, r) { const n = r(27); const i = r(22); const a = '[object Number]'; e.exports = function isNumber(e) { return typeof e === 'number' || i(e) && n(e) == a } }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function getIdParam() { const e = location.href; const t = new RegExp('[\\?&]id=([^&#]*)').exec(e); return t == null ? null : t[1] };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function globalizeComponents(e) { e.forEach((e) => { e.components && e.components.forEach(n.default), e.sections && globalizeComponents(e.sections) }) }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(546)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function globalizeComponent(e) { const t = e.props.displayName; if (!e.name) return; const r = e.module.default || e.module; n.default.component(t, r) }; var n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(23)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; t.default = function processSections(e, t) {
    const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ''; return e.map(e => n({}, e, {
      components: (0, i.default)(e.components || [], t, r + 1, e.name), sections: processSections(e.sections || [], t, r + 1, e.name), nameParent: a, level: r,
    }));
  }; var i = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(548)));
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; function _toConsumableArray(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) }t.default = function processComponents(e, t) {
    const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ''; return e.map((e) => {
      const a = n({}, e, {
        name: e.props.displayName, level: r, nameParent: i, props: n({}, e.props, { examples: [].concat(_toConsumableArray(e.props.examples || []), _toConsumableArray(e.props.example || [])) }),
      }); return delete a.props.example, a.props.examples = (function processExamples(e, t) { return e.map(e => e.type === 'code' && (e.vuex = t), e) }(a.props.examples, t)), a;
    });
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function processMixins(e) { e.forEach((e) => { e.default ? globalizeMixin(e.default) : globalizeMixin(e) }) }; const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(23))); function globalizeMixin(e) { n.default.mixin(e) }
}, function (e, t, r) {
  e.exports = {
    config: {
      title: 'Animeloop Web Nuxt Style Guide',
      showCode: !1,
      showUsage: !0,
      showSidebar: !0,
      previewDelay: 500,
      theme: {},
      navigation: !1,
      styles: {},
      compilerConfig: { objectAssign: 'Object.assign' },
      editorConfig: {
        theme: 'base16-light', mode: 'jsx', lineWrapping: !0, smartIndent: !1, matchBrackets: !0, viewportMargin: 1 / 0, lineNumbers: !1,
      },
      ribbon: void 0,
    },
    welcomeScreen: !1,
    patterns: void 0,
    sections: [{
      name: 'Components',
      description: void 0,
      slug: 'components',
      sections: [{
        name: 'Common',
        description: 'Common Components.',
        slug: 'common',
        sections: [],
        filepath: void 0,
        components: [{
          filepath: 'components/Common/PageIcon.vue', slug: 'pageicon', pathLine: 'components/Common/PageIcon.vue', module: r(158), props: r(556), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Common/TimeTag.vue', slug: 'timetag', pathLine: 'components/Common/TimeTag.vue', module: r(160), props: r(560), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Common/TypeTag.vue', slug: 'typetag', pathLine: 'components/Common/TypeTag.vue', module: r(61), props: r(570), hasExamples: !1, metadata: {},
        }],
        content: void 0,
      }, {
        name: 'Loop',
        description: 'Components for Loop Page.',
        slug: 'loop',
        sections: [],
        filepath: void 0,
        components: [{
          filepath: 'components/Loop/Breadcrumb.vue', slug: 'breadcrumb', pathLine: 'components/Loop/Breadcrumb.vue', module: r(163), props: r(574), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/Card.vue', slug: 'card', pathLine: 'components/Loop/Card.vue', module: r(102), props: r(581), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/CardDetails.vue', slug: 'carddetails', pathLine: 'components/Loop/CardDetails.vue', module: r(168), props: r(585), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/Downloads.vue', slug: 'downloads', pathLine: 'components/Loop/Downloads.vue', module: r(170), props: r(589), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/GifPlayer.vue', slug: 'gifplayer', pathLine: 'components/Loop/GifPlayer.vue', module: r(166), props: r(590), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/Grid.vue', slug: 'grid', pathLine: 'components/Loop/Grid.vue', module: r(103), props: r(594), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/index.vue', slug: 'loop-1', pathLine: 'components/Loop/index.vue', module: r(173), props: r(601), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Loop/Info.vue', slug: 'info', pathLine: 'components/Loop/Info.vue', module: r(175), props: r(602), hasExamples: !1, metadata: {},
        }],
        content: void 0,
      }, {
        name: 'Navbar',
        description: 'Navbar Components.',
        slug: 'navbar',
        sections: [],
        filepath: void 0,
        components: [{
          filepath: 'components/Navbar/Entry.vue', slug: 'entry', pathLine: 'components/Navbar/Entry.vue', module: r(177), props: r(606), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Navbar/index.vue', slug: 'navbar-1', pathLine: 'components/Navbar/index.vue', module: r(607), props: r(624), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Navbar/LangMenu.vue', slug: 'langmenu', pathLine: 'components/Navbar/LangMenu.vue', module: r(180), props: r(625), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Navbar/Menu.vue', slug: 'menu', pathLine: 'components/Navbar/Menu.vue', module: r(182), props: r(626), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Navbar/Search.vue', slug: 'search', pathLine: 'components/Navbar/Search.vue', module: r(184), props: r(627), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Navbar/Title.vue', slug: 'title', pathLine: 'components/Navbar/Title.vue', module: r(186), props: r(628), hasExamples: !1, metadata: {},
        }],
        content: void 0,
      }, {
        name: 'Series',
        description: 'Components for Series/Episodes Page.',
        slug: 'series',
        sections: [],
        filepath: void 0,
        components: [{
          filepath: 'components/Series/Cover.vue', slug: 'cover', pathLine: 'components/Series/Cover.vue', module: r(188), props: r(632), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Series/Genres.vue', slug: 'genres', pathLine: 'components/Series/Genres.vue', module: r(104), props: r(636), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Series/Grid.vue', slug: 'grid-1', pathLine: 'components/Series/Grid.vue', module: r(105), props: r(640), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Series/index.vue', slug: 'series-1', pathLine: 'components/Series/index.vue', module: r(106), props: r(647), hasExamples: !1, metadata: {},
        }, {
          filepath: 'components/Series/Info.vue', slug: 'info-1', pathLine: 'components/Series/Info.vue', module: r(193), props: r(648), hasExamples: !1, metadata: {},
        }],
        content: void 0,
      }, {
        name: 'Loading',
        description: 'Nuxt Loading Progress Bar.',
        slug: 'loading',
        sections: [],
        filepath: void 0,
        components: [{
          filepath: 'components/Loading.vue', slug: 'loading-1', pathLine: 'components/Loading.vue', module: r(649), props: r(653), hasExamples: !1, metadata: {},
        }],
        content: void 0,
      }],
      filepath: void 0,
      components: [],
      content: void 0,
    }, {
      name: 'Pages',
      description: void 0,
      slug: 'pages',
      sections: [],
      filepath: void 0,
      components: [{
        filepath: 'pages/about.vue', slug: 'about', pathLine: 'pages/about.vue', module: r(654), props: r(658), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/apistatus.vue', slug: 'apistatus', pathLine: 'pages/apistatus.vue', module: r(659), props: r(661), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/episode/_id/index.vue', slug: 'id', pathLine: 'pages/episode/_id/index.vue', module: r(662), props: r(684), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/index.vue', slug: 'pages-1', pathLine: 'pages/index.vue', module: r(685), props: r(689), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/list/index.vue', slug: 'list', pathLine: 'pages/list/index.vue', module: r(690), props: r(707), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/loop/_id/index.vue', slug: 'id-1', pathLine: 'pages/loop/_id/index.vue', module: r(708), props: r(712), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/random.vue', slug: 'random', pathLine: 'pages/random.vue', module: r(713), props: r(714), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/search.vue', slug: 'search-1', pathLine: 'pages/search.vue', module: r(715), props: r(719), hasExamples: !1, metadata: {},
      }, {
        filepath: 'pages/series/_id/index.vue', slug: 'id-2', pathLine: 'pages/series/_id/index.vue', module: r(720), props: r(724), hasExamples: !1, metadata: {},
      }],
      content: void 0,
    }],
    vuex: r(725),
    mixins: [],
  };
}, function (e, t, r) { let n = r(552); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('1978e402', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.PageIcon[data-v-72d66d28]{background-color:#f0f0f0;padding:.5em 2em;border-radius:5px;text-align:center;color:#888;-webkit-box-flex:2;-ms-flex:2 2 auto;flex:2 2 auto}.PageIcon--disabled[data-v-72d66d28]{color:#ddd}', '']) }, function (e, t) {
  e.exports = function listToStyles(e, t) {
    for (var r = [], n = {}, i = 0; i < t.length; i++) {
      const a = t[i]; const o = a[0]; const s = {
        id: `${e}:${i}`, css: a[1], media: a[2], sourceMap: a[3],
      }; n[o] ? n[o].parts.push(s) : r.push(n[o] = { id: o, parts: [s] });
    } return r;
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), r.d(t, 'config', () => Ne), r.d(t, 'icon', () => Oe), r.d(t, 'noAuto', () => Te), r.d(t, 'layer', () => Le), r.d(t, 'text', () => Fe), r.d(t, 'library', () => Ae), r.d(t, 'dom', () => Pe), r.d(t, 'parse', () => Re), r.d(t, 'findIconDefinition', () => findIconDefinition);
  /*!
 * Font Awesome Free 5.0.9 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
  const n = function noop() {}; let i = {}; let a = {}; let o = null; let s = { mark: n, measure: n }; try { typeof window !== 'undefined' && (i = window), typeof document !== 'undefined' && (a = document), typeof MutationObserver !== 'undefined' && (o = MutationObserver), typeof performance !== 'undefined' && (s = performance) } catch (e) {} const u = (i.navigator || {}).userAgent; const l = void 0 === u ? '' : u; const c = i; const p = a; const f = o; const d = s; const h = !!c.document; const m = !!p.documentElement && !!p.head && typeof p.addEventListener === 'function' && typeof p.createElement === 'function'; const g = ~l.indexOf('MSIE') || ~l.indexOf('Trident/'); const v = 16; const y = 'data-fa-i2svg'; const b = 'data-fa-pseudo-element'; const x = 'fontawesome-i2svg'; const D = (function () { try { return !0 } catch (e) { return !1 } }()); const _ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; const C = _.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]); const w = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask']; const E = ['xs', 'sm', 'lg', 'fw', 'ul', 'li', 'border', 'pull-left', 'pull-right', 'spin', 'pulse', 'rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'stack', 'stack-1x', 'stack-2x', 'inverse', 'layers', 'layers-text', 'layers-counter'].concat(_.map(e => `${e}x`)).concat(C.map(e => `w-${e}`)); const S = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }; const k = (function () { function defineProperties(e, t) { for (let r = 0; r < t.length; r++) { const n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (e, t, r) { return t && defineProperties(e.prototype, t), r && defineProperties(e, r), e } }()); const A = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e }; const T = function (e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r } return Array.from(e) }; const P = c.FontAwesomeConfig || {}; const R = Object.keys(P); const O = A({
    familyPrefix: 'fa', replacementClass: 'svg-inline--fa', autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0,
  }, P); O.autoReplaceSvg || (O.observeMutations = !1); const F = A({}, O); function update(e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).asNewDefault; const r = void 0 !== t && t; const n = Object.keys(F); const i = r ? function (e) { return ~n.indexOf(e) && !~R.indexOf(e) } : function (e) { return ~n.indexOf(e) }; Object.keys(e).forEach((t) => { i(t) && (F[t] = e[t]) }) }c.FontAwesomeConfig = F; const L = c || {}; L.___FONT_AWESOME___ || (L.___FONT_AWESOME___ = {}), L.___FONT_AWESOME___.styles || (L.___FONT_AWESOME___.styles = {}), L.___FONT_AWESOME___.hooks || (L.___FONT_AWESOME___.hooks = {}), L.___FONT_AWESOME___.shims || (L.___FONT_AWESOME___.shims = []); const M = L.___FONT_AWESOME___; const j = []; let N = !1; m && ((N = (p.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(p.readyState)) || p.addEventListener('DOMContentLoaded', function listener() { p.removeEventListener('DOMContentLoaded', listener), N = 1, j.map(e => e()) })); const I = function (e) { m && (N ? setTimeout(e, 0) : j.push(e)) }; const B = v; const q = {
    size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1,
  }; function insertCss(e) { if (e && m) { const t = p.createElement('style'); t.setAttribute('type', 'text/css'), t.innerHTML = e; for (var r = p.head.childNodes, n = null, i = r.length - 1; i > -1; i--) { const a = r[i]; const o = (a.tagName || '').toUpperCase(); ['STYLE', 'LINK'].indexOf(o) > -1 && (n = a) } return p.head.insertBefore(t, n), e } } let U = 0; function nextUniqueId() { return ++U } function toArray(e) { for (var t = [], r = (e || []).length >>> 0; r--;)t[r] = e[r]; return t } function classArray(e) { return e.classList ? toArray(e.classList) : (e.getAttribute('class') || '').split(' ').filter(e => e) } function getIconName(e, t) { const r = t.split('-'); const n = r[0]; const i = r.slice(1).join('-'); return n !== e || i === '' || (function isReserved(e) { return ~E.indexOf(e) }(i)) ? null : i } function htmlEscape(e) {
    return (`${e}`).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  } function joinStyles(e) { return Object.keys(e || {}).reduce((t, r) => `${t}${r}: ${e[r]};`, '') } function transformIsMeaningful(e) { return e.size !== q.size || e.x !== q.x || e.y !== q.y || e.rotate !== q.rotate || e.flipX || e.flipY } function transformForSvg(e) { const t = e.transform; const r = e.containerWidth; const n = e.iconWidth; return { outer: { transform: `translate(${r / 2} 256)` }, inner: { transform: `translate(${32 * t.x}, ${32 * t.y}) ` + ' ' + `scale(${t.size / 16 * (t.flipX ? -1 : 1)}, ${t.size / 16 * (t.flipY ? -1 : 1)}) ` + ' ' + `rotate(${t.rotate} 0 0)` }, path: { transform: `translate(${n / 2 * -1} -256)` } } } const z = {
    x: 0, y: 0, width: '100%', height: '100%',
  }; const V = function (e) { const t = e.children; const r = e.attributes; const n = e.main; const i = e.mask; const a = e.transform; const o = n.width; const s = n.icon; const u = i.width; const l = i.icon; const c = transformForSvg({ transform: a, containerWidth: u, iconWidth: o }); const p = { tag: 'rect', attributes: A({}, z, { fill: 'white' }) }; const f = { tag: 'g', attributes: A({}, c.inner), children: [{ tag: 'path', attributes: A({}, s.attributes, c.path, { fill: 'black' }) }] }; const d = { tag: 'g', attributes: A({}, c.outer), children: [f] }; const h = `mask-${nextUniqueId()}`; const m = `clip-${nextUniqueId()}`; const g = { tag: 'defs', children: [{ tag: 'clipPath', attributes: { id: m }, children: [l] }, { tag: 'mask', attributes: A({}, z, { id: h, maskUnits: 'userSpaceOnUse', maskContentUnits: 'userSpaceOnUse' }), children: [p, d] }] }; return t.push(g, { tag: 'rect', attributes: A({ fill: 'currentColor', 'clip-path': `url(#${m})`, mask: `url(#${h})` }, z) }), { children: t, attributes: r } }; const H = function (e) { const t = e.children; const r = e.attributes; const n = e.main; const i = e.transform; const a = joinStyles(e.styles); if (a.length > 0 && (r.style = a), transformIsMeaningful(i)) { const o = transformForSvg({ transform: i, containerWidth: n.width, iconWidth: n.width }); t.push({ tag: 'g', attributes: A({}, o.outer), children: [{ tag: 'g', attributes: A({}, o.inner), children: [{ tag: n.icon.tag, children: n.icon.children, attributes: A({}, n.icon.attributes, o.path) }] }] }) } else t.push(n.icon); return { children: t, attributes: r } }; const $ = function (e) { const t = e.children; const r = e.main; const n = e.mask; const i = e.attributes; const a = e.styles; const o = e.transform; if (transformIsMeaningful(o) && r.found && !n.found) { const s = { x: r.width / r.height / 2, y: 0.5 }; i.style = joinStyles(A({}, a, { 'transform-origin': `${s.x + o.x / 16}em ${s.y + o.y / 16}em` })) } return [{ tag: 'svg', attributes: i, children: t }] }; const G = function (e) { const t = e.prefix; const r = e.iconName; const n = e.children; const i = e.attributes; const a = e.symbol; const o = !0 === a ? `${t}-${F.familyPrefix}-${r}` : a; return [{ tag: 'svg', attributes: { style: 'display: none;' }, children: [{ tag: 'symbol', attributes: A({}, i, { id: o }), children: n }] }] }; function makeInlineSvgAbstract(e) {
    const t = e.icons; const r = t.main; const n = t.mask; const i = e.prefix; const a = e.iconName; const o = e.transform; const s = e.symbol; const u = e.title; const l = e.extra; const c = e.watchable; const p = void 0 !== c && c; const f = n.found ? n : r; const d = f.width; const h = f.height; const m = `fa-w-${Math.ceil(d / h * 16)}`; const g = [F.replacementClass, a ? `${F.familyPrefix}-${a}` : '', m].concat(l.classes).join(' '); const v = {
      children: [],
      attributes: A({}, l.attributes, {
        'data-prefix': i, 'data-icon': a, class: g, role: 'img', xmlns: 'http://www.w3.org/2000/svg', viewBox: `0 0 ${d} ${h}`,
      }),
    }; p && (v.attributes[y] = ''), u && v.children.push({ tag: 'title', attributes: { id: v.attributes['aria-labelledby'] || `title-${nextUniqueId()}` }, children: [u] }); const b = A({}, v, {
      prefix: i, iconName: a, main: r, mask: n, transform: o, symbol: s, styles: l.styles,
    }); const x = n.found && r.found ? V(b) : H(b); const D = x.children; const _ = x.attributes; return b.children = D, b.attributes = _, s ? G(b) : $(b);
  } function makeLayersTextAbstract(e) {
    const t = e.content; const r = e.width; const n = e.height; const i = e.transform; const a = e.title; const o = e.extra; const s = e.watchable; const u = void 0 !== s && s; const l = A({}, o.attributes, a ? { title: a } : {}, { class: o.classes.join(' ') }); u && (l[y] = ''); const c = A({}, o.styles); transformIsMeaningful(i) && (c.transform = (function transformForCss(e) { const t = e.transform; const r = e.width; const n = void 0 === r ? v : r; const i = e.height; const a = void 0 === i ? v : i; const o = e.startCentered; const s = void 0 !== o && o; let u = ''; return u += s && g ? `translate(${t.x / B - n / 2}em, ${t.y / B - a / 2}em) ` : s ? `translate(calc(-50% + ${t.x / B}em), calc(-50% + ${t.y / B}em)) ` : `translate(${t.x / B}em, ${t.y / B}em) `, u += `scale(${t.size / B * (t.flipX ? -1 : 1)}, ${t.size / B * (t.flipY ? -1 : 1)}) `, u += `rotate(${t.rotate}deg) ` }({
      transform: i, startCentered: !0, width: r, height: n,
    })), c['-webkit-transform'] = c.transform); const p = joinStyles(c); p.length > 0 && (l.style = p); const f = []; return f.push({ tag: 'span', attributes: l, children: [t] }), a && f.push({ tag: 'span', attributes: { class: 'sr-only' }, children: [a] }), f;
  } const J = function noop() {}; const W = F.measurePerformance && d && d.mark && d.measure ? d : { mark: J, measure: J }; const K = function end(e) { W.mark(`FA "5.0.9" ${e} ends`), W.measure(`FA "5.0.9" ${e}`, `FA "5.0.9" ${e} begins`, `FA "5.0.9" ${e} ends`) }; const X = { begin: function begin(e) { return W.mark(`FA "5.0.9" ${e} begins`), function () { return K(e) } }, end: K }; const Y = function fastReduceObject(e, t, r, n) { let i; let a; let o; const s = Object.keys(e); const u = s.length; const l = void 0 !== n ? (function bindInternal4(e, t) { return function (r, n, i, a) { return e.call(t, r, n, i, a) } }(t, n)) : t; for (void 0 === r ? (i = 1, o = e[s[0]]) : (i = 0, o = r); i < u; i++)o = l(o, e[a = s[i]], a, e); return o }; const Q = M.styles; const Z = M.shims; let ee = {}; let te = {}; let re = {}; const ne = function build() { const e = function lookup(e) { return Y(Q, (t, r, n) => t[n] = Y(r, e, {}), t, {}) }; ee = e((e, t, r) => e[t[3]] = r, e), te = e((e, t, r) => { const n = t[2]; return e[r] = r, n.forEach((t) => { e[t] = r }), e }); const t = 'far' in Q; re = Y(Z, (e, r) => { const n = r[0]; let i = r[1]; const a = r[2]; return i !== 'far' || t || (i = 'fas'), e[n] = { prefix: i, iconName: a }, e }, {}) }; ne(); const ie = M.styles; const ae = function emptyCanonicalIcon() { return { prefix: null, iconName: null, rest: [] } }; function getCanonicalIcon(e) { return e.reduce((e, t) => { const r = getIconName(F.familyPrefix, t); if (ie[t])e.prefix = t; else if (r) { const n = e.prefix === 'fa' ? (function byOldName(e) { return re[e] || { prefix: null, iconName: null } }(r)) : {}; e.iconName = n.iconName || r, e.prefix = n.prefix || e.prefix } else t !== F.replacementClass && t.indexOf('fa-w-') !== 0 && e.rest.push(t); return e }, ae()) } function iconFromMapping(e, t, r) { if (e && e[t] && e[t][r]) return { prefix: t, iconName: r, icon: e[t][r] }; } function toHtml(e) { const t = e.tag; const r = e.attributes; const n = void 0 === r ? {} : r; const i = e.children; const a = void 0 === i ? [] : i; return typeof e === 'string' ? htmlEscape(e) : `<${t} ${(function joinAttributes(e) { return Object.keys(e || {}).reduce((t, r) => `${t}${r}="${htmlEscape(e[r])}" `, '').trim() }(n))}>${a.map(toHtml).join('')}</${t}>` } const oe = function noop() {}; function isWatched(e) { return typeof (e.getAttribute ? e.getAttribute(y) : null) === 'string' } var se = { replace: function replace(e) { const t = e[0]; const r = e[1].map(e => toHtml(e)).join('\n'); if (t.parentNode && t.outerHTML)t.outerHTML = r + (F.keepOriginalSource && t.tagName.toLowerCase() !== 'svg' ? `\x3c!-- ${t.outerHTML} --\x3e` : ''); else if (t.parentNode) { const n = document.createElement('span'); t.parentNode.replaceChild(n, t), n.outerHTML = r } }, nest: function nest(e) { const t = e[0]; const r = e[1]; if (~classArray(t).indexOf(F.replacementClass)) return se.replace(e); const n = new RegExp(`${F.familyPrefix}-.*`); delete r[0].attributes.style; const i = r[0].attributes.class.split(' ').reduce((e, t) => (t === F.replacementClass || t.match(n) ? e.toSvg.push(t) : e.toNode.push(t)), e, { toNode: [], toSvg: [] }); r[0].attributes.class = i.toSvg.join(' '); const a = r.map(e => toHtml(e)).join('\n'); t.setAttribute('class', i.toNode.join(' ')), t.setAttribute(y, ''), t.innerHTML = a } }; function perform(e, t) { const r = typeof t === 'function' ? t : oe; e.length === 0 ? r() : (c.requestAnimationFrame || function (e) { return e() })(() => { const t = (function getMutator() { return !0 === F.autoReplaceSvg ? se.replace : se[F.autoReplaceSvg] || se.replace }()); const n = X.begin('mutate'); e.map(t), n(), r() }) } let ue = !1; let le = null; const ce = function (e) { const t = e.getAttribute('style'); let r = []; return t && (r = t.split(';').reduce((e, t) => { const r = t.split(':'); const n = r[0]; const i = r.slice(1); return n && i.length > 0 && (e[n] = i.join(':').trim()), e }, {})), r }; const pe = function (e) { const t = e.getAttribute('data-prefix'); const r = e.getAttribute('data-icon'); const n = void 0 !== e.innerText ? e.innerText.trim() : ''; const i = getCanonicalIcon(classArray(e)); return t && r && (i.prefix = t, i.iconName = r), i.prefix && n.length > 1 ? i.iconName = (function byLigature(e, t) { return te[e][t] }(i.prefix, e.innerText)) : i.prefix && n.length === 1 && (i.iconName = (function byUnicode(e, t) { return ee[e][t] }(i.prefix, (function toHex(e) { for (var t = '', r = 0; r < e.length; r++)t += (`000${e.charCodeAt(r).toString(16)}`).slice(-4); return t }(e.innerText))))), i }; const fe = function parseTransformString(e) {
    const t = {
      size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0,
    }; return e ? e.toLowerCase().split(' ').reduce((e, t) => { const r = t.toLowerCase().split('-'); const n = r[0]; let i = r.slice(1).join('-'); if (n && i === 'h') return e.flipX = !0, e; if (n && i === 'v') return e.flipY = !0, e; if (i = parseFloat(i), isNaN(i)) return e; switch (n) { case 'grow': e.size += i; break; case 'shrink': e.size -= i; break; case 'left': e.x -= i; break; case 'right': e.x += i; break; case 'up': e.y -= i; break; case 'down': e.y += i; break; case 'rotate': e.rotate += i; } return e }, t) : t;
  }; const de = function (e) { return fe(e.getAttribute('data-fa-transform')) }; const he = function (e) { const t = e.getAttribute('data-fa-symbol'); return t !== null && (t === '' || t) }; const me = function (e) { const t = toArray(e.attributes).reduce((e, t) => e.name !== 'class' && e.name !== 'style' && (e[t.name] = t.value), e, {}); const r = e.getAttribute('title'); return F.autoA11y && (r ? t['aria-labelledby'] = `${F.replacementClass}-title-${nextUniqueId()}` : t['aria-hidden'] = 'true'), t }; const ge = function (e) { const t = e.getAttribute('data-fa-mask'); return t ? getCanonicalIcon(t.split(' ').map(e => e.trim())) : ae() }; function MissingIcon(e) { this.name = 'MissingIcon', this.message = e || 'Icon unavailable', this.stack = (new Error()).stack }MissingIcon.prototype = Object.create(Error.prototype), MissingIcon.prototype.constructor = MissingIcon; const ve = { fill: 'currentColor' }; const ye = { attributeType: 'XML', repeatCount: 'indefinite', dur: '2s' }; const be = { tag: 'path', attributes: A({}, ve, { d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z' }) }; const xe = A({}, ye, { attributeName: 'opacity' }); const De = { tag: 'g', children: [be, { tag: 'circle', attributes: A({}, ve, { cx: '256', cy: '364', r: '28' }), children: [{ tag: 'animate', attributes: A({}, ye, { attributeName: 'r', values: '28;14;28;28;14;28;' }) }, { tag: 'animate', attributes: A({}, xe, { values: '1;0;1;1;0;1;' }) }] }, { tag: 'path', attributes: A({}, ve, { opacity: '1', d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z' }), children: [{ tag: 'animate', attributes: A({}, xe, { values: '1;0;0;0;0;1;' }) }] }, { tag: 'path', attributes: A({}, ve, { opacity: '0', d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z' }), children: [{ tag: 'animate', attributes: A({}, xe, { values: '0;0;1;1;0;0;' }) }] }] }; const _e = M.styles; const Ce = 'fa-layers-text'; const we = /Font Awesome 5 (Solid|Regular|Light|Brands)/; const Ee = {
    Solid: 'fas', Regular: 'far', Light: 'fal', Brands: 'fab',
  }; function findIcon(e, t) {
    let r = {
      found: !1, width: 512, height: 512, icon: De,
    }; if (e && t && _e[t] && _e[t][e]) {
      const n = _e[t][e]; r = {
        found: !0, width: n[0], height: n[1], icon: { tag: 'path', attributes: { fill: 'currentColor', d: n.slice(4)[0] } },
      };
    } else if (e && t && !F.showMissingIcons) throw new MissingIcon(`Icon is missing for prefix ${t} with icon name ${e}`); return r;
  } function generateMutation(e) {
    const t = (function parseMeta(e) {
      const t = pe(e); const r = t.iconName; const n = t.prefix; const i = t.rest; const a = ce(e); const o = de(e); const s = he(e); const u = me(e); const l = ge(e); return {
        iconName: r, title: e.getAttribute('title'), prefix: n, transform: o, symbol: s, mask: l, extra: { classes: i, styles: a, attributes: u },
      };
    }(e)); return ~t.extra.classes.indexOf(Ce) ? (function generateLayersText(e, t) {
      const r = t.title; const n = t.transform; const i = t.extra; let a = null; let o = null; if (g) { const s = parseInt(getComputedStyle(e).fontSize, 10); const u = e.getBoundingClientRect(); a = u.width / s, o = u.height / s } return F.autoA11y && !r && (i.attributes['aria-hidden'] = 'true'), [e, makeLayersTextAbstract({
        content: e.innerHTML, width: a, height: o, transform: n, title: r, extra: i, watchable: !0,
      })];
    }(e, t)) : (function generateSvgReplacementMutation(e, t) {
      const r = t.iconName; const n = t.title; const i = t.prefix; const a = t.transform; const o = t.symbol; const s = t.mask; const u = t.extra; return [e, makeInlineSvgAbstract({
        icons: { main: findIcon(r, i), mask: findIcon(s.iconName, s.prefix) }, prefix: i, iconName: r, transform: a, symbol: o, mask: s, title: n, extra: u, watchable: !0,
      })];
    }(e, t));
  } function remove(e) { typeof e.remove === 'function' ? e.remove() : e && e.parentNode && e.parentNode.removeChild(e) } function searchPseudoElements(e) { if (m) { const t = X.begin('searchPseudoElements'); !(function disableObservation(e) { ue = !0, e(), ue = !1 }(() => { toArray(e.querySelectorAll('*')).forEach((e) => { [':before', ':after'].forEach((t) => { const r = c.getComputedStyle(e, t); const n = r.getPropertyValue('font-family').match(we); let i = toArray(e.children).filter(e => e.getAttribute(b) === t)[0]; if (i && (i.nextSibling && i.nextSibling.textContent.indexOf(b) > -1 && remove(i.nextSibling), remove(i), i = null), n && !i) { const a = r.getPropertyValue('content'); const o = p.createElement('i'); o.setAttribute('class', `${Ee[n[1]]}`), o.setAttribute(b, t), o.innerText = a.length === 3 ? a.substr(1, 1) : a, t === ':before' ? e.insertBefore(o, e.firstChild) : e.appendChild(o) } }) }) })), t() } } function onTree(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (m) { const r = p.documentElement.classList; const n = function hclAdd(e) { return r.add(`${x}-${e}`) }; const i = function hclRemove(e) { return r.remove(`${x}-${e}`) }; const a = Object.keys(_e); const o = [`.${Ce}:not([${y}])`].concat(a.map(e => `.${e}:not([${y}])`)).join(', '); if (o.length !== 0) { const s = toArray(e.querySelectorAll(o)); if (s.length > 0) { n('pending'), i('complete'); const u = X.begin('onTree'); const l = s.reduce((e, t) => { try { const r = generateMutation(t); r && e.push(r) } catch (e) { D || e instanceof MissingIcon && console.error(e) } return e }, []); u(), perform(l, () => { n('active'), n('complete'), i('pending'), typeof t === 'function' && t() }) } } } } function onNode(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const r = generateMutation(e); r && perform([r], t) } const Se = function () { const e = 'svg-inline--fa'; const t = F.familyPrefix; const r = F.replacementClass; let n = 'svg:not(:root).svg-inline--fa {\n  overflow: visible; }\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -.125em; }\n  .svg-inline--fa.fa-lg {\n    vertical-align: -.225em; }\n  .svg-inline--fa.fa-w-1 {\n    width: 0.0625em; }\n  .svg-inline--fa.fa-w-2 {\n    width: 0.125em; }\n  .svg-inline--fa.fa-w-3 {\n    width: 0.1875em; }\n  .svg-inline--fa.fa-w-4 {\n    width: 0.25em; }\n  .svg-inline--fa.fa-w-5 {\n    width: 0.3125em; }\n  .svg-inline--fa.fa-w-6 {\n    width: 0.375em; }\n  .svg-inline--fa.fa-w-7 {\n    width: 0.4375em; }\n  .svg-inline--fa.fa-w-8 {\n    width: 0.5em; }\n  .svg-inline--fa.fa-w-9 {\n    width: 0.5625em; }\n  .svg-inline--fa.fa-w-10 {\n    width: 0.625em; }\n  .svg-inline--fa.fa-w-11 {\n    width: 0.6875em; }\n  .svg-inline--fa.fa-w-12 {\n    width: 0.75em; }\n  .svg-inline--fa.fa-w-13 {\n    width: 0.8125em; }\n  .svg-inline--fa.fa-w-14 {\n    width: 0.875em; }\n  .svg-inline--fa.fa-w-15 {\n    width: 0.9375em; }\n  .svg-inline--fa.fa-w-16 {\n    width: 1em; }\n  .svg-inline--fa.fa-w-17 {\n    width: 1.0625em; }\n  .svg-inline--fa.fa-w-18 {\n    width: 1.125em; }\n  .svg-inline--fa.fa-w-19 {\n    width: 1.1875em; }\n  .svg-inline--fa.fa-w-20 {\n    width: 1.25em; }\n  .svg-inline--fa.fa-pull-left {\n    margin-right: .3em;\n    width: auto; }\n  .svg-inline--fa.fa-pull-right {\n    margin-left: .3em;\n    width: auto; }\n  .svg-inline--fa.fa-border {\n    height: 1.5em; }\n  .svg-inline--fa.fa-li {\n    width: 2em; }\n  .svg-inline--fa.fa-fw {\n    width: 1.25em; }\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0; }\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -.125em;\n  width: 1em; }\n  .fa-layers svg.svg-inline--fa {\n    -webkit-transform-origin: center center;\n            transform-origin: center center; }\n\n.fa-layers-text, .fa-layers-counter {\n  display: inline-block;\n  position: absolute;\n  text-align: center; }\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center; }\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: .25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right; }\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right; }\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left; }\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right; }\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left; }\n\n.fa-lg {\n  font-size: 1.33333em;\n  line-height: 0.75em;\n  vertical-align: -.0667em; }\n\n.fa-xs {\n  font-size: .75em; }\n\n.fa-sm {\n  font-size: .875em; }\n\n.fa-1x {\n  font-size: 1em; }\n\n.fa-2x {\n  font-size: 2em; }\n\n.fa-3x {\n  font-size: 3em; }\n\n.fa-4x {\n  font-size: 4em; }\n\n.fa-5x {\n  font-size: 5em; }\n\n.fa-6x {\n  font-size: 6em; }\n\n.fa-7x {\n  font-size: 7em; }\n\n.fa-8x {\n  font-size: 8em; }\n\n.fa-9x {\n  font-size: 9em; }\n\n.fa-10x {\n  font-size: 10em; }\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em; }\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0; }\n  .fa-ul > li {\n    position: relative; }\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit; }\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: .1em;\n  padding: .2em .25em .15em; }\n\n.fa-pull-left {\n  float: left; }\n\n.fa-pull-right {\n  float: right; }\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: .3em; }\n\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: .3em; }\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear; }\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8); }\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg); } }\n\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg); }\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg); }\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg); }\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1); }\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1); }\n\n.fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1); }\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical {\n  -webkit-filter: none;\n          filter: none; }\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2em; }\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0; }\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1em; }\n\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2em; }\n\n.fa-inverse {\n  color: #fff; }\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px; }\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto; }\n'; if (t !== 'fa' || r !== e) { const i = new RegExp('\\.fa\\-', 'g'); const a = new RegExp(`\\.${e}`, 'g'); n = n.replace(i, `.${t}-`).replace(a, `.${r}`) } return n }; function prepIcon(e) {
    return {
      found: !0, width: e[0], height: e[1], icon: { tag: 'path', attributes: { fill: 'currentColor', d: e.slice(4)[0] } },
    };
  } let ke = !1; function ensureCss() { F.autoAddCss && (ke || insertCss(Se()), ke = !0) } function apiObject(e, t) { return Object.defineProperty(e, 'abstract', { get: t }), Object.defineProperty(e, 'html', { get: function get() { return e.abstract.map(e => toHtml(e)) } }), Object.defineProperty(e, 'node', { get: function get() { if (m) { const t = p.createElement('div'); return t.innerHTML = e.html, t.children } } }), e } function findIconDefinition(e) { const t = e.prefix; const r = void 0 === t ? 'fa' : t; const n = e.iconName; if (n) return iconFromMapping(Ae.definitions, r, n) || iconFromMapping(M.styles, r, n); } var Ae = new (function () { function Library() { S(this, Library), this.definitions = {} } return k(Library, [{ key: 'add', value: function add() { for (var e = this, t = arguments.length, r = Array(t), n = 0; n < t; n++)r[n] = arguments[n]; const i = r.reduce(this._pullDefinitions, {}); Object.keys(i).forEach((t) => { e.definitions[t] = A({}, e.definitions[t] || {}, i[t]), (function define(e, t) { const r = Object.keys(t).reduce((e, r) => { const n = t[r]; return n.icon ? e[n.iconName] = n.icon : e[r] = n, e }, {}); typeof M.hooks.addPack === 'function' ? M.hooks.addPack(e, r) : M.styles[e] = A({}, M.styles[e] || {}, r), e === 'fas' && define('fa', t) }(t, i[t])) }) } }, { key: 'reset', value: function reset() { this.definitions = {} } }, { key: '_pullDefinitions', value: function _pullDefinitions(e, t) { const r = t.prefix && t.iconName && t.icon ? { 0: t } : t; return Object.keys(r).map((t) => { const n = r[t]; const i = n.prefix; const a = n.iconName; const o = n.icon; e[i] || (e[i] = {}), e[i][a] = o }), e } }]), Library }())(); var Te = function noAuto() { !(function auto(e) { update({ autoReplaceSvg: e, observeMutations: e }) }(!1)), (function disconnect() { le && le.disconnect() }()) };


  var Pe = { i2svg: function i2svg() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (m) { ensureCss(); const t = e.node; const r = void 0 === t ? p : t; const n = e.callback; const i = void 0 === n ? function () {} : n; F.searchPseudoElements && searchPseudoElements(r), onTree(r, i) } }, css: Se, insertCss: function insertCss$$1() { insertCss(Se()) } };


  var Re = { transform: function transform(e) { return fe(e) } };


  var Oe = (function resolveIcons(e) { return function (t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = (t || {}).icon ? t : findIconDefinition(t || {}); let i = r.mask; return i && (i = (i || {}).icon ? i : findIconDefinition(i || {})), e(n, A({}, r, { mask: i })) } }(function (e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.transform; const n = void 0 === r ? q : r; const i = t.symbol; const a = void 0 !== i && i; const o = t.mask; const s = void 0 === o ? null : o; const u = t.title; const l = void 0 === u ? null : u; const c = t.classes; const p = void 0 === c ? [] : c; const f = t.attributes; const d = void 0 === f ? {} : f; const h = t.styles; const m = void 0 === h ? {} : h; if (e) {
      const g = e.prefix; const v = e.iconName; const y = e.icon; return apiObject(A({ type: 'icon' }, e), () => ensureCss(), F.autoA11y && (l ? d['aria-labelledby'] = `${F.replacementClass}-title-${nextUniqueId()}` : d['aria-hidden'] = 'true'), makeInlineSvgAbstract({
        icons: {
          main: prepIcon(y),
          mask: s ? prepIcon(s.icon) : {
            found: !1, width: null, height: null, icon: {},
          },
        },
        prefix: g,
        iconName: v,
        transform: A({}, q, n),
        symbol: a,
        title: l,
        extra: { attributes: d, styles: m, classes: p },
      }));
    }
  })); var Fe = function text(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = t.transform; const n = void 0 === r ? q : r; const i = t.title; const a = void 0 === i ? null : i; const o = t.classes; const s = void 0 === o ? [] : o; const u = t.attributes; const l = void 0 === u ? {} : u; const c = t.styles; const p = void 0 === c ? {} : c; return apiObject({ type: 'text', content: e }, () => ensureCss(), makeLayersTextAbstract({
      content: e, transform: A({}, q, n), title: a, extra: { attributes: l, styles: p, classes: [`${F.familyPrefix}-layers-text`].concat(T(s)) },
    }));
  };


  var Le = function layer(e) { return apiObject({ type: 'layer' }, () => { ensureCss(); let t = []; return e((e) => { Array.isArray(e) ? e.map((e) => { t = t.concat(e.abstract) }) : t = t.concat(e.abstract) }), [{ tag: 'span', attributes: { class: `${F.familyPrefix}-layers` }, children: t }] }) };


  const Me = {
    noAuto: Te, dom: Pe, library: Ae, parse: Re, findIconDefinition, icon: Oe, text: Fe, layer: Le,
  };


  const je = function autoReplace() { m && F.autoReplaceSvg && Me.dom.i2svg({ node: p }) }; Object.defineProperty(Me, 'config', { get: function get() { return F }, set: function set(e) { update(e) } }), m && (function bunker(e) { try { e() } catch (e) { if (!D) throw e; } }(() => {
    h && (c.FontAwesome || (c.FontAwesome = Me), I(() => {
      Object.keys(M.styles).length > 0 && je(), F.observeMutations && typeof MutationObserver === 'function' && (function observe(e) {
        if (f) {
          const t = e.treeCallback; const r = e.nodeCallback; const n = e.pseudoElementsCallback; le = new f(((e) => { ue || toArray(e).forEach((e) => { if (e.type === 'childList' && e.addedNodes.length > 0 && !isWatched(e.addedNodes[0]) && (F.searchPseudoElements && n(e.target), t(e.target)), e.type === 'attributes' && e.target.parentNode && F.searchPseudoElements && n(e.target.parentNode), e.type === 'attributes' && isWatched(e.target) && ~w.indexOf(e.attributeName)) if (e.attributeName === 'class') { const i = getCanonicalIcon(classArray(e.target)); const a = i.prefix; const o = i.iconName; a && e.target.setAttribute('data-prefix', a), o && e.target.setAttribute('data-icon', o) } else r(e.target); }) })), m && le.observe(p.getElementsByTagName('body')[0], {
            childList: !0, attributes: !0, characterData: !0, subtree: !0,
          });
        }
      }({ treeCallback: onTree, nodeCallback: onNode, pseudoElementsCallback: searchPseudoElements }));
    })), M.hooks = A({}, M.hooks, { addPack: function addPack(e, t) { M.styles[e] = A({}, M.styles[e] || {}, t), ne(), je() }, addShims: function addShims(e) { let t; (t = M.shims).push.apply(t, T(e)), ne(), je() } });
  })); var Ne = Me.config; t.default = Me;
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { class: { PageIcon: !this.isEnabled, 'PageIcon--disabled': !this.isEnabled } }, [t('FontAwesomeIcon', { staticClass: 'page-fa-icon', attrs: { icon: this.faIcon } })], 1) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Icon Component for Pagination Buttons.',
    methods: [],
    displayName: 'PageIcon',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"left"', func: !1 }, tags: {}, comment: '/**\n     * The direction of the arrow icon.\n     */', description: 'The direction of the arrow icon.', name: 'direction',
    }, {
      type: { name: 'boolean' }, required: !0, defaultValue: { value: 'false', func: !1 }, tags: {}, comment: '/**\n     * The status of the button.\n     */', description: 'The status of the button.', name: 'isEnabled',
    }],
    comment: '/**\n * Icon Component for Pagination Buttons.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(558); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('121a3b68', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.TimeTag-info[data-v-411b1062]{max-width:8em;max-height:1.5em;text-align:center;padding:.1em .75em;font-size:1.1em}.TimeTag-leftHalf[data-v-411b1062]{border-radius:5px 0 0 5px;color:#6a6a6a;background-color:#d6d6d6}.TimeTag-rightHalf[data-v-411b1062]{border-radius:0 5px 5px 0;color:#525252;background-color:#d6d6d6}.TimeTag-fullLength[data-v-411b1062]{border-radius:5px;color:#6a6a6a;background-color:#e6e6e6}.TimeTag-leftArrow[data-v-411b1062]{border-radius:5px 0 0 5px;padding-right:0}.TimeTag-rightArrow[data-v-411b1062]{border-radius:0 5px 5px 0;padding-left:0}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'font-opensans' }, [e.type === 'length' ? r('div', { staticClass: 'tag-container' }, [r('span', { staticClass: 'TimeTag-info TimeTag-leftHalf' }, [r('FontAwesomeIcon', { attrs: { icon: 'stopwatch' } })], 1), e._v(' '), r('span', { staticClass: 'TimeTag-info TimeTag-rightHalf' }, [e._v(`${e._s(e.duration)}s`)])]) : e._e(), e._v(' '), e.type === 'timestamp' ? r('div', { staticClass: 'tag-container TimeTag-fullLength' }, [r('span', { staticClass: 'TimeTag-info TimeTag-leftArrow' }, [r('FontAwesomeIcon', { attrs: { icon: 'long-arrow-alt-left' } })], 1), e._v(' '), r('span', { staticClass: 'TimeTag-info start-time' }, [e._v(e._s(e.start))]), e._v(' '), r('span', { staticClass: 'TimeTag-info end-time' }, [e._v(e._s(e.end))]), e._v(' '), r('span', { staticClass: 'TimeTag-info TimeTag-rightArrow' }, [r('FontAwesomeIcon', { attrs: { icon: 'long-arrow-alt-right' } })], 1)]) : e._e()]) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Time Tag Component for Loop Pages.',
    methods: [],
    displayName: 'TimeTag',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"length"', func: !1 }, tags: {}, comment: '/**\n     * Type of the Time Tag\n     *\n     * `length, timestamp`\n     */', description: 'Type of the Time Tag\n\n`length, timestamp`', name: 'type',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '"0"', func: !1 }, tags: {}, comment: '/**\n     * The duration, when `type` is `length`\n     */', description: 'The duration, when `type` is `length`', name: 'duration',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '"0"', func: !1 }, tags: {}, comment: '/**\n     * The ending time, when `type` is `timestamp`\n     */', description: 'The ending time, when `type` is `timestamp`', name: 'end',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '"0"', func: !1 }, tags: {}, comment: '/**\n     * The starting time, when `type` is `timestamp`\n     */', description: 'The starting time, when `type` is `timestamp`', name: 'start',
    }],
    comment: '/**\n * Time Tag Component for Loop Pages.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(562); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('271a330a', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.TypeTag[data-v-5d20253a]{max-width:8em;max-height:1.5em;text-align:center;color:#fff;padding:0 .5em;border-radius:5px;letter-spacing:.25px}.TypeTag-leftHalf[data-v-5d20253a]{border-radius:5px 0 0 5px}.TypeTag-rightHalf[data-v-5d20253a]{border-radius:0 5px 5px 0}.TypeTag-large[data-v-5d20253a]{padding:.1em .5em}', '']) }, function (e, t, r) {
  t.__esModule = !0; const n = (function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }(r(564))); t.default = function (e, t, r) {
    return t in e ? (0, n.default)(e, t, {
      value: r, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = r, e;
  };
}, function (e, t, r) { e.exports = { default: r(565), __esModule: !0 } }, function (e, t, r) { r(566); const n = r(7).Object; e.exports = function defineProperty(e, t, r) { return n.defineProperty(e, t, r) } }, function (e, t, r) { const n = r(6); n(n.S + n.F * !r(25), 'Object', { defineProperty: r(19).f }) }, function (e, t, r) { e.exports = !r(25) && !r(33)(() => Object.defineProperty(r(100)('div'), 'a', { get() { return 7 } }).a != 7) }, function (e, t, r) { const n = r(20); e.exports = function (e, t) { if (!n(e)) return e; let r; let i; if (t && typeof (r = e.toString) === 'function' && !n(i = r.call(e))) return i; if (typeof (r = e.valueOf) === 'function' && !n(i = r.call(e))) return i; if (!t && typeof (r = e.toString) === 'function' && !n(i = r.call(e))) return i; throw TypeError("Can't convert object to primitive value") } }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'font-opensans' }, [e.type === 'withSeason' ? r('div', { staticClass: 'tag-container' }, [r('span', { staticClass: 'TypeTag TypeTag-large TypeTag-leftHalf text-lg ', class: e.typeClassObj({ type: e.animeType }) }, [e._v(e._s(e.animeType))]), e._v(' '), r('span', { staticClass: 'TypeTag TypeTag-large TypeTag-rightHalf text-lg light', class: e.typeClassObj({ type: e.animeType }) }, [e._v(e._s(e.season))])]) : [r('span', { staticClass: 'TypeTag text-sm', class: e.typeClassObj({ type: e.animeType }) }, [e._v(e._s(e.animeType))])]], 2) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Series Type Component for Loop/Series/Episode Pages.',
    methods: [{
      name: 'typeClassObj',
      comment: '/**\n     * Returns CSS class object used by Vue.\n     *\n     * @public\n     * @param {Object} obj - Object for destruction.\n     * @param {string} obj.type - Type of the Series.\n     * @returns {Object} The object containing CSS class to be applied, differentiated by colors.\n     */',
      modifiers: [],
      params: [{ name: 'obj', description: 'Object for destruction.', type: { name: 'Object' } }, { name: 'obj.type', description: 'Type of the Series.', type: { name: 'string' } }],
      returns: { description: 'The object containing CSS class to be applied, differentiated by colors.', type: { name: 'Object' } },
      description: 'Returns CSS class object used by Vue.',
      tags: {
        access: [{ title: 'access', description: 'public' }],
        returns: [{ title: 'returns', description: 'The object containing CSS class to be applied, differentiated by colors.', type: { type: 'NameExpression', name: 'Object' } }],
        public: [{ title: 'public', description: null, type: null }],
        param: [{
          title: 'param', description: 'Object for destruction.', name: 'obj', type: { type: 'NameExpression', name: 'Object' },
        }, {
          title: 'param', description: 'Type of the Series.', name: 'obj.type', type: { type: 'NameExpression', name: 'string' },
        }],
      },
    }],
    displayName: 'TypeTag',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"Unknown"', func: !1 }, tags: {}, comment: '/**\n     * Type of the Series\n     */', description: 'Type of the Series', name: 'animeType',
    }, {
      type: { name: 'string' }, required: !0, defaultValue: { value: '"simple"', func: !1 }, tags: {}, comment: '/**\n     * Type of the Anime Type Tag\n     *\n     * `simple, withSeason`\n     */', description: 'Type of the Anime Type Tag\n\n`simple, withSeason`', name: 'type',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '"2046-01"', func: !1 }, tags: {}, comment: '/**\n     * Season of the Series\n     */', description: 'Season of the Series', name: 'season',
    }],
    comment: '/**\n * Series Type Component for Loop/Series/Episode Pages.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(572); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('5f5f953e', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.Breadcrumb-wrapper[data-v-1dfafaec]{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;white-space:nowrap;overflow:hidden;color:rgba(21,81,166,.5)}.Breadcrumb-link[data-v-1dfafaec]{display:inline-block;max-width:calc(100% - 3em)}.Breadcrumb-link>a[data-v-1dfafaec]{color:#1e50a2}.Breadcrumb-title[data-v-1dfafaec]{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.Breadcrumb-divider[data-v-1dfafaec]{display:inline-block;color:#95989a;padding:0 8px;padding:0 .5rem}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; const t = this._self._c || e; return t('nav', { staticClass: 'Breadcrumb-wrapper' }, [t('span', { staticClass: 'Breadcrumb-link Breadcrumb-title' }, [this._t('title')], 2), this._v(' '), t('span', { staticClass: 'Breadcrumb-divider' }, [this._v('/')]), this._v(' '), t('span', { staticClass: 'Breadcrumb-link' }, [this._t('no')], 2)]) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Breadcrumb Component for Loop Pages.', methods: [], displayName: 'Breadcrumb', props: void 0, comment: '/**\n * Breadcrumb Component for Loop Pages.\n */', tags: {}, events: {}, slots: { title: { description: null }, no: { description: null } }, examples: [],
  };
}, function (e, t, r) { let n = r(576); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('bdaa0058', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.LoopCard-video[data-v-100c0cfe]{max-width:100%;max-height:calc(100vh - 15rem);-o-object-fit:contain;object-fit:contain}@media (max-width:640px){.LoopCard-video[data-v-100c0cfe]{width:100%}}@media (min-width:641px) and (max-width:820px){.LoopCard-video[data-v-100c0cfe]{width:100%;max-height:calc(100vh - 5em)}}.LoopCard-fixedImageSize[data-v-100c0cfe]{width:360px;height:203px}.LoopCard-videoCover[data-v-100c0cfe]{width:100%;-webkit-transition:all .5s;transition:all .5s}.LoopCard--blur[data-v-100c0cfe]{filter:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="10" /></filter></svg>#filter\');-webkit-filter:blur(10px);filter:blur(10px)}.LoopCard-faIcon[data-v-100c0cfe]{margin:0 .5em}.LoopCard-spinner[data-v-100c0cfe]{background-color:hsla(0,0%,100%,.5);top:50%;left:50%;padding:.5em;border-radius:5px;position:absolute;margin:auto;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:1.5em}[v-cloak][data-v-100c0cfe]{display:none}', '']) }, function (e, t, r) { let n = r(578); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('85a9f9d4', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.GifPlayer[data-v-09021016]{display:-webkit-box;display:-ms-flexbox;display:flex;position:relative;overflow:hidden;max-height:100%;max-width:100%;border-radius:3px 3px 0 0}.GifPlayer-img[data-v-09021016]{-webkit-transition:all .5s;transition:all .5s;-o-object-fit:contain;object-fit:contain;margin-left:auto;margin-right:auto}.GifPlayer-gif[data-v-09021016]{width:360px;height:100%}.GifPlayer-blur[data-v-09021016]{filter:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="20" /></filter></svg>#filter\');-webkit-filter:blur(20px);filter:blur(20px)}[v-cloak][data-v-09021016]{display:none}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'GifPlayer' }, [e.playState ? r('img', {
      directives: [{
        name: 'show', rawName: 'v-show', value: e.gifLoaded, expression: 'gifLoaded',
      }],
      staticClass: 'GifPlayer-gif',
      attrs: { src: e.gifsrc, alt: 'Static Loop Image' },
      on: { load: e.imageOnload },
    }) : e._e(), e._v(' '), e.gifLoaded && e.playState ? e._e() : r('img', { staticClass: 'GifPlayer-img', class: { 'GifPlayer-blur': e.playState }, attrs: { src: e.jpgsrc, alt: 'Animated Loop Image' } })]);
  }; var i = [];
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('section', [e.loopType === 'mp4' ? r('div', { on: { mouseover(t) { e.onHovered() }, mouseout(t) { e.onUnhovered() } } }, [e.canplaythrough ? e._e() : r('div', { staticClass: 'LoopCard-spinner' }, [r('FontAwesomeIcon', { staticClass: 'LoopCard-faIcon', attrs: { icon: 'circle-notch', spin: '' } })], 1), e._v(' '), r('video', {
      ref: 'video',
      staticClass: 'LoopCard-video',
      attrs: {
        loop: '', muted: '', autoplay: '', playsInline: '', vcloak: '',
      },
      domProps: { muted: !0 },
      on: { '~canplaythrough': function (t) { return e.canplay(t) } },
    }, [r('source', { attrs: { src: e.files.mp4_720p, type: 'video/mp4', media: 'screen' } }), e._v(' '), r('source', { attrs: { src: e.files.mp4_1080p, type: 'video/mp4', media: '(screen and (min-device-width: 1000px))' } }), e._v(' '), r('track', { attrs: { label: 'English', kind: 'captions', srcLang: 'en' } })])]) : r('div', { staticClass: 'flex', class: { 'LoopCard-fixedImageSize': e.pageType === 'home' } }, [r('GifPlayer', { attrs: { gifsrc: e.files.gif_360p, jpgsrc: e.files.jpg_360p } })], 1)]);
  }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Loop Card components for Loop/Series/Episode pages.\nBasically a Wrapper for video/GIF player.',
    methods: [],
    displayName: 'LoopCard',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"mp4"', func: !1 }, tags: {}, comment: '/**\n    * Video Format of the LoopCard.\n    *\n    * `mp4, gif`\n    */', description: 'Video Format of the LoopCard.\n\n`mp4, gif`', name: 'loopType',
    }, {
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n    * `loopid` of the LoopCard.\n    */', description: '`loopid` of the LoopCard.', name: 'loopid',
    }, {
      type: { name: 'string' }, required: !0, defaultValue: { value: '"loop"', func: !1 }, tags: {}, comment: '/**\n    * The type of page using this component.\n    *\n    * `home, episode, loop`\n    */', description: 'The type of page using this component.\n\n`home, episode, loop`', name: 'pageType',
    }],
    comment: '/**\n * Loop Card components for Loop/Series/Episode pages.\n * Basically a Wrapper for video/GIF player.\n */',
    tags: {},
    events: {
      canplay: {
        description: 'When video.canplaythrough is fired, show the video.', type: { names: ['function'] }, properties: void 0, comment: '/**\n     * When video.canplaythrough is fired, show the video.\n     *\n     * @event canplay\n     * @type {Function}\n     */',
      },
      onUnhovered: {
        description: 'When LoopCard is not hovered, pause the video.', type: { names: ['function'] }, properties: void 0, comment: '/**\n     * When LoopCard is not hovered, pause the video.\n     *\n     * @event onUnhovered\n     * @type {Function}\n     */',
      },
      onHovered: {
        description: 'When LoopCard is hovered, play the video.', type: { names: ['function'] }, properties: void 0, comment: '/**\n     * When LoopCard is hovered, play the video.\n     *\n     * @event onHovered\n     * @type {Function}\n     */',
      },
    },
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(583); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('34fb2f89', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.CardDetails-gridContainer[data-v-1c713996]{height:3em;padding:.1em .5em;background-color:hsla(0,0%,100%,.95);border-radius:0 0 3px 3px;display:grid;grid-template-columns:auto;grid-template-rows:auto auto;grid-template-areas:"card-title card-right-half" "card-timestamp card-right-half";grid-column-gap:.25em;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.CardDetails--episode[data-v-1c713996]{display:block;padding:.25em .5em;background-color:hsla(0,0%,100%,.95);border-radius:0 0 3px 3px}.CardDetails-title[data-v-1c713996]{grid-area:card-title;display:inline;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;font-size:1em}.CardDetails-rightHalf[data-v-1c713996]{grid-area:card-right-half;justify-self:end;-ms-flex-item-align:stretch;align-self:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-webkit-box-pack:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly}.CardDetails-episodeNo[data-v-1c713996]{text-align:center;font-weight:400;font-size:19.2px;font-size:1.2rem;justify-self:center;line-height:.9}.CardDetails-type[data-v-1c713996]{max-width:8em;max-height:1.5em;-ms-flex-item-align:end;align-self:flex-end;text-align:center;line-height:1.3}.CardDetails-timestamp[data-v-1c713996]{grid-area:card-timestamp;font-size:.75em;font-style:italic;color:#95989a}.CardDetails-timestamp--episode[data-v-1c713996]{font-size:1.2em;text-align:center;color:#95989a}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return e.type === 'loop' ? r('div', { staticClass: 'CardDetails-gridContainer' }, [r('div', { staticClass: 'CardDetails-title' }, [e._v(e._s(e.i18nTitle))]), e._v(' '), r('div', { staticClass: 'CardDetails-rightHalf' }, [r('div', { staticClass: 'CardDetails-episodeNo' }, [e._v(e._s(e.loop.episode.no))]), e._v(' '), r('TypeTag', { staticClass: 'CardDetails-type', attrs: { 'anime-type': e.loop.series.type, type: 'simple' } })], 1), e._v(' '), r('div', { staticClass: 'CardDetails-timestamp' }, [e._v(`\n    ${e._s(e.formattedTimeStamps.begin)} - ${e._s(e.formattedTimeStamps.end)}\n  `)])]) : r('div', { staticClass: 'CardDetails--episode' }, [r('div', { staticClass: 'CardDetails-timestamp--episode' }, [e._v(`\n    ${e._s(e.formattedTimeStamps.begin)} - ${e._s(e.formattedTimeStamps.end)}\n  `)])]) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Details of Loop, shown below LoopCard in Series/Episode/Home Pages.',
    methods: [],
    displayName: 'CardDetails',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n    * `loopid` of the `LoopCard`.\n    */', description: '`loopid` of the `LoopCard`.', name: 'loopid',
    }, {
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n    * The type of the `LoopCard` details.\n    *\n    * `loops` shows full detail while `episode` shows timestamps only.\n    *\n    * `episode, loop`\n    */', description: 'The type of the `LoopCard` details.\n\n`loops` shows full detail while `episode` shows timestamps only.\n\n`episode, loop`', name: 'type',
    }],
    comment: '/**\n * Details of Loop, shown below LoopCard in Series/Episode/Home Pages.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(587); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('563b2913', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.Downloads-wrapper[data-v-131a77aa]{margin-top:-.4em;margin-left:-.2em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap}.Downloads-tag[data-v-131a77aa]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;text-align:center;height:1.5em;margin:.25em;padding:.25em .75em;font-size:.9em;background-color:#3b71c7;border-radius:2px;white-space:nowrap}.Downloads-video[data-v-131a77aa]{background-color:#1e50a2}.Downloads-gif[data-v-131a77aa]{background-color:#6096ec}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'Downloads-wrapper font-opensans' }, e._l(e.downloadEntries, t => r('div', { key: t.name, staticClass: 'Downloads-tag', class: t.typeClass }, [r('a', { staticClass: 'text-white', attrs: { href: t.url, download: '' } }, [e._v(e._s(t.name))])]))) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Download section of Loop Page.',
    methods: [],
    displayName: 'Downloads',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n    * `loopid` of the `LoopCard`.\n    */', description: '`loopid` of the `LoopCard`.', name: 'loopid',
    }],
    comment: '/**\n * Download section of Loop Page.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Wrapper for `.gif` files.',
    methods: [],
    displayName: 'GifPlayer',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * Src path for `.gif` file.\n     */', description: 'Src path for `.gif` file.', name: 'gifsrc',
    }, {
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * Src path for `.jpg` file.\n     */', description: 'Src path for `.jpg` file.', name: 'jpgsrc',
    }],
    comment: '/**\n * Wrapper for `.gif` files.\n */',
    tags: {},
    events: {
      imageOnload: {
        description: 'Show the `gif` once it completes loading.', type: { names: ['function'] }, properties: void 0, comment: '/**\n     * Show the `gif` once it completes loading.\n     *\n     * @event imageOnload\n     * @type {Function}\n     */',
      },
    },
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(592); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('c39b1eb8', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.LoopGrid[data-v-71f0e36b]{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,360px));grid-template-rows:auto;grid-gap:1em;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.LoopGrid a[data-v-71f0e36b]{color:#000}.LoopGrid-child[data-v-71f0e36b]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-webkit-box-shadow:0 1px 5px 0 rgba(0,0,0,.15);box-shadow:0 1px 5px 0 rgba(0,0,0,.15);border-radius:3px}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return e.pageType === 'home' ? r('div', { staticClass: 'LoopGrid' }, e._l(e.loopList, t => r('div', { key: t, staticClass: 'LoopGrid-child' }, [r('nuxt-link', { attrs: { to: { name: 'loop-id', params: { id: t } } } }, [r('LoopCard', { attrs: { loopid: t, 'loop-type': 'gif', 'page-type': 'home' } }), e._v(' '), r('CardDetails', { staticClass: 'z-1', attrs: { loopid: t, type: 'loop' } })], 1)], 1))) : r('div', { staticClass: 'LoopGrid' }, e._l(e.loopList, t => r('div', { key: t.id, staticClass: 'LoopGrid-child' }, [r('nuxt-link', { attrs: { to: { name: 'loop-id', params: { id: t.id } } } }, [r('LoopCard', { attrs: { loopid: t.id, 'page-type': 'episode', 'loop-type': 'gif' } }), e._v(' '), r('CardDetails', { staticClass: 'z-1', attrs: { loopid: t.id, type: 'episode' } })], 1)], 1))) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Grid layout wrapper for `LoopCard`.',
    methods: [],
    displayName: 'LoopGrid',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"home"', func: !1 }, tags: {}, comment: '/**\n     * The type of page including this component.\n     *\n     * `home, episode`\n     */', description: 'The type of page including this component.\n\n`home, episode`', name: 'pageType',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '""', func: !1 }, tags: {}, comment: '/**\n     * `episodeid` of the Episode, when `pageType` is `episode`.\n     */', description: '`episodeid` of the Episode, when `pageType` is `episode`.', name: 'episodeid',
    }],
    comment: '/**\n * Grid layout wrapper for `LoopCard`.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(596); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('71fdc907', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.LoopPage[data-v-2dff73ba]{display:grid;grid-template-columns:auto;grid-template-rows:auto;grid-gap:1em 2em;grid-template-areas:"breadcrumb vertical-title" "loop-card vertical-title" "loop-info vertical-title" "loop-info vertical-title";-ms-flex-line-pack:start;align-content:start}@media (min-width:641px) and (max-width:820px){.LoopPage[data-v-2dff73ba]{grid-template-columns:auto;grid-template-rows:auto;grid-template-areas:"breadcrumb" "loop-card" "loop-info"}}@media (max-width:640px){.LoopPage[data-v-2dff73ba]{grid-template-columns:auto;grid-template-rows:auto;grid-template-areas:"breadcrumb" "loop-card" "loop-info";margin:0}}.LoopPage-verticalTitle[data-v-2dff73ba]{grid-area:vertical-title;-webkit-writing-mode:vertical-rl;-ms-writing-mode:tb-rl;writing-mode:vertical-rl;color:#969798;font-size:3em;font-family:serif;max-height:calc(100vh - 5rem);white-space:normal;word-break:normal}@media (min-width:641px) and (max-width:820px){.LoopPage-verticalTitle[data-v-2dff73ba]{display:none}}@media (max-width:640px){.LoopPage-verticalTitle[data-v-2dff73ba]{display:none}}.LoopPage-loopCard[data-v-2dff73ba]{grid-area:loop-card}@media (max-width:640px){.LoopPage-info[data-v-2dff73ba]{margin:0 .5em}}.LoopPage-breadcrumb[data-v-2dff73ba]{grid-area:breadcrumb}@media (max-width:640px){.LoopPage-breadcrumb[data-v-2dff73ba]{margin:0 .5em}}', '']) }, function (e, t, r) { let n = r(598); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('429f1a9d', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.LoopInfo[data-v-14fa35fc]{grid-area:loop-info;display:grid;-webkit-box-align:start;-ms-flex-align:start;align-items:start;grid-template-columns:auto;grid-template-rows:auto;grid-gap:1em;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch}.LoopInfo-tags[data-v-14fa35fc]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap}.LoopInfo-season[data-v-14fa35fc]{margin:.25em .25em .25em 0}.LoopInfo-duration[data-v-14fa35fc]{margin:.25em .5em .25em .25em}.LoopInfo-timestamp[data-v-14fa35fc]{margin:.25em .25em .25em 0}.LoopInfo-downloads[data-v-14fa35fc]{font-weight:400;color:#333}.LoopInfo-downloadsText[data-v-14fa35fc]{font-weight:500;padding-bottom:1em}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'LoopInfo' }, [r('div', { staticClass: 'LoopInfo-tags' }, [r('TypeTag', { staticClass: 'LoopInfo-season', attrs: { 'anime-type': e.loop.series.type, season: e.loop.series.season, type: 'withSeason' } }), e._v(' '), r('TimeTag', { staticClass: 'LoopInfo-duration', attrs: { duration: e.formattedTimeStamps.duration, type: 'length' } }), e._v(' '), r('TimeTag', { staticClass: 'LoopInfo-timestamp', attrs: { start: e.formattedTimeStamps.begin, end: e.formattedTimeStamps.end, type: 'timestamp' } })], 1), e._v(' '), r('div', { staticClass: 'LoopInfo-downloads' }, [r('p', {
      directives: [{
        name: 't', rawName: 'v-t', value: 'loop.downloads', expression: "'loop.downloads'",
      }],
      staticClass: 'LoopInfo-downloadsText',
    }), e._v(' '), r('Downloads', { attrs: { loopid: e.loopid } })], 1)]);
  }; var i = [];
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('section', { staticClass: 'LoopPage' }, [r('Breadcrumb', { staticClass: 'LoopPage-breadcrumb' }, [r('nuxt-link', { attrs: { slot: 'title', to: { name: 'series-id', params: { id: e.loop.series.id } }, type: 'title' }, slot: 'title' }, [e._v(e._s(e.i18nTitle))]), e._v(' '), r('nuxt-link', { attrs: { slot: 'no', to: { name: 'episode-id', params: { id: e.loop.episode.id } }, type: 'no' }, slot: 'no' }, [e._v(e._s(e.loop.episode.no))])], 1), e._v(' '), r('div', { staticClass: 'LoopPage-loopCard' }, [r('LoopCard', { attrs: { loopid: e.loop.uuid, 'loop-type': 'mp4', 'page-type': 'loop' } })], 1), e._v(' '), r('div', { staticClass: 'LoopPage-info' }, [r('LoopInfo', { attrs: { loopid: e.loop.uuid } })], 1), e._v(' '), r('div', { staticClass: 'LoopPage-verticalTitle', attrs: { lang: 'ja' } }, [r('p', [e._v(e._s(e.loop.series.titleJA))])])], 1) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'View component of `LoopPage`.',
    methods: [],
    displayName: 'LoopPageView',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"loop"', func: !1 }, tags: {}, comment: '/**\n     * Type of current `LoopPage`.\n     *\n     * `loop, random`\n     */', description: 'Type of current `LoopPage`.\n\n`loop, random`', name: 'pageType',
    }],
    comment: '/**\n * View component of `LoopPage`.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Info of current Loop, used in the `LoopPage`.',
    methods: [],
    displayName: 'LoopInfo',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * `loopid` of current loop.\n     */', description: '`loopid` of current loop.', name: 'loopid',
    }],
    comment: '/**\n * Info of current Loop, used in the `LoopPage`.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(604); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('270f9e3e', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.NavbarEntry[data-v-2eb55006]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 1em;height:3em;-ms-flex-negative:0;flex-shrink:0}@media (min-width:641px) and (max-width:820px){.NavbarEntry[data-v-2eb55006]{-webkit-box-ordinal-group:5;-ms-flex-order:4;order:4;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;padding:0;margin:0 -.5em}}@media (max-width:640px){.NavbarEntry[data-v-2eb55006]{-webkit-box-ordinal-group:5;-ms-flex-order:4;order:4;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;padding:0;margin:0 -.5em .5em;display:none;height:auto;-ms-flex-wrap:wrap;flex-wrap:wrap}}.NavbarEntry-link[data-v-2eb55006]{margin:0 .5em;padding:.4em 0;color:#333}.NavbarEntry-link[data-v-2eb55006]:hover{border-bottom:2.4px solid #6683bb;border-bottom:.15rem solid #6683bb;padding-bottom:3.2px;padding-bottom:.2rem}.NavbarEntry-link[data-v-2eb55006]{cursor:pointer;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media (max-width:640px){.NavbarEntry-link[data-v-2eb55006]{width:100%;height:3em}.NavbarEntry-link[data-v-2eb55006]:hover{border-bottom:none;padding:.4em 0}}.NavbarEntry-faIcon[data-v-2eb55006]{margin-right:.5em}@media (max-width:640px){.NavbarEntry-faIcon[data-v-2eb55006]{width:1em}}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'NavbarEntry', style: e.toggledStyle }, e._l(e.entries, t => r('nuxt-link', {
      key: t.route, staticClass: 'NavbarEntry-link', attrs: { to: { name: t.routeName } }, nativeOn: { click(t) { return e.toggleBurger(t) } },
    }, [r('FontAwesomeIcon', { staticClass: 'NavbarEntry-faIcon', attrs: { icon: t.icon } }), e._v(' '), r('span', [e._v(e._s(e.$t(t.name)))])], 1)));
  }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Entries of the Navbar.', methods: [], displayName: 'NavbarEntry', props: void 0, comment: '/**\n * Entries of the Navbar.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(179); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(623); const s = r(3); const u = function injectStyle(e) { r(608) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-72100f86', null); t.default = l.exports;
}, function (e, t, r) { let n = r(609); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('60550968', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.Navbar[data-v-72100f86]{grid-area:nav;position:fixed;top:0;width:100%;background-color:#fff}@supports ((-webkit-backdrop-filter:none) or (backdrop-filter:none)){.Navbar[data-v-72100f86]{background-color:hsla(0,0%,100%,.75);-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.Navbar[data-v-72100f86]{-webkit-box-shadow:0 1px 10px 0 rgba(0,0,0,.15);box-shadow:0 1px 10px 0 rgba(0,0,0,.15);padding:0 1em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media (min-width:641px) and (max-width:820px){.Navbar[data-v-72100f86]{padding:0 2em;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}}@media (max-width:640px){.Navbar[data-v-72100f86]{-ms-flex-wrap:nowrap;flex-wrap:nowrap}}.Navbar-lineBreak[data-v-72100f86]{display:none}@media (min-width:641px) and (max-width:820px){.Navbar-lineBreak[data-v-72100f86]{display:block}}.Navbar-lineBreak[data-v-72100f86]{content:"";-webkit-box-ordinal-group:4;-ms-flex-order:3;order:3;width:100%}', '']) }, function (e, t, r) { let n = r(611); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('717d892c', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.NavbarLangMenu[data-v-0731830a]{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-negative:0;flex-shrink:0}@media (max-width:640px){.NavbarLangMenu[data-v-0731830a]{margin-left:auto;-webkit-box-flex:0;-ms-flex:0 1 25%;flex:0 1 25%;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}}.NavbarLangMenu>div[data-v-0731830a]{position:relative}.NavbarLangMenu-icon[data-v-0731830a]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.NavbarLangMenu-icon[data-v-0731830a]:focus{outline:none}.NavbarLangMenu-icon[data-v-0731830a]:hover{border-bottom:2.4px solid #6683bb;border-bottom:.15rem solid #6683bb;margin-bottom:-2.4px;margin-bottom:-.15rem}.NavbarLangMenu-icon[data-v-0731830a]{color:#333;margin-left:16px;margin-left:1rem;border:none;outline:none;padding:0;background:transparent;font-size:1.4em}.NavbarLangMenu-icon .down[data-v-0731830a]{font-size:.75em;margin-left:8px;margin-left:.5rem}.NavbarLangMenu-dropdown[data-v-0731830a]{display:none;position:absolute;background:#fff;-webkit-box-shadow:0 6px 6px 0 rgba(0,0,0,.1);box-shadow:0 6px 6px 0 rgba(0,0,0,.1)}.NavbarLangMenu-dropdownItem[data-v-0731830a]{border:none;outline:none;padding:0;background:transparent;font-size:1em;padding:.6em;cursor:pointer;color:#333}.NavbarLangMenu-dropdownItem[data-v-0731830a]:hover{padding:.6em .6em .6em .3em;border-left:.3em solid rgba(102,131,187,.8)}.NavbarLangMenu-selected[data-v-0731830a]{padding:.6em .6em .6em .3em;border-left:.3em solid #6683bb}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', {
      directives: [{
        name: 'click-outside', rawName: 'v-click-outside', value: e.onClickOutside, expression: 'onClickOutside',
      }],
      staticClass: 'NavbarLangMenu',
    }, [r('div', [r('button', { staticClass: 'NavbarLangMenu-icon', attrs: { 'aria-label': 'Select Language Button' }, on: { click: e.toggleLang } }, [r('FontAwesomeIcon', { attrs: { icon: 'language' } }), e._v(' '), r('FontAwesomeIcon', { staticClass: 'down', attrs: { icon: 'angle-down' } })], 1), e._v(' '), r('div', { staticClass: 'NavbarLangMenu-dropdown', style: e.toggleLangStyle }, e._l(e.localeList, t => r('button', {
      key: t.id, staticClass: 'NavbarLangMenu-dropdownItem', class: { 'NavbarLangMenu-selected': e.currentLocale === t.id }, on: { click(r) { e.setLanguage(t.id) } },
    }, [e._v(e._s(t.text))])))])]);
  }; var i = [];
}, function (e, t, r) { let n = r(614); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('fe02b6fe', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.NavbarBurgerMenu[data-v-f3deda52]{display:none}@media (max-width:640px){.NavbarBurgerMenu[data-v-f3deda52]{height:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;margin-right:auto;-webkit-box-flex:0;-ms-flex:0 1 25%;flex:0 1 25%}}.NavbarBurgerMenu-button[data-v-f3deda52]{color:#333;display:block;margin-right:8px;margin-right:.5rem;border:none;outline:none;padding:0;background:transparent;font-size:1.2em;width:20.8px;width:1.3rem}.NavbarBurgerMenu-icon[data-v-f3deda52]{width:17.6px;width:1.1rem}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { staticClass: 'NavbarBurgerMenu', style: this.toggleSearchStyle }, [t('button', { staticClass: 'NavbarBurgerMenu-button NavbarBurgerMenu-icon', attrs: { 'aria-label': 'Menu Icon' }, on: { click: this.toggleBurger } }, [t('FontAwesomeIcon', { attrs: { icon: this.burgerIcon } })], 1), this._v(' '), this.navStates.searchOpen ? this._e() : t('button', { staticClass: 'NavbarBurgerMenu-button', attrs: { 'aria-label': 'Search Icon' }, on: { click: this.toggleSearch } }, [t('FontAwesomeIcon', { attrs: { icon: 'search' } })], 1)]) }; var i = [];
}, function (e, t, r) { let n = r(617); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('530d4c24', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.NavbarSearch[data-v-68b232e0]{height:3em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-flex:0;-ms-flex:0 1 20em;flex:0 1 20em;margin:0 0 0 auto;max-width:30em}@media (max-width:640px){.NavbarSearch[data-v-68b232e0]{display:none;margin:0 0 0 .5rem;-webkit-box-flex:0;-ms-flex:0 1 95%;flex:0 1 95%}}.NavbarSearch-input[data-v-68b232e0]{width:100%;display:block;font-size:1em;text-align:center;border-radius:5px;color:#999;border:none;background-color:#f0f0f0;height:2em;padding:0 .5em;-webkit-appearance:none;-moz-appearance:none;appearance:none}.NavbarSearch-input[data-v-68b232e0]:focus{text-align:start;color:#000}.NavbarSearch-button[data-v-68b232e0]{margin-left:16px;margin-left:1rem;display:none;border:none;outline:none;padding:0;background:transparent;font-size:1.2em}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('form', {
      staticClass: 'NavbarSearch', style: e.toggleContainerStyle, attrs: { action: '' }, on: { submit(e) { e.preventDefault() } },
    }, [r('input', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.keyword, expression: 'keyword',
      }],
      ref: 'search',
      staticClass: 'NavbarSearch-input',
      attrs: {
        placeholder: e.searchbarPlaceholder, value: '', name: 'search', type: 'search', required: '',
      },
      domProps: { value: e.keyword },
      on: {
        keyup(t) { return 'button' in t || !e._k(t.keyCode, 'enter', 13, t.key, 'Enter') ? e.dispatchSearch(t) : null }, focus(t) { e.searchFocused = !0 }, blur(t) { e.searchFocused = !1 }, input(t) { t.target.composing || (e.keyword = t.target.value) },
      },
    }), e._v(' '), r('button', { staticClass: 'NavbarSearch-button', style: e.toggleArrowButtonStyle, on: { click: e.dispatchSearch } }, [r('FontAwesomeIcon', { staticClass: 'arrow-right-fa-icon', attrs: { icon: 'arrow-right' } })], 1)]);
  }; var i = [];
}, function (e, t, r) { let n = r(620); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('b43dc83a', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.NavbarTitle-logo[data-v-267aba02]{font-size:1.2em;display:block;height:1.6em}.NavbarTitle-logoLink[data-v-267aba02]{display:-webkit-box;display:-ms-flexbox;display:flex;cursor:pointer}@media (max-width:640px){.NavbarTitle-logoLink[data-v-267aba02]{-webkit-box-flex:0;-ms-flex:0 1 50%;flex:0 1 50%;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}}.NavbarTitle-playBtn[data-v-267aba02]{border:none;outline:none;background:transparent;margin:-.5em -.5em -.5em -.2em;padding:.5em;cursor:pointer;font-size:1.2em}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this.$createElement; const t = this._self._c || e; return t('div', { staticClass: 'NavbarTitle-logoLink' }, [t('nuxt-link', { attrs: { to: '/' } }, [t('img', { staticClass: 'NavbarTitle-logo', attrs: { alt: 'Animeloop Logo', src: r(622) } })]), this._v(' '), t('button', { staticClass: 'NavbarTitle-playBtn', attrs: { 'aria-label': 'Play or Pause button' }, on: { click: this.togglePlay } }, [t('FontAwesomeIcon', {
      directives: [{
        name: 'show', rawName: 'v-show', value: this.showPlayIcon, expression: 'showPlayIcon',
      }],
      attrs: { icon: this.playIcon },
    })], 1)], 1);
  }; var i = [];
}, function (e, t) { e.exports = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxvZ28iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDggNTQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwOCA1NDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtlbmFibGUtYmFja2dyb3VuZDpuZXcgICAgO30KPC9zdHlsZT4KPGcgY2xhc3M9InN0MCI+Cgk8cGF0aCBkPSJNMTUuMywxMy40TDI2LjUsNDJoLTIuOWwtMy41LTguOWgtMTNMMy43LDQySDAuOGwxMS41LTI4LjZIMTUuM3ogTTE5LjIsMzAuOGwtNS41LTE0LjZMOCwzMC44SDE5LjJ6Ii8+Cgk8cGF0aCBkPSJNMzEuMSwyMS40VjI1aDAuMWMwLjUtMS4zLDEuMy0yLjMsMi42LTNjMS4yLTAuOCwyLjYtMS4xLDQtMS4xczIuNiwwLjIsMy42LDAuNmMxLDAuNCwxLjgsMC45LDIuMywxLjYKCQljMC42LDAuNywxLDEuNSwxLjIsMi41czAuNCwyLjEsMC40LDMuM1Y0MmgtMi41VjI5LjFjMC0wLjktMC4xLTEuNy0wLjItMi41Yy0wLjItMC44LTAuNC0xLjQtMC44LTJjLTAuNC0wLjYtMC45LTEtMS42LTEuMwoJCWMtMC43LTAuMy0xLjUtMC41LTIuNS0wLjVTMzUuOCwyMywzNSwyMy4zYy0wLjgsMC40LTEuNSwwLjktMiwxLjVzLTEsMS40LTEuMywyLjJjLTAuMywwLjktMC41LDEuOC0wLjUsMi44djEyaC0yLjVWMjEuMmgyLjRWMjEuNAoJCXoiLz4KCTxwYXRoIGQ9Ik01Mi42LDEzLjR2NGgtMi41di00SDUyLjZ6IE01Mi42LDIxLjRWNDJoLTIuNVYyMS40SDUyLjZ6Ii8+Cgk8cGF0aCBkPSJNNTkuOCwyMS40djMuNWgwLjFjMC43LTEuMywxLjUtMi4zLDIuNi0zczIuNS0xLjEsNC4xLTEuMWMxLjQsMCwyLjYsMC4zLDMuNywxYzEuMSwwLjcsMS44LDEuNywyLjIsMwoJCWMwLjYtMS40LDEuNS0yLjQsMi43LTNjMS4yLTAuNywyLjUtMSwzLjgtMWM0LjYsMCw2LjgsMi40LDYuOCw3LjJ2MTRoLTIuNVYyOC4xYzAtMS43LTAuNC0zLTEuMS0zLjljLTAuNy0wLjktMi0xLjMtMy44LTEuMwoJCWMtMS4xLDAtMiwwLjItMi43LDAuNmMtMC43LDAuNC0xLjMsMS0xLjcsMS43cy0wLjcsMS41LTAuOSwyLjRzLTAuMywxLjgtMC4zLDIuOFY0MmgtMi41VjI4YzAtMC43LTAuMS0xLjQtMC4yLTIKCQljLTAuMS0wLjYtMC40LTEuMi0wLjctMS42Yy0wLjMtMC41LTAuOC0wLjgtMS4zLTEuMXMtMS4yLTAuNC0yLTAuNGMtMS4xLDAtMiwwLjItMi44LDAuNmMtMC44LDAuNC0xLjQsMC45LTEuOSwxLjYKCQljLTAuNSwwLjctMC45LDEuNS0xLjEsMi40Yy0wLjIsMC45LTAuNCwxLjktMC40LDNWNDJoLTIuNVYyMS40SDU5Ljh6Ii8+Cgk8cGF0aCBkPSJNOTIuNywzNS4yYzAuMywxLDAuNywxLjgsMS4yLDIuNmMwLjYsMC44LDEuMywxLjQsMi4xLDEuOWMwLjksMC41LDEuOSwwLjgsMy4xLDAuOGMxLjgsMCwzLjMtMC41LDQuMy0xLjRzMS44LTIuMiwyLjItMy44CgkJaDIuNWMtMC41LDIuMy0xLjUsNC4yLTIuOSw1LjRjLTEuNCwxLjMtMy40LDEuOS02LjEsMS45Yy0xLjYsMC0zLTAuMy00LjItMC45Yy0xLjItMC42LTIuMi0xLjQtMi45LTIuNHMtMS4zLTIuMi0xLjctMy41CgkJcy0wLjUtMi43LTAuNS00LjJjMC0xLjQsMC4yLTIuNywwLjUtNGMwLjQtMS4zLDAuOS0yLjUsMS43LTMuNWMwLjctMSwxLjctMS45LDIuOS0yLjVzMi42LTAuOSw0LjItMC45YzEuNywwLDMuMSwwLjMsNC4yLDEKCQljMS4yLDAuNywyLjEsMS41LDIuOSwyLjZjMC43LDEuMSwxLjMsMi4zLDEuNiwzLjdzMC41LDIuOCwwLjQsNC4zSDkyLjNDOTIuMywzMy4zLDkyLjQsMzQuMiw5Mi43LDM1LjJ6IE0xMDUuMSwyNy41CgkJYy0wLjMtMC45LTAuNy0xLjctMS4zLTIuM2MtMC42LTAuNy0xLjItMS4yLTItMS42Yy0wLjgtMC40LTEuNy0wLjYtMi43LTAuNnMtMiwwLjItMi44LDAuNmMtMC44LDAuNC0xLjUsMS0yLDEuNgoJCWMtMC42LDAuNy0xLDEuNS0xLjMsMi40cy0wLjYsMS44LTAuNywyLjdoMTMuNEMxMDUuNiwyOS4zLDEwNS40LDI4LjQsMTA1LjEsMjcuNXoiLz4KPC9nPgo8ZyBjbGFzcz0ic3QwIj4KCTxwYXRoIGQ9Ik0xMTYsMTQuMmg0Ljl2MjMuNmgxNC4yVjQyaC0xOUwxMTYsMTQuMkwxMTYsMTQuMnoiLz4KCTxwYXRoIGQ9Ik0xNDcsNDIuNWMtMS42LDAtMy0wLjMtNC4zLTAuOHMtMi4zLTEuMy0zLjItMi4ycy0xLjUtMi4xLTItMy40Yy0wLjUtMS4zLTAuNy0yLjctMC43LTQuM2MwLTEuNSwwLjItMywwLjctNC4zCgkJczEuMS0yLjQsMi0zLjRjMC45LTAuOSwxLjktMS43LDMuMi0yLjJzMi43LTAuOCw0LjMtMC44czMsMC4zLDQuMywwLjhzMi4zLDEuMywzLjIsMi4yczEuNSwyLjEsMiwzLjRzMC43LDIuNywwLjcsNC4zCgkJcy0wLjIsMy0wLjcsNC4zcy0xLjEsMi40LTIsMy40cy0xLjksMS43LTMuMiwyLjJDMTUwLDQyLjMsMTQ4LjYsNDIuNSwxNDcsNDIuNXogTTE0NywzOWMxLDAsMS44LTAuMiwyLjYtMC42CgkJYzAuNy0wLjQsMS4zLTEsMS44LTEuNnMwLjgtMS40LDEtMi4zYzAuMi0wLjgsMC4zLTEuNywwLjMtMi42YzAtMC45LTAuMS0xLjctMC4zLTIuNmMtMC4yLTAuOS0wLjYtMS42LTEtMi4zCgkJYy0wLjUtMC43LTEuMS0xLjItMS44LTEuNmMtMC43LTAuNC0xLjYtMC42LTIuNi0wLjZzLTEuOCwwLjItMi42LDAuNmMtMC43LDAuNC0xLjMsMS0xLjgsMS42Yy0wLjUsMC43LTAuOCwxLjQtMSwyLjMKCQljLTAuMiwwLjktMC4zLDEuNy0wLjMsMi42YzAsMC45LDAuMSwxLjcsMC4zLDIuNmMwLjIsMC44LDAuNiwxLjYsMSwyLjNzMS4xLDEuMiwxLjgsMS42UzE0NiwzOSwxNDcsMzl6Ii8+Cgk8cGF0aCBkPSJNMTcwLjEsNDIuNWMtMS42LDAtMy0wLjMtNC4zLTAuOHMtMi4zLTEuMy0zLjItMi4ycy0xLjUtMi4xLTItMy40Yy0wLjUtMS4zLTAuNy0yLjctMC43LTQuM2MwLTEuNSwwLjItMywwLjctNC4zCgkJczEuMS0yLjQsMi0zLjRjMC45LTAuOSwxLjktMS43LDMuMi0yLjJzMi43LTAuOCw0LjMtMC44czMsMC4zLDQuMywwLjhzMi4zLDEuMywzLjIsMi4yczEuNSwyLjEsMiwzLjRzMC43LDIuNywwLjcsNC4zCgkJcy0wLjIsMy0wLjcsNC4zcy0xLjEsMi40LTIsMy40cy0xLjksMS43LTMuMiwyLjJDMTczLjEsNDIuMywxNzEuNyw0Mi41LDE3MC4xLDQyLjV6IE0xNzAuMSwzOWMxLDAsMS44LTAuMiwyLjYtMC42CgkJYzAuNy0wLjQsMS4zLTEsMS44LTEuNmMwLjUtMC43LDAuOC0xLjQsMS0yLjNjMC4yLTAuOCwwLjMtMS43LDAuMy0yLjZjMC0wLjktMC4xLTEuNy0wLjMtMi42Yy0wLjItMC45LTAuNi0xLjYtMS0yLjMKCQljLTAuNS0wLjctMS4xLTEuMi0xLjgtMS42Yy0wLjctMC40LTEuNi0wLjYtMi42LTAuNnMtMS44LDAuMi0yLjYsMC42Yy0wLjcsMC40LTEuMywxLTEuOCwxLjZjLTAuNSwwLjctMC44LDEuNC0xLDIuMwoJCWMtMC4yLDAuOS0wLjMsMS43LTAuMywyLjZjMCwwLjksMC4xLDEuNywwLjMsMi42YzAuMiwwLjgsMC42LDEuNiwxLDIuM2MwLjUsMC43LDEuMSwxLjIsMS44LDEuNlMxNjkuMSwzOSwxNzAuMSwzOXoiLz4KCTxwYXRoIGQ9Ik0xODQuMSwyMS44aDQuMnYyLjdoMC4xYzAuNi0xLjIsMS41LTIsMi42LTIuNXMyLjMtMC44LDMuNi0wLjhjMS42LDAsMywwLjMsNC4yLDAuOGMxLjIsMC42LDIuMiwxLjMsMi45LDIuMwoJCWMwLjgsMSwxLjQsMi4xLDEuOCwzLjRjMC40LDEuMywwLjYsMi43LDAuNiw0LjJjMCwxLjQtMC4yLDIuNy0wLjUsMy45Yy0wLjQsMS4zLTAuOSwyLjQtMS42LDMuNGMtMC43LDEtMS42LDEuOC0yLjcsMi4zCgkJYy0xLjEsMC42LTIuNCwwLjktMy45LDAuOWMtMC43LDAtMS4zLTAuMS0yLTAuMmMtMC42LTAuMS0xLjMtMC4zLTEuOS0wLjZjLTAuNi0wLjMtMS4yLTAuNi0xLjctMXMtMC45LTAuOS0xLjMtMS40aC0wLjF2MTAuMUgxODQKCQlMMTg0LjEsMjEuOEwxODQuMSwyMS44eiBNMTk5LjYsMzEuOWMwLTAuOS0wLjEtMS44LTAuNC0yLjdjLTAuMi0wLjktMC42LTEuNi0xLjEtMi4zcy0xLjEtMS4yLTEuOC0xLjZjLTAuNy0wLjQtMS41LTAuNi0yLjQtMC42CgkJYy0xLjksMC0zLjMsMC43LTQuMiwycy0xLjQsMy0xLjQsNS4yYzAsMSwwLjEsMiwwLjQsMi44czAuNiwxLjYsMS4xLDIuMnMxLjEsMS4xLDEuOCwxLjVzMS41LDAuNSwyLjQsMC41YzEsMCwxLjktMC4yLDIuNi0wLjYKCQljMC43LTAuNCwxLjMtMSwxLjctMS42YzAuNS0wLjcsMC44LTEuNCwxLTIuM0MxOTkuNSwzMy43LDE5OS42LDMyLjgsMTk5LjYsMzEuOXoiLz4KPC9nPgo8L3N2Zz4K' }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('nav', { staticClass: 'Navbar z-10', style: e.toggleContainerStyle }, [r('NavbarBurgerMenu'), e._v(' '), e.navStates.searchOpen ? e._e() : r('NavbarTitle'), e._v(' '), r('NavbarEntry'), e._v(' '), r('NavbarSearch'), e._v(' '), e.navStates.searchOpen ? e._e() : r('NavbarLangMenu'), e._v(' '), r('div', { staticClass: 'Navbar-lineBreak' })], 1) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'The Navbar component.', methods: [], displayName: 'Navbar', props: void 0, comment: '/**\n * The Navbar component.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Language Menu of the Navbar.', methods: [], displayName: 'NavbarLangMenu', props: void 0, comment: '/**\n * Language Menu of the Navbar.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Burger Menu of the Navbar. Enabled in Mobile(phone) layout only.', methods: [], displayName: 'NavbarBurgerMenu', props: void 0, comment: '/**\n * Burger Menu of the Navbar. Enabled in Mobile(phone) layout only.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Search Bar of the Navbar.', methods: [], displayName: 'NavbarSearch', props: void 0, comment: '/**\n * Search Bar of the Navbar.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Title on the Navbar.', methods: [], displayName: 'NavbarTitle', props: void 0, comment: '/**\n * Title on the Navbar.\n */', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) { let n = r(630); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('d6106ed6', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.SeriesCover[data-v-5be6b1a4]{width:180px;height:280px;-webkit-box-shadow:0 1px 5px 0 rgba(0,0,0,.15);box-shadow:0 1px 5px 0 rgba(0,0,0,.15);border-radius:3px;margin:auto}.SeriesCover-link[data-v-5be6b1a4]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;background-size:cover;background-position:50% 50%;border-radius:3px}.SeriesCover-title[data-v-5be6b1a4]{font-size:1em;font-weight:500;color:#fff;padding:1em 0;text-align:center}.SeriesCover-text[data-v-5be6b1a4]{background:-webkit-gradient(linear,left bottom,left top,from(rgba(0,0,0,.8)),color-stop(40%,rgba(0,0,0,.6)),to(transparent));background:linear-gradient(0deg,rgba(0,0,0,.8),rgba(0,0,0,.6) 40%,transparent);border-radius:0 0 3px 3px;z-index:2;height:auto;width:100%;padding:4em 1em 1em;text-align:left}.SeriesCover-detail[data-v-5be6b1a4]{display:-webkit-box;display:-ms-flexbox;display:flex;text-align:center;font-size:1em;font-weight:500;color:#add8e6}.SeriesCover-type[data-v-5be6b1a4]{width:50%}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('section', { staticClass: 'SeriesCover' }, [r('nuxt-link', { staticClass: 'SeriesCover-link', style: e.coverBackgroundImageStyle, attrs: { to: { name: 'series-id', params: { id: e.seriesid } } } }, [r('div', { staticClass: 'SeriesCover-text' }, [r('div', { staticClass: 'SeriesCover-title' }, [e._v(e._s(e.i18nTitle))]), e._v(' '), r('div', { staticClass: 'SeriesCover-detail' }, [r('span', { staticClass: 'SeriesCover-type' }, [e._v(e._s(e.series.type))]), e._v(' '), r('span', { staticClass: 'SeriesCover-type' }, [e._v(e._s(e.series.season))])])])])], 1) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Cover component. Wrapping Series Key visual with an overlay displaying title and aired date.',
    methods: [],
    displayName: 'SeriesCover',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * `seriesid` of current Series.\n     */', description: '`seriesid` of current Series.', name: 'seriesid',
    }],
    comment: '/**\n * Cover component. Wrapping Series Key visual with an overlay displaying title and aired date.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(634); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('e9b75cde', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.SeriesGenres[data-v-35f739b0]{color:#444;font-style:italic;font-size:.9em}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'SeriesGenres' }, [e._l(e.genres, (t, n) => (t ? [r('span', { key: n }, n === 0 ? [e._v(`\n      ${e._s(t)}\n    `)] : [e._v(`\n      / ${e._s(t)}\n    `)])] : e._e()))], 2) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Iterates and displays genres from array.',
    methods: [],
    displayName: 'SeriesGenres',
    props: [{
      type: { name: 'array' }, required: !0, defaultValue: { value: "() => ['Unknown Genre']", func: !0 }, tags: {}, comment: '/**\n     * The array containing genres.\n     */', description: 'The array containing genres.', name: 'genres',
    }],
    comment: '/**\n * Iterates and displays genres from array.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(638); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('ec43e066', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.SeriesGrid[data-v-d0d485ea]{display:grid;grid-template-columns:repeat(auto-fill,180px);grid-gap:1em;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin:1em 0}@media (max-width:640px){.SeriesGrid[data-v-d0d485ea]{grid-gap:.75em;margin:1em auto}}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'SeriesGrid' }, [e.type === 'listPage' ? e._l(e.seriesList, e => r('SeriesCover', { key: e.id, attrs: { seriesid: e.id } })) : e._e(), e._v(' '), e.type === 'search' ? e._l(e.seriesList, e => r('SeriesCover', { key: e, attrs: { seriesid: e } })) : e._e()], 2) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Grid containing `SeriesCover`. Used by `SeriesPage` and `SearchPage`.',
    methods: [],
    displayName: 'SeriesGrid',
    props: [{
      type: { name: 'string' }, required: !0, defaultValue: { value: '"list"', func: !1 }, tags: {}, comment: '/**\n     * Type of page that this component is used in.\n     *\n     * `listPage, search`\n     */', description: 'Type of page that this component is used in.\n\n`listPage, search`', name: 'type',
    }],
    comment: '/**\n * Grid containing `SeriesCover`. Used by `SeriesPage` and `SearchPage`.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) { let n = r(642); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('b1725080', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.SeriesPage[data-v-1eb4bb55]{margin:0 -1em}@media (min-width:641px) and (max-width:820px){@supports (padding:min(0px)){.SeriesPage[data-v-1eb4bb55]{margin-left:-3em;margin-right:-3em}}}@media (max-width:640px){.SeriesPage[data-v-1eb4bb55]{margin:0}}.SeriesPage-upperGrid[data-v-1eb4bb55]{z-index:1;margin-top:-1em;display:grid;grid-template-columns:230px auto;grid-template-rows:auto;grid-gap:.5em 2em;grid-template-areas:"series-cover series-page-info" "series-cover episode-selector";padding:1em 1em 0;background-image:-webkit-gradient(linear,left bottom,left top,from(hsla(0,0%,100%,0)),color-stop(50%,hsla(0,0%,100%,.4)),to(hsla(0,0%,100%,.8)));background-image:linear-gradient(0deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.4) 50%,hsla(0,0%,100%,.8))}@media (min-width:641px) and (max-width:820px){@supports (padding:min(0px)){.SeriesPage-upperGrid[data-v-1eb4bb55]{padding:1em 3em 0}}}@media (max-width:640px){.SeriesPage-upperGrid[data-v-1eb4bb55]{grid-template-columns:auto;grid-template-rows:auto;grid-template-areas:"series-cover" "series-page-info" "episode-selector"}}.SeriesPage-upperHalfCover[data-v-1eb4bb55]{position:absolute;top:4em;z-index:-1;background-size:cover;background-repeat:no-repeat;background-position:top;filter:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="60" /></filter></svg>#filter\');-webkit-filter:blur(60px);filter:blur(60px);width:calc(100vw - 1em);height:40vh}.SeriesPage-cover[data-v-1eb4bb55]{grid-area:series-cover;justify-self:center}.SeriesPage-cover>a>img[data-v-1eb4bb55]{border-radius:3px}.SeriesPage-info[data-v-1eb4bb55]{grid-area:series-page-info}.SeriesPage-episodeSelector[data-v-1eb4bb55]{grid-area:episode-selector}.SeriesPage-episodeSelect[data-v-1eb4bb55]{display:inline-block;position:relative}.SeriesPage-episodeSelect>select[data-v-1eb4bb55]{display:block;position:relative;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border-radius:5px;-webkit-box-shadow:0 1px 5px 0 rgba(0,0,0,.15);box-shadow:0 1px 5px 0 rgba(0,0,0,.15);padding:.2em .5em;width:10em;max-width:100%;height:2.25em;background-color:hsla(0,0%,100%,.6);color:#000;font-size:1em;cursor:pointer}.SeriesPage-episodeSelect>select[data-v-1eb4bb55]:invalid{color:#8e8e8e}.SeriesPage-episodeSelect[data-v-1eb4bb55]:after{z-index:1;display:block;content:" ";position:absolute;width:.5em;height:.5em;margin-top:-.375em;right:.625em;top:50%;border:1px solid #444;border-right:0;border-top:0;pointer-events:none;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:center;transform-origin:center}.SeriesPage-lowerGrid[data-v-1eb4bb55]{z-index:2;margin-top:1em}.SeriesPage-lowerGrid>p[data-v-1eb4bb55]{text-align:center;font-size:2em}.SeriesPage-faIcon[data-v-1eb4bb55]{color:#333}', '']) }, function (e, t, r) { let n = r(644); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('1b9bc73e', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.SeriesInfo[data-v-3cdb4c40]{display:grid;grid-template-columns:auto;grid-template-rows:minmax(2em,auto) minmax(1em,auto) auto;grid-gap:0;grid-template-areas:"series-title" "series-genres-season" "series-description";-ms-flex-line-pack:start;align-content:start}.SeriesInfo-seasonWithGenres[data-v-3cdb4c40]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media (max-width:640px){.SeriesInfo-seasonWithGenres[data-v-3cdb4c40]{margin:.4em 0}}.SeriesInfo-genres[data-v-3cdb4c40]{-webkit-box-flex:0;-ms-flex:0 1 100%;flex:0 1 100%;margin:.25em 0 0}@media (max-width:640px){.SeriesInfo-genres[data-v-3cdb4c40]{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;margin:.25em 0 .25em .25em;-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}.SeriesInfo-season[data-v-3cdb4c40]{margin:.4em 0}@media (max-width:640px){.SeriesInfo-season[data-v-3cdb4c40]{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;margin:0 .25em 0 0}}.SeriesInfo-title[data-v-3cdb4c40]{grid-area:series-title;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline}.SeriesInfo-title--main[data-v-3cdb4c40]{font-size:2em;font-weight:600}.SeriesInfo-title--alt[data-v-3cdb4c40]{font-size:1em;font-weight:400;color:#666}.SeriesInfo-description[data-v-3cdb4c40]{grid-area:series-description;-ms-flex-item-align:start;align-self:start;color:#333;font-size:.9em;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'SeriesInfo' }, [r('div', { staticClass: 'SeriesInfo-title' }, [r('span', { staticClass: 'SeriesInfo-title--main' }, [e._v(`${e._s(e.i18nTitle)}`)]), e._v(' '), e.currentLocale !== 'ja' ? r('span', { staticClass: 'SeriesInfo-title--alt' }, [e._v(e._s(e.series.titleJA))]) : e._e()]), e._v(' '), r('div', { staticClass: 'SeriesInfo-seasonWithGenres' }, [r('Genres', { staticClass: 'SeriesInfo-genres', attrs: { genres: e.series.genres } }), e._v(' '), r('TypeTag', { staticClass: 'SeriesInfo-season', attrs: { 'anime-type': e.series.type, season: e.series.season, type: 'withSeason' } })], 1), e._v(' '), r('p', { staticClass: 'SeriesInfo-description', domProps: { innerHTML: e._s(e.series.description) } })]) }; var i = [];
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('section', { staticClass: 'SeriesPage' }, [r('div', { staticClass: 'SeriesPage-upperHalfCover', style: e.upperHalfBackgroundImage }), e._v(' '), r('div', { staticClass: 'SeriesPage-upperGrid' }, [r('div', { staticClass: 'SeriesPage-cover' }, [r('nuxt-link', { attrs: { to: { name: 'series-id', params: { id: e.seriesid } } } }, [r('img', { attrs: { src: e.series.image_url_large, alt: 'Cover Art' } })])], 1), e._v(' '), r('Info', { staticClass: 'SeriesPage-info', attrs: { seriesid: e.currentSeriesID } }), e._v(' '), e.episodeList ? r('div', { staticClass: 'SeriesPage-episodeSelector' }, [r('div', { staticClass: 'SeriesPage-episodeSelect' }, [r('select', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.selectedEpisodeID, expression: 'selectedEpisodeID',
      }],
      attrs: { required: '' },
      on: { change: [function (t) { const r = Array.prototype.filter.call(t.target.options, e => e.selected).map(e => ('_value' in e ? e._value : e.value)); e.selectedEpisodeID = t.target.multiple ? r : r[0] }, e.selectChanged] },
    }, [r('option', { attrs: { disabled: '', selected: '', value: '' } }, [e._v('Select Episode...')]), e._v(' '), e._l(e.episodeList, t => r('option', { key: t.no, domProps: { value: t.id } }, [e._v(`\n            ${e._s(t.no)}\n          `)]))], 2)])]) : r('div', [r('p', [r('FontAwesomeIcon', { staticClass: 'SeriesPage-faIcon', attrs: { icon: 'circle-notch', spin: '' } })], 1)])], 1), e._v(' '), e.$route.name === 'episode-id' ? r('div', { staticClass: 'SeriesPage-lowerGrid' }, [e.loops ? r('div', [r('LoopGrid', { attrs: { episodeid: e.selectedEpisodeID, 'page-type': 'episode' } })], 1) : r('p', [r('FontAwesomeIcon', { staticClass: 'SeriesPage-faIcon', attrs: { icon: 'circle-notch', spin: '' } })], 1)]) : e._e()]);
  }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'View component of `SeriesPage`.',
    methods: [],
    displayName: 'SeriesPageView',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * `seriesid` of current Series.\n     */', description: '`seriesid` of current Series.', name: 'seriesid',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '""', func: !1 }, tags: {}, comment: '/**\n     * `episodeid` of current Episode.\n     */', description: '`episodeid` of current Episode.', name: 'episodeid',
    }, {
      type: { name: 'string' }, required: '', defaultValue: { value: '""', func: !1 }, tags: {}, comment: '/**\n     * The number of episode in current Series.\n     */', description: 'The number of episode in current Series.', name: 'episodeno',
    }],
    comment: '/**\n * View component of `SeriesPage`.\n */',
    tags: {},
    events: {
      selectChanged: {
        description: 'When episode selection menu changed, navigate to selected `EpisodePage`.', type: { names: ['function'] }, properties: void 0, comment: '/**\n     * When episode selection menu changed, navigate to selected `EpisodePage`.\n     *\n     * @event selectChanged\n     * @type {Function}\n     */',
      },
    },
    slots: {},
    examples: [],
  };
}, function (e, t, r) {
  e.exports = {
    description: 'Anime Series Info for current Series, part of `SeriesPage`.',
    methods: [],
    displayName: 'SeriesInfo',
    props: [{
      type: { name: 'string' }, required: !0, tags: {}, comment: '/**\n     * `seriesid` of current Series.\n     */', description: '`seriesid` of current Series.', name: 'seriesid',
    }],
    comment: '/**\n * Anime Series Info for current Series, part of `SeriesPage`.\n */',
    tags: {},
    events: {},
    slots: {},
    examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(195); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(652); const s = r(3); const u = function injectStyle(e) { r(650) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, null, null); t.default = l.exports;
}, function (e, t, r) { let n = r(651); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('14931d05', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.nuxt-progress{position:fixed;top:3em;left:0;right:0;height:2px;width:0;-webkit-transition:width .2s,opacity .4s;transition:width .2s,opacity .4s;opacity:1;background-color:#efc14e;z-index:999999}@media (min-width:641px) and (max-width:820px){.nuxt-progress{top:6em}}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this.$createElement; return (this._self._c || e)('div', {
      staticClass: 'nuxt-progress',
      style: {
        width: `${this.percent}%`, height: this.height, 'background-color': this.canSuccess ? this.color : this.failedColor, opacity: this.show ? 1 : 0,
      },
    });
  }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: 'Loading bar provided by Nuxt, with customized color and position.', methods: [], displayName: 'NuxtLoading', props: void 0, comment: '/**\n * Loading bar provided by Nuxt, with customized color and position.\n * @see See [Nuxt Loading Property](https://nuxtjs.org/api/configuration-loading/)\n * @see See [Nuxt: nuxt-loading.vue](https://github.com/nuxt/nuxt.js/blob/master/lib/app/components/nuxt-loading.vue)\n */', tags: { see: [{ title: 'see', description: 'See [Nuxt Loading Property](https://nuxtjs.org/api/configuration-loading/)' }, { title: 'see', description: 'See [Nuxt: nuxt-loading.vue](https://github.com/nuxt/nuxt.js/blob/master/lib/app/components/nuxt-loading.vue)' }] }, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(196); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(657); const s = r(3); const u = function injectStyle(e) { r(655) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-571801bc', null); t.default = l.exports;
}, function (e, t, r) { let n = r(656); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('ddb07cb2', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '.AboutPage[data-v-571801bc]{padding:0 1em;margin-left:auto;margin-right:auto;max-width:50em}.AboutPage>p[data-v-571801bc]{margin:1em 0;color:#333}.AboutPage a[data-v-571801bc]{color:#4169e1;font-weight:500}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; this._self._c; return this._m(0) }; var i = [function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'AboutPage' }, [r('h1', [e._v('Animeloop Beta')]), e._v(' '), r('p', [r('a', { attrs: { href: 'https://github.com/OrcaXS/animeloop-web-nuxt' } }, [e._v('Animeloop-web-nuxt')]), e._v(' is an open-source web app built with '), r('a', { attrs: { href: 'https://nuxtjs.org' } }, [e._v('Nuxt.js')]), e._v(', aims to provide better experience than the original Animeloop-server. '), r('br'), e._v(' Currently serves as Animeloop Beta.\n  ')]), e._v(' '), r('p', [e._v('\n    Animeloop belongs to '), r('a', { attrs: { href: 'https://moeoverflow.org/' } }, [e._v('MOEOVERFLOW')]), e._v(' organization, the main goal is to collect some interesting loop fragments in Japanese anime video. All of the content of the site is generated by '), r('a', { attrs: { href: 'https://github.com/moeoverflow/animeloop-cli' } }, [e._v('animeloop-cli')]), e._v('. As you can see, the fragments that are currently generated are not much ideal, and the algorithms are constantly being slowly optimized.\n  ')]), e._v(' '), r('p', [e._v('\n    This site has a set of automated procedures (automator) in the background server running at day and night, the speed for generating new content is about two season anime per one day.\n  ')]), e._v(' '), r('p', [e._v('\n    Currrently the new content source to generate provided by administrator manually, and in the future, the source will be added by automator from dmhy.org etc with a full Automator.\n  ')]), e._v(' '), r('p', [e._v('\n    Site development plan, at this stage, the main focus on the development of server automation, the goal is high stability in the automatic operation.\n  ')]), e._v(' '), r('p', [e._v('\n    In addition, special thanks to '), r('a', { attrs: { href: 'https://whatanime.ga/' } }, [e._v('whatanime.ga')]), e._v(' provided by the animation screenshot recognition service support. Thanks to '), r('a', { attrs: { href: 'https://twitter.com/democyann' } }, [e._v('')]), e._v(' for Japanese translation, '), r('a', { attrs: { href: 'https://src.moe/' } }, [e._v('POJO')]), e._v(' for French translation.\n  ')])]) }];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'About', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(197); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(660); const s = r(3); const u = Object(s.a)(i.a, o.a, o.b, !1, null, null, null); t.default = u.exports;
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; this._self._c; return this._m(0) }; var i = [function () { const e = this.$createElement; const t = this._self._c || e; return t('div', [t('h1', [this._v('API')])]) }];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'APIStatus', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(198); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(683); const s = r(3); const u = function injectStyle(e) { r(663) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-4e479b5e', null); t.default = l.exports;
}, function (e, t, r) { let n = r(664); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('72220ba0', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '', '']) }, function (e, t, r) { const n = (function () { return this }()) || Function('return this')(); const i = n.regeneratorRuntime && Object.getOwnPropertyNames(n).indexOf('regeneratorRuntime') >= 0; const a = i && n.regeneratorRuntime; if (n.regeneratorRuntime = void 0, e.exports = r(666), i)n.regeneratorRuntime = a; else try { delete n.regeneratorRuntime } catch (e) { n.regeneratorRuntime = void 0 } }, function (e, t) {
  !(function (t) {
    let r; const n = Object.prototype; const i = n.hasOwnProperty; const a = typeof Symbol === 'function' ? Symbol : {}; const o = a.iterator || '@@iterator'; const s = a.asyncIterator || '@@asyncIterator'; const u = a.toStringTag || '@@toStringTag'; const l = typeof e === 'object'; let c = t.regeneratorRuntime; if (c)l && (e.exports = c); else {
      (c = t.regeneratorRuntime = l ? e.exports : {}).wrap = wrap; var p = 'suspendedStart'; var f = 'suspendedYield'; var d = 'executing'; var h = 'completed'; var m = {}; let g = {}; g[o] = function () { return this }; const v = Object.getPrototypeOf; const y = v && v(v(values([]))); y && y !== n && i.call(y, o) && (g = y); const b = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(g); GeneratorFunction.prototype = b.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[u] = GeneratorFunction.displayName = 'GeneratorFunction', c.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === GeneratorFunction || (t.displayName || t.name) === 'GeneratorFunction') }, c.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, u in e || (e[u] = 'GeneratorFunction')), e.prototype = Object.create(b), e }, c.awrap = function (e) { return { __await: e } }, defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[s] = function () { return this }, c.AsyncIterator = AsyncIterator, c.async = function (e, t, r, n) { const i = new AsyncIterator(wrap(e, t, r, n)); return c.isGeneratorFunction(t) ? i : i.next().then(e => (e.done ? e.value : i.next())) }, defineIteratorMethods(b), b[u] = 'Generator', b[o] = function () { return this }, b.toString = function () { return '[object Generator]' }, c.keys = function (e) { const t = []; for (const r in e)t.push(r); return t.reverse(), function next() { for (;t.length;) { const r = t.pop(); if (r in e) return next.value = r, next.done = !1, next; } return next.done = !0, next } }, c.values = values, Context.prototype = {
        constructor: Context, reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = 'next', this.arg = r, this.tryEntries.forEach(resetTryEntry), !e) for (const t in this)t.charAt(0) === 't' && i.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = r); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval }, dispatchException(e) { if (this.done) throw e; const t = this; function handle(n, i) { return o.type = 'throw', o.arg = e, t.next = n, i && (t.method = 'next', t.arg = r), !!i } for (let n = this.tryEntries.length - 1; n >= 0; --n) { const a = this.tryEntries[n]; var o = a.completion; if (a.tryLoc === 'root') return handle('end'); if (a.tryLoc <= this.prev) { const s = i.call(a, 'catchLoc'); const u = i.call(a, 'finallyLoc'); if (s && u) { if (this.prev < a.catchLoc) return handle(a.catchLoc, !0); if (this.prev < a.finallyLoc) return handle(a.finallyLoc); } else if (s) { if (this.prev < a.catchLoc) return handle(a.catchLoc, !0); } else { if (!u) throw new Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return handle(a.finallyLoc); } } } }, abrupt(e, t) { for (let r = this.tryEntries.length - 1; r >= 0; --r) { const n = this.tryEntries[r]; if (n.tryLoc <= this.prev && i.call(n, 'finallyLoc') && this.prev < n.finallyLoc) { var a = n; break } }a && (e === 'break' || e === 'continue') && a.tryLoc <= t && t <= a.finallyLoc && (a = null); const o = a ? a.completion : {}; return o.type = e, o.arg = t, a ? (this.method = 'next', this.next = a.finallyLoc, m) : this.complete(o) }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), m }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const r = this.tryEntries[t]; if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), m; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const r = this.tryEntries[t]; if (r.tryLoc === e) { const n = r.completion; if (n.type === 'throw') { var i = n.arg; resetTryEntry(r) } return i } } throw new Error('illegal catch attempt') }, delegateYield(e, t, n) { return this.delegate = { iterator: values(e), resultName: t, nextLoc: n }, this.method === 'next' && (this.arg = r), m },
      };
    } function wrap(e, t, r, n) { const i = t && t.prototype instanceof Generator ? t : Generator; const a = Object.create(i.prototype); const o = new Context(n || []); return a._invoke = (function makeInvokeMethod(e, t, r) { let n = p; return function invoke(i, a) { if (n === d) throw new Error('Generator is already running'); if (n === h) { if (i === 'throw') throw a; return doneResult() } for (r.method = i, r.arg = a; ;) { const o = r.delegate; if (o) { const s = maybeInvokeDelegate(o, r); if (s) { if (s === m) continue; return s } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (n === p) throw n = h, r.arg; r.dispatchException(r.arg) } else r.method === 'return' && r.abrupt('return', r.arg); n = d; const u = tryCatch(e, t, r); if (u.type === 'normal') { if (n = r.done ? h : f, u.arg === m) continue; return { value: u.arg, done: r.done } }u.type === 'throw' && (n = h, r.method = 'throw', r.arg = u.arg) } } }(e, r, o)), a } function tryCatch(e, t, r) { try { return { type: 'normal', arg: e.call(t, r) } } catch (e) { return { type: 'throw', arg: e } } } function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} function defineIteratorMethods(e) { ['next', 'throw', 'return'].forEach((t) => { e[t] = function (e) { return this._invoke(t, e) } }) } function AsyncIterator(e) { let t; this._invoke = function enqueue(r, n) { function callInvokeWithMethodAndArg() { return new Promise(((t, a) => { !(function invoke(t, r, n, a) { const o = tryCatch(e[t], e, r); if (o.type !== 'throw') { const s = o.arg; const u = s.value; return u && typeof u === 'object' && i.call(u, '__await') ? Promise.resolve(u.__await).then((e) => { invoke('next', e, n, a) }, (e) => { invoke('throw', e, n, a) }) : Promise.resolve(u).then((e) => { s.value = e, n(s) }, a) }a(o.arg) }(r, n, t, a)) })) } return t = t ? t.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg() } } function maybeInvokeDelegate(e, t) { const n = e.iterator[t.method]; if (n === r) { if (t.delegate = null, t.method === 'throw') { if (e.iterator.return && (t.method = 'return', t.arg = r, maybeInvokeDelegate(e, t), t.method === 'throw')) return m; t.method = 'throw', t.arg = new TypeError("The iterator does not provide a 'throw' method") } return m } const i = tryCatch(n, e.iterator, t.arg); if (i.type === 'throw') return t.method = 'throw', t.arg = i.arg, t.delegate = null, m; const a = i.arg; return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, t.method !== 'return' && (t.method = 'next', t.arg = r), t.delegate = null, m) : a : (t.method = 'throw', t.arg = new TypeError('iterator result is not an object'), t.delegate = null, m) } function pushTryEntry(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t) } function resetTryEntry(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t } function Context(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(pushTryEntry, this), this.reset(!0) } function values(e) { if (e) { const t = e[o]; if (t) return t.call(e); if (typeof e.next === 'function') return e; if (!isNaN(e.length)) { let n = -1; const a = function next() { for (;++n < e.length;) if (i.call(e, n)) return next.value = e[n], next.done = !1, next; return next.value = r, next.done = !0, next }; return a.next = a } } return { next: doneResult } } function doneResult() { return { value: r, done: !0 } }
  }((function () { return this }()) || Function('return this')()));
}, function (e, t, r) { r(200), r(107), r(206), r(678), r(681), r(682), e.exports = r(7).Promise }, function (e, t, r) { const n = r(108); const i = r(109); e.exports = function (e) { return function (t, r) { let a; let o; const s = String(i(t)); const u = n(r); const l = s.length; return u < 0 || u >= l ? e ? '' : void 0 : (a = s.charCodeAt(u)) < 55296 || a > 56319 || u + 1 === l || (o = s.charCodeAt(u + 1)) < 56320 || o > 57343 ? e ? s.charAt(u) : a : e ? s.slice(u, u + 2) : o - 56320 + (a - 55296 << 10) + 65536 } } }, function (e, t, r) { e.exports = r(28) }, function (e, t, r) {
  const n = r(202); const i = r(101); const a = r(65); const o = {}; r(28)(o, r(13)('iterator'), function () { return this }), e.exports = function (e, t, r) { e.prototype = n(o, { next: i(1, r) }), a(e, `${t} Iterator`) };
}, function (e, t, r) { const n = r(19); const i = r(29); const a = r(62); e.exports = r(25) ? Object.defineProperties : function defineProperties(e, t) { i(e); for (var r, o = a(t), s = o.length, u = 0; s > u;)n.f(e, r = o[u++], t[r]); return e } }, function (e, t, r) { const n = r(40); const i = r(63); const a = r(673)(!1); const o = r(112)('IE_PROTO'); e.exports = function (e, t) { let r; const s = i(e); let u = 0; const l = []; for (r in s)r != o && n(s, r) && l.push(r); for (;t.length > u;)n(s, r = t[u++]) && (~a(l, r) || l.push(r)); return l } }, function (e, t, r) { const n = r(63); const i = r(64); const a = r(674); e.exports = function (e) { return function (t, r, o) { let s; const u = n(t); const l = i(u.length); let c = a(o, l); if (e && r != r) { for (;l > c;) if ((s = u[c++]) != s) return !0; } else for (;l > c; c++) if ((e || c in u) && u[c] === r) return e || c || 0; return !e && -1 } } }, function (e, t, r) { const n = r(108); const i = Math.max; const a = Math.min; e.exports = function (e, t) { return (e = n(e)) < 0 ? i(e + t, 0) : a(e, t) } }, function (e, t, r) { const n = r(40); const i = r(43); const a = r(112)('IE_PROTO'); const o = Object.prototype; e.exports = Object.getPrototypeOf || function (e) { return e = i(e), n(e, a) ? e[a] : typeof e.constructor === 'function' && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? o : null } }, function (e, t, r) {
  const n = r(677); const i = r(207); const a = r(41); const o = r(63); e.exports = r(110)(Array, 'Array', function (e, t) { this._t = o(e), this._i = 0, this._k = t }, function () { const e = this._t; const t = this._k; const r = this._i++; return !e || r >= e.length ? (this._t = void 0, i(1)) : i(0, t == 'keys' ? r : t == 'values' ? e[r] : [r, e[r]]) }, 'values'), a.Arguments = a.Array, n('keys'), n('values'), n('entries');
}, function (e, t) { e.exports = function () {} }, function (e, t, r) {
  let n; let i; let a; let o; const s = r(201); const u = r(12); const l = r(24); const c = r(114); const p = r(6); const f = r(20); const d = r(39); const h = r(115); const m = r(44); const g = r(211); const v = r(212).set; const y = r(680)(); const b = r(116); const x = r(213); const D = r(214); const _ = u.TypeError; const C = u.process; let w = u.Promise; const E = c(C) == 'process'; const S = function () {}; let k = i = b.f; const A = !!(function () { try { const e = w.resolve(1); const t = (e.constructor = {})[r(13)('species')] = function (e) { e(S, S) }; return (E || typeof PromiseRejectionEvent === 'function') && e.then(S) instanceof t } catch (e) {} }()); const T = function (e) { let t; return !(!f(e) || typeof (t = e.then) !== 'function') && t }; const P = function (e, t) { if (!e._n) { e._n = !0; const r = e._c; y(() => { for (var n = e._v, i = e._s == 1, a = 0, o = function (t) { let r; let a; const o = i ? t.ok : t.fail; const s = t.resolve; const u = t.reject; const l = t.domain; try { o ? (i || (e._h == 2 && F(e), e._h = 1), !0 === o ? r = n : (l && l.enter(), r = o(n), l && l.exit()), r === t.promise ? u(_('Promise-chain cycle')) : (a = T(r)) ? a.call(r, s, u) : s(r)) : u(n) } catch (e) { u(e) } }; r.length > a;)o(r[a++]); e._c = [], e._n = !1, t && !e._h && R(e) }) } }; var R = function (e) { v.call(u, () => { let t; let r; let n; const i = e._v; const a = O(e); if (a && (t = x(() => { E ? C.emit('unhandledRejection', i, e) : (r = u.onunhandledrejection) ? r({ promise: e, reason: i }) : (n = u.console) && n.error && n.error('Unhandled promise rejection', i) }), e._h = E || O(e) ? 2 : 1), e._a = void 0, a && t.e) throw t.v; }) }; var O = function (e) { return e._h !== 1 && (e._a || e._c).length === 0 }; var F = function (e) { v.call(u, () => { let t; E ? C.emit('rejectionHandled', e) : (t = u.onrejectionhandled) && t({ promise: e, reason: e._v }) }) }; const L = function (e) { let t = this; t._d || (t._d = !0, (t = t._w || t)._v = e, t._s = 2, t._a || (t._a = t._c.slice()), P(t, !0)) }; var M = function (e) { let t; let r = this; if (!r._d) { r._d = !0, r = r._w || r; try { if (r === e) throw _("Promise can't be resolved itself"); (t = T(e)) ? y(() => { const n = { _w: r, _d: !1 }; try { t.call(e, l(M, n, 1), l(L, n, 1)) } catch (e) { L.call(n, e) } }) : (r._v = e, r._s = 1, P(r, !1)) } catch (e) { L.call({ _w: r, _d: !1 }, e) } } }; A || (w = function Promise(e) { h(this, w, 'Promise', '_h'), d(e), n.call(this); try { e(l(M, this, 1), l(L, this, 1)) } catch (e) { L.call(this, e) } }, (n = function Promise(e) { this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1 }).prototype = r(117)(w.prototype, { then: function then(e, t) { const r = k(g(this, w)); return r.ok = typeof e !== 'function' || e, r.fail = typeof t === 'function' && t, r.domain = E ? C.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && P(this, !1), r.promise }, catch(e) { return this.then(void 0, e) } }), a = function () { const e = new n(); this.promise = e, this.resolve = l(M, e, 1), this.reject = l(L, e, 1) }, b.f = k = function (e) { return e === w || e === o ? new a(e) : i(e) }), p(p.G + p.W + p.F * !A, { Promise: w }), r(65)(w, 'Promise'), r(215)('Promise'), o = r(7).Promise, p(p.S + p.F * !A, 'Promise', { reject: function reject(e) { const t = k(this); return (0, t.reject)(e), t.promise } }), p(p.S + p.F * (s || !A), 'Promise', { resolve: function resolve(e) { return D(s && this === o ? w : this, e) } }), p(p.S + p.F * !(A && r(216)((e) => { w.all(e).catch(S) })), 'Promise', { all: function all(e) { const t = this; const r = k(t); const n = r.resolve; const i = r.reject; const a = x(() => { const r = []; let a = 0; let o = 1; m(e, !1, (e) => { const s = a++; let u = !1; r.push(void 0), o++, t.resolve(e).then((e) => { u || (u = !0, r[s] = e, --o || n(r)) }, i) }), --o || n(r) }); return a.e && i(a.v), r.promise }, race: function race(e) { const t = this; const r = k(t); const n = r.reject; const i = x(() => { m(e, !1, (e) => { t.resolve(e).then(r.resolve, n) }) }); return i.e && n(i.v), r.promise } });
}, function (e, t) { e.exports = function (e, t, r) { const n = void 0 === r; switch (t.length) { case 0: return n ? e() : e.call(r); case 1: return n ? e(t[0]) : e.call(r, t[0]); case 2: return n ? e(t[0], t[1]) : e.call(r, t[0], t[1]); case 3: return n ? e(t[0], t[1], t[2]) : e.call(r, t[0], t[1], t[2]); case 4: return n ? e(t[0], t[1], t[2], t[3]) : e.call(r, t[0], t[1], t[2], t[3]); } return e.apply(r, t) } }, function (e, t, r) { const n = r(12); const i = r(212).set; const a = n.MutationObserver || n.WebKitMutationObserver; const o = n.process; const s = n.Promise; const u = r(42)(o) == 'process'; e.exports = function () { let e; let t; let r; const l = function () { let n; let i; for (u && (n = o.domain) && n.exit(); e;) { i = e.fn, e = e.next; try { i() } catch (n) { throw e ? r() : t = void 0, n } }t = void 0, n && n.enter() }; if (u)r = function () { o.nextTick(l) }; else if (!a || n.navigator && n.navigator.standalone) if (s && s.resolve) { const c = s.resolve(); r = function () { c.then(l) } } else r = function () { i.call(n, l) }; else { let p = !0; const f = document.createTextNode(''); new a(l).observe(f, { characterData: !0 }), r = function () { f.data = p = !p } } return function (n) { const i = { fn: n, next: void 0 }; t && (t.next = i), e || (e = i, r()), t = i } } }, function (e, t, r) {
  const n = r(6); const i = r(7); const a = r(12); const o = r(211); const s = r(214); n(n.P + n.R, 'Promise', { finally(e) { const t = o(this, i.Promise || a.Promise); const r = typeof e === 'function'; return this.then(r ? r => s(t, e()).then(() => r) : e, r ? r => s(t, e()).then(() => { throw r }) : e) } });
}, function (e, t, r) {
  const n = r(6); const i = r(116); const a = r(213); n(n.S, 'Promise', { try(e) { const t = i.f(this); const r = a(e); return (r.e ? t.reject : t.resolve)(r.v), t.promise } });
}, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; return (this._self._c || e)('SeriesPage', { attrs: { seriesid: this.episodes.series.id, episodeid: this.episodeid, episodeno: this.episodes.no } }) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageEpisodeID', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(217); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(688); const s = r(3); const u = function injectStyle(e) { r(686) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-3a3d0888', null); t.default = l.exports;
}, function (e, t, r) { let n = r(687); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('48360aa6', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '@media (min-width:641px) and (max-width:820px){.HomePage[data-v-3a3d0888]{margin-left:-1em;margin-right:-1em}}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; return (this._self._c || e)('LoopGrid', { staticClass: 'HomePage', attrs: { 'page-type': 'home' } }) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'Home', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(218); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(706); const s = r(3); const u = function injectStyle(e) { r(691) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-daa5b00a', null); t.default = l.exports;
}, function (e, t, r) { let n = r(692); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('262d8a6a', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '@media (max-width:640px){.ListPage-heading[data-v-daa5b00a]{text-align:center}}.ListPage-grid[data-v-daa5b00a]{display:grid;grid-template-columns:auto}.ListPage-filter[data-v-daa5b00a]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-top:1em;margin-left:auto;margin-right:auto}@media (max-width:640px){.ListPage-filter[data-v-daa5b00a]{width:100%;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}}.ListPage-select[data-v-daa5b00a]{position:relative;margin:0 .5em;-webkit-box-flex:0;-ms-flex:0 0 4em;flex:0 0 4em}.ListPage-select[data-v-daa5b00a]:first-child{margin-left:0}.ListPage-select.month-selector>select[data-v-daa5b00a],.ListPage-select.type-selector>select[data-v-daa5b00a],.ListPage-select.year-selector>select[data-v-daa5b00a]{padding-left:1em;padding-right:2em}.ListPage-select>select[data-v-daa5b00a]{display:block;position:relative;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border-radius:5px;-webkit-box-shadow:0 0 3px 0 rgba(0,0,0,.2);box-shadow:0 0 3px 0 rgba(0,0,0,.2);padding-right:.5em;min-width:4em;max-width:100%;height:2.25em;background-color:hsla(0,0%,100%,.6);color:#444;font-size:1em;text-align:center;text-align-last:center;cursor:pointer}.ListPage-select[data-v-daa5b00a]:after{border:2px solid #888;border-right:0;border-top:0;content:" ";display:block;height:.5em;pointer-events:none;position:absolute;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:center;transform-origin:center;width:.5em;margin-top:-.375em;right:.625em;top:50%;z-index:1}.ListPage-filterBtn[data-v-daa5b00a]{border:1px solid #6683bb;border-radius:5px;outline:none;padding:0 16px;padding:0 1rem;height:36px;height:2.25rem;font-size:1.1em;color:#fff;background-color:#1e50a2}.ListPage-pagination[data-v-daa5b00a]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-left:auto;margin-right:auto;width:90%;min-width:320px}@media (max-width:640px){.ListPage-pagination[data-v-daa5b00a]{width:100%}}.ListPage-pageIcon[data-v-daa5b00a]{background-color:#f0f0f0;padding:.5em 2em;border-radius:5px;text-align:center;color:#888;-webkit-box-flex:2;-ms-flex:2 2 auto;flex:2 2 auto}.ListPage-pageIcon--disabled[data-v-daa5b00a]{color:#ddd}', '']) }, function (e, t, r) { e.exports = { default: r(694), __esModule: !0 } }, function (e, t, r) { r(695), e.exports = r(7).Object.assign }, function (e, t, r) { const n = r(6); n(n.S + n.F, 'Object', { assign: r(696) }) }, function (e, t, r) {
  const n = r(62); const i = r(697); const a = r(219); const o = r(43); const s = r(111); const u = Object.assign; e.exports = !u || r(33)(() => { const e = {}; const t = {}; const r = Symbol(); const n = 'abcdefghijklmnopqrst'; return e[r] = 7, n.split('').forEach((e) => { t[e] = e }), u({}, e)[r] != 7 || Object.keys(u({}, t)).join('') != n }) ? function assign(e, t) { for (var r = o(e), u = arguments.length, l = 1, c = i.f, p = a.f; u > l;) for (var f, d = s(arguments[l++]), h = c ? n(d).concat(c(d)) : n(d), m = h.length, g = 0; m > g;)p.call(d, f = h[g++]) && (r[f] = d[f]); return r } : u;
}, function (e, t) { t.f = Object.getOwnPropertySymbols }, function (e, t, r) {
  t.__esModule = !0, t.default = function (e, t) { const r = {}; for (const n in e)t.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]); return r };
}, function (e, t, r) { e.exports = { default: r(700), __esModule: !0 } }, function (e, t, r) { r(107), r(701), e.exports = r(7).Array.from }, function (e, t, r) {
  const n = r(24); const i = r(6); const a = r(43); const o = r(208); const s = r(209); const u = r(64); const l = r(702); const c = r(210); i(i.S + i.F * !r(216)((e) => { Array.from(e) }), 'Array', { from: function from(e) { let t; let r; let i; let p; const f = a(e); const d = typeof this === 'function' ? this : Array; const h = arguments.length; let m = h > 1 ? arguments[1] : void 0; const g = void 0 !== m; let v = 0; const y = c(f); if (g && (m = n(m, h > 2 ? arguments[2] : void 0, 2)), void 0 == y || d == Array && s(y)) for (r = new d(t = u(f.length)); t > v; v++)l(r, v, g ? m(f[v], v) : f[v]); else for (p = y.call(f), r = new d(); !(i = p.next()).done; v++)l(r, v, g ? o(p, m, [i.value, v], !0) : i.value); return r.length = v, r } });
}, function (e, t, r) {
  const n = r(19); const i = r(101); e.exports = function (e, t, r) { t in e ? n.f(e, t, i(0, r)) : e[t] = r };
}, function (e, t, r) { r(704), e.exports = r(7).Object.keys }, function (e, t, r) { const n = r(43); const i = r(62); r(705)('keys', () => function keys(e) { return i(n(e)) }) }, function (e, t, r) { const n = r(6); const i = r(7); const a = r(33); e.exports = function (e, t) { const r = (i.Object || {})[e] || Object[e]; const o = {}; o[e] = t(r), n(n.S + n.F * a(() => { r(1) }), 'Object', o) } }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () {
    const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', [r('h1', { staticClass: 'ListPage-heading' }, [e._v('List Anime by Filter')]), e._v(' '), r('div', { staticClass: 'ListPage-filter' }, [r('div', { staticClass: 'ListPage-select year-selector' }, [r('select', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.selectedYear, expression: 'selectedYear',
      }],
      on: { change(t) { const r = Array.prototype.filter.call(t.target.options, e => e.selected).map(e => ('_value' in e ? e._value : e.value)); e.selectedYear = t.target.multiple ? r : r[0] } },
    }, e._l(e.seasons, (t, n) => r('option', { key: n, domProps: { value: n } }, [e._v(`\n          ${e._s(n)}\n        `)])))]), e._v(' '), r('div', { staticClass: 'ListPage-select month-selector' }, [r('select', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.selectedMonth, expression: 'selectedMonth',
      }],
      on: { change(t) { const r = Array.prototype.filter.call(t.target.options, e => e.selected).map(e => ('_value' in e ? e._value : e.value)); e.selectedMonth = t.target.multiple ? r : r[0] } },
    }, e._l(e.seasons[e.selectedYear].map(Number).sort((e, t) => e - t), t => r('option', { key: t.toString(), domProps: { value: t.toString() } }, [e._v(`\n          ${e._s(t)}\n        `)])))]), e._v(' '), r('div', { staticClass: 'ListPage-select type-selector' }, [r('select', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.selectedType, expression: 'selectedType',
      }],
      on: { change(t) { const r = Array.prototype.filter.call(t.target.options, e => e.selected).map(e => ('_value' in e ? e._value : e.value)); e.selectedType = t.target.multiple ? r : r[0] } },
    }, [r('option', { attrs: { selected: '', value: '' } }, [e._v('(All)')]), e._v(' '), e._l(e.seriesTypes, t => r('option', { key: t, domProps: { value: t } }, [e._v(`\n          ${e._s(t)}\n        `)]))], 2)]), e._v(' '), r('button', { staticClass: 'ListPage-filterBtn', on: { click: e.applyFilter } }, [r('FontAwesomeIcon', { attrs: { icon: 'filter' } })], 1)]), e._v(' '), r('SeriesGrid', { attrs: { type: 'listPage' } }), e._v(' '), e.pageCount > 1 ? r('div', { staticClass: 'ListPage-pagination' }, [e.disablePrevPage ? r('PageIcon', { attrs: { 'is-enabled': !1, direction: 'left' } }) : r('nuxt-link', { staticClass: 'ListPage-pageIcon', attrs: { to: { name: 'list', query: e.prevPageQueryObj } } }, [r('PageIcon', { attrs: { 'is-enabled': !0, direction: 'left' } })], 1), e._v(' '), r('div', { staticClass: 'ListPage-select' }, [r('select', {
      directives: [{
        name: 'model', rawName: 'v-model', value: e.selectedPageNum, expression: 'selectedPageNum',
      }],
      on: { change: [function (t) { const r = Array.prototype.filter.call(t.target.options, e => e.selected).map(e => ('_value' in e ? e._value : e.value)); e.selectedPageNum = t.target.multiple ? r : r[0] }, e.pageChanged] },
    }, e._l(e.pageCount, t => r('option', { key: t.toString(), domProps: { value: t.toString() } }, [e._v(`\n          ${e._s(t.toString())}\n        `)])))]), e._v(' '), e.disableNextPage ? r('PageIcon', { attrs: { 'is-enabled': !1, direction: 'right' } }) : r('nuxt-link', { staticClass: 'ListPage-pageIcon', attrs: { to: { name: 'list', query: Object.assign({}, this.$route.query, { page: e.currentPageNumInt + 1 }) } } }, [r('PageIcon', { attrs: { 'is-enabled': !0, direction: 'right' } })], 1)], 1) : e._e()], 1);
  }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageList', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(222); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(711); const s = r(3); const u = function injectStyle(e) { r(709) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-054a9d34', null); t.default = l.exports;
}, function (e, t, r) { let n = r(710); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('45305a2f', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; return (this._self._c || e)('LoopPage', { attrs: { 'page-type': 'loop' } }) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageLoopID', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(223); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(3); const s = Object(o.a)(i.a, void 0, void 0, !1, null, null, null); t.default = s.exports;
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageRandom', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(224); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(718); const s = r(3); const u = function injectStyle(e) { r(716) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-1802aca4', null); t.default = l.exports;
}, function (e, t, r) { let n = r(717); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('1f08ae6a', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '@media (max-width:640px){.SearchPage-heading[data-v-1802aca4]{margin-left:.5em}}', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', [e.errMsg ? r('div', [r('h2', { staticClass: 'SearchPage-heading' }, [e._v(e._s(e.errMsg))])]) : e.isSearching ? r('div', [r('h2', { staticClass: 'SearchPage-heading' }, [e._v(`\n      Loading search result for "${e._s(this.$route.query.keyword)}"\n    `)])]) : e.isEmptyResult ? r('div', [r('h2', { staticClass: 'SearchPage-heading' }, [e._v(`No Results for "${e._s(this.$route.query.keyword)}"`)])]) : r('div', [r('h2', { staticClass: 'SearchPage-heading' }, [e._v(`\n      Displaying search result for "${e._s(this.$route.query.keyword)}"\n    `)]), e._v(' '), r('SeriesGrid', { attrs: { type: 'search' } })], 1)]) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageSearch', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = r(225); const i = r.n(n); for (const a in n)a !== 'default' && (function (e) { r.d(t, e, () => n[e]) }(a)); const o = r(723); const s = r(3); const u = function injectStyle(e) { r(721) }; const l = Object(s.a)(i.a, o.a, o.b, !1, u, 'data-v-1ff06d3a', null); t.default = l.exports;
}, function (e, t, r) { let n = r(722); typeof n === 'string' && (n = [[e.i, n, '']]), n.locals && (e.exports = n.locals); r(5)('40519e12', n, !0) }, function (e, t, r) { (e.exports = r(4)(!1)).push([e.i, '', '']) }, function (e, t, r) {
  r.d(t, 'a', () => n), r.d(t, 'b', () => i); var n = function () { const e = this.$createElement; return (this._self._c || e)('SeriesPage', { attrs: { seriesid: this.$route.params.id, episodeid: '' } }) }; var i = [];
}, function (e, t, r) {
  e.exports = {
    description: '', methods: [], displayName: 'PageSeriesID', props: void 0, comment: '', tags: {}, events: {}, slots: {}, examples: [],
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(23)); const i = _interopRequireDefault(r(726)); const a = _interopRequireDefault(r(727)); const o = _interopRequireDefault(r(728)); const s = _interopRequireDefault(r(739)); const u = _interopRequireDefault(r(756)); const l = _interopRequireDefault(r(760)); const c = _interopRequireDefault(r(761)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } }n.default.use(i.default); t.default = function createStore() {
    return new i.default.Store({
      state: function state() { return {} },
      modules: {
        loop: o.default, series: s.default, episode: u.default, search: l.default, i18n: a.default, navbar: c.default,
      },
    });
  };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }), r.d(t, 'Store', () => l), r.d(t, 'install', () => install), r.d(t, 'mapState', () => p), r.d(t, 'mapMutations', () => f), r.d(t, 'mapGetters', () => d), r.d(t, 'mapActions', () => h), r.d(t, 'createNamespacedHelpers', () => m);
  /**
 * Vuex v3.0.1
 * (c) 2017 Evan You.
 *
 * @license MIT
 */
  const n = function (e) { if (Number(e.version.split('.')[0]) >= 2)e.mixin({ beforeCreate: vuexInit }); else { const t = e.prototype._init; e.prototype._init = function (e) { void 0 === e && (e = {}), e.init = e.init ? [vuexInit].concat(e.init) : vuexInit, t.call(this, e) } } function vuexInit() { const e = this.$options; e.store ? this.$store = typeof e.store === 'function' ? e.store() : e.store : e.parent && e.parent.$store && (this.$store = e.parent.$store) } }; const i = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function forEachValue(e, t) { Object.keys(e).forEach(r => t(e[r], r)) } const a = function Module(e, t) { this.runtime = t, this._children = Object.create(null), this._rawModule = e; const r = e.state; this.state = (typeof r === 'function' ? r() : r) || {} }; const o = { namespaced: { configurable: !0 } }; o.namespaced.get = function () { return !!this._rawModule.namespaced }, a.prototype.addChild = function addChild(e, t) { this._children[e] = t }, a.prototype.removeChild = function removeChild(e) { delete this._children[e] }, a.prototype.getChild = function getChild(e) { return this._children[e] }, a.prototype.update = function update(e) { this._rawModule.namespaced = e.namespaced, e.actions && (this._rawModule.actions = e.actions), e.mutations && (this._rawModule.mutations = e.mutations), e.getters && (this._rawModule.getters = e.getters) }, a.prototype.forEachChild = function forEachChild(e) { forEachValue(this._children, e) }, a.prototype.forEachGetter = function forEachGetter(e) { this._rawModule.getters && forEachValue(this._rawModule.getters, e) }, a.prototype.forEachAction = function forEachAction(e) { this._rawModule.actions && forEachValue(this._rawModule.actions, e) }, a.prototype.forEachMutation = function forEachMutation(e) { this._rawModule.mutations && forEachValue(this._rawModule.mutations, e) }, Object.defineProperties(a.prototype, o); const s = function ModuleCollection(e) { this.register([], e, !1) }; s.prototype.get = function get(e) { return e.reduce((e, t) => e.getChild(t), this.root) }, s.prototype.getNamespace = function getNamespace(e) { let t = this.root; return e.reduce((e, r) => e + ((t = t.getChild(r)).namespaced ? `${r}/` : ''), '') }, s.prototype.update = function update$1(e) {
    !(function update(e, t, r) {
      0;

      t.update(r); if (r.modules) for (const n in r.modules) { if (!t.getChild(n)) return void 0; update(e.concat(n), t.getChild(n), r.modules[n]) }
    }([], this.root, e));
  }, s.prototype.register = function register(e, t, r) { const n = this; void 0 === r && (r = !0); const i = new a(t, r); e.length === 0 ? this.root = i : this.get(e.slice(0, -1)).addChild(e[e.length - 1], i); t.modules && forEachValue(t.modules, (t, i) => { n.register(e.concat(i), t, r) }) }, s.prototype.unregister = function unregister(e) { const t = this.get(e.slice(0, -1)); const r = e[e.length - 1]; t.getChild(r).runtime && t.removeChild(r) }; let u; var l = function Store(e) { const t = this; void 0 === e && (e = {}), !u && typeof window !== 'undefined' && window.Vue && install(window.Vue); let r = e.plugins; void 0 === r && (r = []); let n = e.strict; void 0 === n && (n = !1); let a = e.state; void 0 === a && (a = {}), typeof a === 'function' && (a = a() || {}), this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new s(e), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._watcherVM = new u(); const o = this; const l = this.dispatch; const c = this.commit; this.dispatch = function boundDispatch(e, t) { return l.call(o, e, t) }, this.commit = function boundCommit(e, t, r) { return c.call(o, e, t, r) }, this.strict = n, installModule(this, a, [], this._modules.root), resetStoreVM(this, a), r.forEach(e => e(t)), u.config.devtools && (function devtoolPlugin(e) { i && (e._devtoolHook = i, i.emit('vuex:init', e), i.on('vuex:travel-to-state', (t) => { e.replaceState(t) }), e.subscribe((e, t) => { i.emit('vuex:mutation', e, t) })) }(this)) }; const c = { state: { configurable: !0 } }; function genericSubscribe(e, t) { return t.indexOf(e) < 0 && t.push(e), function () { const r = t.indexOf(e); r > -1 && t.splice(r, 1) } } function resetStore(e, t) { e._actions = Object.create(null), e._mutations = Object.create(null), e._wrappedGetters = Object.create(null), e._modulesNamespaceMap = Object.create(null); const r = e.state; installModule(e, r, [], e._modules.root, !0), resetStoreVM(e, r, t) } function resetStoreVM(e, t, r) { const n = e._vm; e.getters = {}; const i = {}; forEachValue(e._wrappedGetters, (t, r) => { i[r] = function () { return t(e) }, Object.defineProperty(e.getters, r, { get() { return e._vm[r] }, enumerable: !0 }) }); const a = u.config.silent; u.config.silent = !0, e._vm = new u({ data: { $$state: t }, computed: i }), u.config.silent = a, e.strict && (function enableStrictMode(e) { e._vm.$watch(function () { return this._data.$$state }, () => { 0 }, { deep: !0, sync: !0 }) }(e)), n && (r && e._withCommit(() => { n._data.$$state = null }), u.nextTick(() => n.$destroy())) } function installModule(e, t, r, n, i) {
    const a = !r.length; const o = e._modules.getNamespace(r); if (n.namespaced && (e._modulesNamespaceMap[o] = n), !a && !i) { const s = getNestedState(t, r.slice(0, -1)); const l = r[r.length - 1]; e._withCommit(() => { u.set(s, l, n.state) }) } const c = n.context = (function makeLocalContext(e, t, r) { const n = t === ''; const i = { dispatch: n ? e.dispatch : function (r, n, i) { const a = unifyObjectStyle(r, n, i); const o = a.payload; const s = a.options; let u = a.type; return s && s.root || (u = t + u), e.dispatch(u, o) }, commit: n ? e.commit : function (r, n, i) { const a = unifyObjectStyle(r, n, i); const o = a.payload; const s = a.options; let u = a.type; s && s.root || (u = t + u), e.commit(u, o, s) } }; return Object.defineProperties(i, { getters: { get: n ? function () { return e.getters } : function () { return (function makeLocalGetters(e, t) { const r = {}; const n = t.length; return Object.keys(e.getters).forEach((i) => { if (i.slice(0, n) === t) { const a = i.slice(n); Object.defineProperty(r, a, { get() { return e.getters[i] }, enumerable: !0 }) } }), r }(e, t)) } }, state: { get() { return getNestedState(e.state, r) } } }), i }(e, o, r)); n.forEachMutation((t, r) => { !(function registerMutation(e, t, r, n) { (e._mutations[t] || (e._mutations[t] = [])).push((t) => { r.call(e, n.state, t) }) }(e, o + r, t, c)) }), n.forEachAction((t, r) => {
      const n = t.root ? r : o + r; const i = t.handler || t; !(function registerAction(e, t, r, n) {
        (e._actions[t] || (e._actions[t] = [])).push((t, i) => {
          let a = r.call(e, {
            dispatch: n.dispatch, commit: n.commit, getters: n.getters, state: n.state, rootGetters: e.getters, rootState: e.state,
          }, t, i); return (function isPromise(e) { return e && typeof e.then === 'function' }(a)) || (a = Promise.resolve(a)), e._devtoolHook ? a.catch((t) => { throw e._devtoolHook.emit('vuex:error', t), t }) : a;
        });
      }(e, n, i, c));
    }), n.forEachGetter((t, r) => { !(function registerGetter(e, t, r, n) { if (e._wrappedGetters[t]) return void 0; e._wrappedGetters[t] = function wrappedGetter(e) { return r(n.state, n.getters, e.state, e.getters) } }(e, o + r, t, c)) }), n.forEachChild((n, a) => { installModule(e, t, r.concat(a), n, i) });
  } function getNestedState(e, t) { return t.length ? t.reduce((e, t) => e[t], e) : e } function unifyObjectStyle(e, t, r) { return (function isObject(e) { return e !== null && typeof e === 'object' }(e)) && e.type && (r = t, t = e, e = e.type), { type: e, payload: t, options: r } } function install(e) { u && e === u || n(u = e) }c.state.get = function () { return this._vm._data.$$state }, c.state.set = function (e) { 0 }, l.prototype.commit = function commit(e, t, r) { const n = this; const i = unifyObjectStyle(e, t, r); const a = i.type; const o = i.payload; const s = (i.options, { type: a, payload: o }); const u = this._mutations[a]; u && (this._withCommit(() => { u.forEach((e) => { e(o) }) }), this._subscribers.forEach(e => e(s, n.state))) }, l.prototype.dispatch = function dispatch(e, t) { const r = this; const n = unifyObjectStyle(e, t); const i = n.type; const a = n.payload; const o = { type: i, payload: a }; const s = this._actions[i]; if (s) return this._actionSubscribers.forEach(e => e(o, r.state)), s.length > 1 ? Promise.all(s.map(e => e(a))) : s[0](a); }, l.prototype.subscribe = function subscribe(e) { return genericSubscribe(e, this._subscribers) }, l.prototype.subscribeAction = function subscribeAction(e) { return genericSubscribe(e, this._actionSubscribers) }, l.prototype.watch = function watch(e, t, r) { const n = this; return this._watcherVM.$watch(() => e(n.state, n.getters), t, r) }, l.prototype.replaceState = function replaceState(e) { const t = this; this._withCommit(() => { t._vm._data.$$state = e }) }, l.prototype.registerModule = function registerModule(e, t, r) { void 0 === r && (r = {}), typeof e === 'string' && (e = [e]), this._modules.register(e, t), installModule(this, this.state, e, this._modules.get(e), r.preserveState), resetStoreVM(this, this.state) }, l.prototype.unregisterModule = function unregisterModule(e) { const t = this; typeof e === 'string' && (e = [e]), this._modules.unregister(e), this._withCommit(() => { const r = getNestedState(t.state, e.slice(0, -1)); u.delete(r, e[e.length - 1]) }), resetStore(this) }, l.prototype.hotUpdate = function hotUpdate(e) { this._modules.update(e), resetStore(this, !0) }, l.prototype._withCommit = function _withCommit(e) { const t = this._committing; this._committing = !0, e(), this._committing = t }, Object.defineProperties(l.prototype, c); var p = normalizeNamespace((e, t) => { const r = {}; return normalizeMap(t).forEach((t) => { const n = t.key; const i = t.val; r[n] = function mappedState() { let t = this.$store.state; let r = this.$store.getters; if (e) { const n = getModuleByNamespace(this.$store, 'mapState', e); if (!n) return; t = n.context.state, r = n.context.getters } return typeof i === 'function' ? i.call(this, t, r) : t[i] }, r[n].vuex = !0 }), r }); var f = normalizeNamespace((e, t) => { const r = {}; return normalizeMap(t).forEach((t) => { const n = t.key; const i = t.val; r[n] = function mappedMutation() { for (var t = [], r = arguments.length; r--;)t[r] = arguments[r]; let n = this.$store.commit; if (e) { const a = getModuleByNamespace(this.$store, 'mapMutations', e); if (!a) return; n = a.context.commit } return typeof i === 'function' ? i.apply(this, [n].concat(t)) : n.apply(this.$store, [i].concat(t)) } }), r }); var d = normalizeNamespace((e, t) => { const r = {}; return normalizeMap(t).forEach((t) => { const n = t.key; let i = t.val; i = e + i, r[n] = function mappedGetter() { if (!e || getModuleByNamespace(this.$store, 'mapGetters', e)) return this.$store.getters[i]; }, r[n].vuex = !0 }), r }); var h = normalizeNamespace((e, t) => { const r = {}; return normalizeMap(t).forEach((t) => { const n = t.key; const i = t.val; r[n] = function mappedAction() { for (var t = [], r = arguments.length; r--;)t[r] = arguments[r]; let n = this.$store.dispatch; if (e) { const a = getModuleByNamespace(this.$store, 'mapActions', e); if (!a) return; n = a.context.dispatch } return typeof i === 'function' ? i.apply(this, [n].concat(t)) : n.apply(this.$store, [i].concat(t)) } }), r }); var m = function (e) {
    return {
      mapState: p.bind(null, e), mapGetters: d.bind(null, e), mapMutations: f.bind(null, e), mapActions: h.bind(null, e),
    };
  }; function normalizeMap(e) { return Array.isArray(e) ? e.map(e => ({ key: e, val: e })) : Object.keys(e).map(t => ({ key: t, val: e[t] })) } function normalizeNamespace(e) { return function (t, r) { return typeof t !== 'string' ? (r = t, t = '') : t.charAt(t.length - 1) !== '/' && (t += '/'), e(t, r) } } function getModuleByNamespace(e, t, r) { return e._modulesNamespaceMap[r] } const g = {
    Store: l, install, version: '3.0.1', mapState: p, mapMutations: f, mapGetters: d, mapActions: h, createNamespacedHelpers: m,
  }; t.default = g;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(23)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const o = {
    state: function state() { return { locale: '' } }, getters: {}, mutations: { SET_LOCALE: function SET_LOCALE(e, t) { const r = t.locale; a.default.set(e, 'locale', r) } }, actions: { setLang: function setLang(e, t) { const r = this; const a = e.dispatch; const o = e.commit; const s = t.locale; return (0, i.default)(n.default.mark(function _callee() { return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: return o('SET_LOCALE', { locale: s }), o('TOGGLE_NAVBAR_STATE', { type: 'langOpen' }), e.next = 4, a('setLangCookie', { locale: s }); case 4: return e.next = 6, a('setAppLang', { locale: s }); case 6: case 'end': return e.stop(); } }, _callee, r) }))() }, setLangCookie: function setLangCookie(e, t) { const r = t.locale; try { this.app.$cookies.set('locale', r) } catch (e) { throw new Error(`Cannot modify cookies.\n          ${e}`) } }, setAppLang: function setAppLang(e, t) { const r = t.locale; try { this.app.i18n.locale = r } catch (e) { throw new Error(`Cannot set app locale.\n          ${e}`) } } },
  }; t.default = o;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(23)); const o = _interopRequireDefault(r(66)); const s = _interopRequireDefault(r(67)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function tidyTimestamp(e) { const t = e.split(':'); return t[0] !== '00' && (t[1] = 60 * parseInt(t[0], 10) + parseInt(t[1], 10), t[1] = t[1].toString()), t[2] = t[2].includes('.') ? t[2].slice(0, -3) : `${t[2]}.000`, `${t[1]}:${t[2]}` } const u = {
    state: function state() {
      return {
        randomLoopList: [], randomPageLoopid: '', loopList: {}, loops: {}, play: !1,
      };
    },
    mutations: {
      SET_LOOP: function SET_LOOP(e, t) { const r = t.loopid; const n = t.data; e.loops[r] = n }, SET_LOOPS: function SET_LOOPS(e, t) { t.data.forEach((t) => { a.default.set(e.loops, t.id, t) }) }, SET_LOOPLIST: function SET_LOOPLIST(e, t) { const r = t.episodeid; const n = t.data; a.default.set(e.loopList, r, n) }, SET_RANDOM_PAGE_LOOP_ID: function SET_RANDOM_PAGE_LOOP_ID(e, t) { const r = t.data; e.randomPageLoopid = r[0].id }, SET_RANDOM_LOOPLIST: function SET_RANDOM_LOOPLIST(e, t) { const r = t.data; e.randomLoopList = [], r.forEach((t) => { e.randomLoopList.push(t.id) }) }, SET_PLAY: function SET_PLAY(e, t) { const r = t.play; e.play = r },
    },
    getters: { formatTimeStamps: function formatTimeStamps(e) { return function (t) { return { duration: e.loops[t].duration.toFixed(3), begin: `${tidyTimestamp(e.loops[t].period.begin)}`, end: `${tidyTimestamp(e.loops[t].period.end)}` } } } },
    actions: {
      fetchLoopByID: function fetchLoopByID(e, t) { const r = this; const a = e.commit; const u = t.loopid; return (0, i.default)(n.default.mark(function _callee() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, o.default.getLoopByID(u); case 2: if (e = r.sent, t = e.data, s.default.obj(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: a('SET_LOOP', { loopid: u, data: t }); case 7: case 'end': return r.stop(); } }, _callee, r) }))() }, fetchRandomLoop: function fetchRandomLoop(e) { const t = this; const r = e.dispatch; const a = e.commit; return (0, i.default)(n.default.mark(function _callee2() { let e; let i; return n.default.wrap((t) => { for (;;) switch (t.prev = t.next) { case 0: return t.next = 2, o.default.getRandomLoopList(1); case 2: if (e = t.sent, i = e.data, s.default.arr(i)) { t.next = 6; break } throw new Error('Cannot fetch data'); case 6: return a('SET_RANDOM_PAGE_LOOP_ID', { data: i }), t.next = 9, r('setLoops', { data: i }); case 9: case 'end': return t.stop(); } }, _callee2, t) }))() }, fetchRandomLoopList: function fetchRandomLoopList(e, t) { const r = this; const a = e.dispatch; const u = e.commit; const l = t.count; return (0, i.default)(n.default.mark(function _callee3() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, o.default.getRandomLoopList(l); case 2: if (e = r.sent, t = e.data, s.default.arr(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: return u('SET_RANDOM_LOOPLIST', { data: t }), r.next = 9, a('setLoops', { data: t }); case 9: case 'end': return r.stop(); } }, _callee3, r) }))() }, fetchLoopsByEpisodeID: function fetchLoopsByEpisodeID(e, t) { const r = this; const a = e.dispatch; const u = e.commit; const l = t.episodeid; return (0, i.default)(n.default.mark(function _callee4() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, o.default.getLoopsByEpisodeID(l); case 2: if (e = r.sent, t = e.data, s.default.arr(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: return u('SET_LOOPLIST', { episodeid: l, data: t }), r.next = 9, a('setLoops', { data: t }); case 9: case 'end': return r.stop(); } }, _callee4, r) }))() }, setLoops: function setLoops(e, t) { (0, e.commit)('SET_LOOPS', { data: t.data }) }, setPlay: function setPlay(e, t) { (0, e.commit)('SET_PLAY', { play: t.play }) },
    },
  }; t.default = u;
}, function (e, t, r) { e.exports = { default: r(730), __esModule: !0 } }, function (e, t, r) { r(731), e.exports = r(7).Object.entries }, function (e, t, r) { const n = r(6); const i = r(732)(!0); n(n.S, 'Object', { entries: function entries(e) { return i(e) } }) }, function (e, t, r) { const n = r(62); const i = r(63); const a = r(219).f; e.exports = function (e) { return function (t) { for (var r, o = i(t), s = n(o), u = s.length, l = 0, c = []; u > l;)a.call(o, r = s[l++]) && c.push(e ? [r, o[r]] : o[r]); return c } } }, function (e, t, r) { r(734), e.exports = self.fetch.bind(self) }, function (e, t) {
  !(function (e) {
    if (!e.fetch) {
      var t = {
        searchParams: 'URLSearchParams' in e, iterable: 'Symbol' in e && 'iterator' in Symbol, blob: 'FileReader' in e && 'Blob' in e && (function () { try { return new Blob(), !0 } catch (e) { return !1 } }()), formData: 'FormData' in e, arrayBuffer: 'ArrayBuffer' in e,
      }; if (t.arrayBuffer) var r = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']; var n = function (e) { return e && DataView.prototype.isPrototypeOf(e) }; var i = ArrayBuffer.isView || function (e) { return e && r.indexOf(Object.prototype.toString.call(e)) > -1 }; Headers.prototype.append = function (e, t) { e = normalizeName(e), t = normalizeValue(t); const r = this.map[e]; this.map[e] = r ? `${r},${t}` : t }, Headers.prototype.delete = function (e) { delete this.map[normalizeName(e)] }, Headers.prototype.get = function (e) { return e = normalizeName(e), this.has(e) ? this.map[e] : null }, Headers.prototype.has = function (e) { return this.map.hasOwnProperty(normalizeName(e)) }, Headers.prototype.set = function (e, t) { this.map[normalizeName(e)] = normalizeValue(t) }, Headers.prototype.forEach = function (e, t) { for (const r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this); }, Headers.prototype.keys = function () { const e = []; return this.forEach((t, r) => { e.push(r) }), iteratorFor(e) }, Headers.prototype.values = function () { const e = []; return this.forEach((t) => { e.push(t) }), iteratorFor(e) }, Headers.prototype.entries = function () { const e = []; return this.forEach((t, r) => { e.push([r, t]) }), iteratorFor(e) }, t.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries); var a = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']; Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }) }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function () {
        return new Response(this._bodyInit, {
          status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url,
        });
      }, Response.error = function () { const e = new Response(null, { status: 0, statusText: '' }); return e.type = 'error', e }; const o = [301, 302, 303, 307, 308]; Response.redirect = function (e, t) { if (o.indexOf(t) === -1) throw new RangeError('Invalid status code'); return new Response(null, { status: t, headers: { location: e } }) }, e.Headers = Headers, e.Request = Request, e.Response = Response, e.fetch = function (e, r) { return new Promise(((n, i) => { const a = new Request(e, r); const o = new XMLHttpRequest(); o.onload = function () { const e = { status: o.status, statusText: o.statusText, headers: (function parseHeaders(e) { const t = new Headers(); return e.split(/\r?\n/).forEach((e) => { const r = e.split(':'); const n = r.shift().trim(); if (n) { const i = r.join(':').trim(); t.append(n, i) } }), t }(o.getAllResponseHeaders() || '')) }; e.url = 'responseURL' in o ? o.responseURL : e.headers.get('X-Request-URL'); const t = 'response' in o ? o.response : o.responseText; n(new Response(t, e)) }, o.onerror = function () { i(new TypeError('Network request failed')) }, o.ontimeout = function () { i(new TypeError('Network request failed')) }, o.open(a.method, a.url, !0), a.credentials === 'include' && (o.withCredentials = !0), 'responseType' in o && t.blob && (o.responseType = 'blob'), a.headers.forEach((e, t) => { o.setRequestHeader(t, e) }), o.send(void 0 === a._bodyInit ? null : a._bodyInit) })) }, e.fetch.polyfill = !0;
    } function normalizeName(e) { if (typeof e !== 'string' && (e = String(e)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e)) throw new TypeError('Invalid character in header field name'); return e.toLowerCase() } function normalizeValue(e) { return typeof e !== 'string' && (e = String(e)), e } function iteratorFor(e) { const r = { next() { const t = e.shift(); return { done: void 0 === t, value: t } } }; return t.iterable && (r[Symbol.iterator] = function () { return r }), r } function Headers(e) { this.map = {}, e instanceof Headers ? e.forEach(function (e, t) { this.append(t, e) }, this) : Array.isArray(e) ? e.forEach(function (e) { this.append(e[0], e[1]) }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) { this.append(t, e[t]) }, this) } function consumed(e) { if (e.bodyUsed) return Promise.reject(new TypeError('Already read')); e.bodyUsed = !0 } function fileReaderReady(e) { return new Promise(((t, r) => { e.onload = function () { t(e.result) }, e.onerror = function () { r(e.error) } })) } function readBlobAsArrayBuffer(e) {
      const t = new FileReader(); const
        r = fileReaderReady(t); return t.readAsArrayBuffer(e), r;
    } function bufferClone(e) { if (e.slice) return e.slice(0); const t = new Uint8Array(e.byteLength); return t.set(new Uint8Array(e)), t.buffer } function Body() {
      return this.bodyUsed = !1, this._initBody = function (e) { if (this._bodyInit = e, e) if (typeof e === 'string') this._bodyText = e; else if (t.blob && Blob.prototype.isPrototypeOf(e)) this._bodyBlob = e; else if (t.formData && FormData.prototype.isPrototypeOf(e)) this._bodyFormData = e; else if (t.searchParams && URLSearchParams.prototype.isPrototypeOf(e)) this._bodyText = e.toString(); else if (t.arrayBuffer && t.blob && n(e)) this._bodyArrayBuffer = bufferClone(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]); else { if (!t.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(e) && !i(e)) throw new Error('unsupported BodyInit type'); this._bodyArrayBuffer = bufferClone(e) } else this._bodyText = ''; this.headers.get('content-type') || (typeof e === 'string' ? this.headers.set('content-type', 'text/plain;charset=UTF-8') : this._bodyBlob && this._bodyBlob.type ? this.headers.set('content-type', this._bodyBlob.type) : t.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')) }, t.blob && (this.blob = function () { const e = consumed(this); if (e) return e; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error('could not read FormData body as blob'); return Promise.resolve(new Blob([this._bodyText])) }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? consumed(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(readBlobAsArrayBuffer) }), this.text = function () {
        const e = consumed(this); if (e) return e; if (this._bodyBlob) {
          return (function readBlobAsText(e) {
            const t = new FileReader(); const
              r = fileReaderReady(t); return t.readAsText(e), r;
          }(this._bodyBlob));
        } if (this._bodyArrayBuffer) return Promise.resolve(function readArrayBufferAsText(e) { for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++)r[n] = String.fromCharCode(t[n]); return r.join('') }(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error('could not read FormData body as text'); return Promise.resolve(this._bodyText);
      }, t.formData && (this.formData = function () { return this.text().then(decode) }), this.json = function () { return this.text().then(JSON.parse) }, this;
    } function Request(e, t) { let r = (t = t || {}).body; if (e instanceof Request) { if (e.bodyUsed) throw new TypeError('Already read'); this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new Headers(e.headers)), this.method = e.method, this.mode = e.mode, r || e._bodyInit == null || (r = e._bodyInit, e.bodyUsed = !0) } else this.url = String(e); if (this.credentials = t.credentials || this.credentials || 'omit', !t.headers && this.headers || (this.headers = new Headers(t.headers)), this.method = (function normalizeMethod(e) { const t = e.toUpperCase(); return a.indexOf(t) > -1 ? t : e }(t.method || this.method || 'GET')), this.mode = t.mode || this.mode || null, this.referrer = null, (this.method === 'GET' || this.method === 'HEAD') && r) throw new TypeError('Body not allowed for GET or HEAD requests'); this._initBody(r) } function decode(e) { const t = new FormData(); return e.trim().split('&').forEach((e) => { if (e) { const r = e.split('='); const n = r.shift().replace(/\+/g, ' '); const i = r.join('=').replace(/\+/g, ' '); t.append(decodeURIComponent(n), decodeURIComponent(i)) } }), t } function Response(e, t) { t || (t = {}), this.type = 'default', this.status = 'status' in t ? t.status : 200, this.ok = this.status >= 200 && this.status < 300, this.statusText = 'statusText' in t ? t.statusText : 'OK', this.headers = new Headers(t.headers), this.url = t.url || '', this._initBody(e) }
  }(typeof self !== 'undefined' ? self : this));
}, function (e, t, r) {
  const n = r(736); const i = r(737); const a = r(227); e.exports = { formats: a, parse: i, stringify: n };
}, function (e, t, r) {
  const n = r(226); const i = r(227); const a = { brackets: function brackets(e) { return `${e}[]` }, indices: function indices(e, t) { return `${e}[${t}]` }, repeat: function repeat(e) { return e } }; const o = Date.prototype.toISOString; const s = {
    delimiter: '&', encode: !0, encoder: n.encode, encodeValuesOnly: !1, serializeDate: function serializeDate(e) { return o.call(e) }, skipNulls: !1, strictNullHandling: !1,
  }; const u = function stringify(e, t, r, i, a, o, u, l, c, p, f, d) { let h = e; if (typeof u === 'function')h = u(t, h); else if (h instanceof Date)h = p(h); else if (h === null) { if (i) return o && !d ? o(t, s.encoder) : t; h = '' } if (typeof h === 'string' || typeof h === 'number' || typeof h === 'boolean' || n.isBuffer(h)) return o ? [`${f(d ? t : o(t, s.encoder))}=${f(o(h, s.encoder))}`] : [`${f(t)}=${f(String(h))}`]; let m; let g = []; if (void 0 === h) return g; if (Array.isArray(u))m = u; else { const v = Object.keys(h); m = l ? v.sort(l) : v } for (let y = 0; y < m.length; ++y) { const b = m[y]; a && h[b] === null || (g = Array.isArray(h) ? g.concat(stringify(h[b], r(t, b), r, i, a, o, u, l, c, p, f, d)) : g.concat(stringify(h[b], t + (c ? `.${b}` : `[${b}]`), r, i, a, o, u, l, c, p, f, d))) } return g }; e.exports = function (e, t) { let r = e; const o = t ? n.assign({}, t) : {}; if (o.encoder !== null && void 0 !== o.encoder && typeof o.encoder !== 'function') throw new TypeError('Encoder has to be a function.'); const l = void 0 === o.delimiter ? s.delimiter : o.delimiter; const c = typeof o.strictNullHandling === 'boolean' ? o.strictNullHandling : s.strictNullHandling; const p = typeof o.skipNulls === 'boolean' ? o.skipNulls : s.skipNulls; const f = typeof o.encode === 'boolean' ? o.encode : s.encode; const d = typeof o.encoder === 'function' ? o.encoder : s.encoder; const h = typeof o.sort === 'function' ? o.sort : null; const m = void 0 !== o.allowDots && o.allowDots; const g = typeof o.serializeDate === 'function' ? o.serializeDate : s.serializeDate; const v = typeof o.encodeValuesOnly === 'boolean' ? o.encodeValuesOnly : s.encodeValuesOnly; if (void 0 === o.format)o.format = i.default; else if (!Object.prototype.hasOwnProperty.call(i.formatters, o.format)) throw new TypeError('Unknown format option provided.'); let y; let b; const x = i.formatters[o.format]; typeof o.filter === 'function' ? r = (b = o.filter)('', r) : Array.isArray(o.filter) && (y = b = o.filter); let D; let _ = []; if (typeof r !== 'object' || r === null) return ''; D = o.arrayFormat in a ? o.arrayFormat : 'indices' in o ? o.indices ? 'indices' : 'repeat' : 'indices'; const C = a[D]; y || (y = Object.keys(r)), h && y.sort(h); for (let w = 0; w < y.length; ++w) { const E = y[w]; p && r[E] === null || (_ = _.concat(u(r[E], E, C, c, p, f ? d : null, b, h, m, g, x, v))) } const S = _.join(l); const k = !0 === o.addQueryPrefix ? '?' : ''; return S.length > 0 ? k + S : '' };
}, function (e, t, r) {
  const n = r(226); const i = Object.prototype.hasOwnProperty; const a = {
    allowDots: !1, allowPrototypes: !1, arrayLimit: 20, decoder: n.decode, delimiter: '&', depth: 5, parameterLimit: 1e3, plainObjects: !1, strictNullHandling: !1,
  }; const o = function parseQueryStringKeys(e, t, r) { if (e) { const n = r.allowDots ? e.replace(/\.([^.[]+)/g, '[$1]') : e; const a = /(\[[^[\]]*])/g; let o = /(\[[^[\]]*])/.exec(n); const s = o ? n.slice(0, o.index) : n; const u = []; if (s) { if (!r.plainObjects && i.call(Object.prototype, s) && !r.allowPrototypes) return; u.push(s) } for (let l = 0; (o = a.exec(n)) !== null && l < r.depth;) { if (l += 1, !r.plainObjects && i.call(Object.prototype, o[1].slice(1, -1)) && !r.allowPrototypes) return; u.push(o[1]) } return o && u.push(`[${n.slice(o.index)}]`), (function (e, t, r) { for (var n = t, i = e.length - 1; i >= 0; --i) { var a; const o = e[i]; if (o === '[]')a = (a = []).concat(n); else { a = r.plainObjects ? Object.create(null) : {}; const s = o.charAt(0) === '[' && o.charAt(o.length - 1) === ']' ? o.slice(1, -1) : o; const u = parseInt(s, 10); !isNaN(u) && o !== s && String(u) === s && u >= 0 && r.parseArrays && u <= r.arrayLimit ? (a = [])[u] = n : a[s] = n }n = a } return n }(u, t, r)) } }; e.exports = function (e, t) { const r = t ? n.assign({}, t) : {}; if (r.decoder !== null && void 0 !== r.decoder && typeof r.decoder !== 'function') throw new TypeError('Decoder has to be a function.'); if (r.ignoreQueryPrefix = !0 === r.ignoreQueryPrefix, r.delimiter = typeof r.delimiter === 'string' || n.isRegExp(r.delimiter) ? r.delimiter : a.delimiter, r.depth = typeof r.depth === 'number' ? r.depth : a.depth, r.arrayLimit = typeof r.arrayLimit === 'number' ? r.arrayLimit : a.arrayLimit, r.parseArrays = !1 !== r.parseArrays, r.decoder = typeof r.decoder === 'function' ? r.decoder : a.decoder, r.allowDots = typeof r.allowDots === 'boolean' ? r.allowDots : a.allowDots, r.plainObjects = typeof r.plainObjects === 'boolean' ? r.plainObjects : a.plainObjects, r.allowPrototypes = typeof r.allowPrototypes === 'boolean' ? r.allowPrototypes : a.allowPrototypes, r.parameterLimit = typeof r.parameterLimit === 'number' ? r.parameterLimit : a.parameterLimit, r.strictNullHandling = typeof r.strictNullHandling === 'boolean' ? r.strictNullHandling : a.strictNullHandling, e === '' || e === null || void 0 === e) return r.plainObjects ? Object.create(null) : {}; for (var s = typeof e === 'string' ? (function parseQueryStringValues(e, t) { for (var r = {}, n = t.ignoreQueryPrefix ? e.replace(/^\?/, '') : e, o = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit, s = n.split(t.delimiter, o), u = 0; u < s.length; ++u) { var l; var c; const p = s[u]; const f = p.indexOf(']='); const d = f === -1 ? p.indexOf('=') : f + 1; d === -1 ? (l = t.decoder(p, a.decoder), c = t.strictNullHandling ? null : '') : (l = t.decoder(p.slice(0, d), a.decoder), c = t.decoder(p.slice(d + 1), a.decoder)), i.call(r, l) ? r[l] = [].concat(r[l]).concat(c) : r[l] = c } return r }(e, r)) : e, u = r.plainObjects ? Object.create(null) : {}, l = Object.keys(s), c = 0; c < l.length; ++c) { const p = l[c]; const f = o(p, s[p], r); u = n.merge(u, f, r) } return n.compact(u) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); t.default = { server: 'https://animeloop.org/api/v2/', browser: 'https://animeloop.org/api/v2/' };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(740)); const o = _interopRequireDefault(r(220)); const s = _interopRequireDefault(r(66)); const u = _interopRequireDefault(r(67)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = {
    state: function state() {
      return {
        series: {}, seriesListByGroupFilter: [], seasons: {}, seriesCount: 0, maxSeriesInPage: 30,
      };
    },
    mutations: {
      SET_MULTIPLE_SERIES: function SET_MULTIPLE_SERIES(e, t) { t.data.forEach((t) => { e.series[t.id] = t }) }, SET_SERIES: function SET_SERIES(e, t) { const r = t.seriesid; const n = t.data; e.series[r] = n }, SET_SERIES_COUNT: function SET_SERIES_COUNT(e, t) { const r = t.data; e.seriesCount = r.count }, SET_SERIES_BY_PAGE_NUM: function SET_SERIES_BY_PAGE_NUM(e, t) { const r = t.data; const n = t.pageNum; e.seriesListByPage[n] = [], r.forEach((t) => { e.seriesListByPage[n].push(t.id) }) }, SET_SERIES_GROUP: function SET_SERIES_GROUP(e, t) { const r = t.data; e.seriesListByGroupFilter = r }, SET_SEASONS: function SET_SEASONS(e, t) { const r = t.data; e.seasons = {}, [].concat((0, o.default)(new a.default(r))).forEach((t) => { const r = t.split('-')[0]; const n = t.split('-')[1]; Object.prototype.hasOwnProperty.call(e.seasons, r) || (e.seasons[r] = []), e.seasons[r].push(n) }) },
    },
    actions: {
      fetchSeriesByID: function fetchSeriesByID(e, t) { const r = this; const a = e.commit; const o = t.seriesid; return (0, i.default)(n.default.mark(function _callee() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, s.default.getSeriesByID(o); case 2: if (e = r.sent, t = e.data, u.default.obj(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: a('SET_SERIES', { seriesid: o, data: t }); case 7: case 'end': return r.stop(); } }, _callee, r) }))() },
      fetchSeriesCount: function fetchSeriesCount(e, t) { const r = this; const a = e.commit; const o = t.type; const l = t.season; return (0, i.default)(n.default.mark(function _callee2() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, s.default.getSeriesCount({ type: o, season: l }); case 2: if (e = r.sent, t = e.data, u.default.obj(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: a('SET_SERIES_COUNT', { data: t }); case 7: case 'end': return r.stop(); } }, _callee2, r) }))() },
      fetchSeriesGroup: function fetchSeriesGroup(e, t) {
        const r = this; const a = e.state; const o = e.commit; const l = e.dispatch; const c = t.type; const p = t.season; const f = t.page; const d = t.limit; const h = void 0 === d ? a.maxSeriesInPage : d; return (0, i.default)(n.default.mark(function _callee3() {
          let e; let t; return n.default.wrap((r) => {
            for (;;) {
              switch (r.prev = r.next) {
                case 0: return r.next = 2, s.default.getSeriesGroup({
                  type: c, season: p, page: f, limit: h,
                }); case 2: if (e = r.sent, t = e.data, u.default.arr(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: return o('SET_SERIES_GROUP', { data: t }), r.next = 9, l('fillSeriesList', { data: t }); case 9: case 'end': return r.stop();
              }
            }
          }, _callee3, r);
        }))();
      },
      fetchAllSeasons: function fetchAllSeasons(e) { const t = this; const r = e.commit; return (0, i.default)(n.default.mark(function _callee4() { let e; let i; return n.default.wrap((t) => { for (;;) switch (t.prev = t.next) { case 0: return t.next = 2, s.default.getAllSeasons; case 2: if (e = t.sent, i = e.data, u.default.arr(i)) { t.next = 6; break } throw new Error('Cannot fetch data'); case 6: r('SET_SEASONS', { data: i }); case 7: case 'end': return t.stop(); } }, _callee4, t) }))() },
    },
  }; t.default = l;
}, function (e, t, r) { e.exports = { default: r(741), __esModule: !0 } }, function (e, t, r) { r(200), r(107), r(206), r(742), r(749), r(752), r(754), e.exports = r(7).Set }, function (e, t, r) {
  const n = r(743); const i = r(229); e.exports = r(744)('Set', e => function Set() { return e(this, arguments.length > 0 ? arguments[0] : void 0) }, { add: function add(e) { return n.def(i(this, 'Set'), e = e === 0 ? 0 : e, e) } }, n);
}, function (e, t, r) {
  const n = r(19).f; const i = r(202); const a = r(117); const o = r(24); const s = r(115); const u = r(44); const l = r(110); const c = r(207); const p = r(215); const f = r(25); const d = r(228).fastKey; const h = r(229); const m = f ? '_s' : 'size'; const g = function (e, t) { let r; const n = d(t); if (n !== 'F') return e._i[n]; for (r = e._f; r; r = r.n) if (r.k == t) return r; }; e.exports = {
    getConstructor(e, t, r, l) {
      var c = e((e, n) => { s(e, c, t, '_i'), e._t = t, e._i = i(null), e._f = void 0, e._l = void 0, e[m] = 0, void 0 != n && u(n, r, e[l], e) }); return a(c.prototype, {
        clear: function clear() { for (var e = h(this, t), r = e._i, n = e._f; n; n = n.n)n.r = !0, n.p && (n.p = n.p.n = void 0), delete r[n.i]; e._f = e._l = void 0, e[m] = 0 }, delete(e) { const r = h(this, t); const n = g(r, e); if (n) { const i = n.n; const a = n.p; delete r._i[n.i], n.r = !0, a && (a.n = i), i && (i.p = a), r._f == n && (r._f = i), r._l == n && (r._l = a), r[m]-- } return !!n }, forEach: function forEach(e) { h(this, t); for (var r, n = o(e, arguments.length > 1 ? arguments[1] : void 0, 3); r = r ? r.n : this._f;) for (n(r.v, r.k, this); r && r.r;)r = r.p; }, has: function has(e) { return !!g(h(this, t), e) },
      }), f && n(c.prototype, 'size', { get() { return h(this, t)[m] } }), c;
    },
    def(e, t, r) {
      let n; let i; let a = g(e, t); return a ? a.v = r : (e._l = a = {
        i: i = d(t, !0), k: t, v: r, p: n = e._l, n: void 0, r: !1,
      }, e._f || (e._f = a), n && (n.n = a), e[m]++, i !== 'F' && (e._i[i] = a)), e;
    },
    getEntry: g,
    setStrong(e, t, r) { l(e, t, function (e, r) { this._t = h(e, t), this._k = r, this._l = void 0 }, function () { for (var e = this._k, t = this._l; t && t.r;)t = t.p; return this._t && (this._l = t = t ? t.n : this._t._f) ? c(0, e == 'keys' ? t.k : e == 'values' ? t.v : [t.k, t.v]) : (this._t = void 0, c(1)) }, r ? 'entries' : 'values', !r, !0), p(t) },
  };
}, function (e, t, r) {
  const n = r(12); const i = r(6); const a = r(228); const o = r(33); const s = r(28); const u = r(117); const l = r(44); const c = r(115); const p = r(20); const f = r(65); const d = r(19).f; const h = r(745)(0); const m = r(25); e.exports = function (e, t, r, g, v, y) { const b = n[e]; let x = b; const D = v ? 'set' : 'add'; const _ = x && x.prototype; const C = {}; return m && typeof x === 'function' && (y || _.forEach && !o(() => { (new x()).entries().next() })) ? (x = t((t, r) => { c(t, x, e, '_c'), t._c = new b(), void 0 != r && l(r, v, t[D], t) }), h('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), (e) => { const t = e == 'add' || e == 'set'; e in _ && (!y || e != 'clear') && s(x.prototype, e, function (r, n) { if (c(this, x, e), !t && y && !p(r)) return e == 'get' && void 0; const i = this._c[e](r === 0 ? 0 : r, n); return t ? this : i }) }), y || d(x.prototype, 'size', { get() { return this._c.size } })) : (x = g.getConstructor(t, e, v, D), u(x.prototype, r), a.NEED = !0), f(x, e), C[e] = x, i(i.G + i.W + i.F, C), y || g.setStrong(x, e, v), x };
}, function (e, t, r) { const n = r(24); const i = r(111); const a = r(43); const o = r(64); const s = r(746); e.exports = function (e, t) { const r = e == 1; const u = e == 2; const l = e == 3; const c = e == 4; const p = e == 6; const f = e == 5 || p; const d = t || s; return function (t, s, h) { for (var m, g, v = a(t), y = i(v), b = n(s, h, 3), x = o(y.length), D = 0, _ = r ? d(t, x) : u ? d(t, 0) : void 0; x > D; D++) if ((f || D in y) && (g = b(m = y[D], D, v), e)) if (r)_[D] = g; else if (g) switch (e) { case 3: return !0; case 5: return m; case 6: return D; case 2: _.push(m); } else if (c) return !1; return p ? -1 : l || c ? c : _ } } }, function (e, t, r) { const n = r(747); e.exports = function (e, t) { return new (n(e))(t) } }, function (e, t, r) { const n = r(20); const i = r(748); const a = r(13)('species'); e.exports = function (e) { let t; return i(e) && (typeof (t = e.constructor) !== 'function' || t !== Array && !i(t.prototype) || (t = void 0), n(t) && (t = t[a]) === null && (t = void 0)), void 0 === t ? Array : t } }, function (e, t, r) { const n = r(42); e.exports = Array.isArray || function isArray(e) { return n(e) == 'Array' } }, function (e, t, r) { const n = r(6); n(n.P + n.R, 'Set', { toJSON: r(750)('Set') }) }, function (e, t, r) { const n = r(114); const i = r(751); e.exports = function (e) { return function toJSON() { if (n(this) != e) throw TypeError(`${e}#toJSON isn't generic`); return i(this) } } }, function (e, t, r) { const n = r(44); e.exports = function (e, t) { const r = []; return n(e, !1, r.push, r, t), r } }, function (e, t, r) { r(753)('Set') }, function (e, t, r) {
  const n = r(6); e.exports = function (e) { n(n.S, e, { of: function of() { for (var e = arguments.length, t = new Array(e); e--;)t[e] = arguments[e]; return new this(t) } }) };
}, function (e, t, r) { r(755)('Set') }, function (e, t, r) {
  const n = r(6); const i = r(39); const a = r(24); const o = r(44); e.exports = function (e) { n(n.S, e, { from: function from(e) { let t; let r; let n; let s; const u = arguments[1]; return i(this), (t = void 0 !== u) && i(u), void 0 == e ? new this() : (r = [], t ? (n = 0, s = a(u, arguments[2], 2), o(e, !1, (e) => { r.push(s(e, n++)) })) : o(e, !1, r.push, r), new this(r)) } }) };
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(757)); const o = _interopRequireDefault(r(23)); const s = _interopRequireDefault(r(66)); const u = _interopRequireDefault(r(67)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const l = {
    state: function state() { return { episodes: {}, episodeList: {} } }, mutations: { SET_EPISODE: function SET_EPISODE(e, t) { const r = t.episodeid; const n = t.data; e.episodes[r] = n }, SET_EPISODES_BY_SERIES: function SET_EPISODES_BY_SERIES(e, t) { const r = t.seriesid; const n = t.data; n.sort((e, t) => { function isStringNaN(e) { return (0, a.default)(parseInt(e, 10)) } return isStringNaN(e.no) && isStringNaN(t.no) ? 0 : isStringNaN(e.no) && !isStringNaN(t.no) ? 1 : !isStringNaN(e.no) && isStringNaN(t.no) ? -1 : parseInt(e.no, 10) - parseInt(t.no, 10) }), o.default.set(e.episodeList, r, n) } }, getters: {}, actions: { fetchEpisodeByID: function fetchEpisodeByID(e, t) { const r = this; const a = e.dispatch; const o = e.commit; const l = t.episodeid; return (0, i.default)(n.default.mark(function _callee() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, s.default.getEpisodeByID(l); case 2: if (e = r.sent, t = e.data, u.default.obj(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: return r.next = 8, a('setSeriesByID', { seriesid: t.series.id, data: t.series }); case 8: o('SET_EPISODE', { episodeid: l, data: t }); case 9: case 'end': return r.stop(); } }, _callee, r) }))() }, setSeriesByID: function setSeriesByID(e, t) { const r = this; const a = e.commit; const o = t.seriesid; const s = t.data; return (0, i.default)(n.default.mark(function _callee2() { return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: a('SET_SERIES', { seriesid: o, data: s }); case 1: case 'end': return e.stop(); } }, _callee2, r) }))() }, fetchEpisodesBySeriesID: function fetchEpisodesBySeriesID(e, t) { const r = this; const a = e.commit; const o = t.seriesid; return (0, i.default)(n.default.mark(function _callee3() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, s.default.getEpisodesBySeriesID(o); case 2: if (e = r.sent, t = e.data, u.default.arr(t)) { r.next = 6; break } throw new Error('Cannot fetch data'); case 6: a('SET_EPISODES_BY_SERIES', { seriesid: o, data: t }); case 7: case 'end': return r.stop(); } }, _callee3, r) }))() } },
  }; t.default = l;
}, function (e, t, r) { e.exports = { default: r(758), __esModule: !0 } }, function (e, t, r) { r(759), e.exports = r(7).Number.isNaN }, function (e, t, r) { const n = r(6); n(n.S, 'Number', { isNaN: function isNaN(e) { return e != e } }) }, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = _interopRequireDefault(r(8)); const i = _interopRequireDefault(r(9)); const a = _interopRequireDefault(r(66)); const o = _interopRequireDefault(r(67)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = {
    state: function state() { return { searchResult: [], isSearching: !1 } }, mutations: { SET_SEARCH: function SET_SEARCH(e, t) { const r = t.data; e.searchResult = [], r.forEach((t) => { e.searchResult.push(t.id) }) }, SET_SEARCHING: function SET_SEARCHING(e, t) { const r = t.data; e.isSearching = r } }, getters: {}, actions: { fetchSeriesByString: function fetchSeriesByString(e, t) { const r = this; const s = e.dispatch; const u = e.commit; const l = t.searchString; return (0, i.default)(n.default.mark(function _callee() { let e; let t; return n.default.wrap((r) => { for (;;) switch (r.prev = r.next) { case 0: if (!/^[\w]{0,3}$/.test(l)) { r.next = 2; break } throw new Error('Keyword too short'); case 2: return u('SET_SEARCHING', { data: !0 }), r.next = 5, a.default.getSeriesByString(l); case 5: if (e = r.sent, t = e.data, o.default.arr(t)) { r.next = 9; break } throw new Error('Cannot fetch data'); case 9: return u('SET_SEARCHING', { data: !1 }), u('SET_SEARCH', { data: t }), r.next = 13, s('fillSeriesList', { data: t }); case 13: case 'end': return r.stop(); } }, _callee, r) }))() }, fillSeriesList: function fillSeriesList(e, t) { const r = this; const a = e.commit; const o = t.data; return (0, i.default)(n.default.mark(function _callee2() { return n.default.wrap((e) => { for (;;) switch (e.prev = e.next) { case 0: a('SET_MULTIPLE_SERIES', { data: o }); case 1: case 'end': return e.stop(); } }, _callee2, r) }))() } },
  }; t.default = s;
}, function (e, t, r) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const n = {
    state: function state() { return { burgerOpen: !1, searchOpen: !1, langOpen: !1 } }, getters: {}, mutations: { TOGGLE_NAVBAR_STATE: function TOGGLE_NAVBAR_STATE(e, t) { const r = t.type; e[r] = !e[r] } }, actions: { toggleNavbarState: function toggleNavbarState(e, t) { const r = e.commit; const n = t.type; if (n === 'burger')r('TOGGLE_NAVBAR_STATE', { type: 'burgerOpen' }); else if (n === 'search')r('TOGGLE_NAVBAR_STATE', { type: 'searchOpen' }); else { if (n !== 'lang') throw Error('Wrong toggle type'); r('TOGGLE_NAVBAR_STATE', { type: 'langOpen' }) } } },
  }; t.default = n;
}]));
